/***
 * 
 * Known issue:
 * undo r&edo : does not take atom mapping into account
 * 
 * 
 * 
 * 
 */


package jme;

//START JAVA_IMPORT
import java.util.Vector;
//
import gwt_compat.GWT;
import gwt_compat.RunAsyncCallback;
//
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;
import java.applet.Applet;
import java.applet.AppletContext;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
//
//
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
//
//
import netscape.javascript.JSObject;//To compile JME, you have to link with the NetScape library (plugin.jar) which is available in all JRE distributions, e.g.for linux:  /usr/lib/jvm/java-7-oracle/jre/lib/plugin.jar

//
import com.actelion.research.chem.MolfileCreator;
import com.actelion.research.chem.SmilesParser;
import com.actelion.research.chem.StereoMolecule;

import jme.Rectangle;

//END JAVA_IMPORT





//START GWT_IMPORT


//import java.util.Vector;

//import com.actelion.research.chem.MolfileCreator;
//import com.actelion.research.chem.SmilesParser;
//import com.actelion.research.chem.StereoMolecule;
//import com.google.gwt.core.client.GWT;
//import com.google.gwt.user.client.Window;
//import com.google.gwt.core.client.RunAsyncCallback;

//import ejava.awt.Image;
//import ejava.applet.Applet;
//import ejava.awt.BasicStroke;
//import ejava.awt.Component;
//import ejava.awt.BorderLayout;
//import ejava.awt.Button;
//import ejava.awt.Choice;
//import ejava.awt.MenuItem;
//import ejava.awt.Point;
//import ejava.awt.Color;
//import ejava.awt.Dimension;
//import ejava.awt.Event;
//import ejava.awt.FlowLayout;
//import ejava.awt.Dialog;
//import ejava.awt.Font;
//import ejava.awt.FontMetrics;
//import ejava.awt.Frame;
//import ejava.awt.Graphics;
//import ejava.awt.GridLayout;
//import ejava.awt.Label;
//import ejava.awt.Panel;
//import ejava.awt.PopupMenu;
//import ejava.awt.RenderingHints;
//import ejava.awt.TextField;
//import ejava.awt.event.ActionEvent;
//import ejava.awt.event.ActionListener;
//import ejava.awt.event.WindowAdapter;
//import ejava.awt.event.WindowEvent;
//import ejava.util.StringTokenizer;
//import ejava.lang.System;
//import ejava.net.URL;
//import ejava.applet.AppletContext;
//import ejava.net.MalformedURLException;
//import enetscape.javascript.JSObject;


//import ejava.awt.event.MouseWheelEvent;
//import ejava.awt.event.MouseWheelListener;

//import ejava.awt.Container;

//END GWT_IMPORT



//common import
import jme.TextTransfer.PasteAction;

class TouchedMol {
	int molIndex;
	int atomIndex;
	int bondIndex;
	double distance;
	
	
	public boolean equals(TouchedMol other) {
		return this.molIndex == other.molIndex && this.atomIndex == other.atomIndex && this.bondIndex == other.bondIndex;
		
	}
	
	public void reset() {
		molIndex = 0;
		atomIndex = 0;
		bondIndex = 0;
	}
	
	public void initMyselfWith(TouchedMol other) {
		this.molIndex = other.molIndex;
		this.atomIndex = other.atomIndex;
		this.bondIndex = other.bondIndex;
		
	}
}


// ----------------------------------------------------------------------------
// ****************************************************************************
@SuppressWarnings("serial")
public class JME extends Applet implements ActionListener, MouseWheelListener /*, MouseListener*/  {



	private static final String UN_MARK_ATOM = "unMarkAtom";
	private static final String MARK_ATOM = "markAtom";
	private static final String ADD_ATOM_QUERY = "addAtomQuery";
	private static final String CHARGE_ATOM_MINUS = "chargeAtom-";
	private static final String CHARGE_ATOM_PLUS = "chargeAtom+";
	private static final String CHARGE_ATOM0 = "chargeAtom0";
	private static final String DEL_ATOM2 = "delAtom";
	private static final String SET_ATOM = "setAtom";
	private static final String DEL_BOND2 = "delBond";
	private static final String DEL_ATOM = JME.DEL_ATOM2;
	private static final String REACTION_COPY = "reactionCopy";
	private static final String MARK = "mark";
	private static final String AUTO_NUMBER = "autonumber";
	private static final String SD_FSTACK = "SDFstack";
	private static final String REDO = "redo";
	private static final String UNDO = "undo";
	private static final String READ_MOL_FILE = "readMolFile";
	private static final String READ_RXN_FILE = "readRXNFile";
	private static final String READ_JME = "readJME";
	private static final String CLEAR = "clear";
	private static final String RESET = "reset";
	/* for recording events to external program */
	private static final String ADD_GROUP = "addGroup";
	private static final String ADD_TEMPLATE = "addTemplate";
	private static final String ADD_ATOM = "addAtom";
	private static final String ADD_RING = "addRing";
	private static final String ADD_BOND = "addBond";
	private static final String ADD_CHAIN = "addChain";
	private static final String UN_MARK_BOND = "unMarkBond";
	private static final String MARK_BOND = "markBond";
	private static final String SET_QUERY_BOND = "setQueryBond";
	private static final String ADD_RING_BOND = "addRingBond";
	private static final String SET_BOND_TRIPLE = "setBondTriple";
	private static final String SET_BOND_SINGLE = "setBondSingle";
	private static final String SET_BOND_DOUBLE = "setBondDouble";
	private static final String SET_BOND_STEREO = "setBondStereo";
	private static final String DEL_BOND_GROUP = "delBondGroup";
	private static final String DEL_BOND = JME.DEL_BOND2;
	
	private static final String MOVE_ATOM = "moveAtom";
	private static final String CHANGE_CHIRAL = "changeChiral";
	static final String CHANGE_ATOM_MAP = "changeAtomMap";
	static final String CHANGE_MANY_ATOM_MAP = "changeManyAtomMap";
	

	
	// editor state
	int action;
	
	TouchedMol lastTouchedMol = new TouchedMol();
	
	TouchedMol newTouchedMol = new TouchedMol();
	
	int active_an;
	static boolean isStandAloneApplication = false; //by default the program starts as an applet
	// static String separator =
	// System.getProperties().getProperty("line.separator");
	static String separator = "\n";

	// customization
	static final String version = "2014-06-28";
	//static final String startInfoText = "JSME Molecular Editor by Peter Ertl and Bruno Bienfait";
	static final String startInfoText = "Molecular Editor by Peter Ertl and Bruno Bienfait"; //JSME or JME selected according to the run time environment
	static final String copyright[] = {"Copyright (c) 2014, Novartis Institutes for BioMedical Research Inc. and Bruno Bienfait.",  "All rights reserved."};
	//Note: the copyright is too long for the info()
	int copyRigthmallTextFontSize = 8; //used in the info box for copyright
	Font copyRigthSmallTextFont = new Font(null, 0, copyRigthmallTextFontSize);

	public String helpUrl = "http://peter-ertl.com/jsme/2013_03/help.html";

	String infoText = null;

	//BB: renamed sd to a more meaningful name
	//int sd = 24;
	final double standardMenuCellSize = 24; //the original value
	double menuCellSize = standardMenuCellSize; //should be a multiple of 2 and 3, is set 0 in depict mode
	boolean newLook = true;
	int menuCellBorder = 1; // will be changed to 0 when !newLook

	int arrowWidth = 24 * 2;
	
	
	// the IO triangle/arrows
	double ioMargin = 3;
	double ioArrowWidth = ((double)(menuCellSize - 2 * ioMargin) / 1.5);
	
	static final Color bgColor = Color.lightGray;
	static final Color brightColor = bgColor.brighter();

	enum CopyPasteAction {
		COPY_SMILES, COPY_MOL, COPY_MOL_V3000, PASTE
	}

	protected JMEevent afterStructureChangeEvent =  new JMEevent();

	
	
	
	//Fonts
	Font menuCellFont;
	Font menuCellFontBold; //for the atom symbols
	Font menuCellFontSmaller;
	Font atomDrawingAreaFont,dialogFont;
	FontMetrics menuCellFontMet, menuCellFontBoldMet, menuCellFontSmallerMet;
	FontMetrics atomDrawingAreaFontMet ;

	int fontSize = 13; //with a value != 12, the stringWidth errors are minimized in JS
	float atomMolecularDrawingAreaFontSize = fontSize; //BB
	
	String defaultFontFamily = "Helvetica"; //looks good everywhere
	//BB if null: use the system default font - looks nice also in Java
	//String defaultFontFamily = "sansserif"; //Java: Helvetica is discouraged in Java 1.1 and should be replaced by sansserif
	//String defaultFontFamily = "Sans-Serif"; //CSS



	protected float molecularAreaLineWidth = (float) 1.0;
	
	
	public float getMolecularAreaLineWidth() {
		return molecularAreaLineWidth;
	}

	/**
	 * Line width in pixel
	 * @param molecularAreaLineWidth
	 */
	public void setMolecularAreaLineWidth(float molecularAreaLineWidth) {
		this.molecularAreaLineWidth = molecularAreaLineWidth;
		this.repaint();

	}

	public boolean molecularAreaAntiAlias = true;
	
	
	public boolean isMolecularAreaAntiAlias() {
		return molecularAreaAntiAlias;
	}

	/**
	 * Set antialias for the molecular drawing area
	 * @param molecularAreaAntiAlias
	 */
	public void setMolecularAreaAntiAlias(boolean molecularAreaAntiAlias) {
		this.molecularAreaAntiAlias = molecularAreaAntiAlias;
		this.repaint();
	}

	/**
	 * Used for the test suite
	 * @param width
	 * @param height
	 */
	public JME setDimension(int width, int height) {
		if(this.dimension == null) {
			this.dimension = new Dimension();
		}
		this.dimension.setSize(width, height);
		return this;
	}


	// tieto parametere sa naplnaju v init (aby sa vynulovali pri starte)
	boolean bwMode = false;
	boolean runsmi = false; // traba to, alebo sa automaticky setne v param smi
	// ??
	String depictcgi = null;
	String depictservlet = null;

	boolean canonize = true;
	//boolean canonize = false;
	boolean stereo = true;
	boolean multipart = true; // vzdy aj pri reaction
	boolean xButton = true;
	boolean paste = true; //BB: allow pasting structures, should be disabled in depict mode
	boolean rButton = false;
	boolean showHydrogens = true; //on heteroatom labels OH , NH2, ...
	boolean query = false;
	boolean reaction = false;
	boolean autoez = true;
	boolean writesmi = false;
	boolean writemi = false;
	boolean writemol = false;
	boolean number = false;
	boolean star = false;
	boolean autonumber = false;
	boolean jmeh = false;
	boolean depict = false;
	boolean toggleDepictEdit = false; //BB
	boolean depictActionEnabled = false; //BB allow editing in depict mode
	boolean depictBorder = false;
	boolean keepHydrogens = true;
	boolean removeOnlyCHydrogens = false;
	
	boolean addNewPart = false; //when reading a or pasting a mol: addti or replace everything in the canvas
	
	boolean pasteFromSDFstack = false;
	
	Color canvasBg = Color.white;
	String atomColors = null; // atom coloring
	String atomBgColors = null; // background coloring
	
	
	double depictScale = 1; // ked scaling viacero moleculeParts, alebo reaction
	//double previousDepictScale = depictScale;
	final boolean scalingIsPerformedByGraphicsEngine = true; //BB, gives nicer looking depiction
	
	boolean nocenter = false;
	boolean polarnitro = false; 
	boolean showAtomNumbers = false; // only when starting with a molecule
	// scaling pri depict, nacitanie molekul (jme + mol)

	boolean showAtomMoveButton = false; //BB
	//boolean mdlV2000ChiralFlag = false; //for v2000 note: v300 has also a chiral flag
	boolean useOpenChemLib = true; //for SMILES input
	
	boolean showDragAndDropSymbolInDepictMode = true ; //BB

	boolean allowZooming = true;
	
	// files na nacitanie (2002.06)
	String smilesString = null;
	String jmeString = null;
	String molString = null;

	// pouziva v double bufferingu
	Dimension dimension;
	
	PreciseImage molecularArea;
	int molecularAreaWidth ;
	int molecularAreaHeight ;

	PreciseImage topMenu, leftMenu;
	PreciseImage infoArea;
	
	// pre repaint()
	boolean doMenu = true; // ci draw menu pri repaint()
	boolean movePossible; // not to move when dragg in menu

	// BB - avoid unnecessary redraw - speed optimization for slow browsers
	boolean mustReDrawLeftMenu = true;
	boolean mustReDrawTopMenu = true;
	boolean mustReDrawMolecularArea = true;
	boolean mustReDrawInfo = true;


	protected String notifyStructuralChangeJSfunction = null;
	protected String notifyAtomHighLightJSfunction = null;
	protected String prePasteJSfunction = null;

	protected String pasteLabel = null;

	//boolean atomWasTouched = false;
	//boolean bondWasTouched = false;
	
	
	//the ACTION code on which the mouse was during mouse move
	int mouseWasOverAction = 0;
	
	
	public String getPasteLabel() {
		return pasteLabel;
	}

	/**
	 * Customization of the paste label
	 * @param pasteLabel
	 */
	public void setPasteLabel(String pasteLabel) {
		this.pasteLabel = pasteLabel;
		//rebuild the menu each time the pasteLabel is changed
		this.copyPastePopupMenuMol = this.createCopyPastePopupMenu(false);
	}

	
	// actions 2 riadky s ACTIONX a atomy s ACTIONA
	static int ACTIONA = 10; // meni sa podla rxButton
	// cislo action urcuje aj polohu buttonu
	// empty buttons (a ACTION_END v aplete) su vyradene v mousePressed()
	// a kreslenie textov v createSquare (neda sa to v jednom ?)
	static final int ACTION_DELETE = 104;
	static final int ACTION_MARK = 105;
	static final int ACTION_DELGROUP = 106;
	static final int ACTION_SMI = 101;
	static final int ACTION_QRY = 107;
	static final int ACTION_REACP = 109;
	static final int ACTION_UNDO = 110;
	static final int ACTION_REDO = 111;
	static final int ACTION_SPIRO = 112; //BB: was 111
	static final int ACTION_CLEAR = 102;
	static final int ACTION_NEW = 103; // using newMolecule
	
	static final int ACTION_MOVE_AT = 113; //BB: new
	
	static final int ACTION_JME = 114; //BB: was 113
	
	
	
	
	//BB: the number of cells in the top menu - was ACTION_X
	static final int TOP_MENU_NUMBER_OF_CELLS = ACTION_JME - 100; //assume that ACTION_JME is the last menu entry on the top row

	
	static final int ACTION_PGUP = 151;
	static final int ACTION_PGDN = 152;
	static final int ACTION_ROT90 = 156; // webme
	static final int ACTION_CHARGE_PLUS = 157; // webme
	static final int ACTION_CHARGE_MINUS = 158; // webme

	static final int ACTION_CHARGE = 108;
	static final int ACTION_STEREO = 201;
	static final int ACTION_BOND_SINGLE = 202;
	static final int ACTION_BOND_DOUBLE = 203;
	static final int ACTION_BOND_TRIPLE = 204;
	static final int ACTION_CHAIN = 205;
	static final int ACTION_RING_3 = 206;
	static final int ACTION_RING_4 = 207;
	static final int ACTION_RING_5 = 208;
	public static final int ACTION_RING_PH = 209;
	static final int ACTION_RING_6 = 210;
	static final int ACTION_RING_7 = 211;
	static final int ACTION_RING_8 = 212;

	static final int ACTION_FG = 213; //BB: button for a popup menu with functional groups
	//static final int ACTION_EMPTY_CELL = 214; //BB: defined only to avoid highliting when click on it, to be removed?
	static final int ACTION_IO = 214; //BB replace ACTION_EMPTY_CELL by I/O icon below info icon


	static final int ACTION_RING_FURANE = 221; // nema button
	static final int ACTION_RING_3FURYL = 223; // Alt 0
	static final int ACTION_RING_9 = 229; // nema button
	static final int ACTION_TEMPLATE = 230;


	static final int ACTION_GROUP_MIN = 233; //BB first entry in the substituents (FG)
	static final int ACTION_GROUP_TBU = 233;
	static final int ACTION_GROUP_NITRO = 234;
	static final int ACTION_GROUP_COO = 235;
	static final int ACTION_GROUP_CF3 = 236;
	static final int ACTION_GROUP_CCL3 = 237;
	static final int ACTION_GROUP_CC = 238;
	static final int ACTION_GROUP_SULFO = 239;
	static final int ACTION_GROUP_COOME = 240;
	static final int ACTION_GROUP_OCOME = 241;
	static final int ACTION_GROUP_CYANO = 242;
	static final int ACTION_GROUP_NME2 = 243;
	static final int ACTION_GROUP_NHSO2ME = 244;
	static final int ACTION_GROUP_CCC = 245;
	static final int ACTION_GROUP_C2 = 246;
	static final int ACTION_GROUP_C3 = 247;
	static final int ACTION_GROUP_C4 = 248;
	static final int ACTION_GROUP_COH = 249;
	static final int ACTION_GROUP_dO = 250; // =O
	static final int ACTION_GROUP_PO3H2 = 251;
	static final int ACTION_GROUP_SO2NH2 = 252;
	static final int ACTION_GROUP_TEMPLATE = 253;
	static final int ACTION_GROUP_CF = 254;
	static final int ACTION_GROUP_CL = 255;
	static final int ACTION_GROUP_CB = 256;
	static final int ACTION_GROUP_CI = 257;
	static final int ACTION_GROUP_CN = 258;
	static final int ACTION_GROUP_CO = 259;
	static final int ACTION_GROUP_CON = 260; //BB
	static final int ACTION_GROUP_NCO = 261; //BB
	static final int ACTION_GROUP_MAX = 262; // last+1 len na < test


	static final int ACTION_AN_C = 301;
	static final int ACTION_AN_N = 401;
	static final int ACTION_AN_O = 501;
	static final int ACTION_AN_S = 601;
	static final int ACTION_AN_F = 701;
	static final int ACTION_AN_CL = 801;
	static final int ACTION_AN_BR = 901;
	static final int ACTION_AN_I = 1001;
	static final int ACTION_AN_P = 1101;
	static final int ACTION_AN_X = 1201;
	static final int ACTION_AN_H = 1300;
	static final int ACTION_AN_R = 1301;
	static final int ACTION_AN_R1 = 1302;
	static final int ACTION_AN_R2 = 1303;
	static final int ACTION_AN_R3 = 1304;
	//added by BB
	static final int ACTION_AN_R4 = 1305;
	static final int ACTION_AN_R5 = 1306;
	static final int ACTION_AN_R6 = 1307;
	static final int ACTION_AN_R7 = 1308;
	static final int ACTION_AN_R8 = 1309;
	static final int ACTION_AN_R9 = 1310;
	static final int ACTION_AN_R_LAST = 1310;
	//end added by BB
	
	static final int AN_H = 1;
	static final int AN_B = 2;
	static final int AN_C = 3;
	static final int AN_N = 4;
	static final int AN_O = 5;
	static final int AN_SI = 6;
	static final int AN_P = 7;
	static final int AN_S = 8;
	static final int AN_F = 9;
	static final int AN_CL = 10;
	static final int AN_BR = 11;
	static final int AN_I = 12;
	static final int AN_SE = 13;
	
	//BB
	static final int AN_K = 14;
	static final int AN_METAL1_START = AN_K;
	static final int AN_Na = 15;
	static final int AN_Li = 16;
	static final int AN_METAL1_END= AN_Li;


	
	static final int AN_X = 18;
	static final int AN_R = 19;
	//static final int AN_R1 = 20;
	//static final int AN_R2 = 21;
	//static final int AN_R3 = 22;
	//added by BB
	static final int AN_R_LAST = AN_R + 9;

			
	static final Color color[] = new Color[AN_R_LAST+1];
	static final String zlabel[] = new String[AN_R_LAST+1];

	// info about last action & undo
	int lastAction = 0; // trva len po mouse up
	static final int LA_BOND = 1;
	static final int LA_RING = 2;
	static final int LA_GROUP = 3;
	static final int LA_MOVE = 5;
	static final int LA_ROTATE = 7; //BB used for rotation on touch event
	static final int LA_SCALE = 8; //BB used for scaling on touch event
	static final int LA_FAILED = 9; // failed to create bond or ring
	boolean newMolecule = false; // enable to start new molecule
	int xold, yold; // position of mousePressed, updated in mouseDragged
	boolean afterClear = false; // info pre undo
	boolean mouseShift = false; // kvoli numbering

	//boolean isContextMenu = false; //right mouse click

	MultiBox smilesBox = null, atomxBox = null, aboutBox = null;
	QueryBox queryBox;
	boolean spiroAdding = false;
	boolean movingAtom = false ; //BB
	
	String molText = null;
	// JMEmol mol = new JMEmol(this); // sposobovalo problemy v NS
	JMEmol mol; //BB: the molecule JME is presently working on
	JMEmol uniColorMolecule = null;
	
	int numberofMoleculeParts = 0;
	int actualMoleculePartIndex = 0;
	int saved = 0; // ktora molekula je saved pri multipart
	
	InspectorEvent inspectorEvent;
	
	String template = null; // template as jme string
	JMEmol templateMolecule = null; // template molecule - functional groups?
	static final int maxParts = 99;

	JMEmol moleculeParts[] = new JMEmol[maxParts]; // when multipart, nealokuje !!
	JMEmol smol; // save

	/**
	 * Storage of the state of the chemical structures of restoring for by the undo manager
	 * @author bruno
	 *
	 */
	class SavedState {
		JMEmol moleculeParts[] = new JMEmol[maxParts]; // when multipart, nealokuje !!
		int numberofMoleculeParts = 0;
		int actualMoleculePartIndex = 0;
		boolean reaction;
		boolean multipart;
		double depictScale = 1.0;
		public int lastAction;
	}

	//BB undo & redo section
	final boolean  canMultipleUndo = true; //when false, use Peter's original implementation, otherwise use the changeManager
	ChangeManager<SavedState> molChangeManager;

	static String programName; //JSME or JME


	// static Color[] psColor;
	static Color[] psColor = new Color[7];

	// BB : eclipse added the <JMEmol>
	Vector<JMEmol> molStack = new Vector<JMEmol>();

	//BB
	SDFstack sdfStack = new SDFstack();

	int stackPointer = -1;
	boolean doTags = false; // compatibility with JMEPro
	final boolean webme = false; // compatibility with JMEPro
	public int[] apointx, apointy, bpointx, bpointy; // coordinates for webme
	boolean revertStereo = false; // down stereo bond (only 1 action)
	boolean relativeStereo = false;
	boolean allHs = false;
	// for key marking 2009.04
	boolean markUsed = true;
	int currentMark = 1;

	// images
	//Image infoImage, clearImage, deleteImage, deleterImage, chargeImage;
	//Image templatesImage, rtemplatesImage, undoImage, endImage, smiImage,
	//smitImage, smartsImage, stereoImage, stereoxImage;

	//BB
	//true if the Java code has been compiled to JavaScript
	final boolean isJavaScript = System.getProperty("java.vm.name" ).equals("JavaScript");

	//BB: true for touch device iPad, Android
	final static boolean isTouchSupported = System.getProperty("is_touch_supported") != null;

	//BB for copy & paste
	TextTransfer clipBoardManager = new TextTransfer();
	PopupMenu copyPastePopupMenuMol;
	PopupMenu copyPastePopupMenuReaction;
	
	
	//local popup menu for the touched molecule/atom
	PopupMenu touchedMolPopuMenu;
	static String setChiralFlagAction = "Set molecule Chiral flag";
	static String unSetChiralFlagAction = "Unset molecule chiral flag";

	static String inspectAtomAction = "Change atom map";
	static String autoAtomMapMoleculeAction = "Auto atom map molecule";
	
	//functional group selection coming from the HTML example page
	String functionalGroups[] = 
			new String[]{"-C(=O)OH", "-C(=O)OMe", "-OC(=O)Me", "-C(=O)N", "-NC=O", "-CMe3", "-CF3", "-CCl3", "-NO2",
			"-SO2-NH2", "-NH-SO2-Me", "-NMe2", "-C#N", "-C#CH", "-C#C-Me" };

	PopupMenu functionalGroupPopumemu;
	private Point functionalGroupPopupMenuPosition;
	private Point fixedCopyPastePopupMenuPosition;
	private long lastRotation;
	private boolean bondRubberBanding = false;
	protected PasteAction pasteAction;
	private boolean mouseDownWasUsed;
	//private int lastTouchedMoleculePart;


	// ----------------------------------------------------------------------------
	public JME() {
		mol = new JMEmol(this);
		psColor[0] = Color.gray;
		psColor[1] = new Color(255, 153, 153); // pastel red
		psColor[2] = new Color(255, 204, 102);
		psColor[3] = new Color(255, 255, 153);
		psColor[4] = new Color(102, 255, 255);
		psColor[5] = new Color(51, 204, 255);
		psColor[6] = new Color(255, 153, 255);
		
		lastTouchedMol.molIndex = 1;
		newTouchedMol.molIndex = 1;
		moleculeParts[1] = mol;
		
		inspectorEvent = new InspectorEvent(this);

		//this.alert("isTouchSupported: " + isTouchSupported);

	}

	//-----------------------------------------------------------------------------
	// Shortcuts for molecule
	
	
	/**
	 * 
	 * Change atom coordinate
	 * @param mol
	 * @param atomIndex
	 * @param x
	 * @param y
	 */
	protected void XY(JMEmol mol, int atomIndex, double x, double y) {
		mol.XY(atomIndex, scaleCoordinate(x), scaleCoordinate(y));
	}
	
	protected void moveXY(JMEmol mol, int atomIndex, double x, double y) {
		mol.moveXY(atomIndex, scaleCoordinate(x), scaleCoordinate(y));
	}
	
	// ----------------------------------------------------------------------------
	protected PopupMenu createCopyPastePopupMenu(boolean isReaction) {

		PopupMenu popup = new PopupMenu();

		String smilesOrSmirks = "SMILES";
		String molOrReaction = "MOL";
		String molOrReactionForPasting = "MOL or SDF";

		//String what = "chemical structure(s)";
		if(isReaction) {
			smilesOrSmirks = "SMIRKS";
			molOrReaction = "RXN" ;
			//what = "reaction";
			molOrReactionForPasting = molOrReaction;
		}

		if(useOpenChemLib) {
			molOrReactionForPasting += " or " + smilesOrSmirks;
		}

		//COPY SMILES
		MenuItem mi = new MenuItem("Copy " /*+ what */ + "as "+ smilesOrSmirks /*+ " to the clipboard"*/);
		mi.setActionCommand(CopyPasteAction.COPY_SMILES.toString());
		popup.add(mi);
		mi.addActionListener(this);

		//COPY MOL
		mi = new MenuItem("Copy " /*+ what */+ "as " +  molOrReaction /*+ " to the clipboard"*/);
		mi.setActionCommand(CopyPasteAction.COPY_MOL.toString());
		mi.addActionListener(this);
		popup.add(mi);

		//COPY V3000 MOL
		if(!isReaction) {
			mi = new MenuItem("Copy " /*+ what */+ "as " +  molOrReaction  + " V3000" /*+ " to the clipboard"*/);
			mi.setActionCommand(CopyPasteAction.COPY_MOL_V3000.toString());
			mi.addActionListener(this);
			popup.add(mi);
			
		}
		//createExtendedMolFile

		//PASTE
		if(this.paste) {
			popup.addSeparator();
			String localPasteLabel = this.getPasteLabel(); 
			if(localPasteLabel == null) {
				localPasteLabel= "Paste " + molOrReactionForPasting; //default, no customization
			}
			mi = new MenuItem(localPasteLabel);
	
			mi.setActionCommand(CopyPasteAction.PASTE.toString());
			mi.addActionListener(this);
			popup.add(mi);
			
		}
		this.add(popup); //set the parent the popup

		return popup;

	}

	/**
	 * 
	 * @return
	 */
	protected PopupMenu createMolPopupMenu(JMEmol mol, int eventX, int eventY) {
		PopupMenu popup = new PopupMenu();
		
		boolean showAtomMappingToolsInMenu = number || autonumber ||reaction;
		MenuItem setUnsetChiralFlagMenuItem;
		if (mol.getChiralFlag()) {
			setUnsetChiralFlagMenuItem = new MenuItem(unSetChiralFlagAction);
		} else {
			setUnsetChiralFlagMenuItem = new MenuItem(setChiralFlagAction);
		}
		
		setUnsetChiralFlagMenuItem.setEnabled(mol.canBeChiral());
		
		
		popup.add(setUnsetChiralFlagMenuItem);
		setUnsetChiralFlagMenuItem.addActionListener(this);
		
		if(showAtomMappingToolsInMenu && mol.touchedAtom > 0) {
			MenuItem atomInspectoMenuItem = new MenuItem(inspectAtomAction);
			atomInspectoMenuItem.addActionListener(this.inspectorEvent);
			this.inspectorEvent.reset();
			this.inspectorEvent.atomIndex = mol.touchedAtom;
			this.inspectorEvent.mol = mol;
			this.inspectorEvent.x = eventX;
			this.inspectorEvent.y = eventY;
			this.inspectorEvent.molIndex = this.actualMoleculePartIndex;
			
			
			
			popup.add(atomInspectoMenuItem);
		}
		
		if(showAtomMappingToolsInMenu) {
			MenuItem automap =new MenuItem(autoAtomMapMoleculeAction);
			automap.addActionListener(this);
			popup.add(automap);
		}
		return popup;

	}

	// ----------------------------------------------------------------------------
	public static void main(String args[]) {
		isStandAloneApplication = true;
		JME jme = new JME();
		Frame frame = new Frame("JME Molecular Editor");
		frame.add("Center", jme);
		// frame.resize(24*18,24*16); // urcuje dimensions pre aplikaciu
		frame.setBounds(300, 200, 24 * 18, 24 * 16); // urcuje dimensions pre
		// aplikaciu
		jme.init();
		if (args.length == 1)
			jme.options(args[0]);
		frame.show();
		// po frame.show, aby boli zname dimension
		jme.start();

		// reads molecule (from 2008.12)
		String fileName = null;
		for (int i = 0; i < args.length; i++) {
			if (args[i].startsWith("-f")) {
				fileName = args[++i];
			} else if (args[i].startsWith("-o")) {
				jme.options(args[++i]);
			}
		}
		/*
		 * if (fileName != null) { jme.dimension = jme.size();
		 * jme.readFile(fileName); }
		 */
		
		//BB
		// Add a window listener JDK 1.1 for closing the window using the X button of the window
		//Note: BB removed the END button
		frame.addWindowListener ( new WindowAdapter() {
			public void windowClosing ( WindowEvent evt ) {
				System.exit(0);
			}
		});
		
		
		//works
		//frame.addMouseWheelListener(jme);

	}

	// BB - this method can be used only by input events methods
	void mustRedrawNothing() {
		mustReDrawLeftMenu = false;
		mustReDrawTopMenu = false;
		mustReDrawMolecularArea = false;
		//mustReDrawInfo = false; //handled automatically by the info() method

	}

	// BB
	public void mustRedrawEverything() {
		mustReDrawLeftMenu = true;
		mustReDrawTopMenu = true;
		mustReDrawMolecularArea = true;
		mustReDrawInfo = true;

	}

	// --------------------------------------------------------------------------
	public Color getColor() {
		return bgColor; // it may be used to color other stuff with mi colors
	}

	// --------------------------------------------------------------------------
	public void activateQuery() {
		// v JME menu nastavi na query (ak bolo medzitym ine)
		if (action != JME.ACTION_QRY) {
			action = ACTION_QRY;
			repaint();
		}
	}

	// ----------------------------------------------------------------------------
	@Override
	public void init() {

		if(this.isJavaScript) {
			programName = "JSME";
		} else {
			programName = "JME" ;
		}

		Container parent = this.getParent();
		parent.addMouseWheelListener(this); //works
		//parent.addMouseListener(this); //has no effects in Java in Applet or Application run mode

		// tu su veci co suvisia s grafikou

		// addMouseListener(this);
		// addMouseMotionListener(this);
		// addKeyListener(this);

		//BB
		this.copyPastePopupMenuMol = this.createCopyPastePopupMenu(false);
		this.copyPastePopupMenuReaction = this.createCopyPastePopupMenu(true);

		//Show the copyright stuff at the bottom of the page when the applet starts
		info(programName + " " + startInfoText);




		dimension = size(); // potrebne pre centrovanie nacitanej molekuly //needed for centering loaded molecules

		setLayout(null);

		// NS3 ma error vo font metrics (nedava ascent)
		//fontSize = 8;

		if (!newLook) menuCellBorder = 0;
		if (menuCellFont == null) { // kvoli IE, ktory aj pri Back vola init
			menuCellFont = new Font(defaultFontFamily, Font.PLAIN, fontSize);
			menuCellFontMet = getFontMetrics(menuCellFont);
		}
		if (menuCellFontBold == null) { // kvoli IE, ktory aj pri Back vola init
			menuCellFontBold = new Font(defaultFontFamily, Font.BOLD, fontSize);
			menuCellFontBoldMet = getFontMetrics(menuCellFontBold);
		}

		// int fs = fontSize-1;
		int smallerFontSize = fontSize - 2; //OK for the Java VM

		if (menuCellFontSmaller == null) {
			menuCellFontSmaller = new Font(defaultFontFamily, Font.PLAIN, smallerFontSize);
			menuCellFontSmallerMet = getFontMetrics(menuCellFontSmaller);
		}

		//BB: independent font size for the dialog boxes
		if(this.dialogFont == null) {
			//BB It is not necesssary to specify a font, the default one looks good
			this.dialogFont = null;
			//this.dialogFont = new Font(null, Font.PLAIN, this.dialogFontSize);
		}
		
		
		//BB: independant font size for the atoms in the molecular area
		//if(this.atomDrawingAreaFont == null) {

		initatomDrawingAreaFont(this.atomMolecularDrawingAreaFontSize);
		
		// este aj tu aby sa vzdy iniciovali pre reload
		// ??? urobit to lepsie
		query = false;
		reaction = false;
		autoez = true;
		stereo = true;
		canonize = true;
		xButton = true;
		rButton = false;
		ACTIONA = 10;
		showHydrogens = true;

		if (!isStandAloneApplication) {
			try { // chytanie exception kvoli startu z ineho appletu
				String options = getParameter("options");
				if (options != null)
					options(options, false);
				String jme = getParameter("jme");
				if (jme != null)
					jmeString = jme;
				String molf = getParameter("mol");
				if (molf != null)
					molString = molf;
				String dc = getParameter("depictcgi");
				if (dc != null) {
					depictcgi = dc;
					runsmi = true;
				} // sets runsmi, pred smi
				// v parametroch depictcgi PRED smiles, upravit ????
				String s = getParameter("smiles");
				if (s != null)
					smilesString = s;
				String mt = getParameter("text");
				if (mt != null) {
					molText = mt;
					repaint();
				}
				atomColors = getParameter("atomcolors"); // only 1 of these 2
				atomBgColors = getParameter("atombg");
				String bc = getParameter("depictbg");
				if (bc != null && depict)
					canvasBg = parseHexColor(bc);

				if (showAtomNumbers)
					showAtomNumbers();

				String jsFunction = getParameter("notify_structural_change_js_function");
				this.setNotifyStructuralChangeJSfunction(jsFunction);

			} catch (Exception e) {
				//System.err.println("JME:no parameters");
			}
		}

		action = ACTION_BOND_SINGLE; // musi to tu but, inak nic

		// get gif icons
		// Toolkit toolkit = Toolkit.getDefaultToolkit();
		// infoImage =
		// toolkit.getImage(getClass().getResource("jmeimages/info.gif"));

		// negraficka inicializacia
		atomicData();

		// 2002.06
		validate();

		//BB
		if(this.canMultipleUndo) {
			this.molChangeManager = new ChangeManager<SavedState>();
			//this.postSave(); //no effects because mol is not part of the array molparts and because it has no atoms
		}

	}
	
	//the cache is useful for JSME when there are many instance in depict mode for performance reason
	//stringWidht is expensive, the JSAppplet implementation has a cache inside each font metric instance
	public static final int maxFontSize = 100;
	public static Font[] atomDrawingAreaFontCache = new Font[maxFontSize];
	public static FontMetrics[] atomDrawingAreaFontMetCache = new FontMetrics[maxFontSize];
	
	public void initatomDrawingAreaFont(float realFs) {
		int fs = Math.round(realFs);
		if(fs < maxFontSize) {
			if(atomDrawingAreaFontCache[fs] == null) {
				atomDrawingAreaFontCache[fs]= new Font(defaultFontFamily, Font.PLAIN, fs);
			}
			if(atomDrawingAreaFontMetCache[fs] == null) {
				atomDrawingAreaFontMetCache[fs] = getFontMetrics(atomDrawingAreaFontCache[fs]);
			}
		
			this.atomDrawingAreaFont = atomDrawingAreaFontCache[fs];
			this.atomDrawingAreaFontMet =  atomDrawingAreaFontMetCache[fs];
		} else {
			assert(false);
			
		}
		
	}

	public void setAtomDrawingAreaFontSize(float fs) {
		this.atomMolecularDrawingAreaFontSize = fs;
		this.repaint();
	}
	// ----------------------------------------------------------------------------
	private Color parseHexColor(String hex) {
		Color c = Color.white;
		try {
			if (!hex.startsWith("#"))
				throw new Exception("bad hex encoding");
			int r = Integer.parseInt(hex.substring(1, 3), 16);
			int g = Integer.parseInt(hex.substring(3, 5), 16);
			int b = Integer.parseInt(hex.substring(5, 7), 16);
			c = new Color(r, g, b);
			return c;
		} catch (Exception e) {
			System.err.println("Problems in parsing background color " + hex);
			return c;
		}
	}

	// ----------------------------------------------------------------------------
	public void start() {
		// System.err.println("start");
		// cita molekuly (uz by malo poznat dimension)
		// addNotify(); // ??? nekompatibilne z mipc
		dimension = size();


		if (jmeString != null) {
			readMolecule(jmeString, false); //no repaint because the applet viewer will call repaint() after start()
			// co s coloring multipart a reactions ???
			// only 1 coloring scheme (atoms || bg) may be applied
			if (atomBgColors != null && mol != null)
				mol.setAtomColors(atomBgColors, true);
			if (atomColors != null && mol != null)
				mol.setAtomColors(atomColors, false);
			//this.postSave(); //BB not needed - readMolecule does it

		} else if (molString != null) {
			readMolFile(molString, false, false); // coloring tam //no repaint because the applet viewer will call repaint() after start()
			//this.postSave(); //BB not needed -readMolFile does it
		}
		// else if (smiles != null) readSmiles(smiles);
		// toto musi byt after vytvotrenie mol, aby bolo dimenzovane
		
		else if (smilesString != null && this.useOpenChemLib) {

			// with a local or global instance of RunAsyncCallback, then code split does not work
//			this.read_MOL_SDF_RXN(smilesString, null); // works also
			this.handleReadGenericInput(smilesString, null);
		}
	}

	// ----------------------------------------------------------------------------
	public void stop() {
		// System.err.println("stop");
		if (smilesBox != null)
			smilesBox.dispose();
		if (atomxBox != null)
			atomxBox.dispose();
		if (aboutBox != null)
			aboutBox.dispose();
		if (queryBox != null)
			queryBox.dispose();
		moleculeParts = null; // memory leak ?
	}

	// ----------------------------------------------------------------------------
	// --- public functions
	// -------------------------------------------------------
	// ----------------------------------------------------------------------------
	// for JavaScript to establish connection with JME
	public void ping() {
	}

	// ----------------------------------------------------------------------------
	public String smiles() {


		String smiles = Smiles();
		this.mustRedrawNothing(); //BB - info will be redrawed if changed




		//mol.touchedAtom = 0;
		//mol.touchedBond = 0;


		repaint(); // aby ked je chyba v smilesi (stereo) aby sa objavilo info



		return smiles;
	}

	// ----------------------------------------------------------------------------
	public String nonisomericSmiles() {
		boolean originalStereo = stereo;
		stereo = false;
		String smiles = Smiles();
		stereo = originalStereo;
		repaint(); // aby ked je chyba v smilesi, aby sa objavilo info
		return smiles;
	}

	// ----------------------------------------------------------------------------
	String Smiles() {
		String s;
		if (reaction)
			s = partSmiles(1) + ">" + partSmiles(2) + ">" + partSmiles(3);
		else {
			s = partSmiles(0);
			if (s.length() > 0) {
				molStack.addElement(new JMEmol(mol)); // adding molecule to
				// stack
				// skoci na koniec s molsack pointer
				stackPointer = molStack.size() - 1;
			}
		}
		return s;
	}

	// ----------------------------------------------------------------------------
	String partSmiles(int pp) {
		// vracia multipart smiles, ak pp != 0 (reaction) iba pre tu part
		// neskor pridat sort jednotlivych smilesov (alfanumeric)
		String s = "";
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			if (pp > 0) {
				int p = moleculeParts[m].reactionPart();
				if (p != pp)
					continue;
			}
			//String smiles = moleculeParts[m].createSmilesWithSideEffect();//BB: original SMILES
			String smiles = moleculeParts[m].createSmiles(); //BB: make a copy of the mol and do createSmilesWithSideEffect on it
			if (smiles.length() > 0) {
				if (s.length() > 0)
					s += ".";
				s += smiles; // ta molekula moze byt empty
			}
		}
		return s;
	}

	// ----------------------------------------------------------------------------
	public void reset(boolean repaint) {
		// volane zvonka - vymaze vsetko
		action = ACTION_BOND_SINGLE;
		newMolecule = false;
		
		clearMyMolecularContent();

		molText = null;
		depictScale = 1.; // ??? ked depict viac molekul po sebe

		// BB
		mustReDrawMolecularArea = true;

		if(repaint)
			repaint();
		
		this.recordAfterStructureChangedEvent(JME.RESET);
		notifyStructuralChangeToJS();

	}
	public void reset() {
		this.reset(true);
	}
	
	
	public void clearMyMolecularContent() {
		numberofMoleculeParts = 0;
		// JMEmol.maxMark = 0;
		actualMoleculePartIndex = 0;
		mol = new JMEmol(this); // treba
		mol.maxMark = 0;

		molText = null;
		
	}
	// ----------------------------------------------------------------------------
	public void clear() {
		// zmaze actualMoleculePartIndex, zmensi pocet molekul, actual bude najvyssia

		// BB
		mustReDrawMolecularArea = true;


		action = ACTION_BOND_SINGLE;
		newMolecule = false;

		if (numberofMoleculeParts == 0)
			return;

		// BB
		mustReDrawMolecularArea = true;

		mol.preSave();
		afterClear = true;
		for (int i = actualMoleculePartIndex; i < numberofMoleculeParts; i++)
			moleculeParts[i] = moleculeParts[i + 1];
		numberofMoleculeParts--;
		actualMoleculePartIndex = numberofMoleculeParts;
		if (numberofMoleculeParts > 0)
			mol = moleculeParts[actualMoleculePartIndex]; // kvoli move
		else {
			mol = new JMEmol(this);
			mol.maxMark = 0;
		}
		
		this.recordAfterStructureChangedEvent(JME.CLEAR);
		//this.notifyStructuralChangeToJS(); //recordAfterStructureChangedEvent calls notifyStructuralChangeToJS
		
		//Jan 2016
		this.postSave();
	}

	// ----------------------------------------------------------------------------
	public String jmeFile() {
		// returns molecule(s) in jme format
		String s = "";
		if (reaction)
			s = partJme(1) + ">" + partJme(2) + ">" + partJme(3);
		else
			s = partJme(0);
		return s;
	}

	// ----------------------------------------------------------------------------
	String partJme(int pp) {
		// vracia multipart jme, ak pp != 0 (reaction) iba pre tu part
		// neskor pridat sort jednotlivych smilesov (alfanumeric)
		String s = "";
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			if (pp > 0) {
				int p = moleculeParts[m].reactionPart();
				if (p != pp)
					continue;
			}
			String jme = moleculeParts[m].createJME();
			if (jme.length() > 0) {
				if (s.length() > 0)
					s += "|";
				s += jme; // ta molekula moze byt empty
			}
		}
		return s;
	}

	// ----------------------------------------------------------------------------
	int[][] getReactionParts() {
		// returns fields of indices for reactants, products and modulators
		int part[][] = new int[4][numberofMoleculeParts + 1];
		for (int p = 1; p <= 3; p++) {
			int np = 0;
			for (int m = 1; m <= numberofMoleculeParts; m++)
				if (moleculeParts[m].reactionPart() == p)
					part[p][++np] = m;
			part[p][0] = np;
		}
		return part;
	}


	/**
	 * Read a molecule string in JME format
	 * @param molecule
	 * @param repaint 
	 */
	public void readMolecule (String molecule, boolean repaint) {
		try {
			if(this.handleReadMolecule(molecule, repaint)) {
				this.recordAfterStructureChangedEvent(JME.READ_JME);
				this.postSave();
			} else {
				repaint(); //to show errors
			}
		} catch(Exception e) {
			repaint() ; //for showing the error
		}
	}
	/**
	 * Read a molecule string in JME format
	 * @param molecule
	 */
	public void readMolecule (String molecule) {
		this.readMolecule(molecule, true);
	}

	// ----------------------------------------------------------------------------
	// makos
	protected boolean  handleReadMolecule(String molecule, boolean repaint) {
		// spracuva aj multipart a reactions (aj chybu R>P miesto R>>P)
		// input v JME format


		//this.postSave();

		//reset(repaint); //BB : cancel this: it set numberofMoleculeParts to 0
		int lastReactant = 0, firstProduct = 0;

		StringTokenizer st = new StringTokenizer(molecule, "|>", true);
		boolean inputIsReaction = (molecule.indexOf(">") > -1); //false meas it is a molecule
		int rx = 1; // pocita >

		int nt = st.countTokens();
		boolean addedToExistingParts = numberofMoleculeParts > 0;
		if (! canBeAddedToExistingMultipartOrReaction() ||
				molecule.indexOf(">") > -1) {//if reaction input: replace evrything
			numberofMoleculeParts = 0;
			addedToExistingParts = false;
		}
		

			
		for (int i = 1; i <= nt; i++) {
			String s = st.nextToken();
			s.trim();
			if (s.equals("|"))
				continue;
			if (s.equals(">")) {
				rx++;
				if (rx == 2)
					lastReactant = numberofMoleculeParts;
				else if (rx == 3)
					firstProduct = numberofMoleculeParts + 1;
				continue;
			}
			mol = new JMEmol(this, s, true);
			if (mol.natoms == 0) {
				this.showError("problems in reading/processing molecule !");
				System.err.println("ERROR while processing\n" + s);
				//continue;
				return false;  //BB
			}
			// vsetko ok - preberie ju do editora
			numberofMoleculeParts++; // moze byt aj multipart
			actualMoleculePartIndex = numberofMoleculeParts;
			moleculeParts[numberofMoleculeParts] = mol;
			// newMolecule = false;
			smol = null; // kvoli undo


		}

		// --- chyba v zadani reakcie (zly pocet >)
		if (rx == 2) {
			firstProduct = lastReactant + 1;
			this.showError("strange reaction - fixing !");
			System.err.println("ERROR - reactant and product should be separated by >>\n");
			return false;
		} else if (rx > 3) {
			this.showError("strange reaction !");
			System.err.println("ERROR - strange reaction !\n");
			return false;
		}

			//FIXME: duplicate code with reading MOL/RXN?
		if (numberofMoleculeParts > 1 && !inputIsReaction)
			options("multipart");
		if (inputIsReaction && !reaction)
			reaction=true;
		//if (!inputIsReaction && reaction && !addedToExistingParts)
		//	reaction=false;; //back to mol editing

		if (!inputIsReaction) {
			//BB: align only if needed to avoid overlap, otherwise keep original coordinates but scale if needed
			if(!reaction) {
				alignMolecules(1, numberofMoleculeParts, 0, !addedToExistingParts);
			}
		} else {
			if(!addedToExistingParts) { //aligh with one extra mol : todo correctly
				alignMolecules(1, lastReactant, 1);
				alignMolecules(lastReactant + 1, firstProduct - 1, 2);
				alignMolecules(firstProduct, numberofMoleculeParts, 3);
			}
		}
		
		//BB
		this.setMaxMapAfterReadingInput();
		
		if(repaint) 
			repaint(); 
		this.recordAfterStructureChangedEvent(JME.READ_MOL_FILE); //aded June 2016
		
		return true;
	}

	public void showError(String errorMessage) {
		this.showInfo("ERROR - " + errorMessage);

	}

	// ----------------------------------------------------------------------------
	// adding template from JavaScript
	// template menu is actually JME string
	public void setTemplate(String t, String name) {
		// clear();
		afterClear = false; // otherwise problems in undo
		boolean savedStar = this.star; //BB
		star = false; //BB to avoid a side effect linked to atom mapping (marked atom)
		templateMolecule = new JMEmol(this, t, true); // defined globally
		star=savedStar; //BB - restore
		//templateMolecule.complete(); //BB: not needed because the call above does call complete()
		// now waiting for atom or free space click
		action = ACTION_GROUP_TEMPLATE;

		// mol.center();
		// numberofMoleculeParts = 1; actualMoleculePartIndex = 1; moleculeParts[1] = mol;

		info(name);
		repaint(); // needed to display status line
	}

	/**
	 * Return the width and height of the molecular area
	 * 
	 */
	Rectangle getMolecularAreaSize() {
		if(molecularAreaWidth <= 0 || molecularAreaHeight <= 0) {
			updateMyMolecularAreaSize();
		}
		Rectangle widhtAndHeight = new Rectangle();
		widhtAndHeight.width = 	molecularAreaWidth;
		widhtAndHeight.height = molecularAreaHeight;
		
		return widhtAndHeight;
		
//		//compute the the size of the available display box for the molecular area
//		int xsize = 0;
//		int ysize = 0;
//		if(dimension != null) {
//			xsize = dimension.width;
//			ysize = dimension.height;
//			if (!depict) { //in non depict modus, space is used for the menu and info bar
//				xsize -= menuCellSize;
//				ysize -= 3 * menuCellSize;
//			} else {
//				ysize -= 16; /*space for DnD icon */
//			}
//		}
//		Rectangle widhtAndHeight = new Rectangle();
//		widhtAndHeight.width = xsize;
//		widhtAndHeight.height = ysize;
//		
//		return widhtAndHeight;
		
	}
	
	/**
	 * Return the width and height of the molecular area with scaling
	 * 
	 */
	Rectangle getMolecularAreaSizeWithScalingForDepiction() {
		//compute the the size of the available display box for the molecular area
		Rectangle widhtAndHeight = this.getMolecularAreaSize();
		
		//With a depict scale < 1, more pixels are availaible for display
		widhtAndHeight.width = scaleCoordinate(widhtAndHeight.width);
		widhtAndHeight.height = scaleCoordinate(widhtAndHeight.height);
		
		return widhtAndHeight;
		
	}
	
	void alignMolecules(int m1, int m2, int part) {
		alignMolecules(m1, m2, part, false);
	}
	// --------------------------------------------------------------------------
	//BB side effects: compute the depictScale correctly for only one time if it is different than 1.0
	//recenter molecule in depict mode
	void alignMolecules(int m1, int m2, int part, boolean donotAlignJustScale) {

		if (nocenter)
			return; // aj pre depict ???
		int nm = m2 - m1 + 1;
		if (nm <= 0 || m1 > numberofMoleculeParts || m2 > numberofMoleculeParts)
			return;
		double previousDepictScale = depictScale;
		
		double center[] = new double[4];

		int RBOND = JMEmol.RBOND;
		double[] share = new double[99]; // share na 1 mol (used pri posune)
		double sumx = 0., sumy = 0., maxy = 0.;
		for (int i = m1; i <= m2; i++) {
			CenterAndDimension cad = moleculeParts[i].computeCenterPoint(); // zisti dimenzie
			sumx += cad.sizeX;//center[2]; //width of mol
			sumy += cad.sizeY; //; //height of mol
			if (cad.sizeY > maxy)
				maxy = cad.sizeY;
			share[i] = cad.sizeX;
			if (part == 2)
				share[i] = cad.sizeY;
		}

		// prida medzery (na oboch stranach a medzi), pri !depict to netreba
		if (depict) {
			sumx += RBOND * (nm + 1);
			sumy += RBOND * (nm + 1);
			maxy += RBOND; // malo by byt * 2, ale potom su velke okraje
		}

		// niekedy moze byt nulova
//		if (dimension == null || dimension.width == 0 || dimension.height == 0)
//			dimension = size();
//		// ??? od tychto nezavisi, ale musia tu byt (ide toto 2x)
//		if (dimension.width == 0)
//			dimension.width = 400;
//		if (dimension.height == 0)
//			dimension.height = 300;

		double scalex = 1., scaley = 1.;
		
		//compute the the size of the available display box for the molecular area
		Rectangle widhtAndHeight = this.getMolecularAreaSize();
		int xsize = (int) widhtAndHeight.width;
		int ysize = (int) widhtAndHeight.height;

		if (part == 1 || part == 3)
			xsize = (xsize - arrowWidth) / 2;
		else if (part == 2)
			ysize = ysize / 2;
		
		
		if (sumx >= xsize)
			scalex = (xsize) / sumx;
		if (maxy >= ysize)
			scaley = (ysize) / maxy;

		double medzera = 0.;
		if (depict) { // cize == 1.
			depictScale = Math.min(scalex, scaley); // inak dS = 1.
			
			medzera = RBOND * xsize / sumx;
			if (part == 2)
				medzera = RBOND * ysize / sumy;
			

		}

		for (int i = m1; i <= m2; i++) {
			if (part == 2)
				share[i] = share[i] * ysize / sumy;
			else
				share[i] = share[i] * xsize / sumx;
		}

		double shiftx = -xsize / 2.;
		double shifty = 0.;
		if (part == 1)
			shiftx = -xsize - arrowWidth / 2.;
		else if (part == 3)
			shiftx = arrowWidth / 2.;
		else if (part == 2) {
			shiftx = 0.;
			shifty = -ysize;
		} // preco nie ..+2*sd ???

		for (int i = m1; i <= m2; i++) {

			// ??? toto sposobuje problemy depictScale = 0 ???
			if (depict) { // pri depicte zmensuje
				if (!this.scalingIsPerformedByGraphicsEngine) {
					for (int a = 1; a <= moleculeParts[i].natoms; a++) {
//						moleculeParts[i].x[a] *= depictScale;
//						moleculeParts[i].y[a] *= depictScale;
						moleculeParts[i].atoms[a].scaleXY(depictScale);
					}
				}
				moleculeParts[i].center(); // este raz, teraz uz zmensene
			}

			// pri depict urobi aj medzeru
			if (part == 2)
				shifty += (share[i] / 2. + medzera);
			else
				// part == 1, 3, or 0
				shiftx += (share[i] / 2. + medzera);

			//BB correction afterwards, otherwise the shiftx and shifty are too small
//			if(this.scalingIsPerformedByGraphicsEngine) {
//				shiftx /= depictScale;
//				shifty /= depictScale;
//			}

			if(! donotAlignJustScale) { //bad patch to fix a bug
				for (int a = 1; a <= moleculeParts[i].natoms; a++) {
	//				moleculeParts[i].moveXY(a, shiftx, shifty);
					moveXY(moleculeParts[i],a, shiftx, shifty);
	//				moleculeParts[i].x(a) += shiftx;
	//				moleculeParts[i].y(a) += shifty;
				}
			}

			if (part == 2)
				shifty += share[i] / 2.;
			else
				shiftx += share[i] / 2.;

			if (!depict)
				moleculeParts[i].findBondCenters();
		}
		
		//BB correction: the depictScale must be absolute
		depictScale *= previousDepictScale; //used with iPad scaling
	}

	// --------------------------------------------------------------------------
	public String molFile() {
		return this.molFile(false);
	}
	
	public String molFile(boolean isV3000) {
		return this.molFile(null, true, isV3000);
	}
	public String molFile(String header, boolean stampDate, boolean isV3000) {
		// creates mol file, multipart sd file or reaction (rxn file)
		
		if( header == null) {
			header = smiles(); // now, otherwise for multipart cuts them
		}
		
		String s = "";
		if (reaction) {
			int part[][] = getReactionParts();
			// discarding modulators (if any)
			s += "$RXN" + separator + separator + separator
					+ "JME Molecular Editor" + separator;
			s += JMEmol.iformat(part[1][0], 3) + JMEmol.iformat(part[3][0], 3)
					+ separator;
			for (int i = 1; i <= part[1][0]; i++)
				s += "$MOL" + separator
				+ moleculeParts[part[1][i]].createMolFile(header, stampDate);
			for (int i = 1; i <= part[3][0]; i++)
				s += "$MOL" + separator
				+ moleculeParts[part[3][i]].createMolFile(header, stampDate);
		} else { // viac molekul do 1 mol file
			if (numberofMoleculeParts > 1)
				mol = new JMEmol(this, moleculeParts, numberofMoleculeParts);
			if(! isV3000) 
				s = mol.createMolFile(header, stampDate);
			else //BB
				s = mol.createExtendedMolFile(header, stampDate);
			if (numberofMoleculeParts > 1)
				mol = moleculeParts[actualMoleculePartIndex];
		}
		return s;
	}

	
	// --------------------------------------------------------------------------

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * @param molecule string
	 */
	public void readMolFile(String molecule) {
		readMolFile(molecule, true);
	}

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * @param molecule string
	 */
	public void readMolFile(String molecule, boolean undoSave) {
		this.readMolFile( molecule, undoSave, true);
	}
	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * @param molecule string
	 */
	public void readMolFile(String molecule, boolean undoSave, boolean repaint) {
		try {
			if(this.handleReadMolFileRXN(molecule, repaint)) {
				if(undoSave) {
					this.postSave();
				}
			} else {
				repaint(); //to show errors
			}
		} catch(Exception e) {
			repaint() ; //for showing the error
		}
	}

	/**
	 * Read the molfile and repaint the applet when done
	 * @param MOL or a RXN
	 * @return true on success
	 */
	protected boolean handleReadMolFile(String s) {
		return handleReadMolFileRXN(s,true);
	}
	
	/**
	 * input can be a MOL, RXN, smiles or SMIRKS
	 * @param s
	 */
	
	public void handleReadGenericInput(final String s, final RunAsyncCallback sucessAndFailureHandler) {

		
		// count home many lines we have in the input file
		//if only one or two, then read the input as SMILES using the Actelion library
		
		Exception error = new Exception("Invalid molfile");
		if( JMEmol.findLineSeparator(s) != null) {
			boolean success = JME.this.handleReadMolFile(s);
			if (success) {
				if (sucessAndFailureHandler != null) sucessAndFailureHandler.onSuccess();
			} else {
				if (sucessAndFailureHandler != null) sucessAndFailureHandler.onFailure(error);
			}
		} else if(this.useOpenChemLib) {
			//SMILES interpretation uses code splitting
			GWT.runAsync(new JSME_RunAsyncCallback() {
				
				@Override
				public void onSuccess() {
					boolean success = false;
					Exception error = null;

						//TODO: read SMIRKS
						try {
							success = JME.this.handleReadMolFile(JME.this.SMILESorSMIRKStoMolOrRXN(s));
						}
						catch (Exception e) {
							success= false;
							error = e;
						}
					if (success) {
						if (sucessAndFailureHandler != null) sucessAndFailureHandler.onSuccess();
						JME.this.info("SMILES conversion provided by OpenChemLib");
					} else {
						if (sucessAndFailureHandler != null) sucessAndFailureHandler.onFailure(error);
					}
				}
		});
		
		} else {
			if (sucessAndFailureHandler != null) sucessAndFailureHandler.onFailure(error);
		}
	}
	
	/**
	 * Use the openchemlib to convert a smiles to a molfile string
	 * 2D coordinates are generated
	 * @param smiles
	 * @return
	 * @throws Exception
	 */
	public String SMILEStoMOL(String smiles) throws Exception {
		String result = null;
		StereoMolecule mol = new StereoMolecule();
		new SmilesParser().parse(mol, smiles.trim());

		MolfileCreator mfc = new MolfileCreator(mol);
		result = mfc.getMolfile();
		
		return result;
	}

	/**
	 * Use the openchemlib to convert a smirks to a rxn string
	 * 2D coordinates are generated
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	//TODO: handle a>b>c
	public String SMIRKStoRXN(String smirks) throws Exception {
		String[] parts = smirks.split(">>");
		assert parts.length == 2;
		
		String reactants = this.SMILEStoMOL(parts[0]);
		String products = this.SMILEStoMOL(parts[1]);
		String s = "";
			// discarding modulators (if any)
		s += "$RXN" + separator + separator + separator
					+ "JME Molecular Editor" + separator;
		s += JMEmol.iformat(1, 3) + JMEmol.iformat(1, 3)
					+ separator;
		s += "$MOL" + separator
				+ reactants;
		s += "$MOL" + separator
				+ products;
		
		
		return s;
	}
	
	/**
	 * Use the openchemlib to convert a smiles or a smirks to a mol or rxn string
	 * 2D coordinates are generated
	 * 
	 * @param smilesOrsmirks
	 * @return
	 * @throws Exception
	 */
	public String SMILESorSMIRKStoMolOrRXN(String smilesOrsmirks) throws Exception {
		if(smilesOrsmirks.contains(">>")) {
			return this.SMIRKStoRXN(smilesOrsmirks);
		} else {
			return this.SMILEStoMOL(smilesOrsmirks);
		}

	}
	/**
	 * Used for testing without GUI
	 * @param MOL or a RXN
	 * @return true on success
	 */
	public boolean  readMolFileOrRXN(String s) {
		return this.handleReadMolFileRXN(s, false);
	}

	boolean canBeAddedToExistingMultipartOrReaction() {
		return  ((reaction || multipart) && addNewPart);
	}

	/**
	 * @param MOL or a RXN
	 * @return true on success
	 */
	boolean handleReadMolFileRXN(String s, boolean repaint) {
		//NumberFormatException : for interpreting   the integers
		// Should not perform a save to the undo/redo manager since an exception could be raised

		//BB: change June 2014: allow at add extra molecule when multipart is True
		//reset(repaint); // set numberofMoleculeParts = 0
		if (s.startsWith("$RXN")) { // reaction
			numberofMoleculeParts = 0; //overwrite everything for a reaction
			reaction = true;
			multipart = true;
			String separator = JMEmol.findLineSeparator(s);
			StringTokenizer st = new StringTokenizer(s, separator, true);
			String line = "";
			for (int i = 1; i <= 5; i++) {
				line = JMEmol.nextData(st, separator);
			}
			int nr = Integer.valueOf(line.substring(0, 3).trim()).intValue();
			int np = Integer.valueOf(line.substring(3, 6).trim()).intValue();
			JMEmol.nextData(st, separator); // 1. $MOL
			for (int p = 1; p <= nr + np; p++) {
				String m = "";
				while (true) {
					String ns = JMEmol.nextData(st, separator);
					if (ns == null || ns.equals("$MOL"))
						break;
					else
						m += ns + separator;
				}
				// System.err.print("MOLS"+p+separator+m);
				moleculeParts[++numberofMoleculeParts] = new JMEmol(this, m); //TODO: this can fail and raise an exception
			}
			alignMolecules(1, nr, 1);
			alignMolecules(nr + 1, nr + np, 3);
			this.recordAfterStructureChangedEvent(JME.READ_RXN_FILE); //dec 2014
		} else { // single molecule - ak multipart automaticky urobi multipart
			
			//June 2014: if there a mutipart already (e.g.) a reaction, pasting an additional structure will add
			//it to the existing parts and not replace everything, UNLESS depict mode
			if(true) {
				//reaction = false;
				
				if(depict || pasteFromSDFstack) { //BB let the incoming structure determine the editor mode when in depict mode
					reaction = false;
					multipart = false;
				}
				mol = new JMEmol(this, s); //TODO: this can fail and raise an exception
				// the constructor neve returns a null
				if (mol == null || mol.natoms == 0) { //An empty molfile (0 atoms) is valid input: return true
					// 2008.12
					// info("ERROR - problems in reading/processing molecule !");
					// System.err.println("ERROR while processing\n"+s);
	
					//BB: turn back on the display of the error message
					if(mol == null)
						this.showError("problems in reading/processing MOL input");
					
					return mol != null;
				}
				
				// message will not be visible because "structure pasted will be shown just after
//				if (mol.natoms == 0) { //An empty molfile (0 atoms) is valid input
//					this.showInfo("MOL input with 0 atoms");
//					return true;
//				}
				
				//New June 2014
				//Feb 2016: in depict mode
				
				boolean addedToExistingMultipartOrReaction = canBeAddedToExistingMultipartOrReaction();
				
				// coloring tu, inak pri multiupart problemy
				if (atomBgColors != null && mol != null)
					mol.setAtomColors(atomBgColors, true);
				if (atomColors != null && mol != null)
					mol.setAtomColors(atomColors, false);
				
				if( !addedToExistingMultipartOrReaction) {
					numberofMoleculeParts = 0; //the new parts will not be appended to the moleculeParts[]
				}

				// ak multipart, urobi viac molekul
				int nparts = mol.checkMultipart(false);
				
				//only one part or depict mode: don't need to set/split the multiparts
				if (nparts <= 1 || depict) {//Feb 2016: in depict mode, nparts=0 if empty molecule
					moleculeParts[++numberofMoleculeParts] = mol;
				} else {
					multipart = true;
					//addedToExistingMultipartOrReaction = false; //replace all parts with the new mols, like reading an existing reaction over a reaction
					for (int p = 1; p <= nparts; p++) {
						//extrat each part /and append it to the moleculeParts
						moleculeParts[++numberofMoleculeParts] = new JMEmol(this, mol, p); // aj vycentruje
					}
				}
				
				if(addedToExistingMultipartOrReaction ) {
					actualMoleculePartIndex = numberofMoleculeParts; // the last added mol will be the selected one
					
				} else {
					actualMoleculePartIndex = 1;
				}
				
				mol = moleculeParts[actualMoleculePartIndex]; // odstrani povodnu multipart mol
				// newMolecule = false;
				smol = null; // kvoli undo
				
//				if(addedToExistingMultipartOrReaction) { //BB April 2016 Google+ bug report received by Peter
//					// this creates another bug: in depict mode the structures are not scaled crap 
//					alignMolecules(1, nparts, 0);         // I also commented the line center() in public JMEmol(JME jme, JMEmol m, int part)
//				}
				
				//BB April 2016 Google+ bug report received by Peter
				// this creates another bug: in depict mode the structures are not scaled crap 
				alignMolecules(1, nparts, 0, !addedToExistingMultipartOrReaction);
				// I also commented the line center() in public JMEmol(JME jme, JMEmol m, int part)
				
				this.recordAfterStructureChangedEvent(JME.READ_MOL_FILE);
				
			} else { //older code kept 
				reaction = false;
				mol = new JMEmol(this, s);
	
				if (mol == null || mol.natoms == 0) {
					// 2008.12
					// info("ERROR - problems in reading/processing molecule !");
					// System.err.println("ERROR while processing\n"+s);
	
					//BB: turn back on the display of the error message
					this.showError("problems in reading/processing MOL input");
					return false;
				}
				// coloring tu, inak pri multiupart problemy
				if (atomBgColors != null && mol != null)
					mol.setAtomColors(atomBgColors, true);
				if (atomColors != null && mol != null)
					mol.setAtomColors(atomColors, false);
				// ak multipart, urobi viac molekul
				int nparts = mol.checkMultipart(false);
				if (nparts == 1) {
					moleculeParts[++numberofMoleculeParts] = mol;
				} else {
					multipart = true;
					for (int p = 1; p <= nparts; p++)
						moleculeParts[++numberofMoleculeParts] = new JMEmol(this, mol, p); // aj vycentruje
				}
				actualMoleculePartIndex = 1;
				mol = moleculeParts[actualMoleculePartIndex]; // odstrani povodnu multipart mol
				// newMolecule = false;
				smol = null; // kvoli undo
				alignMolecules(1, nparts, 0);
			}
		}
		
		// BB october 2015 -LP request
		// set the max mark after reading input
		setMaxMapAfterReadingInput();

		if(repaint)
			repaint();
		
		return true; //success
	}

	public int findMaxAtomMapAmongAllMolecules() {
		//first find the max
		int max = -99999;

		
		for(int p = 1; p <= numberofMoleculeParts; p++ ) {
			JMEmol mol = moleculeParts[p];
			int molMaxMap = mol.geMaxAtomMap();
			if(molMaxMap> max) max = molMaxMap;
		}

		return max;
	}
	public void setMaxMapAfterReadingInput() {
		int max = this.findMaxAtomMapAmongAllMolecules();
		
		
		// assign the max
		for(int p = 1; p <= numberofMoleculeParts; p++ ) {
			JMEmol mol = moleculeParts[p];
			mol.maxMark = max;
		}
		
	}
	// --------------------------------------------------------------------------
	// called from JavaScript menu, sets Rgroup
	public void setSubstituent(String s) {
		// substituent menu
		int pressed = -1;
		if (s.equals("Select substituent")) {
			pressed = ACTION_BOND_SINGLE;
			s = "";
		} else if (s.equals("-C(=O)OH"))
			pressed = ACTION_GROUP_COO;
		else if (s.equals("-C(=O)OMe"))
			pressed = ACTION_GROUP_COOME;
		else if (s.equals("-C(=O)N"))
			pressed = ACTION_GROUP_CON;
		else if (s.equals("-NC=O"))
			pressed = ACTION_GROUP_NCO;
		else if (s.equals("-OC(=O)Me"))
			pressed = ACTION_GROUP_OCOME;
		else if (s.equals("-CMe3"))
			pressed = ACTION_GROUP_TBU;
		else if (s.equals("-CF3"))
			pressed = ACTION_GROUP_CF3;
		else if (s.equals("-CCl3"))
			pressed = ACTION_GROUP_CCL3;
		else if (s.equals("-NO2"))
			pressed = ACTION_GROUP_NITRO;
		else if (s.equals("-NMe2"))
			pressed = ACTION_GROUP_NME2;
		else if (s.equals("-SO2-NH2"))
			pressed = ACTION_GROUP_SO2NH2;
		else if (s.equals("-NH-SO2-Me"))
			pressed = ACTION_GROUP_NHSO2ME;
		else if (s.equals("-SO3H"))
			pressed = ACTION_GROUP_SULFO;
		else if (s.equals("-PO3H2"))
			pressed = ACTION_GROUP_PO3H2;
		else if (s.equals("-C#N"))
			pressed = ACTION_GROUP_CYANO;
		else if (s.equals("-C#C-Me"))
			pressed = ACTION_GROUP_CCC;
		else if (s.equals("-C#CH"))
			pressed = ACTION_GROUP_CC;

		if (pressed > 0) {
			menuAction(pressed);
		}
		else
			s = "Not known group!";
		info(s);
		repaint();
	}

	// --------------------------------------------------------------------------
	public void options(String parameters) {
		this.options(parameters, true);
		
	}
	public void options(String parameters, boolean repaint) {
		parameters = parameters.toLowerCase();
		if (parameters.indexOf("norbutton") > -1)
			rButton = false;
		else if (parameters.indexOf("rbutton") > -1)
			rButton = true;
		if (parameters.indexOf("nohydrogens") > -1)
			showHydrogens = false;
		else if (parameters.indexOf("hydrogens") > -1)
			showHydrogens = true;
		
		if (parameters.indexOf("keephs") > -1) {
			keepHydrogens = true;
			removeOnlyCHydrogens = false;
		}
		if (parameters.indexOf("removehs") > -1) {
			keepHydrogens = false;
			removeOnlyCHydrogens = false;
		}

		if (parameters.indexOf("removehsc") > -1) {
			keepHydrogens = false;
			removeOnlyCHydrogens = true;
		}
		if (parameters.indexOf("noquery") > -1)
			query = false;
		else if (parameters.indexOf("query") > -1)
			query = true;
		if (parameters.indexOf("noreaction") > -1)
			reaction = false;
		else if (parameters.indexOf("reaction") > -1)
			reaction = true;
		if (parameters.indexOf("noautoez") > -1)
			autoez = false;
		else if (parameters.indexOf("autoez") > -1)
			autoez = true;
		if (parameters.indexOf("nostereo") > -1)
			stereo = false;
		else if (parameters.indexOf("stereo") > -1)
			stereo = true;
		if (parameters.indexOf("nocanonize") > -1)
			canonize = false;
		else if (parameters.indexOf("canonize") > -1)
			canonize = true;
		if (parameters.indexOf("nomultipart") > -1)
			multipart = false;
		else if (parameters.indexOf("multipart") > -1)
			multipart = true;
		if (parameters.indexOf("nonumber") > -1) {
			number = false;
			autonumber = false;
		} else if (parameters.indexOf("number") > -1) {
			number = true;
			autonumber = false;
		}
		if (parameters.indexOf("newlook") > -1) {
			newLook = true;
			menuCellBorder = 1;
		}
		else if (parameters.indexOf("oldlook") > -1) {
			newLook = false;
			menuCellBorder = 0;
		}
		if (parameters.indexOf("autonumber") > -1) {
			autonumber = true;
			number = true;
		}
		if (parameters.indexOf("star") > -1) {
			star = true;
			number = true;
		}
		if (parameters.indexOf("nostar") > -1) { //BB
			star = false;
			number = false;
		}
		if (parameters.indexOf("polarnitro") > -1)
			polarnitro = true;
		if (parameters.indexOf("nopolarnitro") > -1) //BB
			polarnitro = false;
		
		if(parameters.indexOf("toggle") > -1 ) {
			toggleDepictEdit = true;
		}
		if(parameters.indexOf("notoggle") >-1) {
			toggleDepictEdit = false;
		}

		if (parameters.indexOf("depict") > -1 && depict == false) {
			depict = true;
			menuCellSize = 0;
			molecularArea = null; // pre prechode z depict je ta primala
			// toto len pre norm moleculeParts, nie pre reaction !!!
			alignMolecules(1, numberofMoleculeParts, 0);
			paste = false;  //BB March 2014 : default does not accept paste anymore
			this.resetPopupMenu();
			this.resetAllGraphics();
		}
		//BB CHeck if nodepictaction is used
		if (parameters.indexOf("nodepict" ) > -1 && depict == true) {
			depict = false;
			depictScale = 1; // inak kresli mensi font
			// musi male molekuly vratit na povodnu velkost
			for (int i = 1; i <= numberofMoleculeParts; i++) {
				moleculeParts[i].scaling();
				moleculeParts[i].center(); // este raz, teraz uz zmensene
			}
			//BB moved above - fixed a bug
			//depictScale = 1; // inak kresli mensi font
			// normal font (ak bola mensia molekula) sa nastavi v
			// drawMolecularArea
			menuCellSize = standardMenuCellSize;
			if (mol != null)
				mol.needRecentering = true;
			
			paste = true;  //BB March 2014 : 
			this.resetPopupMenu();
			this.resetAllGraphics();

		}
		//BB
		if (parameters.indexOf("depictaction") > -1) {
			depictActionEnabled = true;
		}
		//BB
		if (parameters.indexOf("nodepictaction") > -1) {
			depictActionEnabled = false;
		}
		
		
		//BB
		if (parameters.indexOf("showDragAndDropSymbolInDepictMode".toLowerCase()) > -1) {
			showDragAndDropSymbolInDepictMode = true;
		}
		//BB
		if (parameters.indexOf("noShowDragAndDropSymbolInDepictMode".toLowerCase()) > -1) {
			showDragAndDropSymbolInDepictMode = false;
		}
		
		//BB
		if (parameters.indexOf("addNewPart".toLowerCase()) > -1) {
			addNewPart = true;
		}
		//BB
		if (parameters.indexOf("noaddNewPart".toLowerCase()) > -1) {
			addNewPart = false;
		}

		
		if (parameters.indexOf("xbutton") > -1) {
			xButton = true;
		}
		if (parameters.indexOf("noxbutton") > -1) {
			xButton = false;
		}
		
		boolean previousPaste = this.paste;
		if (parameters.indexOf("nopaste") > -1)
			paste = false;
		else if (parameters.indexOf("paste") > -1)
			paste = true;
		
		if(previousPaste != this.paste) {
			this.resetPopupMenu(); //the pop menu contains a paste entry that night need to be removed or added
		}
		
		if (parameters.indexOf("border") > -1) {
			depictBorder = true;
		}
		//BB
		if (parameters.indexOf("noborder") > -1) {
			depictBorder = false;
		}
		// undocumented options
		if (parameters.indexOf("writesmi") > -1)
			writesmi = true;
		if (parameters.indexOf("writemi") > -1)
			writemi = true;
		if (parameters.indexOf("writemol") > -1)
			writemol = true;
		if (parameters.indexOf("nocenter") > -1)
			nocenter = true;
		if (parameters.indexOf("jmeh") > -1)
			jmeh = true;
		if (parameters.indexOf("showan") > -1)
			showAtomNumbers = true;
		// System.out.println(rButton+" "+showHydrogens+" "+query+" "+autoez+" "+stereo+" "+canonize+" "+reaction);

		//BB
		if(parameters.indexOf("atommovebutton") > -1)
			showAtomMoveButton = true;
		if(parameters.indexOf("noatommovebutton") > -1)
			showAtomMoveButton = false;
		

		if(parameters.indexOf("useopenchemlib") > -1)
			useOpenChemLib = true;
		if(parameters.indexOf("nouseopenchemlib") > -1)
			useOpenChemLib = false;
		
		if(parameters.indexOf("zoom") > -1)
			allowZooming = true;
		if(parameters.indexOf("nozoom") > -1)
			allowZooming = false;
		
		
		// zladi options - ake dalsie ???
		if (reaction) {
			//BB: if a reaction is read, then the numbering should be autonumber and not number. This should be checked by Peter.
			//With autonumber, one can assign different atom map numbers
			//number = true;
			autonumber = true;
			multipart = true;
		}
		if (!depict)
			depictBorder = false;
		// positions and actions for X and Rx buttons
		// nove X a R action musia byt > 300
		if (rButton)
			ACTIONA++;
		
		
		if(repaint)
			repaint();
	}
	protected void resetAllGraphics() {
		// for subclass
		this.mustRedrawEverything();
		this.molecularArea = null;
		this.topMenu = null;
		this.leftMenu=null;
		this.infoArea=null;

		
	}

	/**
	 * See also getCopyPastePopupMenuMol() and getCopyPastePopupMenuReaction()
	 */
	protected void resetPopupMenu() {
		this.copyPastePopupMenuMol = null;
		this.copyPastePopupMenuReaction = null;
		
	}

	// --------------------------------------------------------------------------
	public void setText(String text) {
		molText = text;
		repaint();
	}

	// --------------------------------------------------------------------------
	public void showAtomNumbers() {
		// shows canonical atom numbering
		// numbers only actual molecule !!!
		if (mol != null)
			mol.numberAtoms();
	}

	// ----------------------------------------------------------------------------
	public boolean hasPrevious() {
		if (molStack.size() == 0 || stackPointer == 0)
			return false;
		return true;
	}

	// ----------------------------------------------------------------------------
	public void getPreviousMolecule() {
		getFromStack(-1);
	}

	// ----------------------------------------------------------------------------
	void getFromStack(int n) {
		info("");
		clear();
		// musi vytvorit kopiu, nie len brat poiner (lebo je zmeni)
		stackPointer += n;
		mol = (JMEmol) molStack.elementAt(stackPointer).deepCopy();
		mol.center();
		numberofMoleculeParts = 1;
		actualMoleculePartIndex = 1;
		moleculeParts[1] = mol;

		// BB
		mustReDrawMolecularArea = true; //not needed because clear() does it
		repaint();
		smol = null; // kvoli undo
	}

	// ----------------------------------------------------------------------------
	// --- end of public functions
	// ------------------------------------------------
	// ----------------------------------------------------------------------------
	public void paint(Graphics g) {
		/*The java applet viewer calls this method when the applet window is resized */
		
		update(g);
		// requestFocus(); // kvoli key action

		// BB
		mustRedrawEverything(); // cancel all changes made by the input events
		// such that when a redraw is requested, from
		// e.g. a window resize, the whole applet is
		// redraw

	}

	/**
	 * Should be called after any applet size change
	 * @param d
	 */
	protected void updateMyMolecularAreaSize(Dimension d) {
		double imagew = d.width - menuCellSize;
		double imageh = d.height - menuCellSize * 3 - menuCellBorder;
		if (imagew < 1)
			imagew = 1;
		if (imageh < 1)
			imageh = 1;
		
		this.molecularAreaWidth = (int) imagew;
		this.molecularAreaHeight = (int) imageh;

		
	}
	/**
	 * Should be called after any applet size change
	 * @param d
	 */
	protected void updateMyMolecularAreaSize() {
		if (this.dimension == null) {
			this.dimension = size();
		}
		this.updateMyMolecularAreaSize(this.dimension);
		
	}
	// ----------------------------------------------------------------------------
	public void update(Graphics g) {
		// pri fill ma rectangle sirku a vysku presne, pri draw o 1 vacsiu
		// Dimension d = getSize();
		Dimension d = size();
		if (dimension == null || (d.width != dimension.width)
				|| (d.height != dimension.height) || molecularArea == null
				|| infoArea == null) {
			
			//BB
			boolean reDimension = false;
			if(dimension != null) {
				reDimension = (d.width != dimension.width) || (d.height != dimension.height);
			}
			// infoArea v if kvoli problemom s appletviewer
			dimension = d;
			// fix for bob hanson when starting JME very small
//			double imagew = d.width - menuCellSize;
//			double imageh = d.height - menuCellSize * 3 - menuCellBorder;
//			if (imagew < 1)
//				imagew = 1;
//			if (imageh < 1)
//				imageh = 1;
			this.updateMyMolecularAreaSize(d);;
//			this.molecularAreaWidth = (int) imagew;
//			this.molecularAreaHeight = (int) imageh;
			
			molecularArea = createOrResizePreciseImage(molecularArea, this.molecularAreaWidth, this.molecularAreaHeight);
			
			//BB the applet window size has changed
			if(depict && reDimension) {
				alignMolecules(1, numberofMoleculeParts, 0); //code copied from the depict option initialisation
			}
			drawMolecularArea(g);
			
			if (depict) {
				//needed because if back to edit mode, the menu will not be redrawn due to optimization
				topMenu = null;
				leftMenu = null;
				infoArea = null;
				
				return;
				
			}

			topMenu = createOrResizePreciseImage(topMenu, d.width, menuCellSize * 2 + menuCellBorder);
			drawTopMenu(g);
			double imageh = d.height - menuCellSize * 2 + menuCellBorder;
			if (imageh < 1)
				imageh = 1;
			//leftMenu = createOrResizeImage(leftMenu, menuCellSize, imageh);
			this.leftMenu = createOrResizePreciseImage(this.leftMenu, menuCellSize, imageh);

			drawLeftMenu(g);
			infoArea = createOrResizePreciseImage(infoArea, this.molecularAreaWidth, menuCellSize);

			
			drawInfo(g);
			
		} else { // robi len cast obrazku
			drawMolecularArea(g);
			if (depict)
				return;
			drawInfo(g); // ???
			if (doMenu) {
				drawTopMenu(g);
				drawLeftMenu(g);
			}
			doMenu = true;
		}
	}

	/**
	 * Method that is overidden in JSME in order to avoid the creation of multiple SVG's during a window resize
	 * @param img
	 * @param width
	 * @param height
	 * @return a new Image in JME or the same image if the argument img is not null in JSME
	 */
	public Image createOrResizeImage(Image img, int width, int height) {
		return createImage(width, height);
	}

	public PreciseImage createOrResizePreciseImage(PreciseImage img, double width, double d) {
		return new PreciseImage(createOrResizeImage(img == null?null:img.getImage(), (int)(Math.round(width)), (int)(Math.round(d))));
	}

	/**
	 * This methos is used only in a batch mode test suite in order to
	 *  have an instance of JME that has a this.dimension that is not null
	 * @param width
	 * @param height
	 */
	public void setDirectSizeForTesting(int width, int height) {
		if (this.dimension == null) {
			this.dimension = new Dimension();
		}
		this.dimension.width = width;
		this.dimension.height = height;
		
		this.updateMyMolecularAreaSize();
		
	}
	// ----------------------------------------------------------------------------
	
	//BB
	//metal like LI, K, Na which can be single cation
	public static boolean isMetal1(int an) {
		return an >= AN_METAL1_START && an <= AN_METAL1_END;
	}
	public static void atomicData() {
		for (int i = 0; i <= AN_R_LAST; i++) {
			if(isMetal1(i)) {
				color[i] = Color.darkGray;				
			} else {
				color[i] = Color.orange;
				zlabel[i] = "X";
			}
		}
		zlabel[AN_H] = "H";
		color[AN_H] = Color.darkGray;
		zlabel[AN_B] = "B";
		color[AN_B] = Color.orange;
		zlabel[AN_C] = "C";
		color[AN_C] = Color.darkGray;
		zlabel[AN_N] = "N";
		color[AN_N] = Color.blue;
		zlabel[AN_O] = "O";
		color[AN_O] = Color.red;
		zlabel[AN_F] = "F";
		color[AN_F] = Color.magenta;
		zlabel[AN_CL] = "Cl";
		color[AN_CL] = Color.magenta;
		zlabel[AN_BR] = "Br";
		color[AN_BR] = Color.magenta;
		zlabel[AN_I] = "I";
		color[AN_I] = Color.magenta;
		zlabel[AN_S] = "S";
		color[AN_S] = Color.yellow.darker();
		zlabel[AN_P] = "P";
		color[AN_P] = Color.orange;
		zlabel[AN_SI] = "Si";
		color[AN_SI] = Color.darkGray;
		zlabel[AN_SE] = "Se";
		color[AN_SE] = Color.darkGray;
		zlabel[AN_X] = "X";
		color[AN_X] = Color.darkGray;
		
		zlabel[AN_K] = "K";
		zlabel[AN_Li] = "Li";
		zlabel[AN_Na] = "Na";

		
		//BB: replace cases by a loop for the R groups
		for(int i = AN_R; i <= AN_R_LAST; i++) {
			String label = "R";
			if(i > AN_R) {
				label += i-AN_R;
			}
			zlabel[i] = label;
			color[i] = Color.darkGray;
		}
		/*
		zlabel[AN_R] = "R";
		color[AN_R] = Color.darkGray;
		zlabel[AN_R1] = "R1";
		color[AN_R1] = Color.darkGray;
		zlabel[AN_R2] = "R2";
		color[AN_R2] = Color.darkGray;
		zlabel[AN_R3] = "R3";
		color[AN_R3] = Color.darkGray;
		*/
	}

	// ----------------------------------------------------------------------------
	void drawMolecularArea(Graphics g) {

		//BB
		if (!this.mustReDrawMolecularArea) {
			return;
		}

		PreciseGraphicsAWT og;
		if(this.scalingIsPerformedByGraphicsEngine) {
			og = molecularArea.getGraphics(this.depictScale);
		} else {
			og = molecularArea.getGraphics(1.0);

		}
		double imgWidth = dimension.width - menuCellSize;
		double imgHeight = dimension.height - menuCellSize * 3 - menuCellBorder;
		og.setColor(canvasBg);
		
		if(this.scalingIsPerformedByGraphicsEngine) {
			imgWidth /= this.depictScale;
			imgHeight /= this.depictScale;
		}
		og.fillRect(0, 0, imgWidth, imgHeight);

		//BB custom antialias and line width for the molecular drawing area
		Object valueAntiAlias = molecularAreaAntiAlias?RenderingHints.VALUE_ANTIALIAS_ON:RenderingHints.VALUE_ANTIALIAS_OFF;
		og.setRenderingHint(RenderingHints.KEY_ANTIALIASING,valueAntiAlias);

		og.setStroke(new BasicStroke(molecularAreaLineWidth));

		for (int m = 1; m <= numberofMoleculeParts; m++)
			moleculeParts[m].draw(og);



		// arrow
		if (reaction) {
			double pWidth = arrowWidth;
			double pStart = (imgWidth - pWidth) / 2;
			double m = arrowWidth / 8; // hrot sipky
			og.setColor(Color.magenta);
			og.drawLine(pStart, imgHeight / 2, pStart + pWidth, imgHeight / 2);
			og.drawLine(pStart + pWidth, imgHeight / 2, pStart + pWidth - m,
					imgHeight / 2 + m);
			og.drawLine(pStart + pWidth, imgHeight / 2, pStart + pWidth - m,
					imgHeight / 2 - m);
		}

		// molText
		if (depict) { // kvoli molText, ale aj depict dalsej molekuly
			// musi robit novy font, lebo v depict moze byt zmeneny
			menuCellFont = new Font(defaultFontFamily, Font.PLAIN, fontSize);
			menuCellFontMet = getFontMetrics(menuCellFont);
			if (molText != null) {
				int w = menuCellFontMet.stringWidth(molText);
				double xstart = (imgWidth - w) / 2.;
				double ystart = imgHeight - fontSize;
				og.setColor(Color.black);
				og.setFont(menuCellFont);
				og.drawString(molText, xstart, ystart);
			}
		}
		
		//draw the DnD icon
		if(depict &&  showDragAndDropSymbolInDepictMode) {
			this.drawDragAndDropSymbol(og, imgWidth, imgHeight);
		}
		
		//right border of the frame
		//BB Feb 2016: - this should not be part of the molecular drawing area
		if(true) {
			
			if (!depict) {
				//avoid linewidth change because of scaling
				og.setStroke(new BasicStroke((float) (1.0 /this.depictScale)));
				og.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
				if (newLook) {
					og.setColor(Color.darkGray);
					og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1);//right line
				}
				else {
					// vonkajsi okraj na pravej strane
					og.setColor(bgColor.darker());
					og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1);
					// predel vo farbe backgroundu
					og.setColor(bgColor);
					og.drawLine(imgWidth - 2, 0, imgWidth - 2, imgHeight - 1);
					// svetly okraj dovnutra
					og.setColor(brightColor);
					og.drawLine(imgWidth - 3, 0, imgWidth - 3, imgHeight - 1);
				}
			}
			//og.setStroke(new BasicStroke(molecularAreaLineWidth));
		}

		g.drawImage(molecularArea.getImage(), (int)menuCellSize, (int)menuCellSize * 2 + menuCellBorder, this);
		this.mustReDrawMolecularArea = false;
		
	}

	// ----------------------------------------------------------------------------
	void drawTopMenu(Graphics g) {
		if (!this.mustReDrawTopMenu)
			return;
		
		
		
		PreciseGraphicsAWT og = topMenu.getGraphics();
		double imgWidth = dimension.width;
		double imgHeight = menuCellSize * 2 + menuCellBorder;
		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (newLook) {
			og.setColor(Color.darkGray);
			double s = (menuCellSize+menuCellBorder) * TOP_MENU_NUMBER_OF_CELLS;
			og.drawRect(s,0,imgWidth-s-1,menuCellSize*2 + menuCellBorder-1);
		}
		else {
			og.setColor(bgColor.darker());
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1); // right
			og.drawLine(0, imgHeight - 1, imgWidth - 1 - 2, imgHeight - 1); // bottom

			og.setColor(brightColor);
			og.drawLine(0, 0, imgWidth - 1, 0); // top
		}

		//og.drawLine(TOP_MENU_NUMBER_OF_CELLS * menuCellSize, 0, TOP_MENU_NUMBER_OF_CELLS * menuCellSize, imgHeight - 1); // predel

		//BB: redraw the FG menu cell if a substituent had been selected
		int savedAction = action;
		if(ACTION_GROUP_MIN <=  action && action <= ACTION_GROUP_MAX) {
			action = ACTION_FG;
		}
		for (int i = 1; i <= TOP_MENU_NUMBER_OF_CELLS; i++) {
			createSquare(og, i, 1);
			createSquare(og, i, 2);
		}

		//restore the action value in case it had been changed for redrawing above
		action = savedAction ; 

		g.drawImage(topMenu.getImage(), 0, 0, this);
	}

	// ----------------------------------------------------------------------------
	void drawLeftMenu(Graphics g) {
		if (!this.mustReDrawLeftMenu)
			return;

		PreciseGraphicsAWT og = leftMenu.getGraphics();
		double imgWidth = menuCellSize;
		double imgHeight = dimension.height - menuCellSize * 2 - menuCellBorder;
		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (newLook) {
			// frame at the bottom
			og.setColor(Color.darkGray);
			og.drawLine(0,imgHeight-1,imgWidth,imgHeight-1); // bottom 
			double y = ACTIONA * (menuCellSize + menuCellBorder) + 2;
			og.drawLine(0,y,imgWidth,y); // top 
			og.drawLine(0,y,0,imgHeight); // left
			og.drawLine(menuCellSize-1,y,menuCellSize-1,imgHeight-menuCellSize); // right
		}
		else {
			og.setColor(brightColor);
			og.drawLine(0, 0, 0, imgHeight - 1); // left
			og.drawLine(0, ACTIONA * menuCellSize, imgHeight - 1, ACTIONA * menuCellSize); // predel
			og.setColor(bgColor.darker());
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1 - menuCellSize); // right
			og.drawLine(0, imgHeight - 1, imgWidth - 1, imgHeight - 1); // bottom
		}
		for (int i = 3; i <= ACTIONA + 2; i++)
			createSquare(og, 1, i);
		g.drawImage(leftMenu.getImage(), 0, (int)menuCellSize * 2 + menuCellBorder, this);
	}

	// ----------------------------------------------------------------------------
	void drawInfo(Graphics g) {
		if (!this.mustReDrawInfo)
			return;
		if (infoText == null){
			infoText = "";
		}
		PreciseGraphicsAWT og = infoArea.getGraphics();
		double imgWidth = dimension.width - menuCellSize; //why is the width reduced?
		double imgHeight = menuCellSize;
		og.setColor(bgColor);
		og.fillRect(0,0,imgWidth,imgHeight);

		if (newLook) {
			og.setColor(Color.darkGray);
			og.drawRect(-1,0,imgWidth,imgHeight-1);
		}
		else {
			og.setColor(brightColor);
			og.drawLine(0, 0, imgWidth - 1 - 2, 0); // top
			og.setColor(bgColor.darker());
			og.drawLine(0, imgHeight - 1, imgWidth - 1, imgHeight - 1); // bottom
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1); // right
		}
		og.setFont(menuCellFontSmaller);
		og.setColor(Color.black);
		
		if (infoText.toLowerCase().contains("error"))
			og.setColor(Color.red);
		og.drawString(infoText, 10, 15);
		
		if (! this.depict) { /*in depict mode, another graphics must be used because the info bar is not present */
			//TODO: the java implemenrtation does not support drag and drop
			this.drawDragAndDropSymbol(og, imgWidth, imgHeight);

		}
		
		g.drawImage(infoArea.getImage(), this.getInfoBarHeight(), dimension.height - this.getInfoBarHeight(), this);
		

	}

	// ----------------------------------------------------------------------------
	boolean menuAction(int pressed) {
		// calling actions after pressing menu button or menu keys
		// called from mousePressed() or keyTyped()

		//idea: this.atomTypeChangeAction = true; //atom type selected or FG or query box
		// mouseover would only highlight the atoms

		if (pressed == 0)
			return false; // moze to byt ? ano, napr z keyTyped

		//BB
		this.mustRedrawNothing();
		boolean status = true;
		boolean structureChangePerformed = false;

		int actionOld = action;
		action = pressed;
		if (pressed <= 300) { // top menu
			//BB
			this.mustReDrawTopMenu = true;
			this.mustReDrawLeftMenu = true; //deselection possible on the left menu

			switch (pressed) {
			case ACTION_CLEAR:
				clear();
				//idea: double click would do a complete cleaning of the undo and redo stack
				//this.molChangeManager.clear(); //delete all undo's
				//this.sdfStack.clear(); //delete all entries from the SDF stack
				//this.recordAfterStructureChangedEvent(JME.CLEAR); //already performed by clear()n
				
				//reset the red highlight correctly
				this.handleMouseLeaveActionMenu(ACTION_CLEAR);
				this.handleMouseEnterActionMenu(ACTION_CLEAR);

				break;
			case ACTION_UNDO:
				// zostavaju rovnake settings ako predtym

				// BB
				mustReDrawMolecularArea = true; // needed for e.g. undo

				action = actionOld;
				if(!this.canMultipleUndo) { //PE's original undo
					// undo po new molecule (pri new smol = null)
					if (smol == null) {
						actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						clear();
					} else if (afterClear) {
						saved = ++numberofMoleculeParts;
						actualMoleculePartIndex = numberofMoleculeParts;
						afterClear = false;
					}
					// undo po standard change (aj po delete s upravenym saved)
					if (smol == null)
						break; // no molecule in undo stack
					mol = smol.deepCopy();
					moleculeParts[saved] = mol;
				} else {
					//multiple undo handling
					if (!this.molChangeManager.canUndo()) {
						info("No more undo");

						//actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						//clear();
					} else if (afterClear) {
						saved = ++numberofMoleculeParts;
						actualMoleculePartIndex = numberofMoleculeParts;
						afterClear = false;
					}
					// undo po standard change (aj po delete s upravenym saved)
					if (!this.molChangeManager.canUndo())
						break; // no molecule in undo stack

					this.retoreState(this.molChangeManager.undo());
					this.recordAfterStructureChangedEvent(JME.UNDO);

					mustReDrawMolecularArea = true; 
					//System.out.println("*********** undo " + mol.natoms);

				}
				break;

			case ACTION_REDO:
				if(!this.canMultipleUndo) {
					action = actionOld;
					this.alert("The redo feature is not implemented yet");

				} else {
					action = actionOld;
					//BB this code is copied from the undo part and adapted
					if (!this.molChangeManager.canRedo()) {
						//actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						//clear();
						info("No more redo");
						break;
					} else if (afterClear) {
						saved = ++numberofMoleculeParts;
						actualMoleculePartIndex = numberofMoleculeParts;
						afterClear = false;
					}
					// undo po standard change (aj po delete s upravenym saved)
					if (!this.molChangeManager.canRedo())
						break; // no molecule in undo stack
					this.retoreState(this.molChangeManager.redo());
					this.recordAfterStructureChangedEvent(JME.REDO);

					mustReDrawMolecularArea = true; 

				}


				break;
				
			case ACTION_IO: /*open popup menu with IO */
				this.handleCopyPastePopupMenu(null, this.fixedCopyPastePopupMenuPosition.x, this.fixedCopyPastePopupMenuPosition.y);
				action = actionOld;
				break;
				
			case ACTION_PGDN:
				//				int ssize = molStack.size();
				//				action = action_old;
				//				if (ssize == 0)
				//					info("No molecules in molstack");
				//				else if (stackPointer == 0)
				//					info("Bottom of molstack reached");
				//				else
				//					getFromStack(-1);
				//				break;

				action = actionOld;
				String sdf = this.sdfStack.next(); //
				if (sdf == null)
					info("No more molecules in SDF buffer");
				else {
					info("MOL n. " + this.sdfStack.getCurrentDisplayIndex() + " of " + this.sdfStack.size());
					//sdf = sdf.replace("\n", "|");
					this.clearMyMolecularContent(); //to avoid any merging with the current molecule
					pasteFromSDFstack = true;
					this.readMolFile(sdf, false); //do not copy in undo
					pasteFromSDFstack = false;
					structureChangePerformed = true;
					
					this.recordAfterStructureChangedEvent(JME.SD_FSTACK);
				}
				break;
			case ACTION_PGUP: //we could use mouse wheel up
				//				ssize = molStack.size();
				//				action = action_old;
				//				if (ssize == 0)
				//					info("No molecules in molstack");
				//				else if (stackPointer == ssize - 1)
				//					info("Top of molstack reached");
				//				else
				//					getFromStack(1);
				//				break;

				action = actionOld;
				sdf = this.sdfStack.previous();
				if (sdf == null)
					info("No more molecules in SDF buffer");
				else {
					info("MOL n. " + this.sdfStack.getCurrentDisplayIndex() + " of " + this.sdfStack.size());
					//sdf = sdf.replace("\n", "|");
					this.clearMyMolecularContent(); //to avoid any merging with the current molecule
					pasteFromSDFstack = true;
					this.readMolFile(sdf, false);//do not copy in undo
					pasteFromSDFstack = false;
					structureChangePerformed = true;
					this.notifyStructuralChangeToJS();
					this.recordAfterStructureChangedEvent(JME.SD_FSTACK);

				}

				break;


			case ACTION_SMI:

				this.handleSmilesBox();
				
				action = actionOld;
				break;
			case ACTION_QRY:
				this.handleQueryBox();
				
				// stay commented
				// action = action_old;
				break;
			case ACTION_JME:
				this.handleAboutBox();
				action = actionOld;
				break;
			case ACTION_NEW:
				// BB
				//mustReDrawMolecularArea = true;
				newMolecule = true;
				action = actionOld; // ak nie je bond alebo ring, malo by
				
				//there is no structure  change!!!!
				//this.recordAfterStructureChangedEvent(JME.CLEAR);

				// resetnut
				break;
			case ACTION_MARK:
				// BB
				//mustReDrawMolecularArea = true;
				if (autonumber) {
					// autonumber added in 2009.09
					if (mouseShift) { // automark all atoms, zrusi stare mark
						mouseShift = false; // aby pridavalo cisla
						mol.numberAtoms();
						
						//added Oct 2015 - not tested
						mustReDrawMolecularArea = true;
						this.recordAfterStructureChangedEvent(JME.AUTO_NUMBER);
						
						
						action = actionOld;
					}
				}
				// set na action_mark
				currentMark = 1; // starts from 1 ????????????????/
				//there is no structure change , only menu selection 123?
				//this.recordAfterStructureChangedEvent(JME.MARK);

				break;
				
//BB: END button was removed
//			case ACTION_SPIRO:
//				if (isStandAloneApplication) {
//					System.exit(0);
//				}
			case ACTION_REACP:
				// save ???
				action = actionOld;
				int part = mol.reactionPart();
				if (part == 2) {
					info("Copying the agent not possible !");
					break;
				}
				CenterAndDimension cad = mol.computeCenterPoint();

				// BB
				mustReDrawMolecularArea = true;
				mol = new JMEmol(mol);
				// mol = mol.createClone(); // ???
				// posunie ju na spravne miesto
				int dx = (int) ((dimension.width - menuCellSize) / 2 - cad.centerX); //center[0]);
				for (int i = 1; i <= mol.natoms; i++)
//					mol.x[i] += dx * 2;
					//mol.atoms[i].x += dx * 2;
					moveXY(mol, i, dx * 2, 0);
					
				mol.complete();
				moleculeParts[++numberofMoleculeParts] = mol;
				actualMoleculePartIndex = numberofMoleculeParts;
				this.recordAfterStructureChangedEvent(JME.REACTION_COPY);
				
				//added Jan 2016
				this.postSave();
				
				//reset the blue highlight correctly
				this.handleMouseLeaveActionMenu(ACTION_REACP);
				this.handleMouseEnterActionMenu(ACTION_REACP);

				break;
			case ACTION_DELETE:
				//FIXME - DUPLICATED CODED with delete using the mouse!!!!!!!!!!!!!!!!!!!!
				// 2011.01 if touchedAtom or bond, deletes it
				structureChangePerformed = this.actionDeleteTouchedAtomOrBond();
				break;

			case ACTION_FG:
				action = actionOld;
				this.getFunctionalGroupPopumemu().show(this, this.functionalGroupPopupMenuPosition.x, functionalGroupPopupMenuPosition.y);
				break;

				
			default: // vsetky co nerobia okamzitu akcion (DEL, templates, +/-,
				// ...)
				break;
			}
		} else { // pressed > 300 (left menu - atoms)
			// BB
			this.mustReDrawLeftMenu = true;
			this.mustReDrawTopMenu = true; //deselection of an item in the top menu

			switch (pressed) {
			case ACTION_AN_C:
				active_an = AN_C;
				break;
			case ACTION_AN_N:
				active_an = AN_N;
				break;
			case ACTION_AN_O:
				active_an = AN_O;
				break;
			case ACTION_AN_F:
				active_an = AN_F;
				break;
			case ACTION_AN_CL:
				active_an = AN_CL;
				break;
			case ACTION_AN_BR:
				active_an = AN_BR;
				break;
			case ACTION_AN_I:
				active_an = AN_I;
				break;
			case ACTION_AN_S:
				active_an = AN_S;
				break;
			case ACTION_AN_P:
				active_an = AN_P;
				break;
			case ACTION_AN_H:
				active_an = AN_H;
				break;
			case ACTION_AN_X:
				this.handleAtomXbox();
				active_an = AN_X;
				
				break;
			/*
			case ACTION_AN_R:
				active_an = AN_R;
				break;
			case ACTION_AN_R1:
				active_an = AN_R1;
				break;
			case ACTION_AN_R2:
				active_an = AN_R2;
				break;
			case ACTION_AN_R3:
				active_an = AN_R3;
				
				
				break;
			*/

			}
			//BB : handling R group
			if(pressed >=  ACTION_AN_R && pressed <= ACTION_AN_R_LAST) {
				active_an = AN_R + (pressed-ACTION_AN_R);
			}
			
			

			// 2009.09 if touchedAtom, changes it
			if (mol.touchedAtom > 0) {
				// BB

				// copied, made subroutine !!!
				if (active_an != mol.an(mol.touchedAtom) && active_an != AN_X) {
					mol.preSave();
					mol.AN(mol.touchedAtom, active_an);
					mol.Q(mol.touchedAtom, 0); // resetne naboj
					//mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
					mol.atoms[mol.touchedAtom].iso = 0; //BB: reset isotop
					//mol.nh[mol.touchedAtom] = 0;
					mol.atoms[mol.touchedAtom].nh = 0;

					//this.postSave();
					this.recordAtomEventAndPostSave(JME.SET_ATOM + active_an); //active_an is an arbitrary number, should be changed to the string of the atom type
					
					//BB Sept 2015: changed the touched atom but do not change the menu
					//action = actionOld;
					structureChangePerformed = true;
				}
				else if (active_an == AN_X) {
					// MultiBox not atomxBox (this is static and always
					// available,
					// needed for key press)
					//FIXME: this code is never reached
					assert false;
					String xx = MultiBox.atomicSymbol.getText();
					mol.setAtom(mol.touchedAtom, xx);
					//this.postSave();
					this.recordAtomEventAndPostSave(JME.SET_ATOM + active_an);
					structureChangePerformed = true;

				}
				//mol.valenceState(); // to add Hs
			
			} 
		}

		//BB Sept 2015: add ring addition
		//extend with other actions:
		// phenyl ring (shortcut is "1"
		//2 for double bond?, see the help for the shortcucts
		/*
		 * atoms C, N, O, P, S, F, L (for Cl), B (for Br), I, H, R
bonds - for single bond, = for double bond
rings 3..8 for 3 to 8 membered rings, 1 for phenyl and 0 for furyl
groups a - COOH, y - NO2, z - SO3H, t - tert. butyl, ft - CF3
		 */
		if(!structureChangePerformed && (mol.touchedAtom > 0 || mol.touchedBond > 0)) {
			// the addRing function can handle both bond and atom
			//duplicated code
			//this works as well for addition of phenyl (KB shortcut is "1")
			if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {

				

				// fusing ring to bond
				mol.preSave();
				lastAction = LA_RING; // in addRing may be set to 0
				mol.addRing();
				structureChangePerformed = true;
				this.recordBondEvent(JME.ADD_RING_BOND);
			}

			//BB Oct 2015: add bond & change bond without switch to double bond bond tool
			else if(action == ACTION_BOND_SINGLE ||  action == ACTION_BOND_DOUBLE || action == ACTION_BOND_TRIPLE) {

				mol.preSave();
				if(mol.touchedAtom > 0) {
					//lastAction = LA_BOND; // in addBond may be set to 0
					lastAction = 0; // correction - ohterwise mouse drag will move the end of the new added bond instead of moving the molecule
					//mol.preSave();
					mol.addBond();
					this.recordBondEvent(JME.ADD_BOND);
					structureChangePerformed = true;
				} else { //mol.touchedBond > 0
					//code cpoied from mouseDown DUPLiCATED !!!! TODO
					int bondType =JMEmol.SINGLE ;
					String eventType = JME.SET_BOND_SINGLE;
					switch(action) {
						case ACTION_BOND_DOUBLE:
							bondType = JMEmol.DOUBLE;
							eventType =JME.SET_BOND_DOUBLE;
							break;
						case ACTION_BOND_TRIPLE:
							bondType = JMEmol.TRIPLE;
							eventType = JME.SET_BOND_TRIPLE;
					}
					mol.preSave();
					mol.bonds[mol.touchedBond].bondType = bondType;
					this.recordBondEvent(eventType);
					structureChangePerformed = true;
					mol.bonds[mol.touchedBond].stereo = 0; // zrusi stereo
					
				}

			}
			

		}

		if(structureChangePerformed) {
			mustReDrawMolecularArea = true;
			mustReDrawLeftMenu = false;
			mustReDrawTopMenu  = false;
			mol.valenceState();
			this.postSave();
			action = actionOld; //avoid menu change BB during repaint()
		}
		
		
		
		
		// repaintuje zbytocne vsetko - zatial nechat
		repaint();

		//BB
		return status;
	}

	/**
	 * 
	 * @return true if the an atom or a bond has been deleted
	 */
	boolean actionDeleteTouchedAtomOrBond() {
		boolean structureChangePerformed = false;
		
		if (mol.touchedAtom > 0 || mol.touchedBond > 0) {
			// BB
			structureChangePerformed = true;
			//mol.preSave(); //TODO REMOVE
			if(mol.touchedAtom > 0 ) {
				mol.deleteAtom(mol.touchedAtom);
				this.recordAtomEventAndPostSave(JME.DEL_ATOM);
				mol.touchedAtom = 0;
			} else {
				mol.deleteBond(mol.touchedBond);
				this.recordAtomEventAndPostSave(JME.DEL_BOND);
				mol.touchedBond = 0;
				
			}
			mol.valenceState(); // to add Hs

			//if an atom or a bond is deleted, then create new moleculeParts if needed
			JMEmol newParts[] = mol.splitMultiparts();
			if(newParts.length > 1) {
				for(int p = 0; p < newParts.length; p++) {
					if(p==0) {
						moleculeParts[actualMoleculePartIndex] = newParts[p]; //replaced by the first new molecule
						mol = moleculeParts[actualMoleculePartIndex];
					} else {
						moleculeParts[++numberofMoleculeParts] =newParts[p]; //Append new parts
					}
				}
			}
		}

		return structureChangePerformed;
	}
	/**
	 * Create an alert box with an OK button to display a message
	 * @param message
	 */
	public void alert(final String message) {
		GWT.runAsync(new JSME_RunAsyncCallback() {
			
		@Override
		public void onSuccess() {
			
			
			
		new AlertBox(message, JME.this, JME.bgColor).show();

		
		}
		});
		
		
		
	}


	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAboutBox() {
		GWT.runAsync(new JSME_RunAsyncCallback() {
			
		@Override
		public void onSuccess() {
			
			
		if (aboutBox != null ) {
			aboutBox.disposeIfShowing();
		}
		aboutBox = new MultiBox(0, JME.this);
		
		
		
		}
		});
	}
	
	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleQueryBox() {
		GWT.runAsync(new JSME_RunAsyncCallback() {
		
		@Override
		public void onSuccess() {
			
			
			
			
			//				if (queryBox != null) {
			//					queryBox.disposeIfShowing();
			//				}
			//				queryBox = new QueryBox(this);

			//BB: it is better that the query box keeps its selection when brought back - dispose() erase everything
			//however, it might be hidden behind another window, thus it has to show in front
			if (queryBox == null) {
				queryBox = new QueryBox(JME.this);
			} else {
				if(queryBox.isShowing()) {
					queryBox.toFront(); //not tested wihthin a browser window, works fine with Eclipse/Linux
					//queryBox.hide();
					//queryBox.show();
				} else {
					queryBox.show();
				}
			}

			
			
			
		}		
	});


	}
	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleSmilesBox() {
		GWT.runAsync(new JSME_RunAsyncCallback() {
			
		@Override
		public void onSuccess() {
		if (smilesBox != null) {
			smilesBox.disposeIfShowing();
		}
		smilesBox = new MultiBox(1, JME.this);
	
		
		
		}		
	});
		
	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAtomXbox() {
		GWT.runAsync(new JSME_RunAsyncCallback() {
			
		@Override
		public void onSuccess() {
			
			
			
			
		if (!webme) {
			if (atomxBox != null) {
				atomxBox.disposeIfShowing();
				atomxBox = null;
			}
			if (mol.touchedAtom == 0)
				atomxBox = new MultiBox(2, JME.this);
		}
		}
		
		
	});
		
	}
	// ----------------------------------------------------------------------------
	void createSquare(PreciseGraphicsAWT g, int xpos, int ypos) {
		int square = ypos * 100 + xpos;
		double xstart = (xpos - 1) * (menuCellSize + menuCellBorder);
		double ystart = (ypos - 1) * (menuCellSize + menuCellBorder);
		if (xpos == 1 && ypos > 2)
			ystart -= (2 * menuCellSize); // relative coordinates in leftMenu
		g.setColor(bgColor);
		if (newLook) {
			if (square == action) {
				g.setColor(bgColor.darker());
				//System.out.println("xstart=" + xstart + " ystart=" + ypos);
			} 

			g.fillRect(xstart, ystart, menuCellSize, menuCellSize);
			g.setColor(Color.darkGray);
			g.drawRect(xstart, ystart, menuCellSize-1, menuCellSize-1);
		}
		else {
			if (square == action)
				g.fill3DRect(xstart + 1, ystart + 1, menuCellSize, menuCellSize, false);
			else
				g.fill3DRect(xstart, ystart, menuCellSize, menuCellSize, true);
		}

		// treba, aby nekreslilo neaktivne buttons
		if (square == ACTION_AN_R && !rButton)
			return;

		//if (square == ACTION_END && !isStandAloneApplication)
		//	return;
		if (square == ACTION_QRY && !query)
			return;
		if (square == ACTION_STEREO && !stereo)
			return;
		if (square == ACTION_NEW && !multipart)
			return;
		if (square == ACTION_MARK && !(number || autonumber))
			return;
		if (square == ACTION_REACP && !reaction)
			return;

		// draws icon or text in the square
		double marginFromCellBorder = menuCellSize / 4; // space between cell border and inside icon
		if (ypos < 3) { // top menu squares
			g.setColor(Color.black);
			switch (square) {
			case ACTION_SMI: // smiley face
				if (!bwMode) {
					g.setColor(Color.yellow);
					g.fillOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // head
					g.setColor(Color.black);
				}
				g.drawOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // head
				g.drawArc(xstart + 6, ystart + 6, menuCellSize - 12, menuCellSize - 12, -35, -110); // mouth
				// oci
				g.fillRect(xstart + 9, ystart + 9, 2, 4);
				g.fillRect(xstart + menuCellSize - 10, ystart + 9, 2, 4);
				// jazyk
				if (Math.random() < 0.04) {
					g.setColor(Color.red);
					g.fillRect(xstart + 10, ystart + 18, 4, 4);
				}
				// blink
				if (Math.random() > 0.96) {
					g.setColor(Color.yellow);
					g.fillRect(xstart + menuCellSize - 10, ystart + 8, 2, 3);
				}
				break;
			case ACTION_SPIRO:
				// drawing spiro button
				double xFarLeft = xstart + marginFromCellBorder;
				double xFarRight = xstart + menuCellSize - marginFromCellBorder;
				double xMiddle =xstart + menuCellSize/2;
				//bottom left - black line
				g.drawLine(xFarLeft, ystart + menuCellSize -marginFromCellBorder ,xMiddle , ystart + menuCellSize/2);
				g.drawLine(xstart + menuCellSize/2, ystart + menuCellSize/2, xFarRight, ystart + menuCellSize -marginFromCellBorder);
				
				double y = ystart + menuCellSize -marginFromCellBorder ;
				double dotLength = ((double)this.menuCellSize)/this.standardMenuCellSize;
				g.drawLine(xMiddle - dotLength, y , xMiddle - 2 * dotLength, y);
				g.drawLine(xMiddle + dotLength, y , xMiddle + 2 * dotLength, y);
				

				g.setColor(Color.magenta);
				//top left - magenta line
				g.drawLine(xFarLeft, ystart + marginFromCellBorder , xMiddle, ystart + menuCellSize/2);
				g.drawLine(xstart + menuCellSize/2, ystart + menuCellSize/2, xFarRight, ystart + marginFromCellBorder);

				y = ystart + marginFromCellBorder ;
				g.drawLine(xMiddle - dotLength, y , xMiddle - 2 * dotLength, y);
				g.drawLine(xMiddle + dotLength, y , xMiddle + 2 * dotLength, y);

				
				//restore default color
				g.setColor(Color.black);
				break;
				
			case ACTION_QRY:
				g.setColor(Color.orange);
				g.fillRect(xstart + 4, ystart + 4, menuCellSize - 8, menuCellSize - 8); // head
				g.setColor(Color.black);
				g.drawRect(xstart + 4, ystart + 4, menuCellSize - 8, menuCellSize - 8); // head
				g.drawArc(xstart + 6, ystart + 6, menuCellSize - 11, menuCellSize - 12, -35, -110); // mouth
				g.fillRect(xstart + 9, ystart + 9, 2, 4);
				g.fillRect(xstart + menuCellSize - 10, ystart + 9, 2, 4);
				break;
			case ACTION_CHARGE:
				//squareText(g, xstart, ystart, "+ /  ");
				//squareText(g, xstart, ystart, "+ / -");
				//squareTextBold(g, xstart, ystart, Color.black, "+ -");
				//g.drawLine(xstart + 15, ystart + 13, xstart + 19, ystart + 13); // better
				// -
				double padding = (double)menuCellSize / 4 ;
				//the / line
				g.drawLine(xstart + padding, ystart + menuCellSize - padding, 
						xstart + menuCellSize - padding, ystart + padding);

				double symbolSize = (double)menuCellSize / 2 - padding;

				// the minus - bottom right
				double minusY = ystart + menuCellSize * 2 / 3;
				double minusStartX = xstart + menuCellSize / 2;
				double minusEndX = minusStartX + symbolSize;

				g.drawLine(minusStartX, minusY, minusEndX, minusY);

				// the plus horizontal line - top left
				double hY = ystart + menuCellSize * 1 / 3;
				double hEndX = minusStartX;
				double hStartX = minusStartX - symbolSize;
				g.drawLine(hStartX, hY, hEndX, hY);

				// the plus vertical line - top left
				double vX = (hStartX + hEndX) / 2;
				double vStartY = hY - symbolSize / 2;
				double vEndY = vStartY + symbolSize;
				g.drawLine(vX, vStartY, vX, vEndY);

				break;

			case ACTION_MOVE_AT:
				
				if(this.showAtomMoveButton) {
					//Draw a blue rectangle centered in the cell
					double reduction = (double)marginFromCellBorder/2;
					double squareSize = menuCellSize - 2 * marginFromCellBorder - 2*reduction;
					double brx = xstart + reduction + marginFromCellBorder; //blue rectangle x
					double bry = ystart + (brx - xstart);
					
					g.setColor(Color.BLUE);
					g.drawRect(brx, bry, squareSize, squareSize);
	
					g.setColor(Color.BLACK);
	
					//four triangles symbolising arrows
					double middleX = xstart + menuCellSize / 2;
					double middleY = ystart + menuCellSize / 2;
					
					double arrowMarginFromCellBorder = reduction; //not enough space for using a complete margin
					double arrowHeight = reduction ;
					double arrowWidth = squareSize ; //must be the same as squareSize for small cells, if different, the code has to be adapted
					assert arrowHeight > 0;
					
					
					//top triangle arrow
					double xLeft = brx;
					double xRight = brx + arrowWidth;
					double yTop = ystart + arrowMarginFromCellBorder;
					//int yBottom = bry - reduction;
					double yBottom = yTop + arrowHeight;
	
					g.drawLine(xLeft, yBottom , middleX , yTop);
					g.drawLine(middleX , yTop, xRight, yBottom);
					
					
					//bottom triangle arrow
					//x coordinates are the same
					yBottom = bry + squareSize + reduction;
					yTop = yBottom + arrowHeight;
					g.drawLine(xLeft, yBottom , middleX , yTop);
					g.drawLine(middleX , yTop, xRight, yBottom);
	
					
					
					//Left triangle
					xLeft =xstart + reduction;
					xRight = xLeft + arrowHeight;
					yTop = bry;
					yBottom = yTop + arrowWidth;
					
					g.drawLine(xRight, yTop , xLeft , middleY);
					g.drawLine(xLeft , middleY , xRight , yBottom);
	
					//right triangle
					//y coordinates are the same
					xLeft = brx + squareSize + reduction;
					xRight = xLeft + arrowHeight;
					
					g.drawLine(xLeft, yTop , xRight , middleY);
					g.drawLine(xRight , middleY , xLeft , yBottom);
				}
				
				break;
				
				
				
			case ACTION_UNDO:
				// g.drawArc(xstart+6,ystart+6,sd-12,sd-12,270,270); // head
				//g.drawArc(xstart + 6, ystart + 7, menuCellSize - 12, menuCellSize - 14, 270, 270); // head

				this.drawUndoOrRedoArrowMenuCell(g, xstart, ystart, menuCellSize, true);


				// squareText(g,xstart,ystart,"UDO");
				break;

			case ACTION_REDO:
				this.drawUndoOrRedoArrowMenuCell(g, xstart, ystart, menuCellSize, false);
				break;

			case ACTION_IO :
				this.drawInputOutputArrowsMenuCell(g, xstart, ystart, menuCellSize);
				this.fixedCopyPastePopupMenuPosition = new Point((int)xstart, (int)ystart);

				break;
				
			case ACTION_REACP:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart
						+ menuCellSize / 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder
						* 3 / 2, ystart + menuCellSize / 2 + marginFromCellBorder / 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder
						* 3 / 2, ystart + menuCellSize / 2 - marginFromCellBorder / 2);
				break;
			case ACTION_CLEAR:
				g.setColor(Color.white);
				g.fillRect(xstart + 3, ystart + 5, menuCellSize - 7, menuCellSize - 11);
				g.setColor(Color.black);
				g.drawRect(xstart + 3, ystart + 5, menuCellSize - 7, menuCellSize - 11);
				// squareText(g,xstart,ystart,"CLR");
				break;
			case ACTION_NEW:
				// special handling (aby boli 2 stvorce on)
				g.setColor(bgColor);
				if (newMolecule)
					g.fill3DRect(xstart + 1, ystart + 1, menuCellSize, menuCellSize, false);
				g.setColor(Color.black);
				squareText(g, xstart, ystart, "NEW");
				break;
			case ACTION_DELGROUP:
				// squareText(g,xstart,ystart,"D-R");
				g.setColor(Color.red);
				g.drawLine(xstart + 7, ystart + 7, xstart + menuCellSize - 7, ystart + menuCellSize
						- 7);
				g.drawLine(xstart + 8, ystart + 7, xstart + menuCellSize - 6, ystart + menuCellSize
						- 7);
				g.drawLine(xstart + 7, ystart + menuCellSize - 7, xstart + menuCellSize - 7,
						ystart + 7);
				g.drawLine(xstart + 8, ystart + menuCellSize - 7, xstart + menuCellSize - 6,
						ystart + 7);
				g.setColor(Color.black);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + 12, ystart
						+ menuCellSize / 2);
				squareText(g, xstart + 6, ystart, "R");
				break;
			case ACTION_DELETE:
				// squareText(g,xstart,ystart,"DEL");
				g.setColor(Color.red);
				// g.drawLine(xstart+m,ystart+m,xstart+sd-m,ystart+sd-m);
				// g.drawLine(xstart+m+1,ystart+m,xstart+sd-m+1,ystart+sd-m);
				// g.drawLine(xstart+m,ystart+sd -m,xstart+sd-m,ystart+m);
				// g.drawLine(xstart+m+1,ystart+sd-m,xstart+sd-m+1,ystart+m);
				g.drawLine(xstart + 7, ystart + 7, xstart + menuCellSize - 7, ystart + menuCellSize
						- 7);
				g.drawLine(xstart + 8, ystart + 7, xstart + menuCellSize - 6, ystart + menuCellSize
						- 7);
				g.drawLine(xstart + 7, ystart + menuCellSize - 7, xstart + menuCellSize - 7,
						ystart + 7);
				g.drawLine(xstart + 8, ystart + menuCellSize - 7, xstart + menuCellSize - 6,
						ystart + 7);
				g.setColor(Color.black);
				break;
			case ACTION_MARK:
				if (star) {
					if(false) {
					// star (not filled yet)
					g.setColor(Color.cyan);
					g.drawLine(xstart + 11, ystart + 5, xstart + 9, ystart + 9);
					g.drawLine(xstart + 9, ystart + 9, xstart + 4, ystart + 9);
					g.drawLine(xstart + 4, ystart + 9, xstart + 8, ystart + 12);
					g.drawLine(xstart + 8, ystart + 12, xstart + 6, ystart + 18);
					g.drawLine(xstart + 6, ystart + 18, xstart + 11,
							ystart + 15);

					g.drawLine(xstart + 12, ystart + 5, xstart + 14, ystart + 9);
					g.drawLine(xstart + 14, ystart + 9, xstart + 19, ystart + 9);
					g.drawLine(xstart + 19, ystart + 9, xstart + 15,
							ystart + 12);
					g.drawLine(xstart + 15, ystart + 12, xstart + 17,
							ystart + 18);
					g.drawLine(xstart + 17, ystart + 18, xstart + 12,
							ystart + 15);
					g.setColor(Color.black);
					} else {
						//May 2015replaced by a circle
						g.setColor(Color.cyan);
						g.fillOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // same as for the smiley
						g.setColor(Color.black);

					}
				} else
					squareText(g, xstart, ystart, "123");
				break;
			case ACTION_JME:
				// squareText(g,xstart,ystart,"JME");
				// g.drawImage(infoImage,xstart+2,ystart+2,this);
				g.setColor(Color.blue);
				double coloredRectSize = menuCellSize - 8;
				double coloredRectSizeX = xstart + (menuCellSize - coloredRectSize) /2 ;
				double coloredRectSizeY = ystart + (menuCellSize - coloredRectSize) /2 ;
				g.fillRect(coloredRectSizeX, coloredRectSizeY, coloredRectSize, coloredRectSize);
				g.setColor(Color.black);
				//g.drawRect(coloredRectSizeX, coloredRectSizeY, coloredRectSize, coloredRectSize);
				//squareTextBold(g, xstart + 1, ystart - 1, Color.white, "i");
				squareTextBold(g, xstart, ystart, Color.white, "i");
				break;
			case ACTION_STEREO:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart
						+ menuCellSize / 2 + 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart
						+ menuCellSize / 2 - 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 2, xstart + menuCellSize
						- marginFromCellBorder, ystart + menuCellSize / 2 - 2);
				break;
			case ACTION_BOND_SINGLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart
						+ menuCellSize / 2);
				break;
			case ACTION_BOND_DOUBLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 - 2, xstart + menuCellSize - marginFromCellBorder,
						ystart + menuCellSize / 2 - 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 + 2, xstart + menuCellSize - marginFromCellBorder,
						ystart + menuCellSize / 2 + 2);
				break;
			case ACTION_BOND_TRIPLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 - 3, xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 3);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 + 3, xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 3);
				break;
			case ACTION_CHAIN:
				g.drawLine(xstart + marginFromCellBorder / 2, ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3, xstart + marginFromCellBorder
						/ 2 * 3, ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3);
				g.drawLine(xstart + marginFromCellBorder / 2 * 3, ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3, xstart
						+ marginFromCellBorder / 2 * 5, ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3);
				g.drawLine(xstart + marginFromCellBorder / 2 * 5, ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3, xstart
						+ marginFromCellBorder / 2 * 7, ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3);
				break;
			case ACTION_RING_3: // klesnute o 2
				drawRingIcon(g, xstart, ystart + 2, 3);
				break;
			case ACTION_RING_4:
				drawRingIcon(g, xstart, ystart, 4);
				break;
			case ACTION_RING_5:
				drawRingIcon(g, xstart, ystart, 5);
				break;
			case ACTION_RING_PH:
				drawRingIcon(g, xstart, ystart, 1);
				break;
			case ACTION_RING_6:
				drawRingIcon(g, xstart, ystart, 6);
				break;
			case ACTION_RING_7:
				drawRingIcon(g, xstart, ystart, 7);
				break;
			case ACTION_RING_8:
				drawRingIcon(g, xstart, ystart, 8);
				break;

			case ACTION_FG:
				squareText(g, xstart, ystart, "FG");
				this.functionalGroupPopupMenuPosition = new Point((int)xstart, (int)ystart);
				break;

			}
		} else { // ypos >=3 (left menu squares)
			int dan = AN_C;
			// switch nahradene if, lebo ACTION nie su final, kvoli xy
			if (square == ACTION_AN_C)
				dan = AN_C;
			else if (square == ACTION_AN_N)
				dan = AN_N;
			else if (square == ACTION_AN_O)
				dan = AN_O;
			else if (square == ACTION_AN_S)
				dan = AN_S;
			else if (square == ACTION_AN_F)
				dan = AN_F;
			else if (square == ACTION_AN_CL)
				dan = AN_CL;
			else if (square == ACTION_AN_BR)
				dan = AN_BR;
			else if (square == ACTION_AN_I)
				dan = AN_I;
			else if (square == ACTION_AN_P)
				dan = AN_P;
			else if (square == ACTION_AN_X)
				dan = AN_X;
			else if (square == ACTION_AN_R)
				dan = AN_R;

			//BB: do not show the X button if xButton option is false
			if(xButton == false && square == ACTION_AN_X) {
				//do nothing
			}
			else {
			//BB
			//during the fist initialization after reading all parameters and options
			// the zlabel array is not initialized (contains null values)
			//System.out.println("dan: " + dan + " label: " + zlabel[dan]);
				if(zlabel[dan] != null)
					squareTextBold(g, xstart, ystart, color[dan], zlabel[dan]);
			}
		}
	}

	//BB
	//To ease debugging this method, the menuCellSize can be set to a higher value , e.g 120
	void drawUndoOrRedoArrowMenuCell(PreciseGraphicsAWT g, double xstart, double ystart, double cellSize, boolean undo) {
		double arrowWidth = ((double)cellSize / 4.0); //6
		double arrowHeight = arrowWidth ;
		double margin = 2;

		//X values: we work with relative values because the absolute values will be different for the Undo and Redo arrows
		double xStartArrowLine = margin;
		double xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		double xEndArrowLine = xStartArrowLine + arrowWidth ;


		//All Y values are absolute
		double yStartArrowLine = ystart + (10.0 * cellSize / 24.0) ;
		double yArrowTip  = yStartArrowLine + arrowHeight;

		double xEnd = xstart + cellSize;

		double absoluteXArrowTip = 0;
		double absoluteXstartArrowLine = 0;
		double absoluteXEndArrowLine = 0;
		if(undo) {
			absoluteXstartArrowLine = xStartArrowLine + xstart;
			absoluteXArrowTip = xArrowTip + xstart ;
			absoluteXEndArrowLine = xEndArrowLine + xstart;
		} else {
			//mirror image
			// Y values stay the same
			absoluteXArrowTip = xEnd - xArrowTip;
			absoluteXstartArrowLine = xEnd - xStartArrowLine;
			absoluteXEndArrowLine =  xEnd - xEndArrowLine ;
		}


		//draw the two lines of the arrow tip - two sides of the triangle
		g.drawLine(absoluteXstartArrowLine , yStartArrowLine, absoluteXArrowTip, yArrowTip);
		g.drawLine(absoluteXEndArrowLine , yStartArrowLine, absoluteXArrowTip , yArrowTip);


		//draw middle line of the arrow , but not as extended as the triangle lines - it looks nicer so
		double yArrowCenterCorrection = arrowHeight / 3 - 0.5; //without the  -0.5 , there is a gap visible when zooming in

		g.drawLine(absoluteXArrowTip , yStartArrowLine + yArrowCenterCorrection, absoluteXArrowTip, yArrowTip);


		//The arc


		//define the coordinates and sizes of the bounding box that will contain the arc 
		double xStartArcBoxTopLeft = xArrowTip;
		double yStartArcBoxTopLeft = ystart + xStartArcBoxTopLeft;
		double arcBoxWidth = cellSize -  xStartArcBoxTopLeft - 2 * margin;
		double arcBoxHeight = cellSize - 2 * margin;

		//The arc has to be moved slightly up in order to align with the start of the line of the center of the arrow (see above)
		yStartArcBoxTopLeft -= yArrowCenterCorrection;
		arcBoxHeight -= yArrowCenterCorrection ;

		arcBoxHeight -= 1; //looks better when the cell size is small

		double arcSpan = 270;
		double startAngle = 0;
		double absoluteXxtartArcBoxTopLeft = 0;
		if(undo) {
			absoluteXxtartArcBoxTopLeft = xstart + xStartArcBoxTopLeft;
			startAngle = 270;
		} else {
			absoluteXxtartArcBoxTopLeft = xEnd - arcBoxWidth - xStartArcBoxTopLeft;
			arcSpan *= -1;
			startAngle = -90;
		}
		//draw an arc inside the box
		g.drawArc(absoluteXxtartArcBoxTopLeft, yStartArcBoxTopLeft, arcBoxWidth , arcBoxHeight, startAngle, arcSpan);
	}
	
	//To ease debugging this method, the menuCellSize can be set to a higher value , e.g 120
	/**
	 * draw two vertical blue arrows to symbolize output / input, arrows are simplified as triangles
	 * @param g
	 * @param xstart
	 * @param ystart
	 * @param cellSize
	 * @param undo
	 */
	void drawInputOutputArrowsMenuCell(PreciseGraphicsAWT g, double xstart, double ystart, double cellSize) {
		
		// arrows are simplified as triangle
		double arrowWidth = this.ioArrowWidth;
		double arrowHeight = arrowWidth ;
		double margin = this.ioMargin;
		double xStartArrowLine = margin + xstart;
		double xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		double xEndArrowLine = xStartArrowLine + arrowWidth ;


		double yStartArrowLine = ystart + margin ;
		double yArrowTip  = yStartArrowLine + arrowHeight;


		g.setColor(Color.BLUE);
		
		g.fillPolygon(new double[] {xStartArrowLine,xArrowTip, xEndArrowLine},
				new double[] {yStartArrowLine, yArrowTip, yStartArrowLine}, 3);

		/*2nd triangle */
		xStartArrowLine = xArrowTip;
		xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		xEndArrowLine = xStartArrowLine + arrowWidth ;
		
		yArrowTip  = yStartArrowLine + arrowHeight / 2.0;
		yStartArrowLine = yArrowTip + arrowHeight;
		
		g.fillPolygon(new double[] {xStartArrowLine,xArrowTip, xEndArrowLine},
				new double[] {yStartArrowLine, yArrowTip, yStartArrowLine}, 3);

	}

	/**
	 * Draw the drag and drop symbol at the bottom right of the JSME container
	 * @param g : either the infor bar or the molecular area
	 * @param graphics_container_width
	 * @param graphics_container_height
	 */
	void drawDragAndDropSymbol(PreciseGraphicsAWT g, double graphics_container_width, double graphics_container_height) {
		// arrows are simplified as triangle

		
		//Use the same size as I/O arrows

		double margin = this.ioMargin;
		double arrowWidth = this.ioArrowWidth;
		double arrowHeight = arrowWidth ;
		
		
		
		if(this.depict) {
			margin = 0; //put the arrow at the extreme left and bottom without any margin
		}
		
		double xStartArrowLine = graphics_container_width - margin - arrowWidth;
		double xArrowTip = xStartArrowLine + arrowWidth ;

		
		double yArrowBottom;

		double yArrowTop ;
		double yArrowMiddle ;

		if(! this.depict) { //non depict mode: the arrow is Y centered in the middle of the info bar
			yArrowMiddle = graphics_container_height / 2;
			yArrowBottom = yArrowMiddle + arrowHeight/2;
			yArrowTop = yArrowMiddle - arrowHeight/2;
		} else { // arrow is placed at the bottom right
			 yArrowBottom  = graphics_container_height;
	
			 yArrowTop = yArrowBottom  - arrowHeight;
			 yArrowMiddle  = (yArrowTop + yArrowBottom) / 2;
		}

		g.setColor(Color.BLUE);
		
		g.fillPolygon(new double[] {xStartArrowLine,xArrowTip, xStartArrowLine},
				new double[] {yArrowTop, yArrowMiddle, yArrowBottom}, 3);
		


	}
	// --------------------------------------------------------------------------
	void squareText(PreciseGraphicsAWT g, double xstart, double ystart, String text) {

		//Smaller font is needed to display NEW and 123

		//		g.setFont(menuCellFontSmaller);
		//		int hSmall = menuCellFontSmallerMet.getBoxUppercaseHeight(); // vyska fontu
		//		int w = menuCellFontSmallerMet.stringWidth(text);

		FontMetrics fm =  menuCellFontMet;
		int w = fm.stringWidth(text);

		//Smaller font is needed to display NEW and 123
		//If the text is too wide for the cell, then use a smaller font
		if(w >=  menuCellSize -1) {
			int size = fm.getFont().getSize();

			//decrease font size until the text fits in the cell
			while(w >=  menuCellSize - 1 && size > 1) {
				size --;
				Font smallerFont = new Font(fm.getFont().getName(), fm.getFont().getStyle(), size);
				fm = getFontMetrics(smallerFont);
				w = fm.stringWidth(text);
				g.setFont(smallerFont);

			}
		} else {
			g.setFont(menuCellFont);
		}
		int h = this.stringHeight(fm); // vyska fontu

		g.drawString(text, xstart + (menuCellSize - w) / 2, ystart + (menuCellSize - h) / 2 + h);


	}



	// --------------------------------------------------------------------------
	void squareTextBold(PreciseGraphicsAWT g, double xstart, double ystart, Color col,
			String text) {
		//Used for the atom symbols on the left side menu
		double h = this.stringHeight(menuCellFontBoldMet); // vyska fontu
		double w = menuCellFontBoldMet.stringWidth(text);
		g.setFont(menuCellFontBold);
		g.setColor(col);
		if (bwMode)
			g.setColor(Color.black);
		g.drawString(text, xstart + (menuCellSize - w) / 2, ystart + (menuCellSize - h) / 2 + h);
		// poor man's BOLD
		// g.drawString(text,xstart+(sd-w)/2+1,ystart+(sd-h)/2+h);
	}


	// --------------------------------------------------------------------------
	void drawRingIcon(PreciseGraphicsAWT g, double xstart, double d, int n) {
		double m = menuCellSize / 4; // margin
		boolean ph = false;
		double xp[] = new double[9];
		double yp[] = new double[9]; // polygon coordinates
		double xcenter = xstart + menuCellSize / 2;
		double ycenter = d + menuCellSize / 2;
		double rc = menuCellSize / 2 - m / 2;
		if (n == 1) {
			n = 6;
			ph = true;
		}
		for (int i = 0; i <= n; i++) {
			double uhol = Math.PI * 2. / n * (i - .5);
			xp[i] = xcenter + rc * Math.sin(uhol);
			yp[i] = ycenter + rc * Math.cos(uhol);
		}
		g.drawPolygon(xp, yp, n + 1);
		if (ph) { // double bonds in Ph icon
			for (int i = 0; i <= n; i++) {
				double uhol = Math.PI * 2. / n * (i - .5);
				xp[i] = xcenter + (rc - 3) * Math.sin(uhol);
				yp[i] = ycenter + (rc - 3) * Math.cos(uhol);
			}
			g.drawLine(xp[0], yp[0], xp[1], yp[1]);
			g.drawLine(xp[2], yp[2], xp[3], yp[3]);
			g.drawLine(xp[4], yp[4], xp[5], yp[5]);
		}
	}

	// ----------------------------------------------------------------------------
	void info(String text) {

		mustReDrawInfo = true;

		infoText = text;
		// co s doMenu a repaintom


	}

	// ----------------------------------------------------------------------------
	// Will do an immediate repaint
	public void showInfo(String text) {

		info(text);
		repaint();


	}

	/**
	 * select one of the menu action without having to click on the menu
	 * @param action
	 */
	public void setAction(int action) {
		this.action = action;
	}
	
	/**
	 * BB
	 * 
	 * Find out which button-action matches the mouse coordinates
	 * @param x
	 * @param y
	 * @return
	 */
	public int determineMenuAction(int x, int y, boolean ignoreDisabledActions) {
		int action = 0;
		if ( x < menuCellSize || y < menuCellSize * 2 + menuCellBorder) { // --- inside the menu area

			int xbutton = 0;
			for (int i = 1; i <= TOP_MENU_NUMBER_OF_CELLS; i++)
				if (x < i * (menuCellSize+menuCellBorder)) {
					xbutton = i;
					break;
				}
			int ybutton = 0;
			for (int i = 1; i <= ACTIONA + 2; i++)
				if (y < i * (menuCellSize+menuCellBorder)) {
					ybutton = i;
					break;
				}
			if (xbutton > 0 && ybutton > 0) {
				action = ybutton * 100 + xbutton;
			}
		}
		
		// TODO: filter out all actions  that are disabled
		if(ignoreDisabledActions) {
			switch(action) {
			case ACTION_REACP:
				if(!this.reaction) action = 0;
				break;
			}
			
		}
		return action;
	}
	
	
	@Override
	public void mouseWheelMoved(MouseWheelEvent e) {
		
		if(!allowZooming) 
			return;
		
//		String message;
//		String newline = "\n";
		double notches = e.getWheelRotation();
//		if (notches < 0) {
//			message = "Mouse wheel moved UP " + -notches + " notch(es)" + newline;
//		} else {
//			message = "Mouse wheel moved DOWN " + notches + " notch(es)" + newline;
//		}
//		if (e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL) {
//			message += "    Scroll type: WHEEL_UNIT_SCROLL" + newline;
//			message += "    Scroll amount: " + e.getScrollAmount() + " unit increments per notch"
//					+ newline;
//			message += "    Units to scroll: " + e.getUnitsToScroll() + " unit increments" + newline;
//			message += "    Vertical unit increment: "
//					+ " pixels" + newline;
//		} else { // scroll type == MouseWheelEvent.WHEEL_BLOCK_SCROLL
//			message += "    Scroll type: WHEEL_BLOCK_SCROLL" + newline;
//			message += "    Vertical block increment: "
//					+ " pixels" + newline;
//		}
//		System.out.println(message);
		Rectangle previousAreaSize  = getMolecularAreaSizeWithScalingForDepiction();
		this.depictScale *= (100+2*notches)/100;
		Rectangle newAreaSize  = getMolecularAreaSizeWithScalingForDepiction();
		
		//mol.scaling();
		
		//should we limit scaling if one molecule becomes invisible?
		if( !reaction) {
			//mol.center(0.1); //should move progressively to center
			//The center position varies with the scale !!!!!!! FIXME
			int x = e.getX();
			int y = e.getY();
			
			//duplicated code FIXME
			x = x - (int)menuCellSize;
			y = y - (2 * (int)menuCellSize + menuCellBorder);

			TouchedMol touchedMol = new TouchedMol();
			this.findMolAndAtomOrBondWithinRadius(x, y, Double.MAX_VALUE, touchedMol);
			//this.findClosestMol(x, y)
			Point.Double shiftXY = this.findTranslationToCenterAfterScaling(touchedMol, previousAreaSize, newAreaSize);

			if(shiftXY != null) {
				for(int i=1; i<=numberofMoleculeParts; i++) {
					moleculeParts[i].moveXY(shiftXY.x, shiftXY.y);
					moleculeParts[i].findBondCenters();
				}
			}
		} else {
			//What to do?
			//reaction TODO
			//multipart 
		}
		this.mustReDrawMolecularArea = true;
		lastAction = LA_SCALE;
		repaint();
	}

	
	/**
	 * Compute the translation X,Y needed for the molecule to stay centered after scaling
	 * @param atomIndex
	 * @param previousAreaSize
	 * @param newAreaSize
	 * @return
	 */
	public Point.Double findTranslationToCenterAfterScaling(TouchedMol closestMol,  Rectangle previousAreaSize, Rectangle newAreaSize) {
		Point.Double result = new Point.Double();

		if(closestMol.molIndex == 0) {
			return result;
		}
		JMEmol closestMolecule = moleculeParts[closestMol.molIndex];
		if(closestMolecule.natoms == 0) {
			return result;
		}
		assert previousAreaSize.width > 0;
		assert previousAreaSize.height > 0;
		
		double x;
		double y;
		if( closestMol.atomIndex > 0) {
			x= closestMolecule.atoms[closestMol.atomIndex].x;
			y= closestMolecule.atoms[closestMol.atomIndex].y;
		} else {
			closestMolecule.findBondCenters();
			x = closestMolecule.bonds[closestMol.bondIndex].bondCenterX;
			y = closestMolecule.bonds[closestMol.bondIndex].bondCenterY;
			
		}
		
		
		double newX = x /previousAreaSize.width * newAreaSize.width;
		double newY = y /previousAreaSize.height * newAreaSize.height;
		
		double shiftX = newX - x;
		double shiftY = newY - y;
	
		
		result.setLocation(shiftX, shiftY);
		
		
		return result;

	}

	/**
     * Invoked when a mouse button has been pressed on a component.
     */
//	@Override
//	public void mousePressed(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//
//	}

    /**
     * Invoked when the mouse button has been clicked (pressed
     * and released) on a component.
     */
//	@Override
//	public void mouseClicked(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//
//	}

	/**
	 * Invoked when a mouse button has been released on a component.
	 */
//	@Override
//	public void mouseReleased(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	/**
	 * Invoked when the mouse enters a component.
	 */
//	@Override
//	public void mouseEntered(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	/**
	 * Invoked when the mouse exits a component.
	 */
//	@Override
//	public void mouseExited(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	// ----------------------------------------------------------------------------
	@Override
	public boolean mouseDown(Event e, int x, int y) {
		// 02.06 niektotre return true zmenene na false (aby events aj v mipc)

		this.mouseDownWasUsed = false;
		//BB popup menu for copy&paste
		if(this.handleCopyPastePopupMenu(e, x, y) ) {
			this.mouseDownWasUsed = true;
			//FIXME
			movePossible = false; //to avoid bug is my JSapplet lib with popup menu disabled, the mouseUp event is not registered and aa mouseDrag event is generated
			return true; //event has been consumed
		}


		if (depict && !(this.canHandleBondClickedCallBack() || this.canHandleBondClickedCallBack() || depictActionEnabled))
			//return true; //no action is performed in depict mode
			return false; //no action is performed in depict mode - BB changed March 2013

		//the return value of this method
		//set to true if the event was consumed and does not need to be propagated
		boolean eventNotUsed = false;
		boolean eventUsed = true;
		boolean returnStatus = eventUsed; // 2206

		//BB
		//this.isContextMenu = this.isEventContextMenu(e); //will be used in the addRing() method to decide if a spiro ring should be added


		//BB
		this.mustReDrawInfo = false;

		//TODO
		xold = x - (int)menuCellSize;
		yold = y - (2 * (int)menuCellSize + menuCellBorder);
		info("");
		// int x = e.getX(); int y = e.getY();
		this.mouseShift = e.shiftDown(); // because of numbering
		
		movePossible = false;

		if ( x < menuCellSize || y < menuCellSize * 2 + menuCellBorder) { // --- menu pressed
			int action = this.determineMenuAction(x, y, true);


			//Code written by PE
			//Should this be moved to menuAction(action)?
			// empty buttons not considered
			if (action == ACTION_SPIRO) { 
				spiroAdding = true;
				info("Next ring will be added as spiro");
				repaint();
				this.mouseDownWasUsed = true;
				return eventUsed;
			}
			
			//Code written by BB
			//Should this be moved to menuAction(action)?
			if(action == ACTION_MOVE_AT) {
				if(this.showAtomMoveButton) {
					info("Move one atom");
					repaint();
				} else {
					this.mouseDownWasUsed = true;
					return eventUsed;
				}
				
			}
			
			//BB: xbutton handling
			if(!xButton && action == ACTION_AN_X) {
				return eventNotUsed;
			}

			if (!query && action == ACTION_QRY)
				return eventNotUsed;
			if (!stereo && action == ACTION_STEREO)
				return eventNotUsed;
			if (!multipart && action == ACTION_NEW)
				return eventNotUsed;
			if (!(number || autonumber) && action == ACTION_MARK)
				return eventNotUsed;
			if (!reaction && action == ACTION_REACP)
				return eventNotUsed;
			//if(action == ACTION_EMPTY_CELL){
			//	return eventNotUsed;
			//}

			returnStatus = menuAction(action); //has its own paint() call
		}

		else if ( y > dimension.height - menuCellSize - 1) { // --- info area clicked
			return eventNotUsed;
		}

		else  { // --- mouse click in the drawing area
			// ---------------------------
			//March 2016
			// the closest mol becomes the active one - needed for table to move one of the fragments
			//int m = findClosestMol(x,y);
			int m = findClosestMol(xold,yold); //xold and yold are the coordinates translated for the drawing area
			if(m>0) {
				actualMoleculePartIndex = m;
				mol = moleculeParts[m];
			} else {
				actualMoleculePartIndex = 0;
				
			}
			//OKK

			//June 2015
			if ( mol.touchedAtom > 0 && this.canHandleAtomClickedCallBack()) {
				
				this.handleAtomClickedCallBack(actualMoleculePartIndex, mol.touchedAtom); //not sure that actualMoleculePartIndex is set correctly in case of a multi structure
				if(depict && ! depictActionEnabled) {
					return true;
				}
			}

			if(mol.touchedBond > 0 && this.canHandleBondClickedCallBack()) {
				this.handleBondClickedCallBack(actualMoleculePartIndex, mol.touchedBond); //not sure that actualMoleculePartIndex is set correctly in case of a multi structure
				if(depict && ! depictActionEnabled) {
					return true;
				}
				
			}

			
			
			
			
			movePossible = true;
			x -= menuCellSize;
			y -= 2 * menuCellSize + menuCellBorder;

			// atom clicked
			
			if( mol.touchedAtom > 0 ) {
				lastTouchedMol.molIndex = actualMoleculePartIndex;
				if (action == ACTION_DELETE) {
					this.actionDeleteTouchedAtomOrBond();
//					mol.preSave();
//					mol.deleteAtom(mol.touchedAtom);
//					this.recordAtomEventAndPostSave(JME.DEL_ATOM2);
//
//					mol.touchedAtom = 0;

				} else if (action == ACTION_DELGROUP) {
					return true; // do nothing
				} else if (action == ACTION_CHARGE) {
					if(mol.changeCharge(mol.touchedAtom, 0))
						this.recordAtomEventAndPostSave(JME.CHARGE_ATOM0);

				} else if (action == ACTION_CHARGE_PLUS) {
					if(mol.changeCharge(mol.touchedAtom, 1))
						this.recordAtomEventAndPostSave(JME.CHARGE_ATOM_PLUS);
				} else if (action == ACTION_CHARGE_MINUS) {
					if(mol.changeCharge(mol.touchedAtom, -1))
						this.recordAtomEventAndPostSave(JME.CHARGE_ATOM_MINUS);
				} else if (action == ACTION_BOND_SINGLE
						|| action == ACTION_BOND_DOUBLE
						|| action == ACTION_BOND_TRIPLE
						|| action == ACTION_STEREO || action == ACTION_CHAIN) {
					mol.preSave();
					lastAction = LA_BOND; // in addBond may be set to 0
					mol.addBond();
					mol.touched_org = mol.touchedAtom;
					
					if (action == ACTION_CHAIN) {
						mol.nchain = 1; // pre CHAIN rubberbanding
						mol.chain[1] = mol.natoms;
						mol.chain[0] = mol.touchedAtom;
						mol.touchedBond = 0; // 2005.02
						// mol.avoidTouch(1);
						this.recordBondEvent(JME.ADD_BOND);
						
					} else {
						this.recordBondEvent(JME.ADD_BOND);
						this.postSave(); //for the CHAIN, save at mouseUp event
					}

				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					mol.preSave();
					lastAction = LA_RING; // in addRing may be set to 0
					mol.addRing();
					this.recordAtomEventAndPostSave(JME.ADD_RING);

				} else if (action == ACTION_TEMPLATE) {
					mol.preSave();
					// mol.addTemplate(template);
					lastAction = LA_GROUP;
					this.recordAtomEventAndPostSave(JME.ADD_TEMPLATE);

				} else if (action >= ACTION_GROUP_MIN
						&& action < ACTION_GROUP_MAX) {
					mol.preSave();

					mol.addGroup(false);
					this.recordAtomEventAndPostSave(JME.ADD_GROUP);

					lastAction = LA_GROUP; // may be set to 0
				} else if (action == ACTION_QRY) { // setting atom as query atom
					if (queryBox.isBondQuery())
						return true;
					mol.setAtom(mol.touchedAtom, queryBox.getSmarts());
					mol.isQuery = true; //2013.09
					
					this.recordAtomEventAndPostSave(JME.ADD_ATOM_QUERY);

				} else if (action == ACTION_MARK) {
					boolean marked = mol.mark();
					if (marked)
						this.recordAtomEventAndPostSave(JME.MARK_ATOM);
					else
						this.recordAtomEventAndPostSave(JME.UN_MARK_ATOM);
						
				} else if (action == ACTION_MOVE_AT) {
					//System.out.println("Move atom started");
				} else if (action > 300) { // atoms
					if (active_an != mol.an(mol.touchedAtom)
							|| active_an == AN_X) {
						mol.preSave();
						mol.AN(mol.touchedAtom, active_an);
						mol.Q(mol.touchedAtom, 0); // resetne naboj
						//mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
						mol.atoms[mol.touchedAtom].iso = 0; //BB: reset isotop
						//mol.nh[mol.touchedAtom] = 0;
						mol.atoms[mol.touchedAtom].nh = 0;

						// special processing pre AN_X, osetrene, ze moze byt aj
						// ""
						if (active_an == AN_X) {
							String xx = MultiBox.atomicSymbol.getText();
							if (xx.length() < 1)
								xx = "X";
							mol.setAtom(mol.touchedAtom, xx);

						} 
						this.recordAtomEventAndPostSave(JME.SET_ATOM + active_an); //active_an is an arbitrary number, should be changed to the string of the atom type


					}
				} else { //BB: nothing happened to the clicked atom
					returnStatus = eventNotUsed; 

				}
				//BB:moved
				//status = false; // 2206




			} 

			// bond clicked
			else if ( mol.touchedBond > 0) {
				lastTouchedMol.molIndex = actualMoleculePartIndex;
				if (action == ACTION_DELETE) {
					this.actionDeleteTouchedAtomOrBond();
//					mol.preSave();
//					mol.deleteBond(mol.touchedBond);
//					this.recordBondEvent(JME.DEL_BOND);
//
//					mol.touchedBond = 0;
//					this.postSave();
				} else if (action == ACTION_DELGROUP) {
					mol.preSave();
					mol.deleteGroup(mol.touchedBond);
					this.recordBondEvent(JME.DEL_BOND_GROUP);
					mol.touchedBond = 0;
					this.postSave();
				} else if (action == ACTION_STEREO) {
					mol.stereoBond(mol.touchedBond);
					this.recordBondEvent(JME.SET_BOND_STEREO);
					this.postSave();
				}
				else if (action == ACTION_BOND_SINGLE || action == ACTION_CHAIN) {
					if (mol.bonds[mol.touchedBond].bondType == JMEmol.SINGLE
							&& mol.bonds[mol.touchedBond].stereo == 0) {// nie pre
						// stereo
						mol.bonds[mol.touchedBond].bondType = JMEmol.DOUBLE;
						this.recordBondEvent(JME.SET_BOND_DOUBLE);

						this.postSave();
					}
					else {
						mol.bonds[mol.touchedBond].bondType = JMEmol.SINGLE;
						mol.bonds[mol.touchedBond].stereo = 0; //BB: remove stereo flag - bug fix - was creating a problem with undo/redo
						this.recordBondEvent(JME.SET_BOND_SINGLE);

						this.postSave();
					}
					mol.bonds[mol.touchedBond].stereo = 0; // zrusi stereo
				} else if (action == ACTION_BOND_DOUBLE) {
					mol.bonds[mol.touchedBond].bondType = JMEmol.DOUBLE;
					mol.bonds[mol.touchedBond].stereo = 0; // zrusi stereo
					this.recordBondEvent(JME.SET_BOND_DOUBLE);

					this.postSave();
				} else if (action == ACTION_BOND_TRIPLE) {
					mol.bonds[mol.touchedBond].bondType = JMEmol.TRIPLE;
					mol.bonds[mol.touchedBond].stereo = 0; // zrusi stereo
					this.recordBondEvent(JME.SET_BOND_TRIPLE);

					this.postSave();
				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					// fusing ring to bond
					mol.preSave();
					lastAction = LA_RING; // in addRing may be set to 0
					mol.addRing();
					this.recordBondEvent(JME.ADD_RING_BOND);
					this.postSave();
				} else if (action == ACTION_QRY) {
					if (!queryBox.isBondQuery())
						return true;
					String bondQuery = queryBox.getSmarts();
					mol.bonds[mol.touchedBond].bondType = JMEmol.QUERY;
					// mol.stereob[mol.touchedBond] = JMEmol.QUERY;
					mol.bonds[mol.touchedBond].btag= bondQuery;
					/*
					 * if ("~".equals(bondQuery)) mol.stereob[mol.touchedBond] =
					 * JMEmol.QB_ANY; if (":".equals(bondQuery))
					 * mol.stereob[mol.touchedBond] = JMEmol.QB_AROMATIC; if
					 * ("@".equals(bondQuery)) mol.stereob[mol.touchedBond] =
					 * JMEmol.QB_RING; if ("!@".equals(bondQuery))
					 * mol.stereob[mol.touchedBond] = JMEmol.QB_NONRING;
					 */
					
					this.recordBondEvent(JME.SET_QUERY_BOND);

					this.postSave();
				} else if (action == ACTION_MARK) {
					//info("Only atoms may be marked !");
					//March 2014
					
					{
						boolean marked = mol.starMarkBond(mol.touchedBond);
						if(marked)
							this.recordBondEvent(JME.MARK_BOND);
						else
							this.recordBondEvent(JME.UN_MARK_BOND);

						
						this.postSave(); 
					}

					
					
				} else {
					//no bond were changed
					returnStatus = false; // 2206
				}
				//BB removed and replaced by above
				//status = false; // 2206
			}

			// free space clicked - new molecule
			// creating new molecule only on start or when ACTION_NEW is on
			else if (numberofMoleculeParts == 0 || newMolecule == true) {
				if (action <= ACTION_STEREO)
					return eventNotUsed;


				numberofMoleculeParts++;
				actualMoleculePartIndex = numberofMoleculeParts;
				moleculeParts[numberofMoleculeParts] = new JMEmol(this);
				mol = moleculeParts[numberofMoleculeParts];
				lastTouchedMol.molIndex = actualMoleculePartIndex;
				newMolecule = false;
				smol = null; // kvoli undo

				//BB: TODO : lot of duplicated code
				if (action >= ACTION_BOND_SINGLE
						&& action <= ACTION_BOND_TRIPLE
						|| action == ACTION_CHAIN) {
					mol.createAtom();
					mol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(mol, 1, x,y);
					mol.touchedAtom = 1;
					mol.touched_org = 1; // needed for checkNewBond();
					lastAction = LA_BOND;
					mol.addBond();
					// orienting chain
					if (action == ACTION_CHAIN) {
//						mol.x[2] = x + JMEmol.RBOND * .866;
//						mol.y[2] = y - JMEmol.RBOND * .5;
						XY(mol, 2, x + JMEmol.RBOND * .866, 
								 y - JMEmol.RBOND * .5);
						mol.chain[0] = 1;
						mol.chain[1] = 2;
						mol.nchain = 1;
						this.recordBondEvent(JME.ADD_CHAIN);

					} else {
						this.recordBondEvent(JME.ADD_BOND);

					}
				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					mol.xorg = scaleCoordinate(x);
					mol.yorg = scaleCoordinate(y);
					lastAction = LA_RING;
					mol.addRing();
					this.recordAfterStructureChangedEvent(JME.ADD_RING);
				} else if (action > 300) { // adding 1st atom
					mol.createAtom();
					mol.AN(1, active_an);
					mol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(mol, 1, x, y);
					mol.touchedAtom = 1;
					if (active_an == AN_X) {
						String xx = MultiBox.atomicSymbol.getText();
						if (xx.length() < 1)
							xx = "X";
						mol.setAtom(1, xx);
					}
					this.recordAtomEvent(JME.ADD_ATOM);

				} else if (action == ACTION_TEMPLATE) {
					readMolecule(template);
					this.recordAfterStructureChangedEvent(JME.ADD_TEMPLATE);

				} else if (action >= ACTION_GROUP_MIN
						&& action < ACTION_GROUP_MAX) {
					// adding first atom (to which group will be connected)
					mol.createAtom();
					mol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(mol, 1, x, y);

					mol.touchedAtom = 1;
					// adding group
					mol.addGroup(true);
					this.recordAfterStructureChangedEvent(JME.ADD_GROUP);
				} else {
					System.err.println("error -report fall through bug !");
				}
				//BB changed
				//returnStatus = eventNotUsed; // 2206

				this.postSave(); //BB: added - there was no save()
			} else { //BB nothing happened
				returnStatus = false;
			}



			if(returnStatus != eventNotUsed) {//BB: if nothing has changed - there is no need to repaint
				// BB
				mol.valenceState();

				this.mustReDrawLeftMenu = false;
				this.mustReDrawTopMenu = false;
				this.mustReDrawMolecularArea = true;
				//don't touch info - automatic
				repaint(); // ciastocne zbytocne repaintuje, ale asi nechat tak
			}
		}
		
		this.mouseDownWasUsed = returnStatus;
		
		return returnStatus;
	}

	// ----------------------------------------------------------------------------
	public boolean mouseUp(Event e, int x, int y) {

		
			
		boolean eventUsed = false;


		if (depict && !depictActionEnabled) {
			if(toggleDepictEdit == true) {
				this.options("nodepict");
				this.handleAfterAfterDepictEditToggleEvent();
			}
			return true;
			
		}

		if(this.movingAtom) {
			//end of atom move
			this.movingAtom = false;
			mol.findBondCenters(); //BB: aton has been moved, thus the bond centers must be updated
			//this.recordAtomEvent(MOVE_ATOM); //this is not a structure change
			this.postSave();
			eventUsed = true;
		}

		//BB
		this.mustReDrawInfo = false;
		lastRotation = 0; //needed?

		// LA_GROUP netreba, tam nemoze byt atom overlap
		if (lastAction == LA_BOND) {
			if (action == ACTION_CHAIN) {
				mol.checkChain();
				//BB
				//this.recordBondEvent("AddChain"); //each added bond is saved
				this.postSave(); //save the new structure with the chain , notify about the event

			} else {

				//find out if the last touched mol is the same
				//findMolAndAtomOrBondInDrawingAreaFromEventXY(x, y, this.newTouchedMol);
				//System.out.println("@@@mouseUp: newTouchedMol: " + newTouchedMol.molIndex + " " + newTouchedMol.atomIndex + " x:" + x + " y: " + y);
				//System.out.println("@@@mouseUp: numberofMoleculeParts: " + numberofMoleculeParts + " actualMoleculePartIndex: " + actualMoleculePartIndex);
				//System.out.println("@@@mouseUp: lastTouchedMol: " + lastTouchedMol.molIndex + " " + lastTouchedMol.atomIndex + " x:" + x + " y: " + y);

				//lastTouchedMol was set during mouseDrag
				if(lastTouchedMol.molIndex != 0 && actualMoleculePartIndex != lastTouchedMol.molIndex) {
					// merge the current mol and the other mol
					mol.deleteAtom(mol.natoms);; //remove the last atom because it will be replaced by the atoms of the new mol
					int atom1 = mol.touched_org; //first atom of the new bond to be created
					int atom2 = lastTouchedMol.atomIndex + mol.natoms;//second atom of the new bond to be created
					
					assert atom1 != mol.natoms +1;

					JMEmol otherMol = moleculeParts[lastTouchedMol.molIndex];
					JMEmol merged = new JMEmol(this, new JMEmol[] {null, mol, otherMol}, 2);
					merged.atoms[0] = new Atom(); //needed by rubberbanding()
					
					//bug: the user selected bond order is not taken into account
					merged.createAndAddNewBond(atom1, atom2);
					
					//
					JMEmol[] newMoleculeParts = new JMEmol[moleculeParts.length];
					for(int p = 0, newP = 0; p < moleculeParts.length; p++) {
						if(moleculeParts[p] == mol) {
							newMoleculeParts[newP++] = merged; //replace mol with merged
						} else if (moleculeParts[p] == otherMol ) { //skip
							continue;
						} else {
							newMoleculeParts[newP++] = moleculeParts[p];
						}
						
					}
					
					moleculeParts = newMoleculeParts;
					numberofMoleculeParts --;
					mol = merged;//replace mol with merged
					lastTouchedMol.reset();
					
				} else {
					//as before - no merge
					//checkBond create or increase bond order
					mol.checkBond(); // standard bond check
				}
			}
			
			mol.findBondCenters(); // zbytocne vela, ale tu kvoli r.b.

			//BB :
			if(this.bondRubberBanding ) {
				//a bond had been added and the state saved
				//to keep only the bond stabilized after the rubberbanding,
				//remove the previous state
				this.molChangeManager.removeLast();

				this.recordBondEvent(ADD_BOND);
				this.postSave(); //save to the undo stack

				this.bondRubberBanding = false;
			}
			eventUsed = true;
		} else if (lastAction == LA_MOVE) {
			// !!! mal by sem este prist check na touched
			mol.findBondCenters();

			//BB
			this.postSave();
			eventUsed = true;

		}
		if (lastAction > 0) {
			doMenu = false;

			// BB
			mustRedrawNothing();
			this.mustReDrawMolecularArea = true;


			mol.valenceState();
			// nevola sa vzdy ked treba !!!!!
			mol.cleanPolarBonds(); // nie je to privela action ??? nie az pri
			// canon
			repaint(); // napr po zdvojeni vazby ju nakresli
			lastAction = 0;
			afterClear = false;
			eventUsed = true;
		}

		//BB: useful for touch devices to avoid showing the marked atom after edition
		if(isTouchSupported && (mol.touchedBond != 0 || mol.touchedAtom != 0) ) {
			mol.touchedBond = 0;
			mol.touchedAtom = 0;
			mustRedrawNothing();
			this.mustReDrawMolecularArea = true;
			repaint();
			eventUsed = true;

		}

		//handle toggle depict/edit
		if(this.toggleDepictEdit && !this.mouseDownWasUsed &&!eventUsed) {
			if ( this.depict) {
				this.options("nodepict");
			} else {
				this.options("depict");
			}
			this.handleAfterAfterDepictEditToggleEvent();
			eventUsed = true;
		}


		return eventUsed;
	}
	/**
	 * screen coordinate to molecular drawing area coordinate
	 * @param coord
	 * @return
	 */
	protected int scaleCoordinate(int coord) {
		double newCoord = scaleCoordinate((double) coord);
			
		return (int)Math.round(newCoord);
	}
	protected double scaleCoordinate(double coord) {
		if(this.scalingIsPerformedByGraphicsEngine) {
			return coord / depictScale;
		}
		return coord;
	}
	// ----------------------------------------------------------------------------
	public boolean mouseDrag(Event e, int x, int y) {
		// public void mouseDragged(MouseEvent e) {

		//System.out.println("mouseDrag");
		if (depict && ! depictActionEnabled)
			return true;
		// 2Banding possible only after succesfull addition of the bond
		if (!movePossible)
			return true;

		//BB popup menu for copy&paste
		boolean meta = e.metaDown() ; //true if right mouse click
		if(meta) {
			return true;
		}

		//BB
		this.mustReDrawInfo = false;

		// ??? MS-Win toto volaju aj len pri MouseClick (handled here)
		// int x = e.getX()-sd; int y = e.getY()-sd*2;
		x -= menuCellSize; //duplicate code
		y -= menuCellSize * 2;
		int drawingAreaMoveX = scaleCoordinate(x - xold);
		int drawingAreaMoveY = scaleCoordinate(y - yold);

		
		int drawingAreaX = scaleCoordinate(x);
		int drawingAreaY = scaleCoordinate(y);

		if (lastAction == LA_RING || lastAction == LA_GROUP
				|| lastAction == LA_FAILED) {
			return true;
		}
		else if (lastAction == LA_BOND) {
			//mol.rubberBanding(drawingAreaX, drawingAreaY);
			
			//code copied and adapted from mol.rubberBanding
			//goal: to crerate bond between two different molecule parts
			boolean done = false;
			moleculeParts[this.lastTouchedMol.molIndex].touchedAtom = 0;
			
			
			//to be used for adding a bond with another part
			//need to differentiate the temporary moving atom that was created during mousedown
			//from the atom of another fragment because they can overlap
			//the temp atom is the last one
			mol.natoms--;
			findMolAndAtomOrBondInDrawingArea(x, y, this.newTouchedMol);
			mol.natoms++; //restore
			
			//System.out.println("@@@ mouseDrag: mol.natoms: " + mol.natoms);
			//System.out.println("@@@ mouseDrag: newTouchedMol: " + newTouchedMol.molIndex + " " + newTouchedMol.atomIndex);

			if(this.newTouchedMol.molIndex > 0 && this.newTouchedMol.atomIndex > 0) {
				JMEmol touched_JMEmol = this.moleculeParts[newTouchedMol.molIndex];
				touched_JMEmol.touchedAtom=this.newTouchedMol.atomIndex;

				if (touched_JMEmol != mol || this.newTouchedMol.atomIndex != mol.touched_org) { // make bond towards existing  atom
					mol.XY(mol.natoms,  touched_JMEmol.x(newTouchedMol.atomIndex),  touched_JMEmol.y(newTouchedMol.atomIndex)); //move the new atom to the coordinate of the closest touched atom "snap"
					// actually it does not move while it still close to the touched atom
					//System.out.println("SNAP otheratom");
					touched_JMEmol.touchedAtom = newTouchedMol.atomIndex;
					
					done = true;
					//lastTouchedMol will be used by mouseUp() to create the new bnond between the two
					//
					this.lastTouchedMol.initMyselfWith(this.newTouchedMol);
				}
//				else { // this was standard position of the bond
//					mol.XY(mol.natoms, mol.xorg, mol.yorg);//move the new atom to the coordinate of the origin atom "snap"
//				}
//				this.lastTouchedMol.init(this.newTouchedMol);
//				System.out.println("@@@ mouseDrag: lastTouchedMol: " + lastTouchedMol.molIndex + " " + lastTouchedMol.atomIndex);
//
//			} else {
//				// bond width normal length follows mouse pointer
//				double dx=drawingAreaX-mol.x(mol.touched_org); 
//				double dy=drawingAreaY-mol.y(mol.touched_org);
//				double rx=Math.sqrt(dx*dx+dy*dy); if (rx < 1.0) rx=1.0;
//				double sina=dy/rx; double cosa=dx/rx;
//				
//				mol.XY(mol.natoms, 
//						mol.x(mol.touched_org)+JMEmol.RBOND*cosa, 
//						mol.y(mol.touched_org)+JMEmol.RBOND*sina
//					);
				
			}
			if(!done) { 
				//perform the rubberbanding within the same mol - old code
				mol.rubberBanding(drawingAreaX, drawingAreaY);
			}
			this.bondRubberBanding = true; //BB
		}
		//BB
		else if (action == ACTION_MOVE_AT && mol.touchedAtom > 0) { 
			if(this.movingAtom == false) {
				this.movingAtom = true;
				mol.preSave();
			}
			//mol.atomRubberBanding(drawingAreaX, drawingAreaY);
			mol.XY(mol.touchedAtom, drawingAreaX, drawingAreaY);
				
		} else if (e.shiftDown() || e.metaDown()) {
			// else if (e.isShiftDown() || e.isMetaDown()) {
			mol.rotate(drawingAreaMoveX);
			lastAction = LA_MOVE; //BB: should it be changed to LA_ROTATE?
			//info("Rotation: " + x ); //BB


		} else if (mol.touchedAtom == 0 && mol.touchedBond == 0 ) { //if no atom or bond  are touched, then the touched mol can be moved
			//Start molecue move only if the mousedrag event started within the drawing area

			//avoid unwanted sudden large moves after a rotation on a touch device
			//if(lastAction != LA_MOVE) {
				//drawingAreaMoveX = drawingAreaMoveY=0;
			//}
			
			//Do not move the molecule if the dragging start is not within the drawing area
			if( !(isOutsideDrawingArea(x, y) && lastAction != LA_MOVE)) {
				Rectangle boundingBox = this.getMolecularAreaSizeWithScalingForDepiction();
				mol.move(drawingAreaMoveX, drawingAreaMoveY, boundingBox);
				//info("Move: " + x  + " " + y); //BB
	
				lastAction = LA_MOVE;
			}
		}


		doMenu = false;

		// BB
		mustRedrawNothing();
		mustReDrawMolecularArea = true;

		repaint();
		xold = x;
		yold = y;
		return true;
	}
	
	protected boolean isOutsideDrawingArea(int x, int y) {
		//x and y have already been moved to the drawing area coordinates
		return ( x < 0 || y < 0 || y > this.molecularAreaHeight || x > this.molecularAreaWidth); 

	}
	

	int findClosestMol(int x, int y) {
		//x and y have already been moved to the drawing area coordinates
	
		int molIndex = 0;
		if (isOutsideDrawingArea(x,y))
			return molIndex;
		
		if(numberofMoleculeParts == 1) {
			return actualMoleculePartIndex;
		}
		x = scaleCoordinate(x);
		y = scaleCoordinate(y);
		//y = (int)Math.round(moleculeParts[2].y(1));
		//moleculeParts[1].Y(1, y);
		//moleculeParts[2].Y(1, y);
		//moleculeParts[1].X(1, 100);
		//moleculeParts[2].X(1, 400);
		
		//x = (int)Math.round(((moleculeParts[1].x(1) + moleculeParts[2].x(1))*0.5));
		//System.out.println("1: "+ moleculeParts[1].x(1) + "  2: "+ moleculeParts[2].x(1));
		//System.out.println("1: "+ moleculeParts[1].y(1) + "  2: "+ moleculeParts[2].y(1));
		double min  = Double.MAX_VALUE;
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			double d = moleculeParts[m].closestAtomDistance(x, y);
			if(d < min) {
				min = d;
				molIndex = m;
			}
		}
		
		return molIndex;
	}
	/**
	 * find the touched atom or bond
	 * @param x
	 * @param y
	 * @param result
	 */
//	void  findMolAndAtomOrBondWithinRadius(int x, int y, double radius,  TouchedMol result) {
//
//		x = scaleCoordinate(x);
//		y = scaleCoordinate(y);
//		for (int m = 1; m <= numberofMoleculeParts; m++) {
//			//a_or_b > 0 if atom , < 0 if bond and 0 if neither
//			int a_or_b = moleculeParts[m].testAtomAndBondTouch(x, y, new DoubleWrapper(radius));
//			//a_or_b = moleculeParts[m].testAtomAndBondTouch(x, y);
//			//info("" + x + " " + y + " " +a_or_b);				
//			if(a_or_b != 0 ) {
//				
//				result.molIndex = m;
//				if(a_or_b > 0) {
//					result.atomIndex = a_or_b;
//				} else {
//					result.bondIndex = a_or_b * -1;
//					
//				}
//				break;
//				
//			}
//		}
		
		
//	}
	
	void findMolAndAtomOrBondInDrawingAreaFromEventXY(int event_x, int event_y,TouchedMol result ) {
		int x =  event_x - (int)menuCellSize;
		int y = event_y - (2 * (int)menuCellSize + menuCellBorder);
		
		findMolAndAtomOrBondInDrawingArea(x, y, result);

	}
	void findMolAndAtomOrBondInDrawingArea(int x, int y,  TouchedMol result) {
		
		if(this.isOutsideDrawingArea(x, y)) {
			result.reset();
			return;
		}
		findMolAndAtomOrBondWithinRadius(x, y, getHumanInteractionTouchRadius(), result);
	}

	
	/**
	 * find the touched atom or bond
	 * @param x
	 * @param y
	 * @param result
	 */
	void  findMolAndAtomOrBondWithinRadius(int x, int y, double radius,  TouchedMol result) {
		
		result.reset();

		x = scaleCoordinate(x);
		y = scaleCoordinate(y);
		double minDistance = radius;
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			DoubleWrapper minDistanceFound = new DoubleWrapper(radius);
			int a_or_b = moleculeParts[m].testAtomAndBondTouch(x, y, minDistanceFound);

			if(minDistanceFound.value <  minDistance) {
				minDistance = minDistanceFound.value;
				result.reset();
				result.molIndex = m;
				result.distance = minDistance;
				assert a_or_b != 0;;
				if(a_or_b > 0) {
					result.atomIndex = a_or_b;
				} else {
					result.bondIndex = a_or_b * -1;
					
				}
			}
		}
		
		
	}
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	/**BB
	 * Compute the radius for human interaction around an atom or a bond.
	 * This radius should be larger for touch device than for pointer based system.
	 * 
	 * The drawback of a larger radius is that one has to be more precise when moving the structure.
	 * @return a radius 
	 */
	static final int TOUCH_LIMIT = 50;

	protected int getHumanInteractionTouchRadius() {
		if(JME.isTouchSupported) {
			return TOUCH_LIMIT + 300; //determined by trial and error on an iPad 4 by BB
		}
		return TOUCH_LIMIT + 120;
	}


	// ----------------------------------------------------------------------------
	@Override
	public boolean mouseMove(Event e, int x, int y) {
		// public void mouseMoved(MouseEvent e) {
		
		//is depictActionEnabled test needed here? if depictActionEnabled is used only for the toggle edit/depict, then no
		if (depict && !(this.canHandleAtomHighLightCallBack()  || this.canHandleBondHighLightCallBack() || depictActionEnabled)) //notifyAtomHighLightJSfunction: Luc P request to show atom highlight in depict mode
			return true;
		// int x = e.getX()-sd; int y = e.getY()-sd*2;

		boolean repaintFlag = false;

		int action = this.determineMenuAction(x, y, true);
		
		if( action != this.mouseWasOverAction) {
			// kind of new event
			repaintFlag |= this.handleMouseLeaveActionMenu(this.mouseWasOverAction);
			repaintFlag |= this.handleMouseEnterActionMenu(action);
			this.mouseWasOverAction = action;
		}
		
		//BB popup menu for copy&paste has been opened
		//boolean meta = e.metaDown() ; //true if right mouse click
		if(this.isEventContextMenu(e)) {
			//do nothing to avoid the molecule moving while popup menu is displayed
			return true;
		}

		//BB
		//this.mustReDrawInfo = false; //whenpaste operation fails, a mouse move can still occur, and there will be no error message.

		//System.out.println("X:Y: " + x +" " + y + " " + menuCellSize);
		
		//BB: bug found by Oli: with structure underneath the menu region: highlight must dissapear
		
		//boolean outsideDrawingArea = !depict  && ( x < menuCellSize || y < menuCellSize * 2 + menuCellBorder || y > dimension.height - menuCellSize - 1 || x >= dimension.width-1); 
		
		x -= menuCellSize;
		y -= menuCellSize * 2;

		//don't create any new object during a mouse move to 
		//avoid stressing the garbage colector
		//BB: bug found by Oli: with structure underneath the menu region: highlight must dissapear
		findMolAndAtomOrBondInDrawingArea(x, y,  newTouchedMol);
		
		//Don't allow bond touching in ACTION_MOVE_AT
		if(action == ACTION_MOVE_AT && newTouchedMol.bondIndex > 0) { 
			newTouchedMol.bondIndex = 0;
		}
		//System.out.println(newTouchedMol.molIndex + " " + newTouchedMol.atomIndex + " " +  newTouchedMol.bondIndex);

		if( ! newTouchedMol.equals(lastTouchedMol)) {
			
		
		// necekuje, ci sa nedotyka 2 molekul naraz, ale to by bolo asi zbytocne
			
			int m  = lastTouchedMol.molIndex;
			
			if( m > 0) {
				moleculeParts[m].touchedAtom = 0;
				moleculeParts[m].touchedBond = 0;
			}
			m  = newTouchedMol.molIndex;
			if( m > 0) {
				moleculeParts[m].touchedAtom = newTouchedMol.atomIndex;
				moleculeParts[m].touchedBond = newTouchedMol.bondIndex;
				//touched mol becomes the mol for edition
				// this must be changed!!!!!
				if (m != actualMoleculePartIndex ) {
					actualMoleculePartIndex = m;
					mol = moleculeParts[actualMoleculePartIndex];
				}
			}

			repaintFlag = true;
			//BB changed: notify only if it is an atom highlight
			
			//Design issue: notifyAtomHighLightJSfunction does not provide the molecule part number
			//presently notifyAtomHighLightJSfunction handle the minimal change reporting
			//if(newTouchedMol.atomIndex != lastTouchedMol.atomIndex || m != lastTouchedMol.molIndex) {
				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);
			//}
			//if(newTouchedMol.bondIndex != lastTouchedMol.bondIndex|| m != lastTouchedMol.molIndex) {
				notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
			//}
			
//			if(newTouchedMol.atomIndex > 0) {
//				if(lastTouchedMol.bondIndex >0) {
//					notifyBondHighLightJSfunction(0);//used to notify that the cursor has moved away from the bond
//				}
//				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex); //used by LP to highlight NMR spectrum part
//								
//			} else if (newTouchedMol.bondIndex>0) { //bond was touched
//				if(lastTouchedMol.atomIndex>0) {
//					notifyAtomHighLightJSfunction(0);//used to notify that the cursor has moved away from the atom
//				}
//				notifyBondHighLightJSfunction(newTouchedMol.bondIndex); //used by LP to highlight NMR spectrum part
//				
//			}
				
			//System.out.println(actualMoleculePartIndex + " "+ m  );
			
			lastTouchedMol.initMyselfWith(newTouchedMol);
			assert lastTouchedMol.equals(newTouchedMol);
			

		} 
//		else {
//			if(this.atomWasTouched) { //NEW 06 2015!!!!!
//				notifyAtomHighLightJSfunction(0); //used to notify that the cursor has moved away from the atom
//				this.atomWasTouched = false;
//			}
//
//			if(this.bondWasTouched) { //NEW 06 2015!!!!!
//				notifyBondHighLightJSfunction(0); //used to notify that the cursor has moved away from the bond
//				this.bondWasTouched = false;
//			}

//			if (moleculeParts[m].touchedAtom > 0 || moleculeParts[m].touchedBond > 0) {
//				moleculeParts[m].touchedAtom = 0;
//				moleculeParts[m].touchedBond = 0;
//				repaintFlag = true;
//			}
//		}
		
		
		if (repaintFlag) {
			// vynuluje pripadny predosly touch
//			for (int m = actualMoleculePartIndex + 1; m <= numberofMoleculeParts; m++) {
//				moleculeParts[m].touchedAtom = 0;
//				moleculeParts[m].touchedBond = 0;
//			}
			doMenu = false;
			// BB
			mustRedrawNothing();
			mustReDrawMolecularArea = true;
			repaint();

		} 
		//added after 
		//    if (depict && this.notifyStructuralChangeJSfunction == null) 
		//above was changed
//		if (depict) {
//			return true;
//		}
		
		

		return repaintFlag;
	}

	// ----------------------------------------------------------------------------
	@Override
	public boolean keyDown(Event e, int key) {

		//BB
		this.mustReDrawInfo = false;

		// public void keyPressed(KeyEvent e) {
		if (depict  && ! depictActionEnabled)
			return true;
		info("");
		// key shortcuts
		// treba to disabled, ked input do elementu;
		// if (elementInput) return false;
		// int key = e.getKeyChar();
		int pressed = 0;
		boolean alt = e.modifiers == e.ALT_MASK;
		boolean ctrl = e.controlDown();

		// System.err.println("key " + key + " " + alt);
		switch (key) {
		// case 'e': case 'E': JMEmol.TESTDRAW = !JMEmol.TESTDRAW; break;
		case 'c':
		case 'C':
			if(ctrl) { //try a Ctrl C for copy. does not work in Java due to java security policy
				this.copyMolFileToClipboard(false);
			}
			else {
				pressed = ACTION_AN_C;
			}

			break;

			//paste with Ctrl V
			//does not work in Java due to java security policy
		case 'v':
		case 'V':
			if(ctrl && this.paste) {
				this.pasteMolFileFromClipboard();
			}
			
			break;
		case 'n':
		case 'N':
			pressed = ACTION_AN_N;
			break;
		case 'o':
		case 'O':
			pressed = ACTION_AN_O;
			break;
		case 's':
		case 'S':
			pressed = ACTION_AN_S;
			break;
		case 'p':
		case 'P':
			pressed = ACTION_AN_P;
			break;
		case 'f':
		case 'F':
			pressed = ACTION_AN_F;
			break;
		case 'l':
		case 'L':
			pressed = ACTION_AN_CL;
			break;
		case 'b':
		case 'B':
			pressed = ACTION_AN_BR;
			break;
		case 'i':
		case 'I':
			pressed = ACTION_AN_I;
			break;
		case 'x':
		case 'X':
			if(this.xButton) {
				info(MultiBox.atomicSymbol.getText());
				pressed = ACTION_AN_X;
				active_an = AN_X;
			}
			break;
		case 'h':
		case 'H':
			info("H");
			pressed = ACTION_AN_H;
			break;
		case 'r':
		case 'R':
			info("-R");
			pressed = ACTION_AN_R;
			break; // if (rButton) ?
		case 't':
		case 'T':
			if (action == ACTION_AN_F) {
				pressed = ACTION_GROUP_CF3;
				info("-CF3");
			} else if (action == ACTION_AN_CL) {
				pressed = ACTION_GROUP_CCL3;
				info("-CCl3");
			} else {
				pressed = ACTION_GROUP_TBU;
				info("-tBu"); //TODO: consistent naming with the FG's
			}
			break;
		case 'y':
		case 'Y':
			if(ctrl) { //BB - does not work in Java
				pressed = ACTION_REDO;
			}
			else {
				pressed = ACTION_GROUP_NITRO;
				info("-NO2");
			}
			break;
		case 'z':
		case 'Z':
			if(ctrl) { //BB - does not work in Java
				pressed = ACTION_UNDO;
			}
			else {
				pressed = ACTION_GROUP_SULFO;
				info("-SO3H");
			}

			break;


		case 'a':
		case 'A':
			pressed = ACTION_GROUP_COO;
			info("-COOH");
			break;
		case 'e':
		case 'E':
			pressed = ACTION_GROUP_CC;
			info("-C#CH");
			break;
		case 'u':
		case 'U':
			pressed = ACTION_UNDO;
			break;
		case 'q':
		case 'Q':
			pressed = ACTION_GROUP_CYANO;
			info("-C#N");
			break;
		case 'g': // used for testing
			return true;
		case 27: //esc
			pressed = ACTION_BOND_SINGLE;
			break;
		case '-':
			// check here that an was changed and then cancell this -X ???
			if (action == ACTION_AN_F) {
				pressed = ACTION_GROUP_CF;
				info("-F");
			} else if (action == ACTION_AN_CL) {
				pressed = ACTION_GROUP_CL;
				info("-Cl");
			} else if (action == ACTION_AN_BR) {
				pressed = ACTION_GROUP_CB;
				info("-Br");
			} else if (action == ACTION_AN_I) {
				pressed = ACTION_GROUP_CI;
				info("-I");
			} else if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_CO;
				info("-OH");
			} else if (action == ACTION_AN_N) {
				pressed = ACTION_GROUP_CN;
				info("-NH2");
			} else
				pressed = ACTION_BOND_SINGLE;
			break;
//BB merged '=' and '
/*		case '=':'
			
			if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_dO;
				info("=O");
			} else
				pressed = ACTION_BOND_DOUBLE;
			break;
*/
			case '#':
			pressed = ACTION_BOND_TRIPLE;
			break;
		case '0':
			if (action == ACTION_MARK)
				updateMark(0);
			else {
				if (!alt) {
					pressed = ACTION_RING_FURANE;
					info("-Furyl");
				} else {
					pressed = ACTION_RING_3FURYL;
					info("-3-Furyl");
				}
			}
			break;
		case '1':
			if (action == ACTION_MARK)
				updateMark(1);
			else if (action == ACTION_AN_R) {
				info("-R1");
				pressed = ACTION_AN_R1;
			} else
				pressed = ACTION_RING_PH;
			break;
		case '2' :
		case '=':
			if (key == '2' && action == ACTION_MARK)
				updateMark(2);
			else if (key == '2' && action == ACTION_AN_R) {
				info("-R2");
				pressed = ACTION_AN_R2;
			}
			//BB added October 2015 : create a double bond
			// duplacade code with  =      TODO:
			else if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_dO;
				info("=O");
			} else
				pressed = ACTION_BOND_DOUBLE;
			break;
		case '3':
			if (action == ACTION_MARK)
				updateMark(3);
			else if (action == ACTION_AN_R) {
				info("-R3");
				pressed = ACTION_AN_R3;
			} else
				pressed = ACTION_RING_3;
			break;
		case '4':
			if (action == ACTION_MARK)
				updateMark(4);
			else if (action == ACTION_AN_R) { //added by BB
				info("-R4");
				pressed = ACTION_AN_R4;
			} else
				pressed = ACTION_RING_4;
			break;
		case '5':
			if (action == ACTION_MARK)
				updateMark(5);
			else if (action == ACTION_AN_R) { //added by BB
				info("-R5");
				pressed = ACTION_AN_R5;
			} else
				pressed = ACTION_RING_5;
			break;
		case '6':
			if (action == ACTION_MARK)
				updateMark(6);
			else if (action == ACTION_AN_R) { //added by BB
				info("-R6");
				pressed = ACTION_AN_R6;
			} else
				pressed = ACTION_RING_6;
			break;
		case '7':
			if (action == ACTION_MARK)
				updateMark(7);
			else if (action == ACTION_AN_R) { //added by BB
				info("-R7");
				pressed = ACTION_AN_R7;
			}else
				pressed = ACTION_RING_7;
			break;
		case '8':
			if (action == ACTION_MARK)
				updateMark(8);
			else if (action == ACTION_AN_R) { //added by BB
				info("-R8");
				pressed = ACTION_AN_R8;
			} else
				pressed = ACTION_RING_8;
			break;
		case '9':
			if (action == ACTION_MARK)
				updateMark(9);
			else if (action == ACTION_AN_R) { //added by BB
				info("-R9");
				pressed = ACTION_AN_R9;
			} else {
				info("9 ring");
				pressed = ACTION_RING_9;
			}
			break;
		case 'd':
		case 'D':
		case 8:
		case 127:
			pressed = ACTION_DELETE;
			break;
		case 32:
			pressed = ACTION_CHAIN;
			break; // SPACE
		case 'm': //BB
		case 'M': //BB
		case Event.PGUP:
			pressed = ACTION_PGUP;
			break; // PgUp


		case 'w': //BB
		case 'W': //BB
		case Event.PGDN:
			pressed = ACTION_PGDN;
			break; // PgDn
			// default: System.out.println("key "+key); break;
		}


		menuAction(pressed);
		return true;
	}


	// --------------------------------------------------------------------------
	// called when number key clicked and marking active
	// updates actual mark which will be used for marking
	private void updateMark(int n) {
		// need to know when new number and when combination of 2 presses i.e.
		// 12
		if (autonumber) {
			if (n == 0) {
				currentMark = -1;
				info("click marked atom to delete mark");
				repaint(); // updates status line
			}
			return;
		}

		if (markUsed)
			currentMark = n;
		else {
			if (currentMark > -1 && currentMark < 10)
				currentMark = currentMark * 10 + n;
			else
				currentMark = n; // mark cannot be > 99
		}
		markUsed = false;

		if (currentMark == 0) {
			currentMark = -1;
			info("click marked atom to delete mark");
		} else
			info(currentMark + " ");
		repaint(); // updates status line
	}
	// --------------------------------------------------------------------------
	//BB used for copy paste and setSubtituents
	@Override
	public void actionPerformed(ActionEvent evt) {
		mustRedrawNothing();

		String cmd = evt.getActionCommand();

		if (cmd.equals(CopyPasteAction.COPY_SMILES.toString())) {
			clipBoardManager.setClipboardContents(this.smiles());
		} 
		else if (cmd.equals(CopyPasteAction.COPY_MOL.toString())) {
			this.copyMolFileToClipboard(false);
		}
		else if (cmd.equals(CopyPasteAction.COPY_MOL_V3000.toString())) {
			this.copyMolFileToClipboard(true);
		}
		else if (cmd.equals(CopyPasteAction.PASTE.toString())) {
			if(this.paste)
				this.pasteMolFileFromClipboard();
		}
		//BB : rotation coming from the touch handling
		else if(cmd.equals("rotation")) { //used by touch devices
			if(lastAction != LA_ROTATE) {
				lastRotation = 0;
			}
			long rotation = evt.getWhen(); //I had to store the rotation somewhere 
			rotation *= -1; //feels more natural
			long deltaRotation = rotation - lastRotation ;

			if(Math.abs(deltaRotation) < 10) {
				mol.rotate((int) deltaRotation);
			}
			//mustRedrawNothing();
			mustReDrawMolecularArea =true;
			//info("Rotation: " + rotation + " deltaRotation " +  deltaRotation);

			//repaint(); //done at the end
			lastAction = LA_ROTATE;
			lastRotation = rotation;


		} else if(cmd == unSetChiralFlagAction || cmd==setChiralFlagAction) {
			boolean changed = this.mol.setChiralFlag(cmd == setChiralFlagAction);
			if(changed) {
				if(this.mol.chiralFlag) {
					info("Chiral flag is set");
				} else {
					info("No Chiral flag");
					
				}
				this.postSave(); //idea: recordMoleculePartEvent could be used to perform the postSave, + giving a name to saved state
				//that could be used for displaying in info() when mouse over undo button
				this.recordMoleculePartEvent(CHANGE_CHIRAL, this.actualMoleculePartIndex);
			}

		}	else if (cmd == autoAtomMapMoleculeAction) {
			
			//find the highest atom map
			int max = this.findMaxAtomMapAmongAllMolecules();
			boolean changed = false;
			for(int at = 1; at<= mol.natoms; at++) {
				Atom atom = mol.atoms[at];
				if( !atom.hasBeenMapped()) {
					max ++;
					atom.setMap(max);
					changed = true;
				}
			}
			
			if(changed) {
				mustReDrawMolecularArea = true;
				this.recordMoleculePartEvent(CHANGE_MANY_ATOM_MAP, this.actualMoleculePartIndex);
				this.postSave();
			}
		}
		
		//BB : rotation coming from the touch handling
		//problem: unwanted interaction with the rotation
		//Chemdoodle rotation & scaling works nice
		else if(cmd.equals("scale100") ) { //used by touch devices
			if(false && this.numberofMoleculeParts == 1) {
				long scale100 = evt.getWhen(); //I had to store the scale somewhere 

				mustReDrawMolecularArea =true;

				double delta = 0.05;
				if(scale100 != 100) {
					if(scale100 < 100){
						delta *= -1;
					}
					this.depictScale = scale100 / 100.0;
					//Todo : compute center of mol
					mol.scaling();
					mol.center(); //TODO : translate back to previous center
					//info("Scale " + this.depictScale );
					lastAction = LA_SCALE; 


				}
			}
		}
		else if(cmd.equals("end_gesture") ) { 
			this.postSave();
		}
		else  {
			this.setSubstituent(cmd);
		}

		if(mustReDrawMolecularArea || mustReDrawInfo) {
			repaint();
		}

	}

	//BB
	public void copyMolFileToClipboard(boolean isV3000) {
		clipBoardManager.setClipboardContents(this.molFile(isV3000));
	}

	public void pasteMolFileFromClipboard() {
		//		String molecule = clipBoardManager.getClipboardContents();
		//		if(molecule != null) {
		//			molecule = molecule.replace("\n", "|");
		//			this.readMolFile(molecule);
		//		}

		//asynchronous action is needed for non IE browsers
		clipBoardManager.getAsyncClipboardContents(this.getPasteAction());


	}
	//used by drag and drop
	public void pasteDirect(String molString) {
		//if pasting is allowed
		if(!this.paste) {
			return;
		}
		if(molString != null && molString.length() > 0) {
			this.createPasteActionInstanceIfNeeded().paste(molString);
		} else {
			this.showError("empty or null structure");
		}
	}
	
	protected PasteAction getPasteAction() {
		return this.createPasteActionInstanceIfNeeded();
	}
	protected  PasteAction createPasteActionInstanceIfNeeded() {
		if(this.pasteAction == null) {
			this.pasteAction = new PasteAction() {

			@Override
			public void paste(final String clipboardContent) {
				//final String molecule = clipboardContent;

				if(clipboardContent != null) {
					
					//customized paste
					if(JME.this.getPrePasteJSfunction() != null) {
						JSObject jsObject =  JSObject.getWindow(JME.this);
						jsObject.call(JME.this.getPrePasteJSfunction(), new String[]{clipboardContent});
						return;
					}
					
					///customized paste only for JSME
					if(JME.this.handleBeforePasteEvent(clipboardContent)) { //if the callback is set
						return;
					}

					JME.this.read_MOL_SDF_RXN(clipboardContent, new RunAsyncCallback() {

						@Override
						public void onFailure(Throwable reason) {
							//read_MOL_SDF_RXN has already handle the error
						}

						@Override
						public void onSuccess() {
							//record an event
							JME.this.handleAfterPasteEvent(clipboardContent);
							
						}
						
					});
				}

			}

		};
		}
		return this.pasteAction;
	}
	
	class StringWrapper {
		public String innnerString ;
	};
	
	//TODO the input error handling has to be redesigned
	// test cases with invalid MOL
	public void read_MOL_SDF_RXN(String SDF_MOL_RXN, final RunAsyncCallback sucessAndFailureHandle) {
		
		final StringWrapper sdfPastedMessage = new StringWrapper();
		sdfPastedMessage.innnerString = "";
		
		//todo: handle RDF
		int countSDF = JME.this.sdfStack.addEntries(SDF_MOL_RXN);
		if( countSDF > 0) {
			//sdfPastedMessage = ". " + countSDF + " structures in stack .Use Page Up/Down for SDF access";
			sdfPastedMessage.innnerString = ". " + " Use Page Up/Down for SDF access (" +countSDF + ")";
		}
		
		RunAsyncCallback localSucessAndFailureHandle  = new RunAsyncCallback() {

			@Override
			public void onFailure(Throwable reason) {
				info("ERROR: " + reason.getMessage()); //the readMolFile() method has already generated a message
				JME.this.alert(JME.this.infoText); //this.infotext has be set on thye line above
				JME.this.reset();
				JME.this.repaint();
				
			}

			@Override
			public void onSuccess() {
				info("Structure pasted" + sdfPastedMessage.innnerString);
				JME.this.postSave(); //add it to the undo/redo manager
				JME.this.repaint();
				
				
				
				sucessAndFailureHandle.onSuccess();
			}};
		try {
			JME.this.handleReadGenericInput(SDF_MOL_RXN, localSucessAndFailureHandle);
		} catch(Exception e) {
			localSucessAndFailureHandle.onFailure(e);
		}
	}
	
	
	/*Same functionality as prePasteJSfunction but only for JSME
	 *Advantage: the argument is a JS function, not a JS function name. The JS fyunction will have two arguments: my self and the string to process before pasting
	 *For JME, always return false - meaning that there is no callback set
	 */
	protected boolean handleBeforePasteEvent(String molecule) {
		
		return false;
	}

	/**
	 * Called when pasting has been sucessful.
	 * Method intended for a subclass.
	 */
	protected void handleAfterPasteEvent(String pasteContent) {
		// Do nothing
		
	}

	/**
	 * Called after swith to edit / depict mode using the toggle option.
	 * Method intended for a subclass.
	 */
	protected void handleAfterAfterDepictEditToggleEvent() {
		//do nothing
	}

	
	boolean handleMouseEnterActionMenu(int action) {
		
		//if there is no atoms, then there is nothing to highlight
		if(this.mol.natoms == 0) {
			return false;
		}
		
		String note = null;

		switch(action) {
			case ACTION_CLEAR:
				if(this.numberofMoleculeParts > 1) {
					note = "Delete selected molecule (red)";
				} else {
					note = "Clear canvas";
				}
				this.mol.forceUniColor(Color.RED);
				this.uniColorMolecule = this.mol;
				break;
			case ACTION_REACP:
				note = "Copy selected (blue) molecule to the other side of the reaction";
				this.mol.forceUniColor(Color.BLUE);
				this.uniColorMolecule = this.mol;
		
		}
		
		if(note!=null) {
			this.info(note);
		}
		
		
		return note != null || this.mustReDrawMolecularArea || this.mustReDrawTopMenu;
	}
	boolean handleMouseLeaveActionMenu(int action) {
		if(this.uniColorMolecule != null && (action == ACTION_CLEAR || (this.reaction && action == ACTION_REACP))) {

			this.uniColorMolecule.resetForceUniColor();
			this.mustReDrawMolecularArea = true;
			this.uniColorMolecule = null;
			for(int i = 1; i <= this.numberofMoleculeParts; i++) {
				this.moleculeParts[i].resetForceUniColor();
			}
			this.info("");

		}
		

		//this.mustReDrawTopMenu = true;

		return this.mustReDrawMolecularArea || this.mustReDrawTopMenu;
		
	}
	
	
	/*
	 * Save the current molecules to the change manager
	 */
	protected void postSave() {

		//Notifify the JavaScript world that my structure has changed
		/*
		switch(this.lastAction) {
		case LA_MOVE:
		case LA_ROTATE :
		case LA_FAILED :
			break;
		default:
			this.notifyStructuralChangeToJS();
		}
		*/

		if(!this.canMultipleUndo) {
			return;
		}

		//System.out.println("save state");
		SavedState state = this.createState();
		if(state != null) {
			this.molChangeManager.insertItem(state);
		}

	}

	/*
	 * Create a state to store the chemical state of the editor.
	 * Return null if there is nothing to save.
	 */
	protected SavedState createState() {
		SavedState state = new SavedState();

		state.actualMoleculePartIndex = actualMoleculePartIndex;
		state.numberofMoleculeParts = this.numberofMoleculeParts;
		boolean mustBeSaved = false;

		for(int i=1; i < JME.maxParts; i++) {
			JMEmol part = this.moleculeParts[i];
			if(part != null) {
				if(part.natoms > 0) {
					mustBeSaved = true;
				}
				state.moleculeParts[i] = part.deepCopy();
			} else {
				break;
			}
		}

		state.reaction = this.reaction;
		state.multipart = this.multipart;

		state.depictScale = this.depictScale;
		state.lastAction = this.lastAction;

		
		
		if(mustBeSaved) {
			return state;
		} else {
			return null;
		}
	}

	protected void retoreState(SavedState state) {
		basicRetoreState(state);



		//Notifify the JavaScript world that my structure has changed
		switch(state.lastAction) {
		case LA_MOVE:
		case LA_ROTATE :
		case LA_FAILED :
			break;
		default:
			this.notifyStructuralChangeToJS();
		}

	}

	protected void basicRetoreState(SavedState state) {

		this.actualMoleculePartIndex = state.actualMoleculePartIndex;
		this.numberofMoleculeParts = state.numberofMoleculeParts;

		for(int i=1; i < JME.maxParts; i++) {
			JMEmol part = state.moleculeParts[i];
			if(part != null) {
				this.moleculeParts[i] = part.deepCopy();
			} else {
				this.moleculeParts[i] = null;
			}
		}
		//issue: this can create a null mol
		if (state.actualMoleculePartIndex > 0) {
			this.mol = this.moleculeParts[actualMoleculePartIndex];
		} else {
			this.mol = new JMEmol(this); //avoid a null pointer, for state saved after a clear or reset
		}

		this.reaction = state.reaction;
		this.multipart = state.multipart;

		this.depictScale = state.depictScale;




	}

	public PopupMenu getCopyPastePopupMenuMol() {
		if(this.copyPastePopupMenuMol == null) {
			this.copyPastePopupMenuMol = this.createCopyPastePopupMenu(false);
		}
		return copyPastePopupMenuMol;
	}
	public PopupMenu getCopyPastePopupMenuReaction() {
		if(this.copyPastePopupMenuReaction == null) {
			this.copyPastePopupMenuReaction = this.createCopyPastePopupMenu(true);
		}
		return copyPastePopupMenuReaction;
	}

	//return true if event has been used
	public boolean handleCopyPastePopupMenu(Event e, int x, int y) {

		//detect mol and atom under the cursor: needed for tablet?

		
		if(e == null || this.isEventContextMenu(e)) {
			
			//Tablet: needed for touch screen because they cannot detect a mouse move
			//Does not work: the delay for the context menu is too long and is needed
//			if(isTouchSupported) {
//				findMolAndAtomOrBondInDrawingArea(x, y, newTouchedMol);
//				if(newTouchedMol.molIndex > 0) {
//					mol = this.moleculeParts[newTouchedMol.molIndex];
//					mol.touchedAtom = newTouchedMol.atomIndex;
//					mol.touchedBond = newTouchedMol.bondIndex;
//					
//				}
//
//			}
			
			boolean isTouched = mol.touchedAtom >0 || mol.touchedBond > 0;
			if(isTouched  && (action == ACTION_DELETE || action == ACTION_DELGROUP)) {
				return true; //true: do not use the context menu to delete atom or bond
			}
//			this.info("isTouched = " + isTouched);
//			repaint();
			
			if(isTouched && !depict) {
				//set shiral flag to the mol
				if(this.touchedMolPopuMenu != null) {
					this.remove(this.touchedMolPopuMenu);

				}
				touchedMolPopuMenu = this.createMolPopupMenu(mol, x, y);
				this.add(touchedMolPopuMenu); //set the parent the popup
				touchedMolPopuMenu.show(this, x, y);
				
			} else {
			
			
			
			
				if(reaction) {
					this.getCopyPastePopupMenuReaction().show(this, x, y);
				} else {
					this.getCopyPastePopupMenuMol().show(this, x, y);
				}
			
			
			}

			//the atom or bond highlight must disappear =-to be improved
			Event ne = new Event(null, 0, 0);
			this.mouseMove(ne, 0,0);
			
			return true;
		}
		return false;

	}

	public boolean isEventContextMenu(Event e) {
		boolean meta = e.metaDown(); //true if right mouse click
		boolean ctrl = e.controlDown() ; //Safari Mac

		return meta || ctrl ;

	}
	public PopupMenu getFunctionalGroupPopumemu() {
		if(this.functionalGroupPopumemu == null) {
			this.functionalGroupPopumemu = this.createFunctionalGroupPopumemu();
		}
		return this.functionalGroupPopumemu;
	}
	public PopupMenu createFunctionalGroupPopumemu() {

		PopupMenu popup = new PopupMenu();

		for(String eachFG: functionalGroups) {
			MenuItem mi = new MenuItem(eachFG);
			popup.add(mi);
			mi.setActionCommand(eachFG);
			mi.addActionListener(this);
		}
		//setSubstituent(r);


		this.add(popup); //set the parent the popup

		return popup;
	}

	/*
	 * Provide the ideal height of a string consisting of usual upper case characters.
	 * Purpose: centering of String in the center of a box.
	 * Does not work for $ , y ;  and others
	 */
	public int stringHeight(FontMetrics fm) {
		return fm.getAscent() - fm.getDescent();
		//return fm.getAscent();
	}

	//	public int stringHeight(FontMetrics fm, String text) {
	//		int h = stringHeight(fm);
	//		//Correction for a string that is only lower case - NO working : i is as high as a L
	//		if(text.equals(text.toLowerCase()) ) {
	//			h = h *2 /3;
	//		}
	//		return h;
	//	}



	/**
	 * 
	 * @return the notifyAtomHighLightJSfunction
	 */
	public String getNotifyAtomHighLightJSfunction() {
		return this.notifyAtomHighLightJSfunction;
	}
	/**
	 * Set the name of the JavaScript function that will be called each time the mouse move over an atom.
	 * To cancel, set to null.
	 * @param notifyAtomHighLightJSfunction
	 */
	public void setNotifyAtomHighLightChangeJSfunction(String notifyAtomHighLightJSfunction) {
		this.notifyAtomHighLightJSfunction = notifyAtomHighLightJSfunction;
	}

	/**
	 * Notify the JavaScript envirronement that the mouse over atom has changed
	 * @param touchedAtom 
	 */
	protected int previousTouchedAtomForHighlight = 0;
	protected int previousTouchedBondForHighlight = 0;
	protected int previousActualMoleculePartIndex = 0;
	
	
	/**
	 * return -1 if no action should be taken or the touchedAtomOrBond, which might have been set to 0
	 * in case the curssor has moved away from the atom or bond
	 * @param touchedAtomOrBond
	 * @param previousTouchedAtomOrBondForHighlight
	 * @return
	 */
	public int notifyAtomOrBondHighLightJSfunction(int touchedAtomOrBond, int previousTouchedAtomOrBondForHighlight) {
		//TODO: exception handling with JSException: this function will not work outside a web browser
			//send an event only if it is about a new atom
			//otherwise each small mouse move will send an event
			
			//case 1: cursor moved away from atom previous atom is not defined -> do nothing
			if(touchedAtomOrBond <=0 && previousTouchedAtomOrBondForHighlight == 0) {
				//System.out.println("case 1");
				return -1;
			}

			//case 2: cursor moved around the same atom -> do nothing
			if(touchedAtomOrBond == previousTouchedAtomOrBondForHighlight && this.actualMoleculePartIndex == previousActualMoleculePartIndex) {
				//System.out.println("case 2");

				return -1;
			}

			//case 3: cursor moved away from the atom that was highlighted - send 0 to the callback function
			// to notify that the atom has been deselected
			if(touchedAtomOrBond <=0 && previousTouchedAtomOrBondForHighlight > 0) {
				//System.out.println("case 3");
				touchedAtomOrBond = 0;
			}

			this.previousActualMoleculePartIndex = this.actualMoleculePartIndex;
			return touchedAtomOrBond;


	}
	public void notifyAtomHighLightJSfunction(int touchedAtom) {
		//TODO: exception handling with JSException: this function will not work outside a web browser
		if(this.canHandleAtomHighLightCallBack()) {
			touchedAtom = this.notifyAtomOrBondHighLightJSfunction(touchedAtom, this.previousTouchedAtomForHighlight);
			if(touchedAtom == -1) return;
			
			this.previousTouchedAtomForHighlight = touchedAtom;
			//do the function call - will work in a real Java applet
			if(this.notifyAtomHighLightJSfunction != null) {
				JSObject jsObject =  JSObject.getWindow(this);
				jsObject.call(this.notifyAtomHighLightJSfunction,
						new Integer[]{new Integer(this.actualMoleculePartIndex), new Integer(touchedAtom)});
			}
			//this is for the new callback mechanism - June 2015
			handleAtomHighLightCallBack(this.actualMoleculePartIndex, touchedAtom);

		}
	}
	
	public void notifyBondHighLightJSfunction(int touchedBond) {
		//TODO: exception handling with JSException: this function will not work outside a web browser
		if(this.canHandleBondHighLightCallBack()) {
			touchedBond = this.notifyAtomOrBondHighLightJSfunction(touchedBond, this.previousTouchedBondForHighlight);
			if(touchedBond == -1) return;
			this.previousTouchedBondForHighlight = touchedBond;

			//this is for the new callback mechanism - June 2015
			handleBondHighLightCallBack(this.actualMoleculePartIndex,  touchedBond);

		}
	}
	
	
	public Boolean canHandleAtomHighLightCallBack() {
		return this.notifyAtomHighLightJSfunction != null;
	}
	public Boolean canHandleBondHighLightCallBack() {
		return false;
	}

	
	public Boolean canHandleAtomClickedCallBack() {
		return false;
	}
	public Boolean canHandleBondClickedCallBack() {
		return false;
	}

	/**
	 */
	public void handleAtomClickedCallBack(int actualMoleculePartIndex, int clickedAtom)
	{
		/*do nothing */
	
	}
	public void handleBondClickedCallBack(int actualMoleculePartIndex, int clickedBond)
	{
		/*do nothing */
	
	}
	

	
	/**
	 * For subclasses
	 * @param actualMoleculePartIndex2
	 * @param touchedAtom
	 */
	public void handleAtomHighLightCallBack(int actualMoleculePartIndex, int touchedAtom)
	{
		/*do nothing */
	
	}
	/**
	 * For subclasses
	 * @param actualMoleculePartIndex2
	 * @param touchedBond
	 */
	public void handleBondHighLightCallBack(int actualMoleculePartIndex, int touchedBond)
	{
		/*do nothing */
	
	}

	
	/**
	 * 
	 * @param molIndex
	 * @param atomIndex
	 */
	public void setAtomToHighLight(int molIndex, int atomIndex) {
		JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);
		
		if(atomIndex < 1 || atomIndex> molToHighLight.natoms) {
			this.showError("invalid atom index: " + atomIndex);
			return;
		}
		molToHighLight.touchedAtom = atomIndex;
		this.redrawMoleculartAreaOnly();
		
		
	}
	
	public void changeAtomMap(int molIndex, int atomIndex, int newMap) {
		JMEmol mol = this.selectMolIfValidOrShowError(molIndex);
		mol.getAtom(atomIndex).setMap(newMap);
		this.recordAtomEvent(JME.CHANGE_ATOM_MAP,atomIndex);
		//this.setAtomToHighLight(molIndex, atomIndex);
		this.postSave();
		this.redrawMoleculartAreaOnly();

	}
	/**
	 * @return the notifyStructuralChangeJSfunction
	 */
	public String getNotifyStructuralChangeJSfunction() {
		return notifyStructuralChangeJSfunction;
	}

	/**
	 * @param notifyStructuralChangeJSfunction the notifyStructuralChangeJSfunction to set
	 */
	public void setNotifyStructuralChangeJSfunction(String notifyStructuralChangeJSfunction) {
		this.notifyStructuralChangeJSfunction = notifyStructuralChangeJSfunction;
	}

	/**
	 * Notify the JavaScript envirronement that the chemical structure has changed
	 */
	public void notifyStructuralChangeToJS() {
		//TODO: exception handling with JSException: this function will not work outside a web browser
		if(this.notifyStructuralChangeJSfunction != null) {
			JSObject jsObject =  JSObject.getWindow(this);
			jsObject.call(this.notifyStructuralChangeJSfunction, null);
		}
		
		//the 2nd implementation for JSME that uses event
		if(this.afterStructureChangeEvent  != null && this.afterStructureChangeEvent.action != null)
			this.handleAftertructureModifiedEvent(this.afterStructureChangeEvent);
	}

	
	public String getPrePasteJSfunction() {
		return prePasteJSfunction;
	}

	/**
	 * Set a JS function that will be called before the paste is performed. THis function will receive one argument: a string that a represent a molecular structure.
	 * The return value of the fuinction is a string.
	 * Purpose: convert a name or a SMILES or an InchI into a MOL.
	 * @param prePasteJSfunction
	 */
	public void setPrePasteJSfunction(String prePasteJSfunction) {
		this.prePasteJSfunction = prePasteJSfunction;
	}
	
	
	
	/**
	 * 
	 * @return the height in pixel of the bottom bar (info bar)
	 * = 0 in depict mode
	 */
	public int getInfoBarHeight() {
		return (int)this.menuCellSize;
	}
	
	/*
	 * 
	 * @return the height in pixel of the bottom bar (info bar)
	 * > 0  also in depict mode
	 */
	public int getDefaultInfoBarHeight() {
		return (int)this.standardMenuCellSize;
	}

	void redrawMoleculartAreaOnly() {
		this.mustRedrawNothing();
		this.mustReDrawMolecularArea = true;
		this.repaint();
		
	}

	
	
	/**
	 * 
	 * @param molIndex
	 * @param atomAndColorCSV : at,c,at,c,at,c, ... at: atom index; c: color index
	 * @param background : background of atoms or foreground
	 */
	public void setAtomColors(int molIndex, String atomAndColorCSV, boolean background) {
		
		//select the molecule to color
		JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);
		
		if(molToHighLight == null) {
			return;
		}
		
		//color its atoms according to the parameters
		molToHighLight.setAtomColors(atomAndColorCSV, background);
		
		//repaint
		this.redrawMoleculartAreaOnly();
	}

	/**
	 * Reset background atom colors
	 * @param molIndex
	 */
	public void resetAtomColors(int molIndex) {
		//select the molecule to decolor
		JMEmol selectedMol = this.selectMolIfValidOrShowError(molIndex);
		
		if(selectedMol == null) {
			return;
		}
		
		//
		selectedMol.resetAtomColors();
		
		//repaint
		this.redrawMoleculartAreaOnly();
		
		//clear the atom colrs from the option
		
	}
	/**
	 * Return the selected mol. If the index is not valid, show an error
	 * @param molIndex
	 * @return JMEmol
	 */
	protected JMEmol selectMolIfValidOrShowError(int molIndex) {
		this.info(""); //clear the info in case an error would occur
		if(molIndex < 1 || molIndex> this.numberofMoleculeParts) {
			this.showError("invalid mol index: " + molIndex);
			return null;
		}
		
		return this.moleculeParts[molIndex];

	}
	
	/**
	 * 
	 * @param action
	 * @param moleculePartIndex
	 * @param atomIndex
	 * @param bondIndex
	 */
	protected void recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex, int bondIndex) {
		if(this.afterStructureChangeEvent != null) {
			this.afterStructureChangeEvent.setAction(action).setAtomAndBondAndMol(atomIndex, bondIndex, moleculePartIndex);
		}
		this.notifyStructuralChangeToJS();


	}
	protected void recordMoleculePartEvent(String action, int moleculePartIndex) {
		this.recordAfterStructureChangedEvent(action, moleculePartIndex, 0,0);

	}
	
	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * @param action
	 */
	protected void recordAtomEvent(String action) {
		this.recordAtomEvent(action, this.mol.touchedAtom);

	}
	protected void recordAtomEventAndPostSave(String action) {
		this.recordAtomEvent(action, this.mol.touchedAtom);
		this.postSave();

	}
	protected void recordAtomEvent(String action, int atom) {
		this.recordAfterStructureChangedEvent(action, this.actualMoleculePartIndex, atom, 0);

	}
	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * @param action
	 */
	protected void recordBondEvent(String action) {
		this.recordAfterStructureChangedEvent(action, this.actualMoleculePartIndex, 0, this.mol.touchedBond);

	}

	protected void recordAfterStructureChangedEvent(String action) {
		this.recordAfterStructureChangedEvent(action, 0,0,0);

	}
	
	/*TODO WHy argument here?*/
	protected void handleAftertructureModifiedEvent(JMEevent afterStructureChangeEvent) {
		//clear the event after it has been used
		//(afterStructureChangeEvent != null)
		//fterStructureChangeEvent.reset(); //not needed anymore because  of using recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex, int bondIndex) 
		
		//subclass do something more
	}
	
	
	
	
	
	/**
	 * 
	 * @return true if the editor is in depict mode
	 */
	public boolean isDepictMode() {
		return this.depict;
	}


} //End of JME class




























































// ****************************************************************************
// The goal is to save the location of the window for the next instantiation




@SuppressWarnings("serial")
class FrameWithLocation extends Frame {
	protected Point lastLocation;
	protected Button closeButton;

	public FrameWithLocation(String title) {
		super(title);
		initialize();
	}
	public FrameWithLocation() {
		super();
		initialize();
	}



	public String closeButtonLabel() {
		return "Close";
	}

	public void initialize() {
		this.closeButton = new Button(this.closeButtonLabel());

		// Add a window listener JDK 1.1 for closing the window using the X button of the window
		this.addWindowListener ( new WindowAdapter () {
			public void windowClosing ( WindowEvent evt )
			{
				hide();
			}
		});

	}
	@Override
	public void hide() {
		if(this.isShowing()) {
			Point currentLocation = this.getLocationOnScreen();
			lastLocation.setLocation(currentLocation);
		}
		//Idea: record the delta position relative to the applet instead of the absolute position

		super.hide();
	}

	public void disposeIfShowing() {
		if(this.isShowing()) {
			this.dispose(); //will call hide()
		}
	}
	@Override
	public void show() {
		this.setLocation(this.lastLocation);
		super.show();
	}


	// ----------------------------------------------------------------------------
	@Override
	public boolean action(Event e, Object arg) {
		if(e.target == this.closeButton) {
			this.hide();
			return true;
		}
		return this.customAction(e, arg); //for the queryBox


		/*
		 * else if ("Submit".equals(arg)) {
		 * jme.readSmiles(smilesText.getText()); }
		 */
	}
	public boolean customAction(Event e, Object arg) {
		return false;
	}

	//avoid a x < 0 or y <
	public void safeTranslate(Point location, int deltaX, int deltaY) {
		location.translate(deltaX, deltaY);
		location.x = location.x <0?0:location.x;
		location.y = location.y <0?0:location.y;

	}


}
//****************************************************************************
// show an alert box centered near the center of the source
//mimic the Javascript alert()( function
@SuppressWarnings("serial")
class AlertBox extends FrameWithLocation {

	//the source can be the applet
	public AlertBox(String msg, Component source, Color backgroundColor) {
		super();

		setResizable(false);

		this.setLayout(new GridLayout(0, 1, 0, 0));

		Label label = new Label(msg,Label.CENTER);
		this.add(label);

		//an extra panel is needed, otherwise the button will be as wide as the frame
		Panel p = new Panel();
		p.add(this.closeButton);
		this.add(p);


		if(source != null) {
			// center the window on top of the source

			this.lastLocation = source.getLocationOnScreen();
			this.pack(); //the translation must be done after the pack() otherwise the size of the window (myself) is not known (=0)

			this.safeTranslate(this.lastLocation, source.getWidth()/2 - this.getWidth()/2, source.getHeight()/2 - this.getHeight()/2);
		}
		if(backgroundColor != null) {
			setBackground(backgroundColor);
		}

	}

	@Override
	public String closeButtonLabel() {
		return "OK";
	}


}

//****************************************************************************
@SuppressWarnings("serial")
class MultiBox extends FrameWithLocation {
	//	static Point aboutBoxPoint = new Point(500, 10);
	//	static Point smilesBoxPoint = new Point(200, 50);
	//	static Point atomxBoxPoint = new Point(150, 420);
	Point aboutBoxPoint ;
	Point smilesBoxPoint ;
	Point atomxBoxPoint ;
	static TextField atomicSymbol = new TextField("H"); // pouziva sa v JME
	Button helpButton = new Button("Help");
	Button homeButton = new Button("Home");

	TextField smilesText;
	JME jme; // parent of MultiBox
	// ----------------------------------------------------------------------------

	/**
	 * 
	 * @param box : 1 is for smiles , 2 for X and 3 for about
	 * @param jme
	 */
	MultiBox(int box, JME jme) {
		super();
		this.jme = jme;

		//BB It is not necesssary to specify a font, the default one looks good - not true - Helevetica looks beter because it is correclty centered
		if(jme.dialogFont != null) {
			setFont(jme.dialogFont);
		}
		setBackground(JME.bgColor);
		setResizable(false);

		//setup the first position of dialog box close to the applet
		Point jmeLocation = jme.getLocationOnScreen();
		//System.out.println(jmeLocation);

		if (box == 1) {
			//BB
			if(smilesBoxPoint == null) {
				smilesBoxPoint = new Point(jmeLocation);
				this.safeTranslate(smilesBoxPoint, -30, 0) ; //above  the applet,close to the smiley
			}
			this.lastLocation = smilesBoxPoint;
			initSmilesBox(jme.Smiles());
		}
		else if (box == 2) {
			//BB
			if(atomxBoxPoint == null) {
				//BB
				atomxBoxPoint = new Point(jmeLocation);
				this.safeTranslate(atomxBoxPoint, -50, (int)jme.menuCellSize * 13 -80) ; //left side of the atom X menu cell
			}
			this.lastLocation = atomxBoxPoint;
			initAtomxBox();
		}
		else {
			//BB
			if(aboutBoxPoint == null) {
				aboutBoxPoint = new Point(jmeLocation);
				this.safeTranslate(aboutBoxPoint, (int)jme.menuCellSize * 5, 0) ; //right side next to the info menu cell
			}
			initAboutBox();
			this.lastLocation = aboutBoxPoint;
		}



		pack();
		show();
	}



	// ----------------------------------------------------------------------------
	void initAboutBox() {
		setTitle("About " + JME.programName);
		setLayout(new GridLayout(0, 1, 0, 0));
		//setFont(jme.fontSmall); //BB not needed - done in the constructor
		setBackground(JME.bgColor);
		add(new Label(JME.programName +" Molecular Editor" + " v" + JME.version,
				Label.CENTER));
		add(new Label("Peter Ertl and Bruno Bienfait", Label.CENTER));
		// add(new Label("peter.ertl@novartis.com",Label.CENTER));
		// add(new Label("HomePage: www.molinspiration.com/jme/",Label.CENTER));


		for(String cl : JME.copyright) {
			Label l = new Label(cl, Label.CENTER);
			l.setFont(jme.copyRigthSmallTextFont);
			add(l);
		}

		
		Panel p = new Panel();

		//Home button

		
		//Online help button: open a HTML page that contains help for end users

		p.add(helpButton);

		//not implemented yet
		//		helpButton.addActionListener(new ActionListener() {
		//
		//			@Override
		//			public void actionPerformed(ActionEvent e) {
		//				//System.out.println("help");
		//				try{
		//					AppletContext a = MultiBox.this.jme.getAppletContext();
		//					URL u = new URL(MultiBox.this.jme.helpUrl);
		//					a.showDocument(u,"_self");
		//				}
		//				catch (MalformedURLException urlException){
		//					System.out.println(urlException.getMessage());
		//					MultiBox.this.jme.showError(urlException.getMessage());
		//				}				
		//			}
		//		});
		p.add(this.closeButton);
		add(p);
		//setLocation(aboutBoxPoint);
	}

	// ----------------------------------------------------------------------------
	void initSmilesBox(String smiles) {
		setTitle("SMILES");
		setLayout(new BorderLayout(2, 0)); // 2, 0 gaps
		smilesText = new TextField(smiles + "     ");
		if (!jme.runsmi) {
			//the textfield cannot be copied in JS when the setEditable is set to false
			//smilesText.setEditable(false);
		}
		add("Center", smilesText);
		Panel p = new Panel();
		p.add(this.closeButton);
		if (jme.runsmi) {
			Button b = new Button("Submit");
			p.add(b);
		}
		add("South", p);

		//this.setSmiles(smilesText.getText().trim()); //BB : to size the SMILES box correctly - does not work
		//this.setMaximumSize(new Dimension(330, 200)); //BB does not work
		smilesText.setText(smilesText.getText().trim()); // odstrani "      "
		setResizable(true);
	}

	// ----------------------------------------------------------------------------
	// sets smiles in smiles box a aj upravi dlzku
	//BB: resize does not work
	void setSmiles(String smiles) {
		Dimension d = size();
		int l = jme.menuCellFontSmallerMet.stringWidth(smiles) + 50;
		if (l < 150)
			l = 150;
		//BB : avoid huge dialog box that does not fit the screen
		if(l>400)
			l =400;

		validate();
		this.resize(l, d.height);
		smilesText.setText(smiles);
	}

	// ----------------------------------------------------------------------------
	void initAtomxBox() {
		setTitle("Nonstandard atom");
		setLayout(new BorderLayout(2, 0)); // 2, 0 gaps
		Panel p = new Panel();
		p.add(new Label("atomic SMILES", Label.CENTER));
		add("North", p);
		// 2007.01 fixed bug - frozen xbutton
		String as = "H";
		if (atomicSymbol != null)
			as = atomicSymbol.getText();
		atomicSymbol = new TextField(as, 8);
		add("Center", atomicSymbol);
		p = new Panel();
		p.add(this.closeButton);
		add("South", p);
	}


	// ----------------------------------------------------------------------------
	public boolean keyDown(Event e, int key) {
		// v JME menu nastavi na X (ak bolo medzitym ine) ak tukane zo atomxBox
		if (atomicSymbol == null)
			return false; // nie null iba v atomxBox
		// vracia false, lebo potom by sa nedalo pisat napr v smilesBox
		if (jme.action != JME.ACTION_AN_X) {
			jme.action = JME.ACTION_AN_X;
			jme.active_an = JME.AN_X; // treba
		}
		// JME.repaint(); //can't make static reference ... kvoli ocierneniu X
		return false; // inak sa nedaju pisat pismena do text boxu
	}
	// ----------------------------------------------------------------------------
	@Override
	public boolean customAction(Event e, Object arg) {
		if(e.target == this.helpButton) {
			try{
				AppletContext a = MultiBox.this.jme.getAppletContext();
				URL u = new URL(MultiBox.this.jme.helpUrl);
				a.showDocument(u);
				//a.showDocument(u, "_blank"); //don'use _target
			}
			catch (MalformedURLException urlException){
				//System.out.println(urlException.getMessage());
				MultiBox.this.jme.showError(urlException.getMessage());
			}
			return true;
		}
		return false;
	}

}

// ****************************************************************************
@SuppressWarnings("serial")
class QueryBox extends FrameWithLocation {
	//static Point point = new Point(20, 200);
	Point myLocation;
	TextField text;
	static Button c, n, o, s, p, f, cl, br, i, any, anyec, halogen, aromatic,
	nonaromatic, ring, nonring;
	static Button anyBond, aromaticBond, ringBond, nonringBond, sdBond;
	static Choice choiced, choiceh;
	Color bgc = JME.bgColor;
	boolean isBondQuery = false;
	JME jme; // reference to parent
	// --- buttony etc su definovane ako static aby sa zachovala ich hodnota po
	// novom stlacenie QRY (aby sa window dostalo hore)
	// ----------------------------------------------------------------------------

	QueryBox(JME jme) {
		super("Atom/Bond Query");
		this.jme = jme;

		//BB
		if(myLocation == null) {
			//setup the first position of dialog box close to the applet
			Point jmeLocation = jme.getLocationOnScreen();
			myLocation = new Point(jmeLocation);
			this.safeTranslate(myLocation, -150, 10);


		}
		this.lastLocation = myLocation;

		setLayout(new GridLayout(0, 1));

		//BB It is not necesssary to specify a font, the default one looks good
		if(jme.dialogFont != null) {
			setFont(jme.dialogFont);
		}
		setBackground(bgc);

		Panel p1 = new Panel();
		p1.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		p1.add(new Label("Atom type :"));

		// boolean first = (any == null); // caused problems
		boolean first = true;

		if (first) {
			any = new Button("Any");
			anyec = new Button("Any except C");
			halogen = new Button("Halogen");
		}
		p1.add(any);
		p1.add(anyec);
		p1.add(halogen);
		add(p1);

		Panel p2 = new Panel();
		p2.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		p2.add(new Label("Or select one or more from the list :", Label.LEFT));
		add(p2);

		Panel p3 = new Panel();
		// p3.setLayout(new GridLayout(1,0));
		p3.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		if (first) {
			c = new Button("C");
			n = new Button("N");
			o = new Button("O");
			s = new Button("S");
			p = new Button("P");
			f = new Button("F");
			cl = new Button("Cl");
			br = new Button("Br");
			i = new Button("I");
		}
		p3.add(c);
		p3.add(n);
		p3.add(o);
		p3.add(s);
		p3.add(p);
		p3.add(f);
		p3.add(cl);
		p3.add(br);
		p3.add(i);
		add(p3);

		Panel p4 = new Panel();
		p4.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		if (first) {
			choiceh = new Choice();
			choiceh.addItem("Any");
			choiceh.addItem("0");
			choiceh.addItem("1");
			choiceh.addItem("2");
			choiceh.addItem("3");
		}
		p4.add(new Label("Number of hydrogens :  "));
		p4.add(choiceh);
		add(p4);

		Panel p5 = new Panel();
		p5.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		if (first) {
			choiced = new Choice();
			choiced.addItem("Any");
			choiced.addItem("0");
			choiced.addItem("1");
			choiced.addItem("2");
			choiced.addItem("3");
			choiced.addItem("4");
			choiced.addItem("5");
			choiced.addItem("6");
		}

		p5.add(new Label("Number of connections :", Label.LEFT));
		p5.add(choiced);
		p5.add(new Label(" (H's don't count.)", Label.LEFT));
		add(p5);

		Panel p6 = new Panel();
		p6.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		p6.add(new Label("Atom is :"));
		if (first)
			aromatic = new Button("Aromatic");
		p6.add(aromatic);
		if (first)
			nonaromatic = new Button("Nonaromatic");
		p6.add(nonaromatic);
		if (first)
			ring = new Button("Ring");
		p6.add(ring);
		if (first)
			nonring = new Button("Nonring");
		p6.add(nonring);
		add(p6);

		Panel p9 = new Panel();
		p9.setBackground(getBackground().darker());
		p9.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		p9.add(new Label("Bond is :"));
		if (first)
			anyBond = new Button("Any");
		p9.add(anyBond);
		if (first)
			aromaticBond = new Button("Aromatic");
		p9.add(aromaticBond);
		// if (first) sdBond = new Button("- or ="); p9.add(sdBond);
		if (first)
			ringBond = new Button("Ring");
		p9.add(ringBond);
		if (first)
			nonringBond = new Button("Nonring");
		p9.add(nonringBond);
		add(p9);

		Panel p8 = new Panel();
		p8.setLayout(new FlowLayout(FlowLayout.CENTER, 3, 1));
		// p8.add(new Label("Query :"));
		if (first)
			text = new TextField("*", 20);
		p8.add(text);
		p8.add(new Button("Reset"));
		p8.add(this.closeButton);
		add(p8);
		setResizable(false);

		if (first) { // musi sa to explicitne, inak nemaju vsetky bgc
			resetAtomList();
			resetAtomType();
			resetBondType();
			aromatic.setBackground(bgc);
			nonaromatic.setBackground(bgc);
			ring.setBackground(bgc);
			nonring.setBackground(bgc);
			choiceh.setBackground(bgc);
			choiced.setBackground(bgc);
			changeColor(any);
		}




		pack();
		show();
	}

	// ----------------------------------------------------------------------------
	@Override
	public boolean customAction(Event e, Object arg) {

		if (arg.equals("Reset")) {
			resetAll();
			changeColor(any); // Any on
			doSmarts();
		} else if (e.target instanceof Button) {
			resetBondType(); // set to any ???
			if (e.target == any) {
				resetAtomList();
				resetAtomType();
			} else if (e.target == anyec) {
				resetAtomList();
				resetAtomType();
			} else if (e.target == halogen) {
				resetAtomList();
				resetAtomType();
			} else if (e.target == ring) {
				nonring.setBackground(bgc);
			} else if (e.target == nonring) {
				ring.setBackground(bgc);
				aromatic.setBackground(bgc);
			} else if (e.target == aromatic) {
				nonaromatic.setBackground(bgc);
				nonring.setBackground(bgc);
			} else if (e.target == nonaromatic) {
				aromatic.setBackground(bgc);
			} else if (e.target == anyBond || e.target == aromaticBond
					|| e.target == ringBond || e.target == nonringBond) {
				resetAll();
				isBondQuery = true;
			} else { // atom z listu pressed (moze by aj posledny vynulovany
				resetAtomType();
			}
			changeColor((Button) (e.target));
			doSmarts();
		} else if (e.target instanceof Choice) {
			resetBondType();
			Choice choice = (Choice) (e.target);
			if (choice.getSelectedIndex() == 0)
				choice.setBackground(bgc);
			else
				choice.setBackground(Color.orange);
			doSmarts();
		}

		// v JME menu nastavi na query (ak bolo medzitym ine)
		if (jme.action != JME.ACTION_QRY) {
			jme.action = JME.ACTION_QRY;
			jme.repaint();
		}

		return true;
	}

	// ----------------------------------------------------------------------------
	private void resetAll() {
		resetAtomList();
		resetAtomType();
		choiceh.select(0);
		choiced.select(0);
		aromatic.setBackground(bgc);
		nonaromatic.setBackground(bgc);
		ring.setBackground(bgc);
		nonring.setBackground(bgc);
		choiceh.setBackground(bgc);
		choiced.setBackground(bgc);
		resetBondType(); // also sets isBondQuery to false

	}

	// ----------------------------------------------------------------------------
	private void resetAtomList() {
		c.setBackground(bgc);
		n.setBackground(bgc);
		o.setBackground(bgc);
		s.setBackground(bgc);
		p.setBackground(bgc);
		f.setBackground(bgc);
		cl.setBackground(bgc);
		br.setBackground(bgc);
		i.setBackground(bgc);
	}

	// ----------------------------------------------------------------------------
	private void resetAtomType() {
		any.setBackground(bgc);
		anyec.setBackground(bgc);
		halogen.setBackground(bgc);
	}

	// ----------------------------------------------------------------------------
	private void resetBondType() {
		anyBond.setBackground(bgc);
		aromaticBond.setBackground(bgc);
		// sdBond.setBackground(bgc);
		ringBond.setBackground(bgc);
		nonringBond.setBackground(bgc);
		isBondQuery = false;
	}

	// ----------------------------------------------------------------------------
	private void changeColor(Button b) {
		if (b.getBackground() == bgc)
			b.setBackground(Color.orange);
		else
			b.setBackground(bgc);
	}

	// ----------------------------------------------------------------------------
	private void doSmarts() {
		String smarts = "";
		boolean showaA = false;

		// basic atom type
		if (any.getBackground() != bgc) {
			smarts = "*";
			showaA = true;
		} else if (anyec.getBackground() != bgc) {
			smarts = "!#6";
			showaA = true;
		} else if (halogen.getBackground() != bgc) {
			f.setBackground(Color.orange);
			cl.setBackground(Color.orange);
			br.setBackground(Color.orange);
			i.setBackground(Color.orange);
			smarts = "F,Cl,Br,I";
		} else {
			boolean ar = aromatic.getBackground() != bgc;
			boolean nar = nonaromatic.getBackground() != bgc;
			if (c.getBackground() != bgc) {
				if (ar)
					smarts += "c,";
				else if (nar)
					smarts += "C,";
				else
					smarts += "#6,";
			}
			if (n.getBackground() != bgc) {
				if (ar)
					smarts += "n,";
				else if (nar)
					smarts += "N,";
				else
					smarts += "#7,";
			}
			if (o.getBackground() != bgc) {
				if (ar)
					smarts += "o,";
				else if (nar)
					smarts += "O,";
				else
					smarts += "#8,";
			}
			if (s.getBackground() != bgc) {
				if (ar)
					smarts += "s,";
				else if (nar)
					smarts += "S,";
				else
					smarts += "#16,";
			}
			if (p.getBackground() != bgc) {
				if (ar)
					smarts += "p,";
				else if (nar)
					smarts += "P,";
				else
					smarts += "#15,";
			}
			if (f.getBackground() != bgc)
				smarts += "F,";
			if (cl.getBackground() != bgc)
				smarts += "Cl,";
			if (br.getBackground() != bgc)
				smarts += "Br,";
			if (i.getBackground() != bgc)
				smarts += "I,";
			// if (h.getBackground() != bgc) smarts += "H,";
			if (smarts.endsWith(","))
				smarts = smarts.substring(0, smarts.length() - 1);
			if (smarts.length() < 1 && !isBondQuery) { // napr pri vynulovani
				// listu
				if (ar)
					smarts = "a";
				else if (nar)
					smarts = "A";
				else {
					any.setBackground(Color.orange);
					smarts = "*";
				}
			}
		}

		// atomic properties
		String ap = "";
		if (showaA && aromatic.getBackground() != bgc)
			ap += ";a";
		if (showaA && nonaromatic.getBackground() != bgc)
			ap += ";A";
		if (ring.getBackground() != bgc)
			ap += ";R";
		if (nonring.getBackground() != bgc)
			ap += ";!R";
		// zjednodusenie (mieso *;r len r ...)
		if (any.getBackground() != bgc && ap.length() > 0)
			smarts = ap.substring(1, ap.length());
		else
			smarts += ap;

		// hydrogens and number of bonds
		int nh = choiceh.getSelectedIndex();
		if (nh > 0) {
			nh--;
			smarts += ";H" + nh;
		}
		int nd = choiced.getSelectedIndex();
		if (nd > 0) {
			nd--;
			smarts += ";D" + nd;
		}

		// bond type
		if (anyBond.getBackground() != bgc)
			smarts = "~";
		if (aromaticBond.getBackground() != bgc)
			smarts = ":";
		// if (sdBond.getBackground() != bgc) smarts = "-,=";
		if (ringBond.getBackground() != bgc)
			smarts = "@";
		if (nonringBond.getBackground() != bgc)
			smarts = "!@";

		text.setText(smarts);
	}

	// --------------------------------------------------------------------------
	boolean isBondQuery() {
		return isBondQuery;
	}

	// --------------------------------------------------------------------------
	String getSmarts() {
		return text.getText();
	}
	// --------------------------------------------------------------------------


}
// ****************************************************************************

class InspectorEvent implements ActionListener {
	JMEmol mol;
	int atomIndex;
	int bondIndex;
	int molIndex;
	int x;
	int y;
	JME jme;
	
	//reuse the same atomInspector each time
	AtomInspector  atomInspector;
	
	public InspectorEvent(JME jme) {
		this.jme = jme;
	}

	public void reset() {
		mol = null;
		molIndex=atomIndex = bondIndex = x = y = 0;
	}

	public int getAtomMap() {
		return mol.getAtom(atomIndex).getMap();
	}
	@Override
	public void actionPerformed(final ActionEvent e) {

		GWT.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				if(e.getActionCommand() == JME.inspectAtomAction) {
					if(InspectorEvent.this.atomInspector == null) {
						InspectorEvent.this.atomInspector = new AtomInspector();
					}
					
					InspectorEvent.this.atomInspector.action(InspectorEvent.this);
				}
				
			}
			
			
		});

	}
	
	public void changeAtomMap(int newMap) {
		this.jme.changeAtomMap(this.molIndex, this.atomIndex, newMap);
	}

	public void reportError(String message) {
		this.jme.showError(message);
		
	}
	
}


/**
 * Dialog box to set the atom map of the atom - later other properties
 * @author bruno
 *
 */
class AtomInspector  {
	Dialog modalDialog;
	ActionListener actionListener;
	TextField atomicMapField;
	private InspectorEvent inspectorEvent;
	
	@SuppressWarnings("serial")
	public AtomInspector() {
		// Create an OK button
		final Button ok = new Button ("OK");
		Button cancel = new Button("Cancel");
		atomicMapField = new TextField("0", 4);

//		actionListener = new  ActionListener()
//		{
//			public void actionPerformed( ActionEvent e )
//			{
//				// Hide dialog
//				modalDialog.setVisible(false);
//				if(e.getSource() == ok) {
//					//make the changes
//					//System.out.println("Here: " + atomicMapField.getText());
//					try {
//						int newMap = Integer.parseInt(atomicMapField.getText());
//						inspectorEvent.changeAtomMap(newMap);
//
//					} catch (NumberFormatException exception) {
//						inspectorEvent.reportError("invalid atom map");
//					}
//				}
//			}
//		};
		// Create a modal dialog

		
		//parent : should be the applet window
		Frame window = new Frame();

		modalDialog = new Dialog(window) {
			@Override
			public boolean action(Event e, Object arg) {
				this.setVisible(false);
				if(e.target == ok) {
					//make the changes
					//System.out.println("Here: " + atomicMapField.getText());
					try {
						int newMap = Integer.parseInt(atomicMapField.getText());
						inspectorEvent.changeAtomMap(newMap);

					} catch (NumberFormatException exception) {
						inspectorEvent.reportError("invalid atom map");
					}
				}
				
				return true;
			}
			
		};
		modalDialog.setModal(true);
		// Use a flow layout
		modalDialog.setLayout( new FlowLayout() );

		// action listener is not implemented in JSapplet
//		ok.addActionListener( actionListener );
//		
//		cancel.addActionListener( actionListener );

		modalDialog.add( new Label ("New atom map"));
		modalDialog.add( ok );
		modalDialog.add( cancel );

		
		modalDialog.setLayout(new BorderLayout(2, 0)); // 2, 0 gaps
		
		Panel p = new Panel();

		p.add(new Label("atom map", Label.CENTER));
		p.add(atomicMapField);
		modalDialog.add("North", p);

		
		p = new Panel();
		p.add(ok);
		p.add(cancel);
		
		modalDialog.add("South", p);

		// Add a window listener JDK 1.1 for closing the window using the X button of the window
		modalDialog.addWindowListener ( new WindowAdapter () {
			public void windowClosing ( WindowEvent evt )
			{
				modalDialog.setVisible(false);
			}
		});


	}

	
	public void action(InspectorEvent event) {
		if(event.atomIndex > 0) {
			this.inspectorEvent = event;
			String title = "Atom " + event.atomIndex;
			modalDialog.setTitle(title);
			atomicMapField.setText("" + event.getAtomMap());
			
			//FIXME: does not work in JavaScript
			modalDialog.setLocation(event.x, event.y);
			
			//recompute the layount
			modalDialog.pack();
	
			// Show dialog
			modalDialog.setVisible(true);
	
		}
		
	}
	
}