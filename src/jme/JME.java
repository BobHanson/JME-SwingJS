/***
 * 
 * 
 * 
 * 
 * 
 */

package jme;

// BH 2023.01.15:
// - moved OCL-dependent methods to OclParser implements Parser
//   -- these are generated by reflection, so a subclass could change that 
// - switched to Swing
//   -- changes java.applet.Applet (deprecated) to JPanel, so JFrame required (but in SwingJS this can be embedded in a div)
//   -- changes Button to JButton, Choice to JComboBox, etc.
//   -- no bypassing simple paints -- just paint everything, since Swing will manage painting itself.
// - corrected missing dimension "2D" in MOL V2000 and V3000 writers.

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Event;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.util.NoSuchElementException;
import java.util.Vector;
import java.util.regex.Pattern;

import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;

import jme.JMEUtil.GWT;

import jme.JMEUtil.JSME_RunAsyncCallback;
import jme.JMEUtil.RunAsyncCallback;
import jme.JMEUtil.RunWhenDataReadyCallback;
import jme.Box.Axis;
import jme.ChemicalFormatDetector.MajorChemicalFormat;
import jme.ColorManager.ColorInfo;
import jme.JMEmol.ReactionRole;
import jme.JMEmolList.MolFileOrRxnParameters;
import jme.MoleculeHandlingParameters.HydrogenHandlingParameters;
import jme.TextTransfer.PasteAction;

// ----------------------------------------------------------------------------
// ****************************************************************************
@SuppressWarnings("serial")
public class JME extends JPanel implements ActionListener, MouseWheelListener
, MouseListener, KeyListener, MouseMotionListener
/* , MouseListener */, PropertyChangeListener {


	protected String parserImpl = "jme.OclParser";

	protected static final String OCL_ID_CODE_LABEL = "OCL ID code" /* + " to the clipboard" */;
	private static final String UN_MARK_ATOM = "unMarkAtom";
	private static final String MARK_ATOM = "markAtom";
	private static final String ADD_ATOM_QUERY = "addAtomQuery";
	private static final String CHARGE_ATOM_MINUS = "chargeAtom-";
	private static final String CHARGE_ATOM_PLUS = "chargeAtom+";
	private static final String CHARGE_ATOM0 = "chargeAtom0";
	private static final String DEL_ATOM2 = "delAtom";
	private static final String SET_ATOM = "setAtom";
	private static final String DEL_BOND2 = "delBond";
	private static final String DEL_ATOM = JME.DEL_ATOM2;
//	private static final String MARK = "mark";
	private static final String AUTO_NUMBER = "autonumber";
	private static final String SD_FSTACK = "SDFstack";
	private static final String REDO = "redo";
	private static final String UNDO = "undo";
	private static final String READ_MOL_FILE = "readMolFile";
	private static final String READ_RXN_FILE = "readRXNFile";
	private static final String READ_JME = "readJME";
	private static final String READ_SMILES = "readSMILES";
	private static final String READ_SMIRKS = "readSMIRKS";
	private static final String READ_OCLCODE = "readOCLCode";
	private static final String READ_MULTI_SDF = "readMultiSDF";

	private static final String CLEAR = "clear";
	private static final String RESET = "reset";

	/* for recording events to external program */
	private static final String ADD_GROUP = "addGroup";
	private static final String ADD_TEMPLATE = "addTemplate";
	private static final String ADD_ATOM = "addAtom";
	private static final String ADD_RING = "addRing";
	private static final String ADD_BOND = "addBond";
	private static final String ADD_CHAIN = "addChain";
	private static final String UN_MARK_BOND = "unMarkBond";
	private static final String MARK_BOND = "markBond";
	private static final String SET_QUERY_BOND = "setQueryBond";
	private static final String ADD_RING_BOND = "addRingBond";
	private static final String SET_BOND_TRIPLE = "setBondTriple";
	private static final String SET_BOND_SINGLE = "setBondSingle";
	private static final String SET_BOND_COORDINATION = "setBondCoordination";
	private static final String UNSET_BOND_COORDINATION = "unSetBondCoordination";
	private static final String SET_BOND_DOUBLE = "setBondDouble";
	private static final String SET_BOND_STEREO = "setBondStereo";
	private static final String DEL_BOND_GROUP = "delBondGroup";
	private static final String DEL_BOND = JME.DEL_BOND2;

	private static final String MOVE_ATOM = "moveAtom";
	private static final String CHANGE_CHIRAL = "changeChiral";
	static final String CHANGE_ATOM_MAP = "changeAtomMap";
	static final String CHANGE_MANY_ATOM_MAP = "changeManyAtomMap";
	static final String DELETE_HYDROGENS = "deleteHydrogens";
	static final String COMPUTE_2D = "compute2D";
	static final String DELETE_ATOM_MAPS = "deleteAtomMaps";

	protected static final String SET_ATOM_ADDITIONAL_DATA = "setAtomAdditionalData";
	protected static final String SET_BOND_ADDITIONAL_DATA = "setBondAdditionalData";

	static final String CHANGE_REACTION_ROLE = "changeReactionRole";
	private static final String REACTION_COPY = "reactionCopy";

	// editor state
	int action;

	TouchedMol lastTouchedMol = new TouchedMol();

	TouchedMol newTouchedMol = new TouchedMol();

	int reactionParts[][]; // computed with getReactionParts()

	int active_an;
	static boolean isStandAloneApplication = false; // by default the program starts as an applet
	// static String separator =
	// System.getProperties().getProperty("line.separator");
	static String separator = "\n";

	// customization
	static final String version = "2014-06-28";
	// static final String startInfoText = "JSME Molecular Editor by Peter Ertl and
	// Bruno Bienfait";
	static final String startInfoText = "Molecular Editor by Peter Ertl and Bruno Bienfait"; // JSME or JME selected
																								// according to the run
																								// time environment
	static final String copyright[] = {
			"Copyright (c) 2014-2023, Peter Ertl, Bruno Bienfait, and Robert Hanson.",
			"All rights reserved." };
	// Note: the copyright is too long for the info()
	int copyRigthmallTextFontSize = 8; // used in the info box for copyright
	Font copyRigthSmallTextFont = new Font(null, 0, copyRigthmallTextFontSize);

	//public String helpUrl = "http://peter-ertl.com/jsme/2013_03/help.html";
	public String helpUrl = "https://jsme-editor.github.io/help.html";
	public String websiteUrl = "https://jsme-editor.github.io/";

	protected String infoText = null;
	String customDefaultInfoText = ""; // may be changed by the JS call

	// BB: renamed sd to a more meaningful name
	// int sd = 24;
	final double standardMenuCellSize = 24; // the original value
	double menuCellSize = standardMenuCellSize; // should be a multiple of 2 and 3, is set 0 in depict mode
	boolean newLook = false;

	final double rightBorderNewLook = 1.0;
	final double rightBorderOldLook = 3; // older look needs more space because of it has a shadow

	int arrowWidth = 24 * 2;
	ReactionArrow reactionArrow = new ReactionArrow(36* 2);

	// the IO triangle/arrows
	double ioMargin = 3;
	double ioArrowWidth = ((double) (menuCellSize - 2 * ioMargin) / 1.5);

	// in depict mode, make the DnD and full screen icons smaller
	double smallerIconsForDepictMode = 0.6;

	Color bgColor = Color.lightGray;
	Color brightColor = bgColor.brighter();
	Color leftMenuAtomColor = null;

	
	public static enum SupportedFileFormat {
		JME, SMILES, MOL, MOL_V3000, INCHI, INCHI_KEY, INCHI_AUXINFO, INCHI_JSON, OCLCODE,
		 SVG, RAW_STRING_GRAPHIC
	}
	// should extend CopyOnClipboard - not possible in Java, stupid programming language
	protected static  enum CopyPasteAction  {
		JME, SMILES, MOL, MOL_V3000, INCHI, INCHI_KEY, INCHI_AUXINFO, INCHI_JSON,OCLCODE,
		 SVG, RAW_STRING_GRAPHIC,
	
		SEARCH_INCHI_KEY, PASTE;
		
		
		public SupportedFileFormat getFormat() {
			return SupportedFileFormat.valueOf(this.toString());
		}
 	}


	// File format for Ctrl C
	protected SupportedFileFormat clipboardFormat = SupportedFileFormat.MOL;
	
	protected JMEevent afterStructureChangeEvent = new JMEevent();

	// icons
	protected Icon fullScreenIcon;
	protected boolean isFullScreen = false;
	protected boolean fullScreenEnterOrExit = false;

	protected Icon dragAndDropIcon;

	// Fonts
	Font menuCellFont;
	Font menuCellFontBold; // for the atom symbols
	Font menuCellFontSmaller;
	Font atomDrawingAreaFont, dialogFont;
	FontMetrics menuCellFontMet, menuCellFontBoldMet, menuCellFontSmallerMet;
	FontMetrics atomDrawingAreaFontMet;

	Font atomMapDrawingAreaFont;
	FontMetrics atomMapDrawingAreaFontMet;

	int fontSize = 13; // with a value != 12, the stringWidth errors are minimized in JS
	float atomMolecularDrawingAreaFontSize = fontSize; // BB

	String defaultFontFamily = "Helvetica"; // looks good everywhere
	// BB if null: use the system default font - looks nice also in Java
	// String defaultFontFamily = "sansserif"; //Java: Helvetica is discouraged in
	// Java 1.1 and should be replaced by sansserif
	// String defaultFontFamily = "Sans-Serif"; //CSS

	protected boolean appletHasBeenResized = false;
	Rectangle2D.Double previousScaledScreenArea = null;

	/**
	 * the menu cell border differs in new and old look
	 * 
	 * @return
	 */
	int menuCellBorder() {
		return newLook ? 1 : 0;
		// will be changed to 0 when !newLook
	}

	protected float molecularAreaLineWidth = (float) 1.0;

	public float getMolecularAreaLineWidth() {
		return molecularAreaLineWidth;
	}

	/**
	 * Line width in pixel
	 * 
	 * @param molecularAreaLineWidth
	 */
	public void setMolecularAreaLineWidth(float molecularAreaLineWidth) {
		this.molecularAreaLineWidth = molecularAreaLineWidth;
		this.drawMolecularAreaRightNow();

	}

	public boolean molecularAreaAntiAlias = true;

	public boolean isMolecularAreaAntiAlias() {
		return molecularAreaAntiAlias;
	}

	/**
	 * Set antialias for the molecular drawing area
	 * 
	 * @param molecularAreaAntiAlias
	 */
	public void setMolecularAreaAntiAlias(boolean molecularAreaAntiAlias) {
		this.molecularAreaAntiAlias = molecularAreaAntiAlias;
		this.drawMolecularAreaRightNow();
	}

	/**
	 * Used for the test suite
	 * 
	 * @param width
	 * @param height
	 */
	public JME setDimension(int width, int height) {
		if (this.dimension == null) {
			this.dimension = new Dimension();
		}
		this.dimension.setSize(width, height);
		return this;
	}

	// tieto parametere sa naplnaju v init (aby sa vynulovali pri starte)
	//boolean bwMode = false;
	boolean runsmi = false; // traba to, alebo sa automaticky setne v param smi
	// ??
	String depictcgi = null;
	String depictservlet = null;
	
	SmilesCreationParameters smilesPars = new SmilesCreationParameters();
	public MoleculeHandlingParameters moleculeHandlingParameters = new MoleculeHandlingParameters();

	protected boolean canonize = true;;
	boolean stereo = true;
	
	
	
	
	boolean multipart = true; // vzdy aj pri reaction
	boolean xJButton = true;
	boolean paste = true; // BB: allow pasting structures, should be disabled in depict mode
	boolean rJButton = false;
	boolean query = false;
	protected boolean reaction = false;
	// boolean autoez = true;

	// unused options
	// boolean writesmi = false;
	// boolean writemi = false;
	// boolean writemol = false;

	boolean jmeh = false; // used in jSME
	//boolean valenceState = true;

	// boolean number = false; // moved to molecular handlig parameters
	//boolean mark = false;
	boolean markOnly1 = false; // only one atom at a time can be marked
	boolean pseudoMark = false; // marking does not happen - used only to trigger event
	boolean starAtomOnly = false;
	boolean starBondOnly = false;
	boolean starNothing= false;

	boolean markerMenu =false; // popup menu to select marker color

	boolean autonumber = false;
	private boolean depict = false;
	boolean toggleDepictEdit = false; // BB
	boolean depictActionEnabled = false; // BB allow editing in depict mode
	boolean depictBorder = false;
	//public boolean keepHydrogens = true;
	//boolean removeOnlyCHydrogens = false;

	boolean addNewPart = false; // when reading a or pasting a mol: add it or replace everything in the canvas

	boolean pasteFromSDFstack = false;

	boolean exportInchi = true;
	boolean exportInchiKey = true;
	boolean searchInchiKey = true;
	boolean exportInchiAuxInfo = true;
	boolean useOclIdCode = false; // OpenChemLib option:  useOclIDCode
	boolean exportSVG = true;

	boolean contextMenuEnabledOption = true;

	boolean fullScreenIconOption = false;
	protected boolean exportRXNmergeOption = false;

	Color canvasBg = Color.white;
	// Color starColor = Color.cyan;
	

	// index in the color manager palette, 0 based index
	public final static int DefaultMarkerColorIndex = 1; 
	int activeMarkerColorIndex = DefaultMarkerColorIndex;


	//String atomColors = null; // atom coloring
	String atomBgColors = null; // background coloring
	final static double defaultAtomBGcircleRelativeSize = 0.8;
	final static double atomBGcircleRelativeSize = defaultAtomBGcircleRelativeSize;
	final static double defaultBondBGrectRelativeSize = 0.5;
	final static double bondBGrectRelativeSize = defaultBondBGrectRelativeSize;

	public final static double defaultMolecularAreaScale = 1.0;

	protected double molecularAreaScale = defaultMolecularAreaScale; // ked scaling viacero moleculeParts, alebo
																		// reaction
	protected final double minmolecularAreaScale = 0.3;
	protected final double maxMolecularAreaScale = 10;

	protected double menuScale = 1.0; // BB scaling the menu
	protected final double minMenuScale = 0.7;
	protected final double maxMenuScale = 4;

	final static boolean scalingIsPerformedByGraphicsEngine = true; // BB, gives nicer looking depiction

	boolean fgMenuOption = true;
	boolean nocenter = false;
	boolean polarnitro = false;
	boolean showAtomNumbers = false; // only when starting with a molecule
	// scaling pri depict, nacitanie molekul (jme + mol)

	boolean showAtomMoveJButton = true; // BB
	// boolean mdlV2000ChiralFlag = false; //for v2000 note: v300 has also a chiral
	// flag
	protected boolean useOpenChemLib = true; // for SMILES input

	boolean showDragAndDropIconInDepictMode = true; // BB
	boolean showFullScreenIconInDepictMode = true; // BB

	boolean allowZooming = true;
	boolean allowGUIzooming = true;
	boolean allowFullScreenToggle = true;

	// files na nacitanie (2002.06)
	String jmeString = null;
	public String molString = null; // why is this variable declared here? Because it is used in init() and start()
	String genericChemicalInputFromInit = null;

	// pouziva v double bufferingu
	protected Dimension dimension;

	protected PreciseImage molecularAreaImage;
	int molecularAreaWidth;
	int molecularAreaHeight;

	// these images are not used in depict mode
	PreciseImage topMenuImage, leftMenuImage;
	PreciseImage infoAreaImage;
	PreciseImage rightBorderImage;

	// pre repaint()
	// boolean doMenu = true; // ci draw menu pri repaint()
	boolean movePossible; // not to move when dragg in menu

	// BB - avoid unnecessary redraw - speed optimization for slow browsers
	boolean mustReDrawLeftMenu = true;
	boolean mustReDrawTopMenu = true;
	boolean mustReDrawMolecularArea = true;
	boolean mustReDrawInfo = true;
	boolean mustReDrawRightBorderImage = true;

	protected String notifyStructuralChangeJSfunction = null;
	protected String notifyAtomHighLightJSfunction = null;
	protected String prePasteJSfunction = null;

	protected String pasteJLabel = null;

	// boolean atomWasTouched = false;
	// boolean bondWasTouched = false;

	// the ACTION code on which the mouse was during mouse move
	int mouseWasOverAction = 0;

	public ColorManager colorManager = new ColorManager();

	public String getPasteJLabel() {
		return pasteJLabel;
	}

	/**
	 * Customization of the paste label
	 * 
	 * @param pasteJLabel
	 */
	public void setPasteJLabel(String pasteJLabel) {
		this.pasteJLabel = pasteJLabel;
		// rebuild the menu each time the pasteJLabel is changed
		this.copyPasteJPopupMenuMol = this.createCopyPasteJPopupMenu(false);
	}

	// actions 2 riadky s ACTIONX a atomy s ACTIONA
	static int LEFT_MENU_NUMBER_OF_CELLS = 10; // meni sa podla rxJButton
	static final int LEFT_MENU_NUMBER_OF_CELLS_WITHOUT_X_R = 9;
	// cislo action urcuje aj polohu buttonu
	// empty buttons (a ACTION_END v aplete) su vyradene v mousePressed()
	// a kreslenie textov v createSquare (neda sa to v jednom ?)
	static final int ACTION_DELETE = 104;
	static final int ACTION_MARK = 105;
	static final int ACTION_DELGROUP = 106;
	static final int ACTION_SMI = 101;
	static final int ACTION_QRY = 107;
	static final int ACTION_REACP = 109;
	static final int ACTION_UNDO = 110;
	static final int ACTION_REDO = 111;
	static final int ACTION_SPIRO = 112; // BB: was 111
	static final int ACTION_CLEAR = 102;
	static final int ACTION_NEW = 103; // using newMolecule

	static final int ACTION_MOVE_AT = 113; // BB: new

	static final int ACTION_JME = 114; // BB: was 113

	// BB: the number of cells in the top menu - was ACTION_X
	static final int TOP_MENU_NUMBER_OF_CELLS = ACTION_JME - 100; // assume that ACTION_JME is the last menu entry on
																	// the top row

	static final int ACTION_PGUP = 151;
	static final int ACTION_PGDN = 152;
	static final int ACTION_HOME = 153;
	static final int ACTION_END = 154;

	static final int ACTION_ROT90 = 156; // webme
	static final int ACTION_CHARGE_PLUS = 157; // webme
	static final int ACTION_CHARGE_MINUS = 158; // webme

	static final int ACTION_CHARGE = 108;
	static final int ACTION_STEREO = 201;
	static final int ACTION_BOND_SINGLE = 202;
	static final int ACTION_BOND_DOUBLE = 203;
	static final int ACTION_BOND_TRIPLE = 204;
	static final int ACTION_CHAIN = 205;
	static final int ACTION_RING_3 = 206;
	static final int ACTION_RING_4 = 207;
	static final int ACTION_RING_5 = 208;
	public static final int ACTION_RING_PH = 209;
	static final int ACTION_RING_6 = 210;
	static final int ACTION_RING_7 = 211;
	static final int ACTION_RING_8 = 212;

	static final int ACTION_FG = 213; // BB: button for a popup menu with functional groups
	// static final int ACTION_EMPTY_CELL = 214; //BB: defined only to avoid
	// highliting when click on it, to be removed?
	static final int ACTION_IO = 214; // BB replace ACTION_EMPTY_CELL by I/O icon below info icon

	static final int ACTION_RING_FURANE = 221; // nema button
	static final int ACTION_RING_3FURYL = 223; // Alt 0
	static final int ACTION_RING_9 = 229; // nema button
	static final int ACTION_TEMPLATE = 230;

	static final int ACTION_GROUP_MIN = 233; // BB first entry in the substituents (FG)
	static final int ACTION_GROUP_TBU = 233;
	static final int ACTION_GROUP_NITRO = 234;
	static final int ACTION_GROUP_COO = 235;
	static final int ACTION_GROUP_CF3 = 236;
	static final int ACTION_GROUP_CCL3 = 237;
	static final int ACTION_GROUP_CC = 238;
	static final int ACTION_GROUP_SULFO = 239;
	static final int ACTION_GROUP_COOME = 240;
	static final int ACTION_GROUP_OCOME = 241;
	static final int ACTION_GROUP_CYANO = 242;
	static final int ACTION_GROUP_NME2 = 243;
	static final int ACTION_GROUP_NHSO2ME = 244;
	static final int ACTION_GROUP_CCC = 245;
	static final int ACTION_GROUP_C2 = 246;
	static final int ACTION_GROUP_C3 = 247;
	static final int ACTION_GROUP_C4 = 248;
	static final int ACTION_GROUP_COH = 249;
	static final int ACTION_GROUP_dO = 250; // =O
	static final int ACTION_GROUP_PO3H2 = 251;
	static final int ACTION_GROUP_SO2NH2 = 252;
	static final int ACTION_GROUP_TEMPLATE = 253;
	static final int ACTION_GROUP_CF = 254;
	static final int ACTION_GROUP_CL = 255;
	static final int ACTION_GROUP_CB = 256;
	static final int ACTION_GROUP_CI = 257;
	static final int ACTION_GROUP_CN = 258;
	static final int ACTION_GROUP_CO = 259;
	static final int ACTION_GROUP_CON = 260; // BB
	static final int ACTION_GROUP_NCO = 261; // BB
	static final int ACTION_GROUP_MAX = 262; // last+1 len na < test

	static final int ACTION_AN_C = 301;
	static final int ACTION_AN_N = 401;
	static final int ACTION_AN_O = 501;
	static final int ACTION_AN_S = 601;
	static final int ACTION_AN_F = 701;
	static final int ACTION_AN_CL = 801;
	static final int ACTION_AN_BR = 901;
	static final int ACTION_AN_I = 1001;
	static final int ACTION_AN_P = 1101;
	static final int ACTION_AN_X = 1201;
	
	static final int ACTION_AN_H = 1300; // does not match a square posiiton on left menu
	// added by BB
	// static final int ACTION_AN_STAR = 1301;

	static final int ACTION_AN_R = 1301; // must be 1301 because it corresponds to the left menu square position ???
	static final int ACTION_AN_R1 = 1302;
	static final int ACTION_AN_R2 = 1303;
	static final int ACTION_AN_R3 = 1304;
	// added by BB
	static final int ACTION_AN_R4 = 1305;
	static final int ACTION_AN_R5 = 1306;
	static final int ACTION_AN_R6 = 1307;
	static final int ACTION_AN_R7 = 1308;
	static final int ACTION_AN_R8 = 1309;
	static final int ACTION_AN_R9 = 1310;

	static final int ACTION_AN_R_LAST = 1310;
	// end added by BB

	// JSME custom atomic numbers for use in Atom.na
	// TODO Element table
	static final int AN_H = 1;
	static final int AN_B = 2;
	static final int AN_C = 3;
	static final int AN_N = 4;
	static final int AN_O = 5;
	static final int AN_SI = 6;
	static final int AN_P = 7;
	static final int AN_S = 8;
	static final int AN_F = 9;
	static final int AN_CL = 10;
	static final int AN_BR = 11;
	static final int AN_I = 12;
	static final int AN_SE = 13;

	// BB
	// https://en.wikipedia.org/wiki/List_of_oxidation_states_of_the_elements
	static final int AN_K = 14;
	static final int AN_METAL1_START = AN_K;
	static final int AN_Na = 15;
	static final int AN_Li = 16;
	static final int AN_Rb = 17;
	static final int AN_Cs = 18;
	static final int AN_Fr = 19;
	static final int AN_Ag = 20;
	static final int AN_METAL1_END = AN_Ag;

	static final int AN_Mg = AN_METAL1_END + 1;
	static final int AN_METAL2_START = AN_Mg;
	static final int AN_Ca = AN_Mg + 1;
	static final int AN_Ba = AN_Ca + 1;
	static final int AN_Sr = AN_Ba + 1;;
	static final int AN_Zn = AN_Sr + 1;
	static final int AN_Ni = AN_Zn + 1;
	static final int AN_Cu = AN_Ni + 1;
	static final int AN_Cd = AN_Cu + 1;

	static final int AN_METAL2_END = AN_Cd;

	static final int AN_METAL3_START = AN_METAL2_END + 1;
	static final int AN_Al = AN_METAL3_START;
	static final int AN_Ga = AN_Al + 1;
	static final int AN_Au = AN_Ga + 1;
	static final int AN_METAL3_END = AN_Au;

	static final int AN_X = AN_METAL3_END + 1;

	static final int AN_R = AN_X + 1;
	// static final int AN_R1 = 20;
	// static final int AN_R2 = 21;
	// static final int AN_R3 = 22;
	// added by BB
	static final int AN_R_LAST = AN_R + 9; // keep the 9! 1 value for each R

	static final int actionToAtomNumberArray[] = { ACTION_AN_C, AN_C, ACTION_AN_N, AN_N, ACTION_AN_O, AN_O, ACTION_AN_F,
			AN_F, ACTION_AN_CL, AN_CL, ACTION_AN_BR, AN_BR, ACTION_AN_I, AN_I, ACTION_AN_S, AN_S, ACTION_AN_P, AN_P,
			ACTION_AN_H, AN_H, ACTION_AN_X, AN_X, ACTION_AN_R, AN_R, };

	// coud have used a HAshMap, but the code to initialize a hashmap is about the
	// same - JS is much better here for simple dict
	protected int mapActionToAtomNumber(int action, int notFound) {
		int result = notFound;
		
		if (action >= ACTION_AN_R) {
			int delta = action - ACTION_AN_R;
			result = AN_R + delta;
		} else {
			for (int i = 0; i < actionToAtomNumberArray.length; i += 2) {
				if (actionToAtomNumberArray[i] == action) {
					result = actionToAtomNumberArray[i + 1];
					break;
				}
			}
			// patch related to determineNumberLeftMenuNumberOfCell
			if (result == AN_X) {
				if (!this.xJButton && this.rJButton) { // X button has been removed and replaced by R button
					result = AN_R;
				}
			}
		
		}
		return result;
	}

	protected int determineNumberLeftMenuNumberOfCell() {
		int result = LEFT_MENU_NUMBER_OF_CELLS_WITHOUT_X_R;
		if (this.rJButton) {
			result++;
		}
		if (this.xJButton) {
			result++;
		}

		return result;

	}

	static final Color color[] = new Color[AN_R_LAST + 1];
	static final String zlabel[] = new String[AN_R_LAST + 1];

	// info about last action & undo
	int lastAction = 0; // trva len po mouse up
	static final int LA_BOND = 1;
	static final int LA_RING = 2;
	static final int LA_GROUP = 3;
	static final int LA_MOVE = 5;
	static final int LA_ROTATE = 7; // BB used for rotation on touch event
	static final int LA_SCALE = 8; // BB used for scaling on touch event
	static final int LA_FAILED = 9; // failed to create bond or ring
	boolean newMolecule = false; // enable to start new molecule
	int xold, yold; // position of mousePressed, updated in mouseDragged
	boolean afterClear = false; // info pre undo
	boolean mouseShift = false; // kvoli numbering

	// boolean isContextMenu = false; //right mouse click

	MultiBox smilesBox = null, atomxBox = null, aboutBox = null;
	QueryBox queryBox;
	boolean spiroAdding = false;
	boolean movingAtom = false; // BB

	String molText = null;
	// JMEmol mol = new JMEmol(this); // sposobovalo problemy v NS
	protected JMEmol activeMol; // BB: the molecule JME is presently working on
	JMEmol uniColorMolecule = null;
	Graphical2DObject activeGraphicalObject;

	//protected int numberofMoleculeParts = 0;
	//int actualMoleculePartIndex = 0;
	int saved = 0; // ktora molekula jindexe saved pri multipart

	InspectorEvent inspectorEvent;

	String template = null; // template as jme string
	JMEmol templateMolecule = null; // template molecule - functional groups?
	static final int maxParts = 99;

	//protected JMEmol moleculeParts[] = new JMEmol[maxParts]; // when multipart, nealokuje !!
	protected JMEmolList moleculePartsList = new JMEmolList(); // when multipart, nealokuje !!
	JMEmol smol; // save

	// BB undo & redo section
	final boolean canMultipleUndo = true; // when false, use Peter's original implementation, otherwise use the
											// changeManager
	ChangeManager<SavedState> molChangeManager;

	static String programName; // JSME or JME

	// BB : eclipse added the <JMEmol>
	Vector<JMEmol> molStack = new Vector<JMEmol>();

	// BB
	SDFstack sdfStack = new SDFstack();

	int stackPointer = -1;
	boolean doTags = false; // compatibility with JMEPro
	final boolean webme = false; // compatibility with JMEPro
	public int[] apointx, apointy, bpointx, bpointy; // coordinates for webme
	boolean revertStereo = false; // down stereo bond (only 1 action)
	boolean relativeStereo = false;
	//boolean allHs = false;
	// for key marking 2009.04
	boolean resetExtendAtomMark = true;
	int keyboradInputMark = -100;
	boolean markFromKeyboardInput = false;

	// images
	// Image infoImage, clearImage, deleteImage, deleterImage, chargeImage;
	// Image templatesImage, rtemplatesImage, undoImage, endImage, smiImage,
	// smitImage, smartsImage, stereoImage, stereoxImage;

	// BB
	// true if the Java code has been compiled to JavaScript
	final boolean isJavaScript = System.getProperty("java.vm.name").equals("JavaScript");

	// BB: true for touch device iPad, Android
	final static boolean isTouchSupported = System.getProperty("is_touch_supported") != null;

	// BB for copy & paste
	protected TextTransfer clipBoardManager = new TextTransfer();
	JPopupMenu copyPasteJPopupMenuMol;
	JPopupMenu copyPasteJPopupMenuReaction;

	// local popup menu for the touched molecule/atom
	JPopupMenu touchedMolPopuMenu;
	static String setChiralFlagAction = "Set molecule chiral flag";
	static String unSetChiralFlagAction = "Unset molecule chiral flag";
	static String changeAtomChargeAction = "Change atom charge";

	static String changeAtomMapAction = "Change atom map";
	static String changeAtomMarkAction = "Change atom mark value";
	static String autoAtomMapMoleculeAction = "Auto atom map molecule";
	static String deleteAtomMapMoleculeAction = "Delete all atom map molecule";
	final static String deleteHydrogensMoleculeAction = "Delete hydrogens";
	final static String compute2DcoordinatesMoleculeAction = "Compute 2D coordinates";

	final static String bondCoordination = "et coordination bond";
	final static String bondSetCoordinationAction = "S" + bondCoordination;
	final static String bondUnSetCoordinationAction = "Uns" + bondCoordination;

	// functional group selection coming from the HTML example page
	String functionalGroups[] = new String[] { "-C(=O)OH", "-C(=O)OMe", "-OC(=O)Me", "-C(=O)N", "-NC=O", "-CMe3",
			"-CF3", "-CCl3", "-NO2", "-SO2-NH2", "-NH-SO2-Me", "-NMe2", "-C#N", "-C#CH", "-C#C-Me" };

	JPopupMenu functionalGroupPopumemu;
	private Point functionalGroupJPopupMenuPosition;
	Point markerJPopupMenuPosition;
	private Point fixedCopyPasteJPopupMenuPosition;
	private long lastRotation;
	private boolean bondRubberBanding = false;
	protected PasteAction pasteAction;
	private boolean mouseDownWasUsed;
	private boolean saveCurrentState = false; // when true means the current state of the chemical structures must be
												// saved in the undo state manager

	protected String searchInchiKeyMenuJLabel = "Search chemical structure (through InChIKey)";
	private boolean alignMoleculesHasBeenPerformedByReadingStructure;
	//protected Rectangle2D.Double reactionArrowBoundingBox;
	private JFrame myFrame;
	private boolean application;

	// used for parsing input
	public static final String NumberParsingErrorMsg = "Number parsing";
	public static final String NotEnoughDataMsgError = "Not enough data";

	public static String makeErrorMessage(Exception e) {
		String errorMsg = null;

		if (e instanceof NumberFormatException) {
			errorMsg = NumberParsingErrorMsg;
		} else if (e instanceof NoSuchElementException) { // if there are no more tokens in this tokenizer's string.)
			errorMsg = NotEnoughDataMsgError;
		}

		if (errorMsg == null) {
			errorMsg = e.toString();
		} else if (e.getMessage() != null) {
			errorMsg += ":" + e.getMessage();
		}

		return errorMsg;

	}

	public int numberOfMolecules() {
		return this.moleculePartsList.size();
	}
	
	// private int lastTouchedMoleculePart;

	public double getMolecularAreaScale() {
		return molecularAreaScale;
	}

	// used by mouse wheel event in reaction mode
	public void setMolecularAreaScale(double newScale) {
		// should we limit scaling if one molecule becomes invisible?
		if (newScale != this.molecularAreaScale) {
			Rectangle2D.Double dim1 = this.getMolecularAreaBoundingBoxCoordinate();
			this.molecularAreaScale = newScale;
			Rectangle2D.Double dim2 = this.getMolecularAreaBoundingBoxCoordinate();
			recenterMoleculesAfterMolecularAreaChange(dim1, dim2);
			this.redrawMolecularAreaOnly();
		}
	}

	public void recenterMoleculesAfterMolecularAreaChange(Rectangle2D.Double before, Rectangle2D.Double after) {
		double moveX = after.getCenterX() - before.getCenterX();
		double moveY = after.getCenterY() - before.getCenterY();

		this.graphicalObjectList().moveXY(moveX, moveY);

	}

	public double getMenuScale() {
		return menuScale;
	}

	public void setMenuScale(double menuScale) {
		if (menuScale != this.menuScale) {
			;
			this.menuScale = menuScale;
			this.resetAllGraphics();
			this.repaint();
		}
	}

	public void setNewJButtonStatus(boolean newStatus) {
		this.newMolecule = newStatus;
		this.mustReDrawTopMenu = true;
		this.repaint();

	}

	public boolean getNewJButtonStatus() {
		return this.newMolecule;
	}

	// ----------------------------------------------------------------------------
	public JME() {
		//this.moleculeHandlingParameters.singleMarkerColorIndex = DefaultMarkerColorIndex;
		
		activeMol = new JMEmol(this, this.moleculeHandlingParameters);
		
		lastTouchedMol.mol = activeMol;
		newTouchedMol.mol = activeMol;
		//moleculeParts[1] = mol;
		moleculePartsList.add(activeMol);
;		
		inspectorEvent = new InspectorEvent(this);

		//this.alert("isTouchSupported: " + isTouchSupported);
		// reactionArrowBoundingBox = new Box();
	}

	// -----------------------------------------------------------------------------
	// Shortcuts for molecule

	/**
	 * 
	 * Change atom coordinate
	 * 
	 * @param mol
	 * @param atomIndex
	 * @param x
	 * @param y
	 */
	protected void XY(JMEmol mol, int atomIndex, int x, int y) {
		mol.XY(atomIndex, screenToDrawingX(x), screenToDrawingY(y));
	}

	// NOT USED!!!!
	/**
	 * Move to atom
	 * 
	 * @param mol
	 * @param atomIndex
	 * @param x
	 * @param y
	 */
	protected void moveXY(JMEmol mol, int atomIndex, int x, int y) {
		mol.moveXY(atomIndex, screenToDrawingX(x), screenToDrawingY(y));
	}

	// ----------------------------------------------------------------------------
	protected JPopupMenu createCopyPasteJPopupMenu(boolean isReaction) {

		JPopupMenu popup = new JPopupMenu();

		String smilesOrSmirks = "SMILES";
		String molOrReaction = "MOL";
		String molOrReactionForPasting = "MOL or SDF";
		Boolean hasAtom = !this.isMolecularAreEmpty();

		// String what = "chemical structure(s)";
		if (isReaction) {
			smilesOrSmirks = "SMIRKS";
			molOrReaction = "RXN";
			// what = "reaction";
			molOrReactionForPasting = molOrReaction;
		}

		if (useOpenChemLib) {
			molOrReactionForPasting += " or " + smilesOrSmirks;
			if (!isReaction && this.useOclIdCode) {
				molOrReactionForPasting += " or " + JME.OCL_ID_CODE_LABEL;
			}
		}

		// COPY SMILES
		JMenuItem mi = new JMenuItem("Copy " /* + what */ + "as " + smilesOrSmirks /* + " to the clipboard" */);
		mi.setActionCommand(CopyPasteAction.SMILES.toString());
		popup.add(mi);
		mi.setEnabled(!hasAtom);
		mi.addActionListener(this);

		// COPY MOL
		mi = new JMenuItem("Copy " /* + what */ + "as " + molOrReaction /* + " to the clipboard" */);
		mi.setActionCommand(CopyPasteAction.MOL.toString());
		mi.addActionListener(this);
		popup.add(mi);

		// COPY V3000 MOL
		if (!isReaction) {
			mi = new JMenuItem("Copy " /* + what */ + "as " + molOrReaction + " V3000" /* + " to the clipboard" */);
			mi.setActionCommand(CopyPasteAction.MOL_V3000.toString());
			mi.addActionListener(this);
			popup.add(mi);

			// handling Inchi: only available for JSME - use the inchi-js
			if (this.canComputeInchi()) {
				if (this.exportInchi) {
					mi = new JMenuItem("Copy " /* + what */ + "as " + "InChI" /* + " to the clipboard" */);
					mi.setActionCommand(CopyPasteAction.INCHI.toString());
					mi.addActionListener(this);
					mi.setEnabled(!hasAtom);
					popup.add(mi);

				}

				if (this.exportInchiKey) {
					mi = new JMenuItem("Copy " /* + what */ + "as " + "InChI key" /* + " to the clipboard" */);
					mi.setActionCommand(CopyPasteAction.INCHI_KEY.toString());
					mi.addActionListener(this);
					mi.setEnabled(!hasAtom);
					popup.add(mi);

				}
				if (this.searchInchiKey) {
					mi = new JMenuItem(this.searchInchiKeyMenuJLabel);
					mi.setActionCommand(CopyPasteAction.SEARCH_INCHI_KEY.toString());
					mi.addActionListener(this);
					mi.setEnabled(!hasAtom);
					popup.add(mi);

				}
				if (this.exportInchiAuxInfo) {
					mi = new JMenuItem("Copy " /* + what */ + "as " + "InChI auxinfo" /* + " to the clipboard" */);
					mi.setActionCommand(CopyPasteAction.INCHI_AUXINFO.toString());
					mi.addActionListener(this);
					mi.setEnabled(!hasAtom);
					popup.add(mi);

				}
			}

		}

		// COPY JME
		mi = new JMenuItem("Copy " /* + what */ + "as " + "JME" /* + " to the clipboard" */);
		mi.setActionCommand(CopyPasteAction.JME.toString());
		mi.addActionListener(this);
		popup.add(mi);

		if (this.useOpenChemLib && this.exportSVG && !isReaction) {
			mi = new JMenuItem("Copy " /* + what */ + "as " + "OCL Scalar Vector Graphics");
			mi.setActionCommand(CopyPasteAction.SVG.toString());
			mi.addActionListener(this);
			popup.add(mi);

		}

		// on IE7, one would get VML instead of SVG - nobody is using IE7 now
		if (this.isJavaScript && this.exportSVG) {
			mi = new JMenuItem("Copy " /* + what */ + "as " + "raw Scalar Vector Graphics");
			mi.setActionCommand(CopyPasteAction.RAW_STRING_GRAPHIC.toString());
			mi.addActionListener(this);
			popup.add(mi);

		}

		if (this.useOpenChemLib && this.useOclIdCode && !isReaction) {
			mi = new JMenuItem("Copy " /* + what */ + "as " + JME.OCL_ID_CODE_LABEL);
			mi.setActionCommand(CopyPasteAction.OCLCODE.toString());
			mi.addActionListener(this);
			mi.setEnabled(!hasAtom);
			popup.add(mi);

		}
		// PASTE
		if (this.paste) {
			popup.addSeparator();
			String localPasteJLabel = this.getPasteJLabel();
			if (localPasteJLabel == null) {
				localPasteJLabel = "Paste " + molOrReactionForPasting; // default, no customization
			}
			mi = new JMenuItem(localPasteJLabel);

			mi.setActionCommand(CopyPasteAction.PASTE.toString());
			mi.addActionListener(this);
			popup.add(mi);

		}
		this.add(popup); // set the parent the popup

		return popup;

	}

	/**
	 * To be redefined in subclass
	 * 
	 * @return true if this implementation can compute inchi
	 */
	protected boolean canComputeInchi() {
		return false;
	}

	/**
	 * return a based 1 index
	 * @return
	 */
	protected int activeMolIndex() {
		return this.moleculePartsList.indexOf(this.activeMol);
	}
	/**
	 * Create a popup menu with additional action for the selected molecule
	 * @return
	 */
	
	
//	boolean ismarkerMultiColorActive() {
//		return this.moleculeHandlingParameters.markerMultiColor;
//	}
	
	protected JPopupMenu createMolJPopupMenu(JMEmol mol, int eventX, int eventY) {
		JPopupMenu popup = new JPopupMenu();

		boolean showAtomMappingToolsInMenu = this.moleculeHandlingParameters.number || autonumber || reaction;
		JMenuItem setUnsetChiralFlagJMenuItem;
		if (mol.getChiralFlag()) {
			setUnsetChiralFlagJMenuItem = new JMenuItem(unSetChiralFlagAction);
		} else {
			setUnsetChiralFlagJMenuItem = new JMenuItem(setChiralFlagAction);
		}

		setUnsetChiralFlagJMenuItem.setEnabled(mol.canBeChiral());

		popup.add(setUnsetChiralFlagJMenuItem);
		setUnsetChiralFlagJMenuItem.addActionListener(this);

		if (mol.touchedAtom > 0  ) {
			this.inspectorEvent.reset();
			this.inspectorEvent.atomIndex = mol.touchedAtom;
			this.inspectorEvent.mol = mol;
			this.inspectorEvent.x = eventX;
			this.inspectorEvent.y = eventY;
			this.inspectorEvent.molIndex = this.activeMolIndex();
			
		}
		if (showAtomMappingToolsInMenu && mol.touchedAtom > 0) {
			JMenuItem atomInspectoJMenuItem = new JMenuItem(this.moleculeHandlingParameters.mark ? changeAtomMarkAction : changeAtomMapAction);
			atomInspectoJMenuItem.addActionListener(this.inspectorEvent);

			popup.add(atomInspectoJMenuItem);
		}
		
		// charge handling
		if( mol.touchedAtom > 0) { 
			// BB July 2022: renable the charge change
			JMenuItem atomInspectoJMenuItem = new JMenuItem(changeAtomChargeAction);
			atomInspectoJMenuItem.addActionListener(this.inspectorEvent);
			popup.add(atomInspectoJMenuItem);
		}

		// add a 2D computation only if Openchemlib is enabled
		if (useOpenChemLib) {
			JMenuItem compute2DJMenuItem = new JMenuItem(compute2DcoordinatesMoleculeAction);
			popup.add(compute2DJMenuItem);
			compute2DJMenuItem.addActionListener(this);
		}
		
		
		JMenuItem deleteHydrogensJMenuItem = new JMenuItem(deleteHydrogensMoleculeAction);
		deleteHydrogensJMenuItem.setEnabled(mol.hasHydrogen());

		popup.add(deleteHydrogensJMenuItem);
		deleteHydrogensJMenuItem.addActionListener(this);

		if (showAtomMappingToolsInMenu) {
			JMenuItem mapJMenuItem = new JMenuItem(autoAtomMapMoleculeAction);
			mapJMenuItem.addActionListener(this);
			popup.add(mapJMenuItem);

			mapJMenuItem = new JMenuItem(deleteAtomMapMoleculeAction);
			mapJMenuItem.addActionListener(this);
			popup.add(mapJMenuItem);
			mapJMenuItem.setEnabled(mol.geMaxAtomMap() > 0);

		}

		JMenuItem bondInspectoJMenuItem = new JMenuItem();
		String label = bondSetCoordinationAction;
		bondInspectoJMenuItem.setEnabled(false);
		if (mol.touchedBond > 0) {
			Bond bond = mol.bonds[mol.touchedBond];
			if (bond.isSingle() || bond.isCoordination()) {
				label = bond.isCoordination() ? bondUnSetCoordinationAction : bondSetCoordinationAction;
				// bondInspectoJMenuItem.addActionListener(this.inspectorEvent); //not used
				this.inspectorEvent.reset();
				this.inspectorEvent.bondIndex = mol.touchedBond;
				this.inspectorEvent.mol = mol;
				this.inspectorEvent.x = eventX;
				this.inspectorEvent.y = eventY;
				this.inspectorEvent.molIndex = this.activeMolIndex();

				bondInspectoJMenuItem.setEnabled(true);
				bondInspectoJMenuItem.addActionListener(this);

			}
		}
		bondInspectoJMenuItem.setLabel(label);
		popup.add(bondInspectoJMenuItem);

		return popup;

	}

	// ----------------------------------------------------------------------------

	  public void setFrame(JFrame frame) {
		    myFrame = frame;
		    frame.setName("JME"); // for embedding in <div id="testApplet-JME-div">
		    frame.add("Center", this);
		    frame.addKeyListener(this);
		    addMouseListener(this);
		    addMouseMotionListener(this);
		    new FileDropper(this);
		    application = true;
		  }

	  @Override
	  public void mouseDragged(MouseEvent e) {
	    mouseDrag(e, e.getX(), e.getY());
	  }

	  @Override
	  public void mouseMoved(MouseEvent e) {
	    mouseMove(e, e.getX(), e.getY());
	  }

	  @Override
	  public void keyTyped(KeyEvent e) {
	  }

	  @Override
	  public void keyPressed(KeyEvent e) {
	    keyDown(e, e.getKeyCode());
	  }

	  @Override
	  public void keyReleased(KeyEvent e) {
	  }

	  @Override
	  public void mouseClicked(MouseEvent e) {
	  }

	  @Override
	  public void mousePressed(MouseEvent e) {
	    mouseDown(e, e.getX(), e.getY());
	  }

	  @Override
	  public void mouseReleased(MouseEvent e) {
	    mouseUp(e, e.getX(), e.getY());
	  }

	  @Override
	  public void mouseEntered(MouseEvent e) {
	    // TODO

	  }

	  @Override
	  public void mouseExited(MouseEvent e) {
	    // TODO

	  }


	// BB - this method can be used only by input events methods
	void mustRedrawNothing() {
		mustRedrawImages(false);
	}

	// BB
	public void mustRedrawEverything() {
		mustRedrawImages(true);
	}

	public void mustRedrawImages(boolean yesOrNo) {
		mustReDrawLeftMenu = yesOrNo;
		mustReDrawTopMenu = yesOrNo;
		setMustRedrawMolecularArea(yesOrNo);
		mustReDrawInfo = yesOrNo;
		mustReDrawRightBorderImage = yesOrNo;

	}
	boolean mustRedrawNSomething() {
		return mustReDrawLeftMenu ||
		mustReDrawTopMenu ||
		mustReDrawMolecularArea ||
		mustReDrawInfo ||
		mustReDrawRightBorderImage ;

	}

	public void mustReDrawMolecularArea() {
		setMustRedrawMolecularArea(true);
	}

	public void redrawEverything() {
		this.mustRedrawEverything();
		this.repaint();
	}

	

	// --------------------------------------------------------------------------
	public Color getColor() {
		return bgColor; // it may be used to color other stuff with mi colors
	}

	// --------------------------------------------------------------------------
	public void activateQuery() {
		// v JME menu nastavi na query (ak bolo medzitym ine)
		if (action != JME.ACTION_QRY) {
			action = ACTION_QRY;
			repaint();
		}
	}

	// ----------------------------------------------------------------------------
	public void initialize() {
		moleculeHandlingParameters.keepSameCoordinatesForOutput = false;
		moleculeHandlingParameters.internalBondScalingForInput = true;

		moleculeHandlingParameters.showAtomMapNumberWithBackgroundColor = false;
		
		
		

		if (this.isJavaScript) {
			programName = "JSME";
		} else {
			programName = "JME";
		}
		
		Container parent = this.getParent();
		if (parent != null ) {
			parent.addMouseWheelListener(this); // works
		}
		// parent.addMouseListener(this); //has no effects in Java in Applet or
		// Application run mode

		// tu su veci co suvisia s grafikou

		// addMouseListener(this);
		// addMouseMotionListener(this);
		// addKeyListener(this);

		// BB
		// this.copyPasteJPopupMenuMol = this.createCopyPasteJPopupMenu(false);
		// this.copyPasteJPopupMenuReaction = this.createCopyPasteJPopupMenu(true);

		// Show the copyright stuff at the bottom of the page when the applet starts
		info(programName + " " + startInfoText);

		dimension = getSize(); // potrebne pre centrovanie nacitanej molekuly //needed for centering loaded
							// molecules
		log("init: " + dimension.width + " " + dimension.height);
		setLayout(null);

		// NS3 ma error vo font metrics (nedava ascent)
		// fontSize = 8;

		if (menuCellFont == null) { // kvoli IE, ktory aj pri Back vola init
			menuCellFont = new Font(defaultFontFamily, Font.PLAIN, fontSize);
			menuCellFontMet = getFontMetrics(menuCellFont);
		}
		if (menuCellFontBold == null) { // kvoli IE, ktory aj pri Back vola init
			menuCellFontBold = new Font(defaultFontFamily, Font.BOLD, fontSize);
			menuCellFontBoldMet = getFontMetrics(menuCellFontBold);
		}

		// int fs = fontSize-1;
		int smallerFontSize = fontSize - 2; // OK for the Java VM

		if (menuCellFontSmaller == null) {
			menuCellFontSmaller = new Font(defaultFontFamily, Font.PLAIN, smallerFontSize);
			menuCellFontSmallerMet = getFontMetrics(menuCellFontSmaller);
		}

		// BB: independent font size for the dialog boxes
		if (this.dialogFont == null) {
			// BB It is not necesssary to specify a font, the default one looks good
			this.dialogFont = null;
			// this.dialogFont = new Font(null, Font.PLAIN, this.dialogFontSize);
		}

		// BB: independant font size for the atoms in the molecular area
		// if(this.atomDrawingAreaFont == null) {

		initatomDrawingAreaFont(this.atomMolecularDrawingAreaFontSize);

		// este aj tu aby sa vzdy iniciovali pre reload
		// ??? urobit to lepsie
		query = false;
		reaction = false;
		//autoez = true;
		stereo = true;
		canonize = true;
		xJButton = true;
		rJButton = false;
		LEFT_MENU_NUMBER_OF_CELLS = this.determineNumberLeftMenuNumberOfCell();
		//showHydrogens = true;


//		if (!isStandAloneApplication) {
//			try { // chytanie exception kvoli startu z ineho appletu
//				String options = getParameter("options");
//				if (options != null)
//					options(options, false);
//				String jme = getParameter("jme");
//				if (jme != null)
//					jmeString = jme;
//				String molf = getParameter("mol");
//				if (molf != null)
//					molString = molf;
//				String chem = getParameter("chem");
//				if (chem != null)
//					genericChemicalInputFromInit = chem;
//
//				String s = getParameter("smiles");
//				if (s != null)
//					genericChemicalInputFromInit = s;
//
//				String dc = getParameter("depictcgi");
//				if (dc != null) {
//					depictcgi = dc;
//					runsmi = true;
//				} // sets runsmi, pred smi
//					// v parametroch depictcgi PRED smiles, upravit ????
//
//				String mt = getParameter("text");
//				if (mt != null) {
//					molText = mt;
//					repaint();
//				}
////				atomColors = getParameter("atomcolors"); // only 1 of these 2
//				atomBgColors = getParameter("atombg");
//				String bc = getParameter("depictbg");
//				if (bc != null && isDepict())
//					canvasBg = parseHexColor(bc);
//
//				String guiColor = getParameter("guicolor");
//				if (guiColor != null) {
//					this.setUserInterfaceBackgroundColor(guiColor);
//				}
//
//				String guiAtomColor = getParameter("guiAtomColor");
//				if (guiAtomColor != null) {
//					this.setLeftMenuAtomColor(guiAtomColor);
//				}
//
////				String starColorPar = getParameter("markerIconColor");
////				if (starColorPar != null) {
////					this.setStarColor(starColorPar);
////
////				}
//
//				String atomCircleRelativeSizeString = getParameter("atombgsize");
//				if (atomCircleRelativeSizeString != null) {
//					atomBGcircleRelativeSize = Double.valueOf(atomCircleRelativeSizeString);
//					if (atomBGcircleRelativeSize < 0)
//						atomBGcircleRelativeSize = defaultAtomBGcircleRelativeSize;
//				}
//				String bondRectangleRelativeSizeString = getParameter("bondbgsize");
//				if (bondRectangleRelativeSizeString != null) {
//					bondBGrectRelativeSize = Double.valueOf(bondRectangleRelativeSizeString);
//					if (bondBGrectRelativeSize < 0)
//						bondBGrectRelativeSize = defaultBondBGrectRelativeSize;
//				}
//
//				if (showAtomNumbers)
//					showAtomNumbers();
//
//				String jsFunction = getParameter("notify_structural_change_js_function");
//				this.setNotifyStructuralChangeJSfunction(jsFunction);
//				
//				this.handleAddiitonalParameters();
//
//			} catch (Exception e) {
//				System.err.println("JME:  parameters error");
//			}
//		}

		action = ACTION_BOND_SINGLE; // musi to tu but, inak nic

		// get gif icons
		// Toolkit toolkit = Toolkit.getDefaultToolkit();
		// infoImage =
		// toolkit.getImage(getClass().getResource("jmeimages/info.gif"));

		// negraficka inicializacia
		// atomicData();

		// 2002.06
		validate();

		// BB
		if (this.canMultipleUndo) {
			this.molChangeManager = new ChangeManager<SavedState>();
			this.postSave(); //no effects because mol is not part of the array molparts
			// and because it has no atoms
		}

	}

	/*
	 * 
	 * For subclassses
	 */
	protected void handleAddiitonalParameters() {
		
	}
	// the cache is useful for JSME when there are many instance in depict mode for
	// performance reason
	// stringWidht is expensive, the JSAppplet implementation has a cache inside
	// each font metric instance
	public static final int maxFontSize = 100;
	public static Font[] atomDrawingAreaFontCache = new Font[maxFontSize];
	public static FontMetrics[] atomDrawingAreaFontMetCache = new FontMetrics[maxFontSize];

	public static Font[] atomMapDrawingAreaFontCache = new Font[maxFontSize];
	public static FontMetrics[] atomMapDrawingAreaFontMetCache = new FontMetrics[maxFontSize];

	public void initatomDrawingAreaFont(float realFs) {
		int fs = Math.round(realFs);
		if (fs < maxFontSize) {
			if (atomDrawingAreaFontCache[fs] == null) {
				atomDrawingAreaFontCache[fs] = new Font(defaultFontFamily, Font.PLAIN, fs);
			}
			if (atomDrawingAreaFontMetCache[fs] == null) {
				atomDrawingAreaFontMetCache[fs] = getFontMetrics(atomDrawingAreaFontCache[fs]);
			}

			this.atomDrawingAreaFont = atomDrawingAreaFontCache[fs];
			this.atomDrawingAreaFontMet = atomDrawingAreaFontMetCache[fs];
		} else {
			assert (false);

		}

		int fsAtomMap = (int) Math.round(realFs * 0.8);
		if (fsAtomMap < maxFontSize) {
			if (atomMapDrawingAreaFontCache[fsAtomMap] == null) {
				atomMapDrawingAreaFontCache[fsAtomMap] = new Font(defaultFontFamily, Font.PLAIN, fsAtomMap);
			}
			if (atomMapDrawingAreaFontMetCache[fsAtomMap] == null) {
				atomMapDrawingAreaFontMetCache[fsAtomMap] = getFontMetrics(atomMapDrawingAreaFontCache[fsAtomMap]);
			}

			this.atomMapDrawingAreaFont = atomMapDrawingAreaFontCache[fsAtomMap];
			this.atomMapDrawingAreaFontMet = atomMapDrawingAreaFontMetCache[fsAtomMap];
		} else {
			assert (false);

		}

	}

	public void setAtomDrawingAreaFontSize(float fs) {
		if (this.atomMolecularDrawingAreaFontSize != fs && fs > 0 && fs < maxFontSize) {
			this.atomMolecularDrawingAreaFontSize = fs;
			initatomDrawingAreaFont(fs);
			this.drawMolecularAreaRightNow();
		}
	}

	
	public SupportedFileFormat getCopyToClipboardFormat() {
		return this.clipboardFormat;
	}
	public void setCopyToClipboardFormat(SupportedFileFormat format) {
		this.clipboardFormat = format;
	}

	// ----------------------------------------------------------------------------
	private Color parseHexColor(String hex) {
		return this.colorManager.parseHexColor(hex);
	}

	// ----------------------------------------------------------------------------
//	@Override
	public void start() {
		// System.err.println("start");
		// cita molekuly (uz by malo poznat dimension)
		// addNotify(); // ??? nekompatibilne z mipc
		// dimension = getSize(); //already done in init()
		// log("start: " + dimension.width + " " + dimension.height);
	    dimension = getSize();

		// no repaint because the applet viewer will call repaint() after start()
		// this was changed because the molecule is always loaded with a GWT.runasync
		boolean repaint = true; 
		
		//this.postSave(); //June 2021

		if (jmeString != null) {
			readMolecule(jmeString, repaint); 
			// co s coloring multipart a reactions ???
			// only 1 coloring scheme (atoms || bg) may be applied
			if (atomBgColors != null && activeMol != null)
				activeMol.setAtomColors(atomBgColors, 0);
//			if (atomColors != null && activeMol != null)
//				activeMol.setAtomColors(atomColors, false);
			this.postSave(); //June 2021

		} else if (molString != null) {
			readMolFile(molString, repaint); // coloring tam //no repaint because the applet viewer will call repaint()
											// after start()
			this.postSave(); //June 2021

		}
		// else if (smiles != null) readSmiles(smiles);
		// toto musi byt after vytvotrenie mol, aby bolo dimenzovane

		else if (genericChemicalInputFromInit != null && this.useOpenChemLib) {

			// with a local or global instance of RunAsyncCallback, then code split does not
			// work
			// this.read_MOL_SDF_RXN(smilesString, null); // works also

			// async conversion with open chemlib
			// redraiwng the molecular area will be performed by the async call
			// after the OCL code is loaded and the smiles converted to MOL
			this.setMustRedrawMolecularArea(false); // the function calling this function will call paint in parallel,
													// DOES NOT WORK test_depict_many_smiles_in_table.html
			//this.handleReadGenericInput(genericChemicalInputFromInit, null, repaint, false); // will call paint to redraw the
			// June 2021: last argument set to true to endure undo stack state is added																	// molecular area after the smiles
			this.handleReadGenericInput(genericChemicalInputFromInit, null, repaint, true); // will call paint to redraw the
																					// has been decoded
		}

	}

	private boolean isPostInitialized = false;
	/**
	 * Perform postinitalization after the editor is completely initialized
	 * SMILES has been read and is ready to be edited
	 * @return
	 */
	private void postInitializeIfNeeded() {
		if (! this.isPostInitialized) {
			this.isPostInitialized = true; // aboid infinite loop
			this.postInitialize();
		}
	}
	
	protected void postInitialize() {

	}
	
//	@Override
//    public void repaint() {
//        super.repaint();
//        this.postInitializeIfNeeded();
//    }

	// ----------------------------------------------------------------------------
	public void stop() {
		// System.err.println("stop");
		if (smilesBox != null)
			smilesBox.dispose();
		if (atomxBox != null)
			atomxBox.dispose();
		if (aboutBox != null)
			aboutBox.dispose();
		if (queryBox != null)
			queryBox.dispose();
		//moleculeParts = null; // memory leak ?
		
	}

	// ----------------------------------------------------------------------------
	// --- public functions
	// -------------------------------------------------------
	// ----------------------------------------------------------------------------
	// for JavaScript to establish connection with JME
	public void ping() {
	}

	// ----------------------------------------------------------------------------
	public String smiles() {
		String smiles;
		try {
			smiles = Smiles();
		//this.mustRedrawNothing(); //BB - info will be redrawed if changed
		} catch(Exception e) {
			this.info(e.getMessage());
	
			return null;
		}
			
		




		//mol.touchedAtom = 0;
		//mol.touchedBond = 0;

		//BB why repaint???
		//repaint(); // aby ked je chyba v smilesi (stereo) aby sa objavilo info
		//transaltion form google: so that when the error is in the SMILES (stereo) to appear Info


		return smiles;
	}

	
	// ----------------------------------------------------------------------------
	/**
	 * Compute and update the reactions roles for each molecule
	 * @return the index (0 based) of the first molecule that has a different reaction role or -1 if no changes
	 */
	protected int updateReactionRoles() {
		
		moleculePartsList.isReaction = reaction;
		int firstChangedIndex = -1;
		
		if(reaction) {
			for( JMEmol mol : moleculePartsList) {
				
				int previousRole = mol.getReactionRole();
				int newRole = this.computeReactionRole(mol);
				
				mol.setReactionRole(newRole);
				
				if(firstChangedIndex == -1 && newRole != previousRole) {
					firstChangedIndex = moleculePartsList.indexOf(mol);
				}
				
			}
		}
		
		return firstChangedIndex;
	}
	
	/**
	 * Find the reaction roles in the JME canvas based on my relative position to the reaction arrow
	 * @return ReactionRole, 
	 */
	protected int computeReactionRole(JMEmol mol) {
		if(mol.nAtoms() == 0) {
			return ReactionRole.NOROLE;
		}
		Box bbox = mol.computeBoundingBoxWithAtomLabels();
//		double middleX = this.getMolecularAreaBoundingBoxCoordinate().getCenterX();
//
//		if (bbox.getCenterX() < middleX - arrowWidth / 2)
//			return ReactionRole.REACTANT;
//		else if (bbox.getCenterX() > middleX + arrowWidth / 2)
//			return ReactionRole.PRODUCT;
//		else
//			return ReactionRole.AGENT;


//		if (bbox.getCenterX() < reactionArrow.centerX())
//			return ReactionRole.REACTANT;
//		else if (bbox.getCenterX() > reactionArrow.centerX())
//			return ReactionRole.PRODUCT;
//		else
//			return ReactionRole.AGENT;

		// May 2020 improvement for the agent
		Box reactionArrowBox = reactionArrow.computeBoundingBoxWithAtomLabels(); 
		if (bbox.getCenterX() < reactionArrowBox.x)
			return ReactionRole.REACTANT;
		else if (bbox.getCenterX() > reactionArrowBox.x + reactionArrowBox.width)
			return ReactionRole.PRODUCT;
		else
			return ReactionRole.AGENT;
		
	}

	// ----------------------------------------------------------------------------
	//?????
	
	public String nonisomericSmiles() {
		boolean originalStereo = stereo;
		stereo = false;
		String smiles = Smiles();
		stereo = originalStereo;
		//BB: I commented the line below
		//repaint(); // aby ked je chyba v smilesi, aby sa objavilo info
		
		return smiles;
	}

	
	
	
	// ----------------------------------------------------------------------------
	String Smiles() {
		
		this.updateReactionRoles();

		smilesPars.stereo = stereo;
		smilesPars.polarnitro = polarnitro;
		//System.err.println("smilesPars.canonize: " +smilesPars.canonize);
		//System.err.println("# molecules: " + moleculeParts.size());
		//System.err.println("# atoms: " + moleculeParts.get(0).natoms);
		smilesPars.canonize = canonize;
		
		String smiles = moleculePartsList.generateSmilesOrSmirks(smilesPars);
		
		return smiles;
		
	}
	
	/*
	String Smiles() {
		String s;
		if (reaction)
			s = partSmiles(1) + ">" + partSmiles(2) + ">" + partSmiles(3);
		else {
			s = partSmiles(0);
			if (s.length() > 0) {
				molStack.addElement(new JMEmol(mol)); // adding molecule to
				// stack
				// skoci na koniec s molsack pointer
				stackPointer = molStack.size() - 1;
			}
		}
		return s;
	}

	// ----------------------------------------------------------------------------
	String partSmiles(int pp) {
		// vracia multipart smiles, ak pp != 0 (reaction) iba pre tu part
		// neskor pridat sort jednotlivych smilesov (alfanumeric)
		String s = "";
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			if (pp > 0) {
				int p = moleculeParts[m].reactionPart();
				if (p != pp)
					continue;
			}
			//String smiles = moleculeParts[m].createSmilesWithSideEffect();//BB: original SMILES
			String smiles = moleculeParts[m].createSmiles(); //BB: make a copy of the mol and do createSmilesWithSideEffect on it
			if (smiles.length() > 0) {
				if (s.length() > 0)
					s += ".";
				s += smiles; // ta molekula moze byt empty
			}
		}
		return s;
	}
*/
	// ----------------------------------------------------------------------------
	public void reset(boolean repaint) {
		// volane zvonka - vymaze vsetko
		action = ACTION_BOND_SINGLE;
		newMolecule = false;

		clearMyMolecularContent();
		clearInfo();

		molText = null;
		// BB
		resetMolecularAreaScale();

		this.recordAfterStructureChangedEvent(JME.RESET);
		// notifyStructuralChangeToJS(); //recordAfterStructureChangedEvent performs
		// notifyStructuralChangeToJS
		if (repaint)
			repaint();

	}

	public void reset() {
		this.reset(true);
	}

	public void resetMolecularAreaScale() {
		if (this.isFullScreen()) {
			molecularAreaScale = fullScreenScale;
		} else {
			molecularAreaScale = 1.; // ??? ked depict viac molekul po sebe
		}
	}

	public void clearMyMolecularContent() {
		//numberofMoleculeParts = 0;
		// JMEmol.maxMark = 0;
		//actualMoleculePartIndex = 0;
		activeMol = new JMEmol(this, this.moleculeHandlingParameters); // treba
		activeMol.maxMark = 0;
		
		moleculePartsList.removeAll();
		moleculePartsList.add(activeMol);

		molText = null;
		mustReDrawMolecularArea();

	}
	// ----------------------------------------------------------------------------

	public void clear() {
		clear(true);
	}

	// delete the active molecule, reselect the active molecule
	public void clear(boolean recordEvent) {
		// zmaze actualMoleculePartIndex, zmensi pocet molekul, actual bude najvyssia

		action = ACTION_BOND_SINGLE;
		newMolecule = false;
		clearInfo();

		if (moleculePartsList.size() == 0)
			return;

		moleculePartsList.remove(activeMol);
		
		if( moleculePartsList.size() > 0) {
			// Feb 2020: the closes mol to the deleted one becomes the active one
			activeMol = this.findClosestMol(scaleDrawingToScreen(activeMol.centerX()),
					scaleDrawingToScreen(activeMol.centerY()));
		} else {
			activeMol = new JMEmol(this, this.moleculeHandlingParameters);
			activeMol.maxMark = 0;
			moleculePartsList.add(activeMol);
		}
		
		
		// BB
		setMustRedrawMolecularArea(true);

		afterClear = true;

		
		
//		for (int i = actualMoleculePartIndex; i < numberofMoleculeParts; i++) {
//			moleculeParts[i] = moleculeParts[i + 1];
//		}
//		numberofMoleculeParts--;
//		actualMoleculePartIndex = numberofMoleculeParts;
//		if (numberofMoleculeParts > 0)
//			activeMol = moleculeParts[actualMoleculePartIndex]; // kvoli move
//		else {
//			activeMol = new JMEmol(this);
//			activeMol.maxMark = 0;
//		}

		if (recordEvent) {
			this.recordAfterStructureChangedEvent(JME.CLEAR);
			// this.notifyStructuralChangeToJS(); //recordAfterStructureChangedEvent calls
			// notifyStructuralChangeToJS
		}
		// Jan 2016
		// this.postSave();

	}

	// ----------------------------------------------------------------------------
	public String jmeFile() {
		// returns molecule(s) in jme format
		
		this.updateReactionRoles();
		
		String result = moleculePartsList.generateJMEstring(false, this.computeMoleculeEnsembleCoordinate2DboundingBox());
		
		return result;
		/*
		String s = "";
		if (reaction)
			s = partJme(1) + ">" + partJme(2) + ">" + partJme(3);
		else
			s = partJme(0);
		return s;
		*/
	}

	// ----------------------------------------------------------------------------
//	String partJme(int pp) { // what is pp?
//		// vracia multipart jme, ak pp != 0 (reaction) iba pre tu part
//		// neskor pridat sort jednotlivych smilesov (alfanumeric)
//		String s = "";
//		for (JMEmol mol: moleculePartsList) {
//			if (pp > 0) {
//				int p = mol.reactionPart();
//				if (p != pp)
//					continue;
//			}
//			String jme = mol.createJME();
//			if (jme.length() > 0) {
//				if (s.length() > 0)
//					s += "|";
//				s += jme; // ta molekula moze byt empty
//			}
//		}
//		return s;
//	}

	// ----------------------------------------------------------------------------
//	int[][] getReactionParts() {
//		// returns fields of indices for reactants, products and modulators
//		int part[][] = new int[JMEmol.ReactionRole.all.length + 1][numberofMoleculeParts + 1];
//		for (int p : JMEmol.ReactionRole.all) { // role loop
//			int np = 0;
//			int m = 0;
//			for (JMEmol mol: moleculePartsList) {
//				if (mol.reactionPart() == p)
//					part[p][++np] = m;
//				m ++;
//			}
//			part[p][0] = np;
//		}
//		return part;
//	}

	// ----------------------------------------------------------------------------
	// NOT USED OR TESTED TO BE DELETED
//	JMEmol[] getMergedReactionParts() {
//
//		JMEmol results[] = new JMEmol[JMEmol.ReactionRole.maxRole + 1];
//
//		int parts[][] = getReactionParts();
//
//		for (int role : JMEmol.ReactionRole.all) { // role loop
//			JMEmol toMerge[] = new JMEmol[parts[role].length];
//			for (int mol : parts[role]) {
//				toMerge[mol] = moleculeParts[mol];
//			}
//			results[role] = new JMEmol(this, toMerge, toMerge.length);
//		}
//		return results;
//	}

	/**
	 * Compare two reaction parts array and returns the first molecule index that
	 * has changed its reaction role or 0 if no changed. This method is useful to
	 * generate an event when one of the molecules has been moved and consequently
	 * its reaction role has changed
	 * 
	 * @param parts1
	 * @param parts2
	 * @return the molecule index or 0
	 */
//	int findFirstMoleculeIndexWithDifferentReactionRole(int[][] parts1, int[][] parts2) {
//		// the arguments are computed by getReactionParts()
//		// if(Arrays.equals(parts1, parts2)) //does not work: doesn't go deep
//		// return 0;
//		for (int role = 1; role <= 3; role++) {
//			if (Arrays.equals(parts1[role], parts2[role]))
//				continue;
//			int n1 = parts1[role][0];
//			int n2 = parts1[role][0];
//			assert (n1 == n2); // see getReactionParts()
//			for (int i = 1; i <= n1; i++) {
//				if (parts1[role][i] != parts2[role][i]) {
//					if (parts1[role][i] == 0) {
//						return parts2[role][i];
//					} else {
//						return parts1[role][i];
//					}
//				}
//			}
//
//		}
//		return 0;
//	}

	/**
	 * Useful to find the max atom map of e.g. all reactants
	 * 
	 * @param moleculeParts
	 * @param whichMolecules
	 * @return
	 */
	int findMaxAtomMapOfMoleculeParts(JMEmolList moleculeParts, int reactionRole) {

		this.updateReactionRoles();
		return moleculeParts.findMaxAtomMap(reactionRole);

//		int max = 0;
//		int[][] allReactionParts = getReactionParts();
//		int[] reactionPartsWithRole = allReactionParts[reactionRole];
//		for (int i = 1; i <= reactionPartsWithRole[0]; i++) {
//			int m = moleculeParts[reactionPartsWithRole[i]].geMaxAtomMap();
//			if (m > max)
//				max = m;
//
//		}
//
//		return max;
	}

	/**
	 * Read a molecule string in JME format
	 * 
	 * @param molecule
	 * @param repaint
	 */
	public boolean readMolecule(String molecule, boolean repaint) {
		boolean success;
		try {
			if (success = this.handleReadMolecule(molecule, repaint)) {

			} else {
				repaint(); // to show errors
			}
		} catch (Exception e) {
			success = false;
			repaint(); // for showing the error
		}

		return success;
	}

	/**
	 * Read a molecule string in JME format
	 * 
	 * @param molecule
	 */
	public void readMolecule(String molecule) {
		this.readMolecule(molecule, true);
	}

	// Read a molecule or reaction in JME format
	// this code is almost never used and is problably buggy because it was not
	// tested
	// especialy molecule align
	// ----------------------------------------------------------------------------
	// makos
	protected boolean handleReadMolecule(String molecule, boolean repaint) {
	
		//duplicated code, a pointer to a function would solve the problem?
		JMEmolList inputMolList = new JMEmolList();
		boolean success = inputMolList.readJMEstringInput(molecule, this.moleculeHandlingParameters);
		if(success && !inputMolList.isReallyEmpty()) {
			this.processIncomingMolecules(inputMolList, repaint);
		}
		
		return success;

		
		// spracuva aj multipart a reactions (aj chybu R>P miesto R>>P)
		// input v JME format

		// this.postSave();

		// reset(repaint); //BB : cancel this: it set numberofMoleculeParts to 0
//		int lastReactant = 0, firstProduct = 0;
//
//		StringTokenizer st = new StringTokenizer(molecule, "|>", true);
//		boolean inputIsReaction = (molecule.indexOf(">") > -1); // false meas it is a molecule
//		int rx = 1; // pocita >
//
//		int nt = st.countTokens();
//		boolean addedToExistingParts = numberofMoleculeParts > 0;
//		if (!canBeAddedToExistingMultipartOrReaction() || inputIsReaction) {// if reaction input: replace evrything
//			numberofMoleculeParts = 0;
//			addedToExistingParts = false;
//		}
//
//		for (int i = 1; i <= nt; i++) {
//			String s = st.nextToken();
//			s.trim();
//			if (s.equals("|"))
//				continue;
//			if (s.equals(">")) {
//				rx++;
//				if (rx == 2)
//					lastReactant = numberofMoleculeParts;
//				else if (rx == 3)
//					firstProduct = numberofMoleculeParts + 1;
//				continue;
//			}
//			activeMol = new JMEmol(this, s, true);
//			if (activeMol.natoms == 0) {
//				this.showError("problems in reading/processing molecule !");
//				System.err.println("ERROR while processing\n" + s);
//				// continue;
//				return false; // BB
//			}
//			// vsetko ok - preberie ju do editora
//			numberofMoleculeParts++; // moze byt aj multipart
//			actualMoleculePartIndex = numberofMoleculeParts;
//			moleculeParts[numberofMoleculeParts] = activeMol;
//			// newMolecule = false;
//			smol = null; // kvoli undo
//
//		}
//
//		// --- chyba v zadani reakcie (zly pocet >)
//		if (rx == 2) {
//			firstProduct = lastReactant + 1;
//			this.showError("strange reaction - fixing !");
//			System.err.println("ERROR - reactant and product should be separated by >>\n");
//			return false;
//		} else if (rx > 3) {
//			this.showError("strange reaction !");
//			System.err.println("ERROR - strange reaction !\n");
//			return false;
//		}
//
//		// FIXME: duplicate code with reading MOL/RXN?
//		if (numberofMoleculeParts > 1 && !inputIsReaction)
//			options("multipart");
//		if (inputIsReaction && !reaction)
//			reaction = true;
//		// if (!inputIsReaction && reaction && !addedToExistingParts)
//		// reaction=false;; //back to mol editing
//
//		if (!inputIsReaction) {
//			// BB: align only if needed to avoid overlap, otherwise keep original
//			// coordinates but scale if needed -does not seem to wotk
//			if (!reaction) {
//				if (isDepict()) {
//					// new simplified method that can handle multiple fragments
//					molecularAreaScale = this.scaleAndCenterForDepictMode();
//				} else {
//					alignMolecules(1, numberofMoleculeParts, 0, !addedToExistingParts);
//				}
//			}
//		} else {
//			if (!addedToExistingParts) { // aligh with one extra mol : todo correctly
//				alignMolecules(1, lastReactant, 1);
//				alignMolecules(lastReactant + 1, firstProduct - 1, 2);
//				alignMolecules(firstProduct, numberofMoleculeParts, 3);
//			}
//		}
//
//		// BB
//		this.setMaxMapAfterReadingInput();
//		this.recordAfterStructureChangedEvent(JME.READ_JME);
//		this.afterStructureChangeEvent.setOrigin_API();
//
//		this.setMustRedrawMolecular(true);
//
//		// BB oct 2019
//		if (this.depict) {
//			molecularAreaScale = this.scaleAndCenterForDepictMode();
//		}
//
//		if (repaint)
//			repaint();
//		// this.recordAfterStructureChangedEvent(JME.READ_JME); //added June 2016
//		// removed Aug 2016 because this will be done by the method calling this one
//
//		return true;
	}

	public void showError(String errorMessage) {
		this.showInfo("ERROR - " + errorMessage);

	}

	// ----------------------------------------------------------------------------
	// adding template from JavaScript
	// template menu is actually JME string
	public void setTemplate(String t, String name) {
		// clear();
		afterClear = false; // otherwise problems in undo
		MoleculeHandlingParameters pars = new MoleculeHandlingParameters();
		pars.mark = true; //needed otherwise the atom map will be ignored
		//boolean savedStar = this.moleculeHandlingParameters.mark; // BB
		//this.moleculeHandlingParameters.mark = true; // BB to avoid a side effect linked to atom mapping (marked atom)
		try {
			templateMolecule = new JMEmol(this, t, true, pars);
			templateMolecule.internalBondLengthScaling(); //June 2020: JMEmol does not do it automatically. SHould be a parameter rom readJMEstringInput?
		} catch (Exception e) {
			// TODO Auto-generated catch block
			//e.printStackTrace();
			info(e.getMessage());
			return;
		} // defined globally
		//this.moleculeHandlingParameters.mark = savedStar; // BB - restore
		// templateMolecule.complete(); //BB: not needed because the call above does
		// call complete()
		// now waiting for atom or free space click
		action = ACTION_GROUP_TEMPLATE;

		// mol.center();
		// numberofMoleculeParts = 1; actualMoleculePartIndex = 1; moleculeParts[1] =
		// mol;

	// TODO
		// check if the the template has a marked atom or atom map, otherwise, show a message
		
		if (! templateMolecule.hasMappedOrMarkedAtom()) {
			// console warning
			showError("template molecule has no mapped atom");
			
		} else {
			info(name);
		}
		repaint(); // needed to display status line
	}

	public void setUserInterfaceBackgroundColor(Color bgColor) {
		this.bgColor = bgColor;
		this.brightColor = this.bgColor.brighter();
		this.redrawEverything();
	}
	public void setLeftMenuAtomColor(Color color) {
		this.leftMenuAtomColor = color;
		this.redrawEverything();
	}

	/**
	 * Choose another background color for the GUI frame and the dialog boxes
	 * 
	 * @param bgColor : string like #FFFBBCC
	 */

	public void setUserInterfaceBackgroundColor(String hexColor) {
		this.setUserInterfaceBackgroundColor(this.parseHexColor(hexColor));
	}
	
	/**
	 * Same color for all atoms of the left menu, e.g. black
	 * @param hexColor
	 */
	public void setLeftMenuAtomColor(String hexColor) {
		if( color != null && color.length > 5)
			this.setLeftMenuAtomColor(this.parseHexColor(hexColor));
		else 
			this.setLeftMenuAtomColor((Color)null);

	}


	/**
	 * not for reaction
	 * 
	 * @return
	 */
//	double scaleAndCenterForDepictMode(JMEmolList molList) {
	double scaleAndCenterForDepictMode(Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList) {

		// when reading a molfile and creating a JMEmol, the compound is already
		// internally scaled
		// such that its average bond length is equal the RBOND

		double scaleToFit = this.molecularAreaScale;

		double margin = JMEmol.RBOND;

		Rectangle2D.Double cdbb = getChemicalDrawingBoundingBox(graphicalObjecList); // is empty if no molecules
		Rectangle2D.Double mabb = getMolecularAreaBoundingBox();

		if (cdbb.isEmpty() || mabb == null || mabb.getWidth() == 0 || mabb.getHeight() == 0) {
			return scaleToFit; // no change
		}

		double ratioWidth = mabb.getWidth() / (cdbb.getWidth() + margin);
		double ratioHeight = mabb.getHeight() / (cdbb.getHeight() + margin);

		if (ratioWidth == 0 || ratioHeight == 0) {
			return scaleToFit;
		}

		// first case: the molecule is too big
		if (ratioWidth <= 1 || ratioHeight <= 1) {
			scaleToFit = Math.min(ratioWidth, ratioHeight);
			// shrink
		} else {
			scaleToFit = 1.0; // no need to increase the size because of internal bond scaling
		}

		
		centerAllMoleculesAsAgroup(graphicalObjecList, this.dimension, this.menuScale, scaleToFit);

		return scaleToFit;
	}

	/**
	 * New BB method developed for SMIRKS INPUT molecules internal scaling must have
	 * been performed based on JMEmol.RBOND the reactionRole will determine if the
	 * molecules must be aligned horizontally of vertically Assume that the size of
	 * the drawing canvas is infinite
	 * 
	 * @param m1 0 based
	 * @param m2 0 based
	 * @param reactionRole
	 */
	void alignAndDistributeMolecules(int m1, int m2, int reactionRole) {
		int nm = m2 - m1 + 1;
		if (nm <= 0 || m1 >= moleculePartsList.size() || m2 >= moleculePartsList.size())
			return;

		double spaceBetweenMolecules = JMEmol.RBOND;

		double lastMove = 0;

		for (int i = m1; i <= m2; i++) {
			JMEmol mol = moleculePartsList.get(i);
			Rectangle2D.Double moleculeBox = mol.computeBoundingBoxWithAtomLabels();
			double dx = moleculeBox.x * -1;
			double dy = moleculeBox.y * -1;

			if (reactionRole != JMEmol.ReactionRole.AGENT) {
				dx -= moleculeBox.getWidth() / 2;
				dy += lastMove;
				lastMove += moleculeBox.getHeight();

			} else {
				dy -= moleculeBox.getHeight() / 2;
				dx += lastMove;
				lastMove += moleculeBox.getWidth();

			}

			mol.moveXY(dx, dy);

			lastMove += spaceBetweenMolecules;
		}

	}

	/**
	 * 
	 * @param m1           0 based
	 * @param m2           0 based
	 * @param reactionRole ??
	 */
	void alignMolecules(int m1, int m2, int reactionRole) {
		alignMolecules(m1, m2, reactionRole, false);
	}

	// --------------------------------------------------------------------------
	// BB side effects: compute the depictScale correctly for only one time if it is
	// different than 1.0
	// recenter molecule in depict mode
	// m1 and m2 are indices of the molecules in molecularParts: align molecules m1
	// to m2 inclusive
	void alignMolecules(int m1, int m2, int reactionRole, boolean donotAlignJustScale) {

		if (nocenter)
			return; // aj pre depict ???
		int nm = m2 - m1 + 1;
		if (nm <= 0 || m1 >= moleculePartsList.size() || m2 >= moleculePartsList.size())
			return;
		// double previousDepictScale = molecularAreaScale;

		// double center[] = new double[4];

		double RBOND = JMEmol.RBOND;
		double[] share = new double[99]; // share na 1 mol (used pri posune)
		double sumx = 0., sumy = 0., maxy = 0.;
		for (int i = m1; i <= m2; i++) {
			if (moleculePartsList.get(i).nAtoms() == 0)
				continue; // boundingBox() returns null if no atoms
			Rectangle2D.Double moleculeBox = moleculePartsList.get(i).computeBoundingBoxWithAtomLabels(); // zisti dimenzie
			sumx += moleculeBox.getWidth();// center[2]; //width of mol
			sumy += moleculeBox.getHeight(); // ; //height of mol
			maxy = Math.max(maxy, moleculeBox.getHeight());

			share[i] = moleculeBox.getWidth();
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				share[i] = moleculeBox.getHeight();
		}

		// prida medzery (na oboch stranach a medzi), pri !depict to netreba
		if (isDepict()) {
			sumx += RBOND * (nm + 1); // add enough space between molecules
			sumy += RBOND * (nm + 1);
			maxy += RBOND; // malo by byt * 2, ale potom su velke okraje
		}

		double scalex = 1., scaley = 1.;

		// compute the size of the available display box for the molecular area
		Rectangle2D.Double widhtAndHeight;
		if (isDepict()) // in depict mode, the scale will be recomputed, therefore we use the original
						// size
			widhtAndHeight = this.getMolecularAreaBoundingBox();
		else
			widhtAndHeight = this.getMolecularAreaBoundingBoxCoordinate();

		int xsize = (int) widhtAndHeight.width;
		int ysize = (int) widhtAndHeight.height;

		if (reactionRole == JMEmol.ReactionRole.REACTANT || reactionRole == JMEmol.ReactionRole.PRODUCT)
			xsize = (xsize - arrowWidth) / 2;
		else if (reactionRole == JMEmol.ReactionRole.AGENT)
			ysize = ysize / 2;

		if (sumx >= xsize)
			scalex = (xsize) / sumx;
		if (maxy >= ysize)
			scaley = (ysize) / maxy;

		double space = 0.;
		if (isDepict()) { // cize == 1.
			molecularAreaScale = Math.min(scalex, scaley); // inak dS = 1.
			log("alignMolecules Depict: molecularAreaScale=" + molecularAreaScale + " xsize=" + xsize + " ysize="
					+ ysize + "\n");
			space = RBOND * xsize / sumx;
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				space = RBOND * ysize / sumy;

		}

		for (int i = m1; i <= m2; i++) {
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				share[i] = share[i] * ysize / sumy; // share[i] was the y size of the molecule
			else
				share[i] = share[i] * xsize / sumx;// share[i] was the x size of the molecule
		}

		double shiftx = -xsize / 2.;
		double shifty = 0.;
		if (reactionRole == JMEmol.ReactionRole.REACTANT)
			shiftx = -xsize - arrowWidth / 2.;
		else if (reactionRole == JMEmol.ReactionRole.PRODUCT)
			shiftx = arrowWidth / 2.;
		else if (reactionRole == JMEmol.ReactionRole.AGENT) {
			shiftx = 0.;
			shifty = -ysize;
		} // preco nie ..+2*sd ???

		for (int i = m1; i <= m2; i++) {

			// ??? toto sposobuje problemy depictScale = 0 ???
			if (isDepict()) { // pri depicte zmensuje
				// assert(false);
				if (!scalingIsPerformedByGraphicsEngine) {
					moleculePartsList.get(i).scaleXY(molecularAreaScale);
				}
				moleculePartsList.get(i).center(); // Once again, now reduced
			}

			// pri depict urobi aj medzeru
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				shifty += (share[i] / 2. + space);
			else
				// part == JMEmol.ReactionRole.REACTANT, JMEmol.ReactionRole.PRODUCT, or 0
				shiftx += (share[i] / 2. + space);

			// BB correction afterwards, otherwise the shiftx and shifty are too small
//			if(this.scalingIsPerformedByGraphicsEngine) {
//				shiftx /= depictScale;
//				shifty /= depictScale;
//			}

			if (!donotAlignJustScale) { // bad patch to fix a bug
				moleculePartsList.get(i).moveXY(shiftx, shifty);
				// for (int a = 1; a <= moleculeParts[i].natoms; a++) {
				// moleculeParts[i].moveXY(a, shiftx, shifty);
				// moveXY(moleculeParts[i],a, shiftx, shifty);
				// moleculeParts[i].x(a) += shiftx;
				// moleculeParts[i].y(a) += shifty;
				// }
			}

			if (reactionRole == JMEmol.ReactionRole.AGENT)
				shifty += share[i] / 2.;
			else
				shiftx += share[i] / 2.;

		}

		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// BB correction: the depictScale must be absolute
		// molecularAreaScale *= previousDepictScale; //used with iPad scaling
	}

	/**
	 * compute the space needed to display the molecular structures in the molecular
	 * area return null if there is nothing displayed includes the reaction arrow if
	 * present
	 * 
	 * @return
	 */
	public Box getChemicalDrawingBoundingBox(Graphical2DObjectGroup<?> graphicalObjecList) {

		Box boundingBox = graphicalObjecList.newBoundingBox();

		// leave a margin around the molecule
		double margin = (double) JMEmol.RBOND / 2;

		if (boundingBox != null && !boundingBox.isEmpty()) {
			boundingBox.x -= margin;
			boundingBox.y -= margin;
			boundingBox.width += margin * 2;
			boundingBox.height += margin * 2;
		}

		return boundingBox;
	}

	/**
	 * Molecule ensemble bounding box atom label size not taken into account
	 * @return
	 */
	public Box computeMoleculeEnsembleCoordinate2DboundingBox() {
		return this.moleculePartsList.computeCoordinate2DboundingBox();
	}
	
	public Boolean isMolecularAreEmpty() {
		for (JMEmol mol: moleculePartsList) {
			if (mol.natoms > 0)
				return true;
		}

		return false;

	}

	public boolean hasMarkedAtom() {
		return this.moleculePartsList.hasMarkedAtom();
	}

	/**
	 * compute the maximum scale that can be used to fit all objects in the
	 * molecular drawing area
	 * 
	 * return -1 if there is nothing to display
	 */
	public double maximumScaleDisplayArea(Dimension appletDimension, double menuScale) {
		Rectangle2D.Double boundingBox = getChemicalDrawingBoundingBox(this.graphicalObjectList());

		if (boundingBox == null)
			return -1;

		Rectangle2D.Double molecularAreaBox = this.getMolecularAreaBoundingBoxPixel(appletDimension, menuScale);

		double maxScale = Math.min(molecularAreaBox.width / boundingBox.width,
				molecularAreaBox.height / boundingBox.height);

		return maxScale;

	}

	protected Graphical2DObjectGroup<Graphical2DObject> graphicalObjectList(JMEmolList molList) {
		Graphical2DObjectGroup<Graphical2DObject> results = 
				new Graphical2DObjectGroup<Graphical2DObject>();
		
		for(JMEmol mol: molList) {
			results.add((Graphical2DObject)mol);
		}
		if (reaction) {
			results.add((Graphical2DObject) reactionArrow);
		}
		
		return results;
	}	
	
	protected Graphical2DObjectGroup<Graphical2DObject> graphicalObjectList() {
		
		return this.graphicalObjectList(this.moleculePartsList);
	}

	// --------------------------------------------------------------------------
	/**
	 * Create a V2000 MOL
	 * 
	 * @return
	 */
	public String molFile() {
		return this.molFile(false);
	}

	public String molFile(boolean isV3000) {
		return this.molFileOrRxn(null, true, isV3000, exportRXNmergeOption);
	}

	public String molFile(MolFileOrRxnParameters pars) {
		
		if (pars.debugDoNotUpdateReactionRole) {
			moleculePartsList.isReaction = true;;
		} else {
			this.updateReactionRoles();
		}
				
		return moleculePartsList.generateMolFileOrRxn(pars);
	
	}
	
	public String molFileOrRxn(final String header_, final boolean stampDate_, final boolean isV3000_,
			boolean mergeReationComponents) {

		MolFileOrRxnParameters pars = new MolFileOrRxnParameters() {
			{
				header = header_; // 1st line of the MOL
				stampDate = stampDate_;
				isV3000 = isV3000_;
				mergeReationComponents = exportRXNmergeOption;
			}
		};

		return this.molFile(pars);

//		// creates mol file, multipart sd file or reaction (rxn file)
//
//		if (header == null) {
//			header = smiles(); // now, otherwise for multipart cuts them
//		}
//
//		String s = "";
//		if (reaction) {
//			int nReactants;
//			int nProducts;
//			int nAgents;
//			int part[][] = getReactionParts();
//			if (mergeReationComponents) {
//				nReactants = 1;
//				nProducts = 1;
//				nAgents = 1;
//			} else {
//				nReactants = part[JMEmol.ReactionRole.REACTANT][0];
//				nProducts = part[JMEmol.ReactionRole.PRODUCT][0];
//				nAgents = part[JMEmol.ReactionRole.PRODUCT][0];
//
//			}
//
//			s += "$RXN" + separator + separator + separator + "JME Molecular Editor" + separator;
//			s += JMEmol.iformat(nReactants, 3) + JMEmol.iformat(nProducts, 3);
//			if (part[2][0] > 0) { // if agents are present
//				s += JMEmol.iformat(nAgents, 3);
//			}
//			s += separator;
//
//			// reactants products, agents
//			for (int role : new int[] { JMEmol.ReactionRole.REACTANT, JMEmol.ReactionRole.PRODUCT,
//					JMEmol.ReactionRole.AGENT }) {
//				if (mergeReationComponents && part[role][0] > 1) {
//					JMEmol toMerge[] = new JMEmol[part[role][0] + 1];
//					for (int mol : part[role]) {
//						toMerge[mol] = moleculeParts[mol];
//					}
//
//					JMEmol merged = new JMEmol(this, toMerge, toMerge.length);
//					s += "$MOL" + separator + merged.createMolFile(header, stampDate);
//				} else {
//					for (int i = 1; i <= part[role][0]; i++) {
//						s += "$MOL" + separator + moleculeParts[part[role][i]].createMolFile(header, stampDate);
//					}
//				}
//			}
//
//		} else { // viac molekul do 1 mol file
//			if (moleculePartsList.size() > 1)
//				// merge the molecules into one ensemble
//				activeMol = new JMEmol(this, (JMEmol[]) moleculePartsList.toArray(), moleculePartsList.size());
//			if (!isV3000)
//				s = activeMol.createMolFile(header, stampDate);
//			else // BB
//				s = activeMol.createExtendedMolFile(header, stampDate);
//
//			// ???? WHY DOES THIS CHANGE THE IN MEMORY MOL?
//			if (numberofMoleculeParts > 1)
//				activeMol = moleculeParts[actualMoleculePartIndex];
//		}
//		return s;
	}

	// --------------------------------------------------------------------------

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * 
	 * @param molecule string
	 */
	public void readMolFile(String molecule) {
		readMolFile(molecule, true);
	}

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * 
	 * @param molecule string
	 */
	public void readMolFile(String molecule, boolean repaint) {
		try {
			if (this.handleReadMolFileRXN(molecule, repaint)) {

			} else {
				repaint(); // to show errors
			}
		} catch (Exception e) {
			repaint(); // for showing the error
		}
	}

	/**
	 * Read the molfile and repaint the applet when done
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	protected boolean handleReadMolFile(String s) {
		return handleReadMolFileRXN(s, true);
	}

	/**
	 * repaint and record event
	 * @param s
	 * @param sucessAndFailureHandler
	 */
	public void handleReadGenericInput(final String s, final RunAsyncCallback sucessAndFailureHandler) {
		handleReadGenericInput(s, sucessAndFailureHandler, true, true);
	}

	/**
	 * input can be a MOL, RXN, smiles or SMIRKS or OCL
	 * 
	 * @param s
	 */

	public void handleReadGenericInput(String s, final RunAsyncCallback sucessAndFailureHandler,
			final boolean repaint, final boolean recordEvent) {

		final ChemicalFormatDetector cfd = new ChemicalFormatDetector(s);
		String error = null;
		boolean runAsync = false;
		if (s == null || s.trim().length() == 0) {
			return;
		}
		this.afterStructureChangeEvent.setOrigin_API(); // will not overwrite if already set for instance if the call is coming from the GUI

		clearInfo(); // clear previous error message if any
		String afterStructureChangedEvent = null;
		
		

		do {
			
			if (cfd.majorChemicalFormat == ChemicalFormatDetector.MajorChemicalFormat.SVG
					&& cfd.embeddedChemicalFormat != null) {
				// copy the embedded chemical format to cfd
				cfd.init(cfd.embeddedChemicalFormat);
			}
			if (cfd.author == ChemicalFormatDetector.Author.MDL
					&& cfd.minorChemicalFormat != ChemicalFormatDetector.MinorChemicalFormat.V3000) {
				// bug: handling "|" as a line separator

				// TODO : handleReadMolFileRXN is async because of the 2D coordinate computation
				if (!JME.this.handleReadMolFileRXN(cfd.chemicalString, false)) //will do repaint later after event recording
					error = "Invalid V2000 molfile";
				else {
					afterStructureChangedEvent = cfd.isReaction() ? READ_RXN_FILE : READ_MOL_FILE;
				}
				break;
			}

			if (cfd.author == ChemicalFormatDetector.Author.P_ERTL) {
				if (!readMolecule(cfd.chemicalString, false)) { //will do repaint later after event recording
					error = "Invalid JME string";
				} else {
					afterStructureChangedEvent = READ_JME;
				}
				break;
			}
			if (cfd.author == ChemicalFormatDetector.Author.IUPAC || cfd.majorChemicalFormat == ChemicalFormatDetector.MajorChemicalFormat.CSRML) {
				// GWT: <set-configuration-property name="compiler.enum.obfuscate.names"
				// value="false" /> otherwise the number of the enum is shown instead of its
				// name
				error = "Reading " + cfd.majorChemicalFormat + " is not supported";
				break;
			}
			

			if (this.useOpenChemLib) {
				runAsync = true;
				// code splitting used to run OpenChemlib code
				JMEUtil.runAsync(new JSME_RunAsyncCallback() {

					@Override
					public void onSuccess() {
						String error = null;
						String convertedmolFile = null;
						String afterStructureChangedEvent = null;

						if (cfd.author == ChemicalFormatDetector.Author.MDL
								&& cfd.minorChemicalFormat == ChemicalFormatDetector.MinorChemicalFormat.V3000) {
							try {
								convertedmolFile = JME.this.v3000toV2000MOL(cfd.chemicalString);
								if (convertedmolFile == null) {
									throw new Exception("V3000 read failed.");
								}
								afterStructureChangedEvent = READ_MOL_FILE;
								JME.this.sdfPastedMessage.innnerString = "V3000 conversion provided by OpenChemLib";
							} catch (Exception e) {
								error = e.getMessage();
							}
						} else {
							if (cfd.author == ChemicalFormatDetector.Author.DAYLIGHT) {
								try {
									convertedmolFile = JME.this.SMILESorSMIRKStoMolOrRXN(cfd.chemicalString);
									if (cfd.majorChemicalFormat == MajorChemicalFormat.SMIRKS)
										afterStructureChangedEvent = READ_SMIRKS;
									else if (cfd.majorChemicalFormat == MajorChemicalFormat.SMILES)
										afterStructureChangedEvent = READ_SMILES;

									JME.this.sdfPastedMessage.innnerString = "SMILES conversion provided by OpenChemLib";

								} catch (Exception e) {
									error = "SMILES parsing error:" + e.getMessage();
								}
							} else {
								error = "Invalid or unsupported input";
								if (JME.this.useOclIdCode && cfd.couldBeOclIdCode()) {
									// try to parse OCL if not SMILES
									// ChemicalFormatDetector can not detect OCLcode
									try {
										convertedmolFile = JME.this.OclCodeToMOL(cfd.chemicalString);
										afterStructureChangedEvent = READ_OCLCODE;
										error = null;
									} catch (Exception e) {

									}
								}
							}
						}

						boolean success = false;
						if (convertedmolFile != null && error == null) {
							try {
								success = JME.this.handleReadMolFileRXN(convertedmolFile, false);
								if (success && recordEvent) {
									assert (afterStructureChangedEvent != null);
									JME.this.recordAfterStructureChangedEvent(afterStructureChangedEvent);

								}
							} catch (Exception e) {
								error = "Invalid converted molfile";
							}
						}
						setMustRedrawMolecularArea(success);

						if (sucessAndFailureHandler != null) {
							if (success) {
								sucessAndFailureHandler.onSuccess();
							} else {
								assert (error != null);
								sucessAndFailureHandler.onFailure(new Exception(error));
							}
						} else {
							if (error != null) {
								JME.this.showError(error);
							}

						}
						if (repaint) {
							repaint();
							// drawMolecularAreaRightNow(); //does not work if called from start(),
							// molecularAreaImage is not initialized
						}

					}
				});

				break;
			}

		} while (false);

		if (!runAsync) {
			
			
			if(error == null && recordEvent && afterStructureChangedEvent != null) {
				JME.this.recordAfterStructureChangedEvent(afterStructureChangedEvent); // the event will be fired after the repaint() has completed
			}
				
			// duplicated code with the one inside the runAsync block
			// used for debugging JS code
			setMustRedrawMolecularArea(error == null);
			if (sucessAndFailureHandler != null) {
				if (error == null) {
					sucessAndFailureHandler.onSuccess();
				} else {
					sucessAndFailureHandler.onFailure(new Exception(error));
				}
			} else {
				if (error != null) {
					JME.this.showError(error);
				}

			}
			
			if (error == null && repaint) {
				repaint();
				
			}
		}

	}

	/**
	 * Returns the graphics representation used in the molecular area, either a SVG
	 * or a VML string This is avalailable only in JavaScript implementation
	 * 
	 * @return a string that can be used in a DOM element innerHTML
	 */

	public String getMolecularAreaGraphicsString() {

		return null;
	}

	/**
	 * Read the input structure (all chemical structure formats supported by JSME)
	 * Update the editor display. An event will be reported if successful.
	 * 
	 * @param s
	 */
	// public JSME interface
	public void readGenericMolecularInput(String s) {
		this.readGenericMolecularInput(s, true);
	}

	/**
	 * Read the input structure (all chemical structure formats supported by JSME)
	 * Update the editor display.
	 * @param s
	 * @param recordEvent
	 */
	public void readGenericMolecularInput(String s, boolean recordEvent) {
		this.handleReadGenericInput(s, null, true, recordEvent);
	}

	public String getOclCode() {
		String molFile = this.molFileOrRxn(null, false, true, false);
		return newParser().getOclCode(molFile);
	}

	/**
	 * Generate SVG representation of the molecule Use OpenChem lib SVG generator.
	 * 
	 * @return
	 */
	public String getOclSVG() {
		String molFile = this.molFileOrRxn(null, false, true, false); // use v3000
		return newParser().getOclSVG(molFile);
	}

	/**
	 * Use the openchemlib to convert a OCL code to a molfile string TODO: what
	 * about 2D coordinates?
	 * 
	 * @param oclCode
	 * @return
	 */
	public String OclCodeToMOL(String oclCode) {
		return newParser().OclCodeToMOL(oclCode);
	}

	/**
	 * Use the openchemlib to convert a smiles to a molfile string 2D coordinates
	 * are generated
	 * 
	 * @param smiles
	 * @return
	 * @throws Exception
	 */
	public String SMILEStoMOL(String smiles) throws Exception {
		return newParser().SMILEStoMOL(smiles);
	}

	/**
	 * Use the openchemlib to convert a smirks to a rxn string 2D coordinates are
	 * generated. The individual reaction components are not further split into
	 * molecules (see handleReadMolFileRXN() )
	 * 
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	public String SMIRKStoRXN(String smirks) throws Exception {
		String[] parts = smirks.split(">");
		assert parts.length >= 1 && parts.length <= 3;
		
		// JS and Java behave differently for string split
		// "bla>>" => 3 parts in JS
		//         => 1 part in Java

		// JMEmol newParts[] = mol.splitMultiparts()
		
		boolean hasProducts = parts.length >= 3 && parts[2].length() > 0;
		boolean hasAgents = parts.length >=2 && parts[1].length() > 0;
		
		String reactants = this.SMILEStoMOL(parts[0]);
		
		String products = hasProducts ? this.SMILEStoMOL(parts[2]) : this.SMILEStoMOL("");
		String agents =  hasAgents ? this.SMILEStoMOL(parts[1]) : this.SMILEStoMOL("");

		String s = "";

		s += "$RXN" + separator + separator + separator + "JME Molecular Editor" + separator;
		s += JMEUtil.iformat(1, 3) + JMEUtil.iformat(1, 3);
		if (hasAgents)
			s += JMEUtil.iformat(1, 3);

		s += separator;
		s += "$MOL" + separator + reactants;
		s += "$MOL" + separator + products;
		// not standard
		if (hasAgents)
			s += "$MOL" + separator + agents;

		return s;
	}

	/**
	 * to be completed - used only for the test suite read the modulator as well,
	 * should we (re)use the JME string input code for reaction?
	 * 
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	public boolean readSmirks(String smirks) throws Exception {

		String convertedmolFile = JME.this.SMILESorSMIRKStoMolOrRXN(smirks);

		this.handleReadMolFileRXN(convertedmolFile, false);

		return true;
	}

	/**
	 * Use the openchemlib to convert a V3000 MOL to a V2000 molfile string
	 * 
	 * @param v3000
	 * @return
	 * @throws Exception
	 */
	public String v3000toV2000MOL(String v3000Mol) throws Exception {
		return newParser().v3000toV2000MOL(v3000Mol);
	}

	private Parser newParser() {
		return (Parser) getInterface(parserImpl);
	}

	private Parser getInterface(String name) {
	    try {
	        Class<?> x = Class.forName(name);
	        return (Parser) (x == null ? null : x.newInstance());
	      } catch (Exception e) {
	        System.out.println("Interface.getInterface Error creating instance for " + parserImpl + ": \n" + e);
	        return null;
	      }
	}

	/**
	 * Use the openchemlib to convert a smiles or a smirks to a mol or rxn string 2D
	 * coordinates are generated
	 * 
	 * @param smilesOrsmirks
	 * @return
	 * @throws Exception
	 */
	public String SMILESorSMIRKStoMolOrRXN(String smilesOrsmirks) throws Exception {
		if (smilesOrsmirks.contains(">")) {
			return this.SMIRKStoRXN(smilesOrsmirks);
		} else {
			return this.SMILEStoMOL(smilesOrsmirks);
		}

	}

	/**
	 * Used for testing without GUI
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	public boolean readMolFileOrRXN(String s) {
		return this.handleReadMolFileRXN(s, false);
	}

	boolean canBeAddedToExistingMultipartOrReaction() {
		return ((reaction || multipart) && addNewPart) || newMolecule; // newMolecule is true if NEW button is pushed
	}

	void processIncomingMolecules(final JMEmolList newMolecules, final boolean repaint) {
		
		if( !newMolecules.isReallyEmpty()) {
			
			if (this.moleculeHandlingParameters.internalBondScalingForInput) {
				newMolecules.internalBondLengthScaling();
			}
			
			// Runasync is needed because of 2D computation with openchmlid if the input
			// has no 2D or is 3D
			// Removed because too much added complexity: all calling functions must provide an async callback
			// it would be anyway useless because most of the application stsrts with a molecule in the editor
//			GWT.runAsync(new JSME_RunAsyncCallback() {
//				
//				@Override
//				public void onSuccess() {
					JME.this.processIncomingMolecules(newMolecules);
					if (JME.this.newMolecule) {
						JME.this.newMolecule = false; //addition performed, cancel NEW option
						JME.this.mustReDrawTopMenu = true;
					}
					if(repaint) {
						JME.this.drawMolecularAreaRightNow();
						if (JME.this.mustReDrawTopMenu) {
							JME.this.drawTopMenu(getGraphics());
						}
						
					}
					
				}
				
//			});
//			
//		}
		

	}

	
	//caller should check isReallyEmpty() first
	void processIncomingMolecules(final JMEmolList newMolecules) {

		if(newMolecules.isReallyEmpty()) {
			return;
		}
		
				// New Jan 2019
				for(int i = 0; i < newMolecules.size(); i++) {
					JMEmol each = newMolecules.get(i);
					each.jme = this;

					//// HERE USE OCL LIB !!!!!!
					each = newMolecules.reComputeBondOrderIfAromaticBondType(each);
					
					if ( each != null) {
						newMolecules.set(i, each);
					} 

					//// HERE USE OCL LIB !!!!!!
					// Bug: ensemble does not work correctly
					// Feb 2020
					each = newMolecules.compute2DcoordinatesIfMissing(each);
					if (each != null ) {
						newMolecules.set(i, each);
					}
					

				}
				// Feb 2020
				newMolecules.scaleInternalBondMolList();

				if(newMolecules.isReaction()) {
					reaction = true;
					multipart = true;
					
					double spacing = JMEmol.RBOND;
					Graphical2DObjectGroup<Graphical2DObjectGroup<Graphical2DObject>> groups = new Graphical2DObjectGroup<Graphical2DObjectGroup<Graphical2DObject>>();
					
					Graphical2DObjectGroup<Graphical2DObject> agentGroup = null;
					
					for(int role : JMEmol.ReactionRole.all) {
						JMEmolList mols = newMolecules.reactionParts(role);
						
						Graphical2DObjectGroup<Graphical2DObject> group = new Graphical2DObjectGroup<Graphical2DObject>();
						group.addAll(mols.asGroup());
						
						if (role != JMEmol.ReactionRole.AGENT) {
							group.distributePositions(Axis.X, spacing, true);
							group.alignCenter(Axis.Y);
							
						} else {
							
							// reaction agents on top and below the arrow
							int pos = (int) ((0.5 * group.size()) + 0.5);
							group.add(pos, JME.this.reactionArrow);
							group.distributePositions(Axis.Y, spacing, false);
							group.alignCenter(Axis.X);// this is  centering along Y axis
							
							agentGroup = group;
							
						}
					
						groups.add(group);
						
					}
					
					groups.distributePositions(Axis.X, spacing, false);
					groups.alignCenter(Axis.Y); // this is  centering along x axis
					
					// move the agent group such that it is aligned with the center of the two other groups
					assert(agentGroup != null && agentGroup.size() >= 1); // the agent group contains the arrow
					agentGroup.move(Axis.Y, agentGroup.centerY() -  JME.this.reactionArrow.centerY());
					
					//new June 2017: split the reaction components if needed after the alignment is done
					//such that each molecule can be moved individually	
					// the coordinates are not changed
					newMolecules.splitFragments(true);
					
					// addedToExistingMultipartOrReaction is not implemented
					// would be much more complex
					moleculePartsList.removeAll();
					moleculePartsList.addAll(newMolecules);
					
					// For reaction, it is better to scale down if this a big reaction
					JME.this.molecularAreaScale = JME.this.scaleAndCenterForDepictMode(JME.this.graphicalObjectList(JME.this.moleculePartsList));

					
					
					


				} else {
					
					if(isDepict() || pasteFromSDFstack) { //BB let the incoming structure determine the editor mode when in depict mode
						reaction = false;
						//multipart = false;
					}
					boolean addedToExistingMultipartOrReaction = canBeAddedToExistingMultipartOrReaction();
								
					
					if( !addedToExistingMultipartOrReaction) {
						moleculePartsList.removeAll(); //the new parts will not be appended to the moleculeParts[]
						resetMolecularAreaScale(); //could be an option
					}
					

					{
						double scale = isDepict() ? 1.0 : molecularAreaScale; // in depict mode, the scale will be recomputed afterwards
						centerAllMoleculesAsAgroup(JME.this.graphicalObjectList(newMolecules), JME.this.dimension, menuScale, scale);
					}

					if (! isDepict()) { // solve the cross fragment issue with atom highlighting based on atom indices (CT3 chemotyper-like display)
						newMolecules.splitFragments(true); 
					}

					moleculePartsList.addAll(newMolecules); // newMolecules must be internal scaled and centered as a group before addition
				
					if (isDepict() ) {
						// if the molecules are too big to fit => recompute the scale
						JME.this.molecularAreaScale = JME.this.scaleAndCenterForDepictMode(JME.this.graphicalObjectList(JME.this.moleculePartsList));
					}


				}
				
				
				// coloring tu, inak pri multiupart problemy
				moleculePartsList.setAtomBackGroundColors(atomBgColors);
				assert(moleculePartsList.size() > 0);
				activeMol = newMolecules.first();
				
			

	}
	
	/*
	 * the complex stuff
	 */
//	double alignScaleCenter(Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList) {
//		double newMolecularAreaScale = this.molecularAreaScale;
//		if (! reaction) {
//			if (! isDepict()) {
//				centerAllMoleculesAsAgroup(graphicalObjecList, this.dimension, menuScale, molecularAreaScale);
//			} else {
//				// depict mode
//				newMolecularAreaScale = this.scaleAndCenterForDepictMode(graphicalObjecList);
//
//			}
//		
//		}
//		
//		return newMolecularAreaScale;
//	}
	

	/**
	 * generate an afterStructureChangedEvent
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	boolean handleReadMolFileRXN(String s, boolean repaint) {
		
		JMEmolList inputMolList = new JMEmolList();
		boolean success = inputMolList.readMDLstringInput(s, this.moleculeHandlingParameters);
		if(success && !inputMolList.isReallyEmpty()) {
			this.processIncomingMolecules(inputMolList, repaint);
		}
		
		return success;
	}

	public int findMaxAtomMapAmongAllMolecules() {
		
		return moleculePartsList.findMaxAtomMap();
		
	}
	public void setMaxMapAfterReadingInput() {
		int max = this.findMaxAtomMapAmongAllMolecules();
		
		
		// assign the max
		for( JMEmol mol: moleculePartsList) {
			mol.maxMark = max;
		}
		
	}

	// --------------------------------------------------------------------------
	// called from JavaScript menu, sets Rgroup
	public void setSubstituent(String s) {
		// substituent menu
		int pressed = -1;
		if (s.equals("Select substituent")) {
			pressed = ACTION_BOND_SINGLE;
			s = "";
		} else if (s.equals("-C(=O)OH"))
			pressed = ACTION_GROUP_COO;
		else if (s.equals("-C(=O)OMe"))
			pressed = ACTION_GROUP_COOME;
		else if (s.equals("-C(=O)N"))
			pressed = ACTION_GROUP_CON;
		else if (s.equals("-NC=O"))
			pressed = ACTION_GROUP_NCO;
		else if (s.equals("-OC(=O)Me"))
			pressed = ACTION_GROUP_OCOME;
		else if (s.equals("-CMe3"))
			pressed = ACTION_GROUP_TBU;
		else if (s.equals("-CF3"))
			pressed = ACTION_GROUP_CF3;
		else if (s.equals("-CCl3"))
			pressed = ACTION_GROUP_CCL3;
		else if (s.equals("-NO2"))
			pressed = ACTION_GROUP_NITRO;
		else if (s.equals("-NMe2"))
			pressed = ACTION_GROUP_NME2;
		else if (s.equals("-SO2-NH2"))
			pressed = ACTION_GROUP_SO2NH2;
		else if (s.equals("-NH-SO2-Me"))
			pressed = ACTION_GROUP_NHSO2ME;
		else if (s.equals("-SO3H"))
			pressed = ACTION_GROUP_SULFO;
		else if (s.equals("-PO3H2"))
			pressed = ACTION_GROUP_PO3H2;
		else if (s.equals("-C#N"))
			pressed = ACTION_GROUP_CYANO;
		else if (s.equals("-C#C-Me"))
			pressed = ACTION_GROUP_CCC;
		else if (s.equals("-C#CH"))
			pressed = ACTION_GROUP_CC;

		if (pressed > 0) {
			menuAction(pressed);
		} else
			s = "Not known group!";
		info(s);
		repaint();
	}

	protected String menuXShortcuts = null;
	//protected final String markerMultiColorOptionJLabel = "markerMultiColor";
	
	/**
	 * Specify custom keyboard shortcuts letters for the X menu box. These new shortcuts will have a higher
	 * priority than predefined shortcuts. For instance, to specify polymers shortcuts  e, d, t, and g, the argument
	 *  would be "edtg"
	 * @param shortcuts
	 */

	public void setMenuXShortcuts(String shortcuts) {
		this.menuXShortcuts = shortcuts;
	}
	
	/**
	 * Get the custom keyboard shortcuts letters that have been set using
	 *  the {@link #setMenuXShortcuts(String)} method
	 * @return
	 */

	public String getMenuXShortcuts() {
		return this.menuXShortcuts;
	}
	
	// --------------------------------------------------------------------------
	public void options(String parameters) {
		//this.options(parameters, true);
		this.options(parameters, false); //Changed June 2021: options() cand ecide if repaint is needed

	}

	public void options(String parameters, boolean repaint) {
		Boolean optionTest;
		parameters = parameters.toLowerCase();
		
		
		repaint = true; // June 2021, otherwise need to rework  and test all options

		if ((optionTest = parseOption(parameters, "rbutton")) != null) {
			rJButton = optionTest;
			this.mustReDrawLeftMenu = true;
		}

		// show implicit H
		if ((optionTest = parseOption(parameters, "hydrogens")) != null) {
			if (moleculeHandlingParameters.hydrogenHandlingParameters.showHs != optionTest) {
				moleculeHandlingParameters.hydrogenHandlingParameters.showHs = optionTest;
				this.mustReDrawMolecularArea();
			}
			
		}

		if ((optionTest = parseOption(parameters, "polarnitro")) != null)
			polarnitro = optionTest;

		if ((optionTest = parseOption(parameters, "valenceState")) != null) {
			
			if (this.moleculeHandlingParameters.computeValenceState != optionTest) {
				this.moleculeHandlingParameters.computeValenceState = optionTest; // April 2019
				this.mustReDrawMolecularArea();
				
				// should we update all atom internals e.g. charge, nh, ...?
				//this.mustReDrawMolecularArea();
				//repaint = true;
			}

			
		}

		
		
		if (parameters.indexOf("keephs") > -1) {
			//keepHydrogens = true;
			//removeOnlyCHydrogens = false;
			this.moleculeHandlingParameters.hydrogenHandlingParameters.removeHs = false;
		}
		if (parameters.indexOf("removehs") > -1) {
			this.moleculeHandlingParameters.hydrogenHandlingParameters.removeHs = true;
			this.moleculeHandlingParameters.hydrogenHandlingParameters.removeOnlyCHs = false;

			//keepHydrogens = false;
			//removeOnlyCHydrogens = false;
		}

		if (parameters.indexOf("removehsc") > -1) {
			//keepHydrogens = false;
			//removeOnlyCHydrogens = true;
			this.moleculeHandlingParameters.hydrogenHandlingParameters.removeHs = true;
			this.moleculeHandlingParameters.hydrogenHandlingParameters.removeOnlyCHs = true;
			
		}

		if ((optionTest = parseOption(parameters, "query")) != null)
			if (query != optionTest) {
				query = optionTest;
				repaint = true;
			}


		if ((optionTest = parseOption(parameters, "reaction")) != null) {
			if (reaction != optionTest) {
				setMustRedrawMolecularArea(true); // reaction arrow change : redrawing needed
				repaint = true;
			}
			if (!reaction) {
				this.reactionArrow.hasBeenPlaced = false;
			}
			reaction = optionTest;
		}

		if ((optionTest = parseOption(parameters, "autoez")) != null) {
			//autoez = optionTest;
			this.smilesPars.autoez = optionTest;
		}
		
		if ((optionTest = parseOption(parameters, "stereo")) != null)
			stereo = optionTest;

		if ((optionTest = parseOption(parameters, "canonize")) != null)
			canonize = optionTest;

		if ((optionTest = parseOption(parameters, "multipart")) != null)
			if (multipart != optionTest) {
				multipart = optionTest;
				repaint = true;
			}


		// New: handling the negative option
		if (optionTest = parseOption(parameters, "autonumber") != null) {
			if (autonumber != optionTest) {
				autonumber = optionTest;
				if (autonumber) {
					options("number");
					return;
				}
			}
		}
		if (optionTest = parseOption(parameters, "number") != null) {
			if (this.moleculeHandlingParameters.number != optionTest)
				this.mustReDrawTopMenu = true;

			this.moleculeHandlingParameters.number = optionTest;
			if (!this.moleculeHandlingParameters.number)
				autonumber = false;
			else {
				if (this.moleculeHandlingParameters.mark)
					this.mustRedrawEverything(); // if star option is selected later
				this.moleculeHandlingParameters.mark = false;
			}
		}
		
		if (optionTest = parseOption(parameters, "showAtomMapNumberWithBackgroundColor") != null) {
			this.moleculeHandlingParameters.showAtomMapNumberWithBackgroundColor = optionTest;
		}

		if ((optionTest = parseOption(parameters, "newlook")) != null) {
			newLook = optionTest;
			resetAllGraphics();
		}
		if ((optionTest = parseOption(parameters, "oldlook")) != null) {
			newLook = !optionTest;
			resetAllGraphics();
		}

		if ((optionTest = parseSynonymOptions(parameters, "star", "marker")) != null) {
			if (moleculeHandlingParameters.mark != optionTest) {
				this.moleculeHandlingParameters.number = moleculeHandlingParameters.mark = optionTest; // why number?
				//activeMarkerColorIndex = moleculeHandlingParameters.mark ? 0 : -1; //WIP
				this.mustRedrawEverything();
				if (!optionTest) // if star is off, so is star1
					markOnly1 = false;

			}

		}
		if ((optionTest = parseSynonymOptions(parameters, "star1", "marker1")) != null) {
			if (markOnly1 != optionTest) {
				markOnly1 = optionTest;
				if (optionTest) {
					this.moleculeHandlingParameters.number = moleculeHandlingParameters.mark =  optionTest; // why number?
				} else {
					
				}
				this.mustRedrawEverything();

			}

		}
		
		if ((optionTest = parseOption(parameters, "markerMenu")) != null ) {
			markerMenu = optionTest;
		}
		
//		if ((optionTest = parseSynonymOptions(parameters, markerMultiColorOptionJLabel )) != null) {
//			if (this.moleculeHandlingParameters.markerMultiColor != optionTest) {
//				this.moleculeHandlingParameters.markerMultiColor = optionTest;
//				
//				this.mustRedrawEverything();
//
//			}
//
//		}
		
		

		// atom marking will not happen, but an event will be triggered
		if ((optionTest = parseOption(parameters, "pseudoMark")) != null) {
			pseudoMark = optionTest;
		}

		if ((optionTest = parseOption(parameters, "markAtomOnly")) != null) {
			starAtomOnly = optionTest;
			if (starAtomOnly) {
				starBondOnly = false;
				if (starNothing) {
					repaint = true;
				}
				starNothing = false;
			}
		}
		if ((optionTest = parseOption(parameters, "markBondOnly")) != null) {
			starBondOnly = optionTest;
			if (starBondOnly) {
				starAtomOnly = false;
				if (starNothing) {
					repaint = true;
				}
				starNothing = false;
			}
		}

		if ((optionTest = parseOption(parameters, "markNothing")) != null) {
			if (starNothing  != optionTest ) {
				repaint = true;
				starNothing =  optionTest;
			}
		}

		if ((optionTest = parseOption(parameters, "fgmenu")) != null) {
			fgMenuOption = optionTest;
			this.mustReDrawTopMenu = true;
		}


		if ((optionTest = parseOption(parameters, "toggle")) != null)
			toggleDepictEdit = optionTest;

		// BB
		if ((optionTest = parseOption(parameters, "depictaction")) != null) {
			depictActionEnabled = optionTest;
			if (optionTest)
				parameters += " depict";
		}

		optionTest = parseOption(parameters, "depict");
		if (optionTest != null) {
			if (optionTest && isDepict() == false) {
				setDepict(true);
				menuCellSize = 0;
				molecularAreaImage = null; // pre prechode z depict je ta primala
				// toto len pre norm moleculeParts, nie pre reaction !!!
				// alignMolecules(1, numberofMoleculeParts, 0); //will be done during the
				// repaint
				paste = false; // BB March 2014 : default does not accept paste anymore

				// October 2019
				if (this.moleculePartsList.size() > 0) {
					// this is done when reading the input file
					// JMEmol.scaleInternalBondMolList(this.moleculeParts,
					// this.numberofMoleculeParts);
					// JMEmol.centerMolList(this, this.moleculeParts, this.numberofMoleculeParts);
					molecularAreaScale = this.scaleAndCenterForDepictMode(this.graphicalObjectList());
				}
				this.resetAllGraphics();
			}
			// BB CHeck if nodepictaction is used
			if (!optionTest && isDepict() == true) {
				setDepict(false);
				// molecularAreaScale = 1; // inak kresli mensi font
				resetMolecularAreaScale();

				// october 2019 - depict bug fix

				// musi male molekuly vratit na povodnu velkost
				// for (int i = 1; i <= numberofMoleculeParts; i++) {
				// moleculeParts[i].scaling();
				// moleculeParts[i].center(); // este raz, teraz uz zmensene
				// }

				//JMEmol.centerMolList(this, this.moleculeParts, this.numberofMoleculeParts);

				// BB moved above - fixed a bug
				// depictScale = 1; // inak kresli mensi font
				// normal font (ak bola mensia molekula) sa nastavi v
				// drawMolecularArea
				menuCellSize = standardMenuCellSize;
				if (activeMol != null) {
					// mol.needRecentering = true; // october 2019 bug
				}

				paste = true; // BB March 2014 :
				// paste option will be set below
				this.resetAllGraphics();

			}
		}

		if ((optionTest = parseOption(parameters, "showDragAndDropIconInDepictMode")) != null)
			showDragAndDropIconInDepictMode = optionTest;
		// older naming of the same option
		if ((optionTest = parseOption(parameters, "showDragAndDropSymbolInDepictMode")) != null)
			showDragAndDropIconInDepictMode = optionTest;

		if ((optionTest = parseOption(parameters, "addNewPart")) != null)
			addNewPart = optionTest;

		if ((optionTest = parseOption(parameters, "exportInchi")) != null)
			exportInchi = optionTest;
		if ((optionTest = parseOption(parameters, "exportInchiKey")) != null)
			exportInchiKey = optionTest;
		if ((optionTest = parseOption(parameters, "exportInchiAuxInfo")) != null)
			exportInchiAuxInfo = optionTest;
		if ((optionTest = parseOption(parameters, "searchInchiKey")) != null)
			searchInchiKey = optionTest;
		if ((optionTest = parseOption(parameters, "exportSVG")) != null)
			exportSVG = optionTest;

		if ((optionTest = parseOption(parameters, "exportRXNmerge")) != null)
			exportRXNmergeOption = optionTest;

		if ((optionTest = parseOption(parameters, "contextMenu")) != null)
			contextMenuEnabledOption = optionTest;
		if ((optionTest = parseOption(parameters, "fullScreenIcon")) != null)
			fullScreenIconOption = optionTest;
		if ((optionTest = parseOption(parameters, "showFullScreenIconInDepictMode")) != null)
			showFullScreenIconInDepictMode = optionTest;

		if ((optionTest = parseOption(parameters, "useOclIDCode")) != null)
			useOclIdCode = optionTest;

		if ((optionTest = parseOption(parameters, "xbutton")) != null) {
			if (xJButton != optionTest) {
				xJButton = optionTest;
				repaint = true;
			}

		}
		if ((optionTest = parseOption(parameters, "paste")) != null)
			if (paste != optionTest) {
				paste = optionTest;
			}


		if ((optionTest = parseOption(parameters, "border")) != null)
			if (depictBorder != optionTest) {
				depictBorder = optionTest;
				repaint = true;
				this.mustRedrawEverything();
			}
		
		

		// undocumented options
//		if (parameters.indexOf("writesmi") > -1)
//			writesmi = true;
//		if (parameters.indexOf("writemi") > -1)
//			writemi = true;
//		if (parameters.indexOf("writemol") > -1)
//			writemol = true;
		if (parameters.indexOf("nocenter") > -1)
			nocenter = true;
		if (parameters.indexOf("jmeh") > -1)
			jmeh = true;
		if (parameters.indexOf("showan") > -1)
			
			showAtomNumbers = true;
		// System.out.println(rJButton+" "+moleculeHandlingParameters.hydrogenHandlingParameters.showHs+" "+query+" "+autoez+"
		// "+stereo+" "+canonize+" "+reaction);

		// BB
		if ((optionTest = parseOption(parameters, "atommovebutton")) != null)
			showAtomMoveJButton = optionTest;
		if ((optionTest = parseOption(parameters, "useopenchemlib")) != null)
			useOpenChemLib = optionTest;
		if ((optionTest = parseOption(parameters, "zoom")) != null)
			allowGUIzooming = allowZooming = optionTest;
		
		// new Feb 2022
		if ((optionTest = parseOption(parameters, "zoomgui")) != null)
			allowGUIzooming = optionTest && allowZooming;
		
		// zladi options - ake dalsie ???
		if (reaction) {
			// BB: if a reaction is read, then the numbering should be autonumber and not
			// number. This should be checked by Peter.
			// With autonumber, one can assign different atom map numbers
			// number = true;
			autonumber = true;
			multipart = true;
		}
		if (!isDepict())
			depictBorder = false;
		// positions and actions for X and Rx buttons
		// nove X a R action musia byt > 300
//		if (rJButton)
//			LEFT_MENU_NUMBER_OF_CELLS++;
		LEFT_MENU_NUMBER_OF_CELLS = this.determineNumberLeftMenuNumberOfCell();

		this.resetJPopupMenu(); // the pop menu contains entries and labels that night need to be removed or
								// added or changed

		// if star is disabled , then go back to default action
		if (action == ACTION_MARK && (moleculeHandlingParameters.mark == false || starNothing)) {
			action = ACTION_BOND_SINGLE;
			repaint = true;
		}

		if (repaint || mustRedrawNSomething()) {
			this.mustRedrawEverything();
			repaint();
		}
	}

	/**
	 * use boundaries for the search
	 * 
	 * @param parameters
	 * @param option
	 * @param negativePrefix
	 * @return null if option not found
	 */
	protected Boolean parseOption(String parameters, String option, String negativePrefix) {
		boolean pos = Pattern.compile("\\b" + option + "\\b", Pattern.CASE_INSENSITIVE).matcher(parameters).find();
		boolean neg = Pattern.compile("\\b" + negativePrefix + option + "\\b", Pattern.CASE_INSENSITIVE)
				.matcher(parameters).find();

		if (pos && neg) {
			this.log("check option " + option);
			return null;
		}

		if (pos)
			return true;
		if (neg)
			return false;

		return null;

	}

	// TODO: rdefine in JME2
	public void log(String string) {
		System.err.println(string);
	}

	protected Boolean parseOption(String parameters, String option) {
		return parseOption(parameters, option, "no");
	}

	// useful for options with multiple names - for instance star option has been
	// renamed to marker
	protected Boolean parseSynonymOptions(String parameters, String... options) {
		for (String eachOption : options) {
			Boolean found = this.parseOption(parameters, eachOption);
			if (found != null) {
				return found;
			}
		}
		return null;
	}

	protected void resetAllGraphics() {
		// for subclass
		this.mustRedrawEverything();

		this.molecularAreaImage = null;
		this.topMenuImage = null;
		this.leftMenuImage = null;
		this.infoAreaImage = null;
		this.rightBorderImage = null;

	}

	/**
	 * See also getCopyPasteJPopupMenuMol() and getCopyPasteJPopupMenuReaction()
	 */
	protected void resetJPopupMenu() {
		this.copyPasteJPopupMenuMol = null;
		this.copyPasteJPopupMenuReaction = null;

	}

	/**
	 * Ignore bonds during mouse over
	 * 
	 * @return
	 */
	protected boolean ignoreBonds() {
		return  ((starNothing || starAtomOnly) && action == ACTION_MARK) || action == ACTION_MOVE_AT
				|| action == ACTION_CHAIN || action == ACTION_SPIRO || action == ACTION_CHARGE
				|| (action >= ACTION_GROUP_MIN && action <= ACTION_AN_R_LAST
				
				|| (action == ACTION_MARK && ! moleculeHandlingParameters.mark) // case for 123 button - atom mapping June 2020
						
						);
	}

	/**
	 * ignore atoms during mouse over
	 * 
	 * @return
	 */
	protected boolean ignoreAtoms() {
		return (/* action == ACTION_STEREO || */ ((starNothing || starBondOnly) && action == ACTION_MARK));
	}

	// --------------------------------------------------------------------------
	public void setText(String text) {
		molText = text;
		repaint();
	}

	// --------------------------------------------------------------------------
	public void showAtomNumbers() {
		// shows canonical atom numbering
		// numbers only actual molecule !!!
		if (activeMol != null)
			activeMol.numberAtoms();
	}

	// ----------------------------------------------------------------------------
	// --- end of public functions
	// ------------------------------------------------
	// ----------------------------------------------------------------------------
	public void paint(Graphics g) {
		/* The java applet viewer calls this method when the applet window is resized */
		Graphics g2 = g.create();
		update(g2);
		// requestFocus(); // kvoli key action
		g.dispose();
	}

	/**
	 * Should be called after any applet size change
	 * 
	 * @param appletDimension
	 */
	protected void updateMyMolecularAreaSize(Dimension appletDimension, double menuScale) {

		Rectangle2D.Double molecularAreaBoundingBox = getMolecularAreaBoundingBoxPixel(appletDimension, menuScale);

		this.molecularAreaWidth = (int) molecularAreaBoundingBox.width;
		this.molecularAreaHeight = (int) molecularAreaBoundingBox.height;

	}

	/**
	 * Should be called after any applet size change
	 * 
	 * @param d
	 */
	protected void updateMyMolecularAreaSize() {
		if (this.dimension == null) {
			this.dimension = getSize();
		}
		this.updateMyMolecularAreaSize(this.dimension, this.menuScale);

	}

	/**
	 * Return the bounding box of the molecular area (screen pixel)
	 * 
	 */
	Rectangle2D.Double getMolecularAreaBoundingBox() {

		return getMolecularAreaBoundingBoxPixel(this.dimension, this.menuScale);

	}

	protected Box getMolecularAreaBoundingBoxPixel(Dimension appletDimension, double menuScale) {

		double x = isDepict() ? 0 : leftMenuWidth(menuScale);
		double y = isDepict() ? 0 : topMenuHeight(menuScale);
		double width = (double) appletDimension.width - (isDepict() ? 0 : x + rightBorder(menuScale));
		double height = (double) appletDimension.height - (isDepict() ? 0 : y + infoAreaHeight(menuScale));

		return new Box(x, y, width, height);

	}

	protected Box getMolecularAreaBoundingBoxCoordinate(Dimension appletDimension, double menuScale,
			double molecularAreaScale) {
		Box bbox = getMolecularAreaBoundingBoxPixel(appletDimension, menuScale);

		assert(molecularAreaScale > 0);
		
		bbox.x = 0;
		bbox.y = 0;
		bbox.width  /= molecularAreaScale;
		bbox.height /= molecularAreaScale;

		return bbox;

	}

	/**
	 * Return the width and height of the molecular area with scaling
	 * 
	 */
	protected Box getMolecularAreaBoundingBoxCoordinate() {
		return getMolecularAreaBoundingBoxCoordinate(this.dimension, this.menuScale, this.molecularAreaScale);
	}

	// ----------------------------------------------------------------------------
	public void update(Graphics g) {
		// pri fill ma rectangle sirku a vysku presne, pri draw o 1 vacsiu
		// Dimension d = getSize();

		// BB" try to avoid mutilple calls to size() and alignMolecules()

		// Note: Applet has a resize method() that we could override
		boolean initOrResize;
		appletHasBeenResized = false;
		assert (dimension != null); // dimension was initialized by init()()
		if (molecularAreaImage == null) {
			initOrResize = true;
			assert (molecularAreaImage == null);

		} else {
			assert (molecularAreaImage != null);

			Dimension newDimension = getSize();

			// find out if the size of the applet has changed
			initOrResize = (newDimension.width != dimension.width) || (newDimension.height != dimension.height);

			if (initOrResize) { // if applet has a new size

				dimension = newDimension;
				appletHasBeenResized = true;
			}
		}

		if (initOrResize) {
			mustRedrawEverything();
			updateMyMolecularAreaSize(this.dimension, this.menuScale);
			log("update(): " + dimension + " " + "initOrResize: " + initOrResize + " " + this.molecularAreaWidth + " "
					+ this.molecularAreaHeight);

			// compute or resize the graphics
			molecularAreaImage = createOrResizePreciseImage(molecularAreaImage, this.molecularAreaWidth,
					this.molecularAreaHeight);

			if (!isDepict()) {
				// update the menu's and the info area

				topMenuImage = createOrResizePreciseImage(topMenuImage, dimension.width, topMenuHeight());
				double imageh = dimension.height - topMenuHeight();
				if (imageh < 1)
					imageh = 1;
				// leftMenu = createOrResizeImage(leftMenu, menuCellSize, imageh);
				this.leftMenuImage = createOrResizePreciseImage(this.leftMenuImage, this.leftMenuWidth(), imageh);

				infoAreaImage = createOrResizePreciseImage(infoAreaImage, this.molecularAreaWidth + rightBorder(),
						infoAreaHeight());

				rightBorderImage = createOrResizePreciseImage(rightBorderImage, rightBorder(),
						this.molecularAreaHeight);

				// New october 2019
				//JMEmol.centerMolList(this, this.moleculeParts, this.numberofMoleculeParts);

			} else {
				// depict mode
				double oldMolecularAreaScale = this.molecularAreaScale;

				// will recompute the molecular area scale
				this.molecularAreaScale = this.scaleAndCenterForDepictMode(this.graphicalObjectList());

				// October 2019: No molecule alignment : wee keep the layout of the original
				// molecules
				// TODO: for reactions
				// alignMolecules(1, numberofMoleculeParts, 0, isDepict()); //code copied from
				// the depict option initialisation
				// moleculePartsList.scaleInternalBondMolList(); // THIS IS NOT NEEDED!!!!
				//JMEmol.centerMolList(this, this.moleculeParts, this.numberofMoleculeParts);

				log("update() in depict mode: oldMolecularAreaScale = " + oldMolecularAreaScale
						+ " new   molecularAreaScale = " + molecularAreaScale);

				assert topMenuImage == null;
				assert leftMenuImage == null;
				assert infoAreaImage == null;
				assert rightBorderImage == null;
			}
		}

		// draw the parts
		drawMolecularArea(g);
		if (!isDepict()) {
			drawInfo(g); // ???
			drawTopMenu(g);
			drawLeftMenu(g);
			drawRightBorderImage(g);

		}
		
		this.postInitializeIfNeeded();

	}

	/**
	 * Method that is overridden in JSME in order to avoid the creation of multiple
	 * SVG's during a window resize
	 * 
	 * @param img
	 * @param width
	 * @param height
	 * @return a new Image in JME or the same image if the argument img is not null
	 *         in JSME
	 */
	public Image createOrResizeImage(Image img, int width, int height) {
		return createImage(width, height);
	}

	public PreciseImage createOrResizePreciseImage(PreciseImage img, double width, double d) {
		return new PreciseImage(createOrResizeImage(img == null ? null : img.getImage(), (int) (Math.round(width)),
				(int) (Math.round(d))));
	}

	/**
	 * This methos is used only in a batch mode test suite in order to have an
	 * instance of JME that has a this.dimension that is not null
	 * 
	 * @param width
	 * @param height
	 */
	public void setDirectSizeForTesting(int width, int height) {
		if (this.dimension == null) {
			this.dimension = new Dimension();
		}
		this.dimension.width = width;
		this.dimension.height = height;

		this.updateMyMolecularAreaSize();

	}
	// ----------------------------------------------------------------------------

	// BB
	// metal like LI, K, Na which can be single cation
//	public static int isMetal1(int an) {
//		return an >= AN_METAL1_START && an <= AN_METAL1_END? 1 : 0;
//	}
//	//metal like LI, K, Na which can be single cation
//	public static boolean isMetal2(int an) {
//		return an >= AN_METAL2_START && an <= AN_METAL2_END;
//	}

	public static int chargedMetalType(int an) {
		if (an >= AN_METAL1_START && an <= AN_METAL1_END)
			return 1; // Na+
		if (an >= AN_METAL2_START && an <= AN_METAL2_END)
			return 2; // Ca++
		if (an >= AN_METAL3_START && an <= AN_METAL3_END)
			return 3; // Al+++

		return 0;
	}

	public static void atomicData() {
		for (int i = 1; i <= AN_R_LAST; i++) {
			if (chargedMetalType(i) > 0) {
				color[i] = Color.darkGray;
			} else {
				color[i] = Color.orange;
				zlabel[i] = "X";
			}
		}
		zlabel[AN_H] = "H";
		color[AN_H] = Color.darkGray;
		zlabel[AN_B] = "B";
		color[AN_B] = Color.orange;
		zlabel[AN_C] = "C";
		color[AN_C] = Color.darkGray;
		zlabel[AN_N] = "N";
		color[AN_N] = Color.blue;
		zlabel[AN_O] = "O";
		color[AN_O] = Color.red;
		zlabel[AN_F] = "F";
		color[AN_F] = Color.magenta;
		zlabel[AN_CL] = "Cl";
		color[AN_CL] = Color.magenta;
		zlabel[AN_BR] = "Br";
		color[AN_BR] = Color.magenta;
		zlabel[AN_I] = "I";
		color[AN_I] = Color.magenta;
		zlabel[AN_S] = "S";
		color[AN_S] = Color.yellow.darker();
		zlabel[AN_P] = "P";
		color[AN_P] = Color.orange;
		zlabel[AN_SI] = "Si";
		color[AN_SI] = Color.darkGray;
		zlabel[AN_SE] = "Se";
		color[AN_SE] = Color.darkGray;
		zlabel[AN_X] = "X";
		color[AN_X] = Color.darkGray;

		zlabel[AN_K] = "K";
		zlabel[AN_Li] = "Li";
		zlabel[AN_Na] = "Na";
		zlabel[AN_Rb] = "Rb";
		zlabel[AN_Cs] = "Cs";
		zlabel[AN_Fr] = "Fr";
		zlabel[AN_Ag] = "Ag";

		zlabel[AN_Mg] = "Mg";
		zlabel[AN_Ca] = "Ca";
		zlabel[AN_Sr] = "Sr";
		zlabel[AN_Ba] = "Ba";
		zlabel[AN_Zn] = "Zn";
		zlabel[AN_Ni] = "Ni";
		zlabel[AN_Cu] = "Cu";
		zlabel[AN_Cd] = "Cd";

		zlabel[AN_Al] = "Al";
		zlabel[AN_Ga] = "Ga";
		zlabel[AN_Au] = "Au";

		// BB: replace cases by a loop for the R groups
		for (int i = AN_R; i <= AN_R_LAST; i++) {
			String label = "R";
			if (i > AN_R) {
				label += i - AN_R;
			}
			zlabel[i] = label;
			color[i] = Color.darkGray;
		}
		/*
		 * zlabel[AN_R] = "R"; color[AN_R] = Color.darkGray; zlabel[AN_R1] = "R1";
		 * color[AN_R1] = Color.darkGray; zlabel[AN_R2] = "R2"; color[AN_R2] =
		 * Color.darkGray; zlabel[AN_R3] = "R3"; color[AN_R3] = Color.darkGray;
		 */
	}

	// BB : added atomic atomicData initialization , allows to work also in the test
	// suite
	static {
		atomicData();
	}

	PreciseGraphicsAWT getScaledGraphicsOfPreciseImage(PreciseImage pi, double scale, Rectangle2D.Double screenArea) {
		PreciseGraphicsAWT og;
		if (this.scalingIsPerformedByGraphicsEngine) {
			og = pi.getGraphics(scale);
		} else {
			og = pi.getGraphics(1.0); // never used!!?

		}
		og.setDrawOnScreenCoordinates(screenArea);

		return og;
	}

	// direct
	public void drawMolecularAreaRightNow() {
		this.setMustRedrawMolecularArea(true);
		if (molecularAreaImage != null) { // must be initialized
			Graphics g = getGraphics().create();
			drawMolecularArea(g);
			g.dispose();
			this.setMustRedrawMolecularArea(false);
		} else {
			this.repaint();
		}

	}

	// ----------------------------------------------------------------------------
	void drawMolecularArea(Graphics g) {

		log("drawMolecularArea  mustReDrawMolecularArea=" + mustReDrawMolecularArea + "\n");
		// BB
		if (!this.mustReDrawMolecularArea) {
			return;
		}

		// new sept 2016
		// FIXme: should not be done here
		if(this.moleculeHandlingParameters.computeValenceState) {
			if(this.afterStructureChangeEvent  != null && this.afterStructureChangeEvent.action != null) {
				if(this.afterStructureChangeEvent.action != JME.UNDO && this.afterStructureChangeEvent.action != JME.REDO) {
					for(JMEmol mol: moleculePartsList) {
						mol.cleanAfterChanged(this.polarnitro);
					}
				}
			}
		}

		// screen area in pixel
		Rectangle2D.Double molecularScreenArea = new Rectangle2D.Double(leftMenuWidth(), topMenuHeight(),
				this.molecularAreaWidth, this.molecularAreaHeight);

		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(molecularAreaImage, molecularAreaScale,
				molecularScreenArea);

		double imgWidth = this.molecularAreaWidth;
		double imgHeight = this.molecularAreaHeight;
		log("drawMolecularArea  " + imgWidth + " : " + imgHeight + " scale: " + this.molecularAreaScale + "\n");
		og.setColor(canvasBg);

		imgWidth /= this.molecularAreaScale;
		imgHeight /= this.molecularAreaScale;

		og.fillRect(0, 0, imgWidth, imgHeight);

		// BB custom antialias and line width for the molecular drawing area
		Object valueAntiAlias = molecularAreaAntiAlias ? RenderingHints.VALUE_ANTIALIAS_ON
				: RenderingHints.VALUE_ANTIALIAS_OFF;
		og.setRenderingHint(RenderingHints.KEY_ANTIALIASING, valueAntiAlias);

		og.setStroke(new BasicStroke(molecularAreaLineWidth));

		if (fullScreenEnterOrExit || (this.appletHasBeenResized && previousScaledScreenArea != null)) {
			Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList = this.graphicalObjectList();
			centerAllMoleculesAsAgroup(graphicalObjecList, this.dimension, menuScale, molecularAreaScale);
			fullScreenEnterOrExit = false;
		}
		
		for(JMEmol mol : moleculePartsList){
			mol.draw(og);
		}
		if (previousScaledScreenArea == null)
			previousScaledScreenArea = new Rectangle2D.Double();
		previousScaledScreenArea.width = imgWidth;
		previousScaledScreenArea.height = imgHeight;

		// arrow
		if (reaction) {
			// if the reaction arrow is not initialized
			if (! this.reactionArrow.hasBeenPlaced) { //FIXME: to be removed?
				this.reactionArrow.XY(imgWidth / 2, imgHeight / 2);
			}
			this.reactionArrow.draw(og);
		}

		// molText
		if (isDepict()) { // kvoli molText, ale aj depict dalsej molekuly
			// musi robit novy font, lebo v depict moze byt zmeneny
			menuCellFont = new Font(defaultFontFamily, Font.PLAIN, fontSize);
			menuCellFontMet = getFontMetrics(menuCellFont);
			if (molText != null) {
				int w = menuCellFontMet.stringWidth(molText);
				double xstart = (imgWidth - w) / 2.;
				double ystart = imgHeight - fontSize;
				og.setColor(Color.black);
				og.setFont(menuCellFont);
				og.drawString(molText, xstart, ystart);
			}
		}

		// draw the DnD icon
		if (isDepict()) {
			if (showDragAndDropIconInDepictMode)
				// DnD icom is made smaller than the non depict one
				this.drawDragAndDropIcon(og, smallerIconsForDepictMode / this.molecularAreaScale);
			else
				this.dragAndDropIcon = null;

			// FIXME
			// on the left of the DnD icon
			// scaling does not work - because a resize event recomputed the
			// molecularAreaScale
//			if(fullScreenIconOption && showFullScreenIconInDepictMode)
//				this.drawFullScreenIcon(og, imgWidth, imgHeight, smallerIconsForDepictMode /this.molecularAreaScale, this.dragAndDropIcon);
		}

		g.drawImage(molecularAreaImage.getImage(), og.screenX(), og.screenY(), this);
		this.setMustRedrawMolecularArea(false);

		// New September 2016
		// handle the postSave and the event to JS
		if (this.saveCurrentState) {
			this.postSave();
			this.saveCurrentState = false;
		}
		if (this.afterStructureChangeEvent != null && this.afterStructureChangeEvent.action != null) {
			// mol.cleanAfterChanged();
			notifyStructuralChangeToJS();
			//this.afterStructureChangeEvent.reset();

			// BB new Feb 2017
			// disable the NEW button after structure change
			if (newMolecule == true) {
				newMolecule = false;
				mustReDrawTopMenu = true;
				repaint();
			}
		}

	}

	public void centerAllMoleculesAsAgroup(Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList, Dimension appletDimension, double menuScale, double molecularAreaScale) {

//		if (reaction)
//			return; // not implemented yet
		// this.appletHasBeenResized = false;

		Rectangle2D.Double chemicalDrawingBoundingBox = this.getChemicalDrawingBoundingBox(graphicalObjecList); // molecule coordinate
		Rectangle2D.Double appletMolBoundingBox = this.getMolecularAreaBoundingBoxCoordinate(appletDimension, menuScale,
				molecularAreaScale);
		double dx = appletMolBoundingBox.getCenterX() - chemicalDrawingBoundingBox.getCenterX();
		double dy = appletMolBoundingBox.getCenterY() - chemicalDrawingBoundingBox.getCenterY();

		for(Graphical2DObject each :  graphicalObjecList.group) {
			each.moveXY(dx, dy);
		}
		//molecules.moveXY(dx, dy);
		
	}

	
	void drawRightBorderImage(Graphics g) {
		if (!this.mustReDrawRightBorderImage)
			return;

		Rectangle2D.Double screenArea = new Rectangle2D.Double(dimension.width - rightBorder(), topMenuHeight(),
				rightBorder(), molecularAreaHeight);
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(rightBorderImage, menuScale, screenArea);

		double imgWidth = rightBorder(1);
		// double imgHeight = (double)this.molecularAreaHeight/this.depictScale;
		double imgHeight = screenArea.height / this.menuScale;
		// System.out.print("@@@@ drawRightBorderImage
		// dimensionHeight="+dimension.height + " imgHeight=" + imgHeight + "\n");
		if (newLook) {
			og.setColor(Color.darkGray);
			// og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1);//right line
			// og.drawLine(0, 0, 0, imgHeight);//right line
			og.fillRect(0, 0, imgWidth, imgHeight);
			// og.fillRect(0, 0, imgWidth, imgHeight/2);
		} else {
			// vonkajsi okraj na pravej strane
			og.setColor(bgColor.darker());
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight);
			// predel vo farbe backgroundu
			og.setColor(bgColor);
			og.drawLine(imgWidth - 2, 0, imgWidth - 2, imgHeight);
			// svetly okraj dovnutra
			og.setColor(brightColor);
			og.drawLine(imgWidth - 3, 0, imgWidth - 3, imgHeight);
		}

		g.drawImage(rightBorderImage.getImage(), (int) screenArea.x, (int) screenArea.y, this);

	}

	// ----------------------------------------------------------------------------
	void drawTopMenu(Graphics g) {
//Swing will handle this differently
//		if (!this.mustReDrawTopMenu)
//			return;

		// System.out.print("@@@@ drawTopMenu");

		// PreciseGraphicsAWT og = topMenuImage.getGraphics();

		Rectangle2D.Double screenArea = new Rectangle2D.Double(0, 0, dimension.width, topMenuHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(topMenuImage, menuScale, screenArea);

		double imgWidth = (double) dimension.width / this.menuScale;
		double imgHeight = topMenuHeight(1.0);
		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (newLook) {
			// og.setColor(Color.darkGray);
			og.setColor(bgColor.darker());
			double s = (menuCellSize + menuCellBorder()) * TOP_MENU_NUMBER_OF_CELLS;
			// og.drawRect(s,0,imgWidth-s-1,menuCellSize*2 + menuCellBorder()-1);
			og.drawRect(s, 0, imgWidth - s - 1, imgHeight - 1);
		} else {
			og.setColor(bgColor.darker());
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1); // right
			og.drawLine(0, imgHeight - 1, imgWidth - 1, imgHeight - 1); // bottom

			og.setColor(brightColor);
			og.drawLine(0, 0, imgWidth - 1, 0); // top
		}

		// og.drawLine(TOP_MENU_NUMBER_OF_CELLS * menuCellSize, 0,
		// TOP_MENU_NUMBER_OF_CELLS * menuCellSize, imgHeight - 1); // predel

		// BB: redraw the FG menu cell if a substituent had been selected
		int savedAction = action;
		if (ACTION_GROUP_MIN <= action && action <= ACTION_GROUP_MAX) {
			action = ACTION_FG;
		}
		for (int i = 1; i <= TOP_MENU_NUMBER_OF_CELLS; i++) {
			createSquare(og, i, 1); // icon cell
			createSquare(og, i, 2);
		}

		// restore the action value in case it had been changed for redrawing above
		action = savedAction;

		g.drawImage(topMenuImage.getImage(), 0, 0, this);
	}

	// ----------------------------------------------------------------------------
	void drawLeftMenu(Graphics g) {
		//Swing will handle this differently
//		if (!this.mustReDrawLeftMenu)
//			return;

		Rectangle2D.Double screenArea = new Rectangle2D.Double(0, topMenuHeight(), leftMenuWidth(),
				dimension.height - topMenuHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(leftMenuImage, this.menuScale, screenArea);

		double imgWidth = leftMenuWidth(1);

		double imgHeight = (dimension.height - topMenuHeight()) / this.menuScale;

		double yInfoArea = imgHeight - infoAreaHeight(1);

		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (newLook) {
			og.setColor(Color.darkGray);

			double y = LEFT_MENU_NUMBER_OF_CELLS * (menuCellSize + menuCellBorder()) + 3;

			if (yInfoArea > y) {
				og.drawLine(0, y, menuCellSize - 1, y); // top horizontal line
				og.drawLine(0, y, 0, imgHeight - 1); // left

				og.drawLine(menuCellSize - 1, y, menuCellSize - 1, yInfoArea); // right down to info area
				og.drawLine(menuCellSize - 1, yInfoArea, imgWidth, yInfoArea); // small horizontal line to info area
			}
			// frame at the bottom
			og.drawLine(0, imgHeight - 1, imgWidth, imgHeight - 1); // bottom

		} else {
			og.setColor(brightColor);
			og.drawLine(0, 0, 0, imgHeight - 1); // left
			og.drawLine(0, LEFT_MENU_NUMBER_OF_CELLS * menuCellSize, imgHeight - 1,
					LEFT_MENU_NUMBER_OF_CELLS * menuCellSize); // predel

			og.setColor(bgColor.darker());
			// og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1 - menuCellSize); //
			// right down to info area
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, yInfoArea + 1); // right down to info area
			og.drawLine(0, imgHeight - 1, imgWidth - 0, imgHeight - 1); // bottom
		}
		
		// the actions for the left menu matche the squar numbers
		for (int i = 3; i <= LEFT_MENU_NUMBER_OF_CELLS + 2; i++) {
			createSquare(og, 1, i);
		}

		g.drawImage(leftMenuImage.getImage(), (int) screenArea.x, (int) screenArea.y, this);
	}

	// ----------------------------------------------------------------------------
	protected void drawInfo(Graphics g) {
		// log("drawInfo: " + this.mustReDrawInfo + "  : " + infoText);
		//Swing will handle this differently
//		if (!this.mustReDrawInfo)
//			return;
		if (infoText == null) {
			infoText = "";
		}

		int textYPosition = 15;
		// screen position of the info bar at the bottom of the applet
		Rectangle2D.Double screenArea = new Rectangle2D.Double(leftMenuWidth(),
				dimension.height - this.infoAreaHeight(), dimension.width - leftMenuWidth(), infoAreaHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(infoAreaImage, this.menuScale, screenArea);

		double imgWidth = screenArea.width / this.menuScale; // the width is reduced if scale > 1
		double imgHeight = this.infoAreaHeight(1); // unscaled because og is scaled
		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (newLook) {
			og.setColor(Color.darkGray);
			og.drawRect(-10, 0, imgWidth - 1 + 10, imgHeight - 1); // -10: used for masking the left border
		} else {
			og.setColor(brightColor);
			// og.setColor(Color.red);
			// og.drawLine(0, 0, imgWidth - 1 - 2, 0); // top
			og.drawLine(0, 0, imgWidth - rightBorder(1) + 1, 0); // top
			og.setColor(bgColor.darker());
			og.drawLine(0, imgHeight - 1, imgWidth - 1, imgHeight - 1); // bottom
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1); // right
		}
		og.setFont(menuCellFontSmaller);
		og.setColor(Color.black);

		if (infoText.toLowerCase().contains("error"))
			og.setColor(Color.red);
		og.drawString(infoText, 10, textYPosition);

		if (!this.isDepict()) { /*
								 * in depict mode, another graphics must be used because the info bar is not
								 * present
								 */
			// TODO: the java implemenrtation does not support drag and drop
			this.drawDragAndDropIcon(og, 1.0);
			if (fullScreenIconOption && isFullScreenSupported())
				this.drawFullScreenIcon(og, 1.0, this.dragAndDropIcon);
			else
				this.fullScreenIcon = null;
		}
		
		if (imgWidth > 100 && this.activeMol != null && this.moleculePartsList.hasOneMoleculeWithChiralFlag() ){
			String chiralText = "Chiral";
			og.setColor(Color.black);
			og.drawString(chiralText, imgWidth - 100, textYPosition);
		}

		g.drawImage(infoAreaImage.getImage(), (int) screenArea.x, (int) screenArea.y, this);

	}

	protected Dimension nonFullScreenSize = new Dimension();
	final protected double fullScreenScale = 3;

	/*
	 * to be redefined in JSME
	 */
	protected boolean isFullScreenSupported() {
		return true;
	}

	/**
	 * Java applet only. FIXME: recompute bond center?
	 */
	protected void toggleFullScreen() {
		System.out.println("drawFullScreen " + this.isFullScreen);
		this.mustRedrawEverything();
		Dimension newDim;
		if (!isFullScreen) {
			// save current dimension
			nonFullScreenSize.setSize(this.dimension.width, this.dimension.height);
			newDim = Toolkit.getDefaultToolkit().getScreenSize();
			molecularAreaScale = Math.min(molecularAreaScale * fullScreenScale, maxMolecularAreaScale);
			menuScale = Math.min(menuScale * fullScreenScale, maxMenuScale);

		} else {
			molecularAreaScale = Math.max(molecularAreaScale / fullScreenScale, minmolecularAreaScale);
			menuScale = Math.max(menuScale / fullScreenScale, minMenuScale);
			newDim = nonFullScreenSize;

		}
		isFullScreen = !isFullScreen;
		this.setSize(newDim);

	}

	// ----------------------------------------------------------------------------
	boolean menuAction(int pressed) {
		// calling actions after pressing menu button or menu keys
		// called from mousePressed() or keyTyped()

		// idea: this.atomTypeChangeAction = true; //atom type selected or FG or query
		// box
		// mouseover would only highlight the atoms

		if (pressed == 0)
			return false; // moze to byt ? ano, napr z keyTyped

		// BB
		this.mustRedrawNothing();
		boolean status = true;
		boolean structureChangePerformed = false;

		int actionOld = action;
		action = pressed;
		if (pressed <= 300) { // top menu
			// BB
			this.mustReDrawTopMenu = true;
			this.mustReDrawLeftMenu = true; // deselection possible on the left menu
			clearInfo(); // clear any messages

			switch (pressed) {
			case ACTION_CLEAR:
				clear();
				// idea: double click would do a complete cleaning of the undo and redo stack
				// this.molChangeManager.clear(); //delete all undo's
				// this.sdfStack.clear(); //delete all entries from the SDF stack
				// this.recordAfterStructureChangedEvent(JME.CLEAR); //already performed by
				// clear()n

				// reset the red highlight correctly
				this.handleMouseLeaveActionMenu(ACTION_CLEAR);
				this.handleMouseEnterActionMenu(ACTION_CLEAR);

				structureChangePerformed = true; // sept 2016
				break;
			case ACTION_UNDO:
				// zostavaju rovnake settings ako predtym

				// BB
				setMustRedrawMolecularArea(true); // needed for e.g. undo
				
				action = actionOld;
/*				if(!this.canMultipleUndo) { //PE's original undo
					// undo po new molecule (pri new smol = null)
					if (smol == null) {
						actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						clear();
					} else if (afterClear) {
						saved = ++numberofMoleculeParts;
						actualMoleculePartIndex = numberofMoleculeParts;
						afterClear = false;
					}
					// undo po standard change (aj po delete s upravenym saved)
					if (smol == null)
						break; // no molecule in undo stack
					activeMol = smol.deepCopy();
					moleculeParts[saved] = activeMol;
				} else {
*/					//multiple undo handling
					if (!this.molChangeManager.canUndo()) {
						info("No more undo");

						//actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						//clear();
					} else if (afterClear) {
						//saved = ++numberofMoleculeParts;
						//actualMoleculePartIndex = numberofMoleculeParts;
						activeMol = moleculePartsList.last();
						afterClear = false;
					}
					if (!this.molChangeManager.canUndo())
						break; // no molecule in undo stack

					this.retoreState(this.molChangeManager.undo());
					this.recordAfterStructureChangedEvent(JME.UNDO);
					this.willPostSave(false);

					setMustRedrawMolecularArea(true); 
					//System.out.println("*********** undo " + mol.natoms);

				
				break;
			
			
			
			case ACTION_REDO:


				if(!this.canMultipleUndo) {
					action = actionOld;
					this.alert("The redo feature is not implemented yet");

				} else {
					action = actionOld;
					//BB this code is copied from the undo part and adapted
					if (!this.molChangeManager.canRedo()) {
						//actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						//clear();
						info("No more redo");
						break;
					} else if (afterClear) {
						//saved = ++numberofMoleculeParts;
						//actualMoleculePartIndex = numberofMoleculeParts;
						activeMol = moleculePartsList.last();

						afterClear = false;
					}
					// undo po standard change (aj po delete s upravenym saved)
					if (!this.molChangeManager.canRedo())
						break; // no molecule in undo stack
					this.retoreState(this.molChangeManager.redo());
					this.recordAfterStructureChangedEvent(JME.REDO);
					this.willPostSave(false);

					setMustRedrawMolecularArea(true); 

				}


				break;

			case ACTION_IO: /* open popup menu with IO */
				this.handleCopyPasteJPopupMenu(null, this.fixedCopyPasteJPopupMenuPosition.x,
						this.fixedCopyPasteJPopupMenuPosition.y);
				action = actionOld;
				break;

			case ACTION_PGUP:
			case ACTION_PGDN:
			case ACTION_END:
			case ACTION_HOME:
				String sdf = null;
				action = actionOld;

				switch (pressed) {
				case ACTION_PGDN:
					sdf = this.sdfStack.previous();
					break;
				case ACTION_PGUP:
					sdf = this.sdfStack.next();
					break;
				case ACTION_END:
					sdf = this.sdfStack.last();
					break;
				case ACTION_HOME:
					sdf = this.sdfStack.first();
					break;
				default:
					assert (false);

				}

				if (sdf == null)
					info("No more molecules in SDF buffer");
				else {
					// sdf = sdf.replace("\n", "|");
					this.clearMyMolecularContent(); // to avoid any merging with the current molecule
					pasteFromSDFstack = true;
					// Does not work with V3000!!!!
					// this.readMolFile(sdf, false);//do not copy in undo
					this.handleReadGenericInput(sdf, null, false, false); // do not repaint and record event here 

					pasteFromSDFstack = false;

					if (this.infoText.equals("")) { // no error mesage from readMolFile
						info("MOL n. " + this.sdfStack.getCurrentDisplayIndex() + " of " + this.sdfStack.size());
						structureChangePerformed = true;
						this.recordAfterStructureChangedEvent(JME.SD_FSTACK);
						this.willPostSave(false);
					}

				}

				break;

			case ACTION_SMI:

				this.handleSmilesBox();

				action = actionOld;
				break;
			case ACTION_QRY:
				this.handleQueryBox();

				// stay commented
				// action = action_old;
				break;
			case ACTION_JME:
				this.handleAboutBox();
				action = actionOld;
				break;
			case ACTION_NEW:
				// BB
				// setMustRedrawMolecular(true);
				newMolecule = true;
				action = actionOld; // ak nie je bond alebo ring, malo by

				// there is no structure change!!!! this is just a menu click
				// this.recordAfterStructureChangedEvent(JME.CLEAR);

				// resetnut
				break;
			
			case ACTION_MARK:
				if(this.markerMenu) {
					action = actionOld;
					this.showJPopupMenuRealtiveToScaledMainMenu(this.createFBackgroundColorPopumemu(),
							this.markerJPopupMenuPosition.x, markerJPopupMenuPosition.y);

					break;
				}
				// BB
				// setMustRedrawMolecular(true);
				if (autonumber) {
					// autonumber added in 2009.09
					if (mouseShift) { // automark all atoms, zrusi stare mark
						mouseShift = false; // aby pridavalo cisla
						activeMol.numberAtoms();

						// added Oct 2015 - not tested
						setMustRedrawMolecularArea(true);
						this.recordAfterStructureChangedEvent(JME.AUTO_NUMBER);
						structureChangePerformed = true;

						action = actionOld;
					}
				}
				// set na action_mark
				keyboradInputMark = 1; // starts from 1 ????????????????/
				// there is no structure change , only menu selection 123?
				// this.recordAfterStructureChangedEvent(JME.MARK);

				break;

//BB: END button was removed
//			case ACTION_SPIRO:
//				if (isStandAloneApplication) {
//					System.exit(0);
//				}
			// copy a reaction component to the other side of the reaction
			case ACTION_REACP:
				// save ???
				action = actionOld;
				this.updateReactionRoles();
				if (activeMol.getReactionRole() == JMEmol.ReactionRole.AGENT) {
					info("Copying the agent not possible !");
					break;
				}
				
				//compute the bounding box of the source molecule
				Box cad = activeMol.computeBoundingBoxWithAtomLabels();
				if(cad == null)
					break;

				setMustRedrawMolecularArea(true);
				activeMol = new JMEmol(activeMol);
				// mol = mol.createClone(); // ???
				// posunie ju na spravne miesto
				//int dx = (int) ((dimension.width - menuCellSize) / 2 - cad.getCenterX()); //center[0]);
				Rectangle.Double molArea = this.getMolecularAreaBoundingBoxCoordinate();
				double dx = molArea.getCenterX() - cad.getCenterX(); //dx can be negative or positive
//				for (int i = 1; i <= mol.natoms; i++)
//					mol.x[i] += dx * 2;
//					//mol.atoms[i].x += dx * 2;
//					moveXY(mol, i, dx * 2, 0);
				activeMol.moveXY(dx*2, 0); //move the new created molecule to the other side
				
				
					
				//mol.complete();
				//moleculeParts[++numberofMoleculeParts] = activeMol;
				//actualMoleculePartIndex = numberofMoleculeParts;
				moleculePartsList.add(activeMol);
				this.recordAfterStructureChangedEvent(JME.REACTION_COPY);
				
				structureChangePerformed = true;
				//added Jan 2016
				//this.postSave();
				
				//reset the blue highlight correctly
				this.handleMouseLeaveActionMenu(ACTION_REACP);
				this.handleMouseEnterActionMenu(ACTION_REACP);

				break;
				
			case ACTION_DELETE:
				// FIXME - DUPLICATED CODED with delete using the mouse!!!!!!!!!!!!!!!!!!!!
				// 2011.01 if touchedAtom or bond, deletes it
				// happens with keyboard shortcut not mouse action
				structureChangePerformed = this.actionDeleteTouchedAtomOrBond();
				break;

			case ACTION_FG:
				action = actionOld;
				this.showJPopupMenuRealtiveToScaledMainMenu(this.getFunctionalGroupPopumemu(),
						this.functionalGroupJPopupMenuPosition.x, functionalGroupJPopupMenuPosition.y);
				// this.getFunctionalGroupPopumemu().show(this,
				// (int)(this.functionalGroupJPopupMenuPosition.x * this.menuScale),
				// (int)(functionalGroupJPopupMenuPosition.y * this.menuScale));

				break;

			case ACTION_CHARGE:
				// BB
				if (activeMol.touchedAtom > 0 && activeMol.changeCharge(activeMol.touchedAtom, 0)) {
					this.recordAtomEvent(JME.CHARGE_ATOM0); // same code as in mouseDown event
					structureChangePerformed = true;
				}
				break;

			default: // vsetky co nerobia okamzitu akcion (DEL, templates, +/-,
				// ...)
				break;
			}
		} else { // pressed > 300 (left menu - atoms)
			// BB
			this.mustReDrawLeftMenu = true;
			this.mustReDrawTopMenu = true; // deselection of an item in the top menu
			// if the action is coming from a keyboard structure change, then there is no
			// need to redraw the the menu
			active_an = mapActionToAtomNumber(pressed, -1);

			// BB added August 2017
			clearInfo(); // clear any messages

//			switch (pressed) {
//			case ACTION_AN_C:
//				active_an = AN_C;
//				break;
//			case ACTION_AN_N:
//				active_an = AN_N;
//				break;
//			case ACTION_AN_O:
//				active_an = AN_O;
//				break;
//			case ACTION_AN_F:
//				active_an = AN_F;
//				break;
//			case ACTION_AN_CL:
//				active_an = AN_CL;
//				break;
//			case ACTION_AN_BR:
//				active_an = AN_BR;
//				break;
//			case ACTION_AN_I:
//				active_an = AN_I;
//				break;
//			case ACTION_AN_S:
//				active_an = AN_S;
//				break;
//			case ACTION_AN_P:
//				active_an = AN_P;
//				break;
//			case ACTION_AN_H:
//				active_an = AN_H;
//				break;
//			case ACTION_AN_X:
//				this.handleAtomXbox();
//				active_an = AN_X;
//				
//				break;
			/*
			 * case ACTION_AN_R: active_an = AN_R; break; case ACTION_AN_R1: active_an =
			 * AN_R1; break; case ACTION_AN_R2: active_an = AN_R2; break; case ACTION_AN_R3:
			 * active_an = AN_R3;
			 * 
			 * 
			 * break;
			 */

//			}

			if (active_an == AN_X) {
				this.handleAtomXbox();
			}
			// BB : handling R group
			if (pressed >= ACTION_AN_R && pressed <= ACTION_AN_R_LAST) {
				active_an = AN_R + (pressed - ACTION_AN_R);
			}

			// 2009.09 if touchedAtom, changes it
			if (structureChangePerformed == false && activeMol.touchedAtom > 0) {
				// BB
				if (active_an != activeMol.an(activeMol.touchedAtom) && active_an != AN_X) {
					activeMol.AN(activeMol.touchedAtom, active_an);
					activeMol.Q(activeMol.touchedAtom, 0); // resetne naboj
					// mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
					activeMol.atoms[activeMol.touchedAtom].iso = 0; // BB: reset isotop
					// mol.nh[mol.touchedAtom] = 0;
					activeMol.atoms[activeMol.touchedAtom].nh = 0;

					// this.postSave();
					//this.recordAtomEvent(JME.SET_ATOM + active_an); // active_an is an arbitrary number, should be
					// changed to the string of the atom type
					this.recordAtomEvent(JME.SET_ATOM); // useless since the JSME_Event has the atom number

					// BB Sept 2015: changed the touched atom but do not change the menu
					// action = actionOld;
					structureChangePerformed = true;
				} else if (active_an == AN_X) {
					// MultiBox not atomxBox (this is static and always
					// available,
					// needed for key press)
					// FIXME: this code is never reached
					// code reached when the X keyboard shortcut is used
					// assert false;
					String xx = MultiBox.atomicSymbol.getText();
					activeMol.setAtom(activeMol.touchedAtom, xx);
					// this.postSave();
					//this.recordAtomEvent(JME.SET_ATOM + active_an);// useless since the JSME_Event has the atom number
					this.recordAtomEvent(JME.SET_ATOM);
					structureChangePerformed = true;

				}
				// mol.cleanAfterChanged(); // to add Hs

			}
		}

		// BB Sept 2015: add ring addition
		// extend with other actions:
		// phenyl ring (shortcut is "1"
		// 2 for double bond?, see the help for the shortcucts
		/*
		 * atoms C, N, O, P, S, F, L (for Cl), B (for Br), I, H, R bonds - for single
		 * bond, = for double bond rings 3..8 for 3 to 8 membered rings, 1 for phenyl
		 * and 0 for furyl groups a - COOH, y - NO2, z - SO3H, t - tert. butyl, ft - CF3
		 */
		if (!structureChangePerformed && (activeMol.touchedAtom > 0 || activeMol.touchedBond > 0)) {
			// the addRing function can handle both bond and atom
			// duplicated code
			// this works as well for addition of phenyl (KB shortcut is "1")
			if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {

				// fusing ring to bond
				lastAction = LA_RING; // in addRing may be set to 0
				activeMol.addRing();
				structureChangePerformed = true;
				this.recordBondEvent(JME.ADD_RING_BOND);
			}

			// BB Oct 2015: add bond & change bond without switch to double bond bond tool
			else if (action == ACTION_BOND_SINGLE || action == ACTION_BOND_DOUBLE || action == ACTION_BOND_TRIPLE) {

				if (activeMol.touchedAtom > 0) {
					// lastAction = LA_BOND; // in addBond may be set to 0
					lastAction = 0; // correction - ohterwise mouse drag will move the end of the new added bond
									// instead of moving the molecule
					// mol.preSave();
					activeMol.addBond();
					this.recordBondEvent(JME.ADD_BOND);
					structureChangePerformed = true;
				} else { // mol.touchedBond > 0
					// code cpoied from mouseDown DUPLiCATED !!!! TODO
					int bondType = JMEmol.SINGLE;
					String eventType = JME.SET_BOND_SINGLE;
					boolean changed; // BB
					switch (action) {
					case ACTION_BOND_DOUBLE:
						bondType = JMEmol.DOUBLE;
						eventType = JME.SET_BOND_DOUBLE;
						break;
					case ACTION_BOND_TRIPLE:
						bondType = JMEmol.TRIPLE;
						eventType = JME.SET_BOND_TRIPLE;
					}
					changed = bondType != activeMol.bonds[activeMol.touchedBond].bondType;
					if (changed) {
						activeMol.bonds[activeMol.touchedBond].bondType = bondType;
						this.recordBondEvent(eventType);
						structureChangePerformed = true;
						activeMol.bonds[activeMol.touchedBond].stereo = 0; // zrusi stereo
					} else if (bondType == JMEmol.DOUBLE) {
						// no change but clicked a second time on a double bond with the double bond
						// tool
						// change normal double bond into crossed bond or vice versa
						activeMol.bonds[activeMol.touchedBond].toggleNormalCrossedDoubleBond();
						structureChangePerformed = true;
					}

				}

			}

		}

		if (structureChangePerformed) {
			// this.mustRedrawNothing(); //info might have been generated
			setMustRedrawMolecularArea(true);
//			mocleanAfterChangedte();
//			
//			if(mustBeSaveToUndoStack);
//				this.postSave();

			//updateReactionParts(); // a new bond might have connected two separated molecules

			action = actionOld; // BB avoid menu change during repaint() after a key press that has changed the
								// structure, like pressing 2 , add a double bond but do not switch to db tool
		}

		// repaintuje zbytocne vsetko - zatial nechat
		if(mustReDrawMolecularArea) {
			this.drawMolecularAreaRightNow();
			
		}

		repaint();

		// BB
		return status;
	}

	/**
	 * This method recods the event and performn the postSave()
	 * 
	 * @return true if the an atom or a bond has been deleted
	 */
	boolean actionDeleteTouchedAtomOrBond() {
		boolean structureChangePerformed = false;
		
		if (activeMol.touchedAtom > 0 || activeMol.touchedBond > 0) {
			// BB
			structureChangePerformed = true;
			//mol.preSave(); //TODO REMOVE
			if(activeMol.touchedAtom > 0 ) {
				activeMol.deleteAtom(activeMol.touchedAtom);
				this.recordAtomEvent(JME.DEL_ATOM);
				activeMol.touchedAtom = 0;
			} else {
				activeMol.deleteBond(activeMol.touchedBond);
				this.recordAtomEvent(JME.DEL_BOND);
				activeMol.touchedBond = 0;
				
			}
			activeMol.cleanAfterChanged(this.polarnitro); // to add Hs
			
			//if an atom or a bond is deleted, then create new molecule if needed
			moleculePartsList.splitFragments(true); //true: remove any empty molecule
			if(moleculePartsList.isEmpty()) { //can happen when there are no molecule left, e.g, the last one had a single atom that was deleted
				moleculePartsList.add(new JMEmol());
			}
			activeMol = moleculePartsList.get(0);
			/*
			JMEmol newParts[] = mol.splitMultiparts();
			if(newParts.length > 1) {
				int molIndex = moleculeParts.indexOf(mol);
				moleculeParts.remove(molIndex);
				for(int p = 0; p < newParts.length; p++) {
					if(p==0) {
						moleculeParts[actualMoleculePartIndex] = newParts[p]; //replaced by the first new molecule
						mol = moleculeParts[actualMoleculePartIndex];
					} else {
						moleculeParts[++numberofMoleculeParts] =newParts[p]; //Append new parts
					}
				}
			}
			*/
		}

		
		return structureChangePerformed;
	}
	/**
	 * Create an alert box with an OK button to display a message
	 * 
	 * @param message
	 */
	public void alert(final String message) {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {

				new AlertBox(message, JME.this, JME.this.bgColor).setVisible(true);

			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAboutBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {

				if (aboutBox != null) {
					aboutBox.disposeIfShowing();
				}
				aboutBox = new MultiBox(MultiBox.BOX_ABOUT, JME.this);

			}
		});
	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleQueryBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {

				// if (queryBox != null) {
				// queryBox.disposeIfShowing();
				// }
				// queryBox = new QueryBox(this);

				// BB: it is better that the query box keeps its selection when brought back -
				// dispose() erase everything
				// however, it might be hidden behind another window, thus it has to show in
				// front
				if (queryBox == null) {
					queryBox = new QueryBox(JME.this);
				} else {
					if (queryBox.isShowing()) {
						queryBox.toFront(); // not tested wihthin a browser window, works fine with Eclipse/Linux
						// queryBox.setVisible(false);
						// queryBox.setVisible(true);
					} else {
						queryBox.setVisible(true);
					}
				}

			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleSmilesBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				if (smilesBox != null) {
					smilesBox.disposeIfShowing();
				}
				smilesBox = new MultiBox(MultiBox.BOX_SMILES, JME.this);
			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAtomXbox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {

				if (!webme) {
					if (atomxBox != null) {
						atomxBox.disposeIfShowing();
						atomxBox = null;
					}
					if (activeMol.touchedAtom == 0)
						atomxBox = new MultiBox(MultiBox.BOX_ATOMX, JME.this);
				}
			}

		});

	}

	// ----------------------------------------------------------------------------
	void createSquare(PreciseGraphicsAWT g, int xpos, int ypos) {
		int square = ypos * 100 + xpos;
		double xstart = (xpos - 1) * (menuCellSize + menuCellBorder());
		double ystart = (ypos - 1) * (menuCellSize + menuCellBorder());
		if (xpos == 1 && ypos > 2)
			ystart -= (2 * menuCellSize); // relative coordinates in leftMenu
		g.setColor(bgColor);
		if (newLook) {
			if (square == action) {
				g.setColor(bgColor.darker());
				// System.out.println("xstart=" + xstart + " ystart=" + ypos);
			}

			g.fillRect(xstart, ystart, menuCellSize, menuCellSize);
			g.setColor(Color.darkGray);
			g.drawRect(xstart, ystart, menuCellSize - 1, menuCellSize - 1);
		} else {
			if (square == action)
				g.fill3DRect(xstart + 1, ystart + 1, menuCellSize, menuCellSize, false); // color override does not work
																							// - always grey?
			else
				g.fill3DRect(xstart, ystart, menuCellSize, menuCellSize, true);
		}

		
		if (! this.isActionEnabled(square)) {
			return ;
		}

		// draws icon or text in the square
		double marginFromCellBorder = menuCellSize / 4; // space between cell border and inside icon
		if (ypos < 3) { // top menu squares
			g.setColor(Color.black);
			switch (square) {
			case ACTION_SMI: // smiley face
				if (true) {
					g.setColor(Color.yellow);
					g.fillOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // head
					g.setColor(Color.black);
				}
				g.drawOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // head
				g.drawArc(xstart + 6, ystart + 6, menuCellSize - 12, menuCellSize - 12, -35, -110); // mouth
				// oci
				g.fillRect(xstart + 9, ystart + 9, 2, 4);
				g.fillRect(xstart + menuCellSize - 10, ystart + 9, 2, 4);
				// jazyk
				if (Math.random() < 0.04) {
					g.setColor(Color.red);
					g.fillRect(xstart + 10, ystart + 18, 4, 4);
				}
				// blink
				if (Math.random() > 0.96) {
					g.setColor(Color.yellow);
					g.fillRect(xstart + menuCellSize - 10, ystart + 8, 2, 3);
				}
				break;
			case ACTION_SPIRO:
				// drawing spiro button
				double xFarLeft = xstart + marginFromCellBorder;
				double xFarRight = xstart + menuCellSize - marginFromCellBorder;
				double xMiddle = xstart + menuCellSize / 2;
				// bottom left - black line
				g.drawLine(xFarLeft, ystart + menuCellSize - marginFromCellBorder, xMiddle, ystart + menuCellSize / 2);
				g.drawLine(xstart + menuCellSize / 2, ystart + menuCellSize / 2, xFarRight,
						ystart + menuCellSize - marginFromCellBorder);

				double y = ystart + menuCellSize - marginFromCellBorder;
				double dotLength = ((double) this.menuCellSize) / this.standardMenuCellSize;
				g.drawLine(xMiddle - dotLength, y, xMiddle - 2 * dotLength, y);
				g.drawLine(xMiddle + dotLength, y, xMiddle + 2 * dotLength, y);

				g.setColor(Color.magenta);
				// top left - magenta line
				g.drawLine(xFarLeft, ystart + marginFromCellBorder, xMiddle, ystart + menuCellSize / 2);
				g.drawLine(xstart + menuCellSize / 2, ystart + menuCellSize / 2, xFarRight,
						ystart + marginFromCellBorder);

				y = ystart + marginFromCellBorder;
				g.drawLine(xMiddle - dotLength, y, xMiddle - 2 * dotLength, y);
				g.drawLine(xMiddle + dotLength, y, xMiddle + 2 * dotLength, y);

				// restore default color
				g.setColor(Color.black);
				break;

			case ACTION_QRY:
				g.setColor(Color.orange);
				g.fillRect(xstart + 4, ystart + 4, menuCellSize - 8, menuCellSize - 8); // head
				g.setColor(Color.black);
				g.drawRect(xstart + 4, ystart + 4, menuCellSize - 8, menuCellSize - 8); // head
				g.drawArc(xstart + 6, ystart + 6, menuCellSize - 11, menuCellSize - 12, -35, -110); // mouth
				g.fillRect(xstart + 9, ystart + 9, 2, 4);
				g.fillRect(xstart + menuCellSize - 10, ystart + 9, 2, 4);
				break;
			case ACTION_CHARGE:
				// squareText(g, xstart, ystart, "+ / ");
				// squareText(g, xstart, ystart, "+ / -");
				// squareTextBold(g, xstart, ystart, Color.black, "+ -");
				// g.drawLine(xstart + 15, ystart + 13, xstart + 19, ystart + 13); // better
				// -
				double padding = (double) menuCellSize / 4;
				// the / line
				g.drawLine(xstart + padding, ystart + menuCellSize - padding, xstart + menuCellSize - padding,
						ystart + padding);

				double symbolSize = (double) menuCellSize / 2 - padding;

				// the minus - bottom right
				double minusY = ystart + menuCellSize * 2 / 3;
				double minusStartX = xstart + menuCellSize / 2;
				double minusEndX = minusStartX + symbolSize;

				g.drawLine(minusStartX, minusY, minusEndX, minusY);

				// the plus horizontal line - top left
				double hY = ystart + menuCellSize * 1 / 3;
				double hEndX = minusStartX;
				double hStartX = minusStartX - symbolSize;
				g.drawLine(hStartX, hY, hEndX, hY);

				// the plus vertical line - top left
				double vX = (hStartX + hEndX) / 2;
				double vStartY = hY - symbolSize / 2;
				double vEndY = vStartY + symbolSize;
				g.drawLine(vX, vStartY, vX, vEndY);

				break;

			case ACTION_MOVE_AT:

				if (this.showAtomMoveJButton) {
					// Draw a blue rectangle centered in the cell
					double reduction = (double) marginFromCellBorder / 2;
					double squareSize = menuCellSize - 2 * marginFromCellBorder - 2 * reduction;
					double brx = xstart + reduction + marginFromCellBorder; // blue rectangle x
					double bry = ystart + (brx - xstart);

					g.setColor(Color.BLUE);
					g.drawRect(brx, bry, squareSize, squareSize);

					g.setColor(Color.BLACK);

					// four triangles symbolising arrows
					double middleX = xstart + menuCellSize / 2;
					double middleY = ystart + menuCellSize / 2;

					double arrowMarginFromCellBorder = reduction; // not enough space for using a complete margin
					double arrowHeight = reduction;
					double arrowWidth = squareSize; // must be the same as squareSize for small cells, if different, the
													// code has to be adapted
					assert arrowHeight > 0;

					// top triangle arrow
					double xLeft = brx;
					double xRight = brx + arrowWidth;
					double yTop = ystart + arrowMarginFromCellBorder;
					// int yBottom = bry - reduction;
					double yBottom = yTop + arrowHeight;

					g.drawLine(xLeft, yBottom, middleX, yTop);
					g.drawLine(middleX, yTop, xRight, yBottom);

					// bottom triangle arrow
					// x coordinates are the same
					yBottom = bry + squareSize + reduction;
					yTop = yBottom + arrowHeight;
					g.drawLine(xLeft, yBottom, middleX, yTop);
					g.drawLine(middleX, yTop, xRight, yBottom);

					// Left triangle
					xLeft = xstart + reduction;
					xRight = xLeft + arrowHeight;
					yTop = bry;
					yBottom = yTop + arrowWidth;

					g.drawLine(xRight, yTop, xLeft, middleY);
					g.drawLine(xLeft, middleY, xRight, yBottom);

					// right triangle
					// y coordinates are the same
					xLeft = brx + squareSize + reduction;
					xRight = xLeft + arrowHeight;

					g.drawLine(xLeft, yTop, xRight, middleY);
					g.drawLine(xRight, middleY, xLeft, yBottom);
				}

				break;

			case ACTION_UNDO:
				// g.drawArc(xstart+6,ystart+6,sd-12,sd-12,270,270); // head
				// g.drawArc(xstart + 6, ystart + 7, menuCellSize - 12, menuCellSize - 14, 270,
				// 270); // head

				this.drawUndoOrRedoArrowMenuCell(g, xstart, ystart, menuCellSize, true);

				// squareText(g,xstart,ystart,"UDO");
				break;

			case ACTION_REDO:
				this.drawUndoOrRedoArrowMenuCell(g, xstart, ystart, menuCellSize, false);
				break;

			case ACTION_IO:
				this.drawInputOutputArrowsMenuCell(g, xstart, ystart, menuCellSize);
				this.fixedCopyPasteJPopupMenuPosition = new Point((int) xstart, (int) ystart);

				break;

			case ACTION_REACP:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder * 3 / 2,
						ystart + menuCellSize / 2 + marginFromCellBorder / 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder * 3 / 2,
						ystart + menuCellSize / 2 - marginFromCellBorder / 2);
				break;
			case ACTION_CLEAR:
				g.setColor(Color.white);
				g.fillRect(xstart + 3, ystart + 5, menuCellSize - 7, menuCellSize - 11);
				g.setColor(Color.black);
				g.drawRect(xstart + 3, ystart + 5, menuCellSize - 7, menuCellSize - 11);
				// squareText(g,xstart,ystart,"CLR");
				break;
			case ACTION_NEW:
				// special handling (aby boli 2 stvorce on)
				g.setColor(bgColor);
				if (newMolecule)
					g.fill3DRect(xstart + 1, ystart + 1, menuCellSize, menuCellSize, false);
				g.setColor(Color.black);
				squareText(g, xstart, ystart, "NEW");
				break;
			case ACTION_DELGROUP:
				// squareText(g,xstart,ystart,"D-R");
				g.setColor(Color.red);
				g.drawLine(xstart + 7, ystart + 7, xstart + menuCellSize - 7, ystart + menuCellSize - 7);
				// g.drawLine(xstart + 8, ystart + 7, xstart + menuCellSize - 6, ystart +
				// menuCellSize
				// - 7);
				g.drawLine(xstart + 7, ystart + menuCellSize - 7, xstart + menuCellSize - 7, ystart + 7);
				// g.drawLine(xstart + 8, ystart + menuCellSize - 7, xstart + menuCellSize - 6,
				// ystart + 7);
				g.setColor(Color.black);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + 12,
						ystart + menuCellSize / 2);
				squareText(g, xstart + 6, ystart, "R");
				break;
			case ACTION_DELETE:
				// squareText(g,xstart,ystart,"DEL");
				g.setColor(Color.red);
				// g.drawLine(xstart+m,ystart+m,xstart+sd-m,ystart+sd-m);
				// g.drawLine(xstart+m+1,ystart+m,xstart+sd-m+1,ystart+sd-m);
				// g.drawLine(xstart+m,ystart+sd -m,xstart+sd-m,ystart+m);
				// g.drawLine(xstart+m+1,ystart+sd-m,xstart+sd-m+1,ystart+m);
				g.drawLine(xstart + 7, ystart + 7, xstart + menuCellSize - 7, ystart + menuCellSize - 7);
				// g.drawLine(xstart + 8, ystart + 7, xstart + menuCellSize - 6, ystart +
				// menuCellSize
				// - 7);
				g.drawLine(xstart + 7, ystart + menuCellSize - 7, xstart + menuCellSize - 7, ystart + 7);
				// g.drawLine(xstart + 8, ystart + menuCellSize - 7, xstart + menuCellSize - 6,
				// ystart + 7);
				g.setColor(Color.black);
				break;
			case ACTION_MARK: // handle both color marking and setting of atom map
				
				if (! this.starNothing) {
					if (moleculeHandlingParameters.mark) {
	
							// May 2015replaced by a circle
							
							// 6 is  same as for smiley
							double pseudoRadius = 9; // was 6, PE wants it smaller
							Color color = this.colorManager.getColor(activeMarkerColorIndex);
							if (color != null) {
								g.setColor(color);							
								g.fillOval(xstart + pseudoRadius/2, ystart + pseudoRadius/2, menuCellSize - pseudoRadius, menuCellSize - pseudoRadius); 
								g.setColor(Color.black);
							} else {
								this.showInfo("invalid color index:" + activeMarkerColorIndex);
								assert(false);
							}
	
					} else
						squareText(g, xstart, ystart, "123");
					
					this.markerJPopupMenuPosition = new Point((int) xstart, (int) ystart);
				}
				break;
			case ACTION_JME:
				// squareText(g,xstart,ystart,"JME");
				// g.drawImage(infoImage,xstart+2,ystart+2,this);
				g.setColor(Color.blue);
				double coloredRectSize = menuCellSize - 8;
				double coloredRectSizeX = xstart + (menuCellSize - coloredRectSize) / 2;
				double coloredRectSizeY = ystart + (menuCellSize - coloredRectSize) / 2;
				g.fillRect(coloredRectSizeX, coloredRectSizeY, coloredRectSize, coloredRectSize);
				g.setColor(Color.black);
				// g.drawRect(coloredRectSizeX, coloredRectSizeY, coloredRectSize,
				// coloredRectSize);
				// squareTextBold(g, xstart + 1, ystart - 1, Color.white, "i");
				squareTextBold(g, xstart, ystart, Color.white, "i");
				break;
			case ACTION_STEREO:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 2);
				break;
			case ACTION_BOND_SINGLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2);
				break;
			case ACTION_BOND_DOUBLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 - 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 + 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 2);
				break;
			case ACTION_BOND_TRIPLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 - 3,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 3);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 + 3,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 3);
				break;
			case ACTION_CHAIN:
				g.drawLine(xstart + marginFromCellBorder / 2,
						ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3,
						xstart + marginFromCellBorder / 2 * 3,
						ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3);
				g.drawLine(xstart + marginFromCellBorder / 2 * 3,
						ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3,
						xstart + marginFromCellBorder / 2 * 5,
						ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3);
				g.drawLine(xstart + marginFromCellBorder / 2 * 5,
						ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3,
						xstart + marginFromCellBorder / 2 * 7,
						ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3);
				break;
			case ACTION_RING_3: // klesnute o 2
				drawRingIcon(g, xstart, ystart + 2, 3);
				break;
			case ACTION_RING_4:
				drawRingIcon(g, xstart, ystart, 4);
				break;
			case ACTION_RING_5:
				drawRingIcon(g, xstart, ystart, 5);
				break;
			case ACTION_RING_PH:
				drawRingIcon(g, xstart, ystart, 1);
				break;
			case ACTION_RING_6:
				drawRingIcon(g, xstart, ystart, 6);
				break;
			case ACTION_RING_7:
				drawRingIcon(g, xstart, ystart, 7);
				break;
			case ACTION_RING_8:
				drawRingIcon(g, xstart, ystart, 8);
				break;

			case ACTION_FG:
				if (this.fgMenuOption) {
					squareText(g, xstart, ystart, "FG");
					this.functionalGroupJPopupMenuPosition = new Point((int) xstart, (int) ystart);
				}
				break;

			}
		} else { // ypos >=3 (left menu squares)

			if (square == 1301) {
				this.log("");
			}
			int dan = mapActionToAtomNumber(square, -1);
			if (dan != -1) {
				String label = zlabel[dan];
				Color atomSymbolColor =  this.leftMenuAtomColor == null ? color[dan]: this.leftMenuAtomColor ;

				squareTextBold(g, xstart, ystart, atomSymbolColor, label);
			}

		}
	}

	// BB
	// To ease debugging this method, the menuCellSize can be set to a higher value
	// , e.g 120
	void drawUndoOrRedoArrowMenuCell(PreciseGraphicsAWT g, double xstart, double ystart, double cellSize,
			boolean undo) {
		double arrowWidth = ((double) cellSize / 4.0); // 6
		double arrowHeight = arrowWidth;
		double margin = 2;
		ystart -= 1; // Nov 2016: better vertical centering

		// X values: we work with relative values because the absolute values will be
		// different for the Undo and Redo arrows
		double xStartArrowLine = margin;
		double xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		double xEndArrowLine = xStartArrowLine + arrowWidth;

		// All Y values are absolute
		double yStartArrowLine = ystart + (10.0 * cellSize / 24.0);
		double yArrowTip = yStartArrowLine + arrowHeight;

		double xEnd = xstart + cellSize;

		double absoluteXArrowTip = 0;
		double absoluteXstartArrowLine = 0;
		double absoluteXEndArrowLine = 0;
		if (undo) {
			absoluteXstartArrowLine = xStartArrowLine + xstart;
			absoluteXArrowTip = xArrowTip + xstart;
			absoluteXEndArrowLine = xEndArrowLine + xstart;
		} else {
			// mirror image
			// Y values stay the same
			absoluteXArrowTip = xEnd - xArrowTip;
			absoluteXstartArrowLine = xEnd - xStartArrowLine;
			absoluteXEndArrowLine = xEnd - xEndArrowLine;
		}

		// draw the two lines of the arrow tip - two sides of the triangle
		g.drawLine(absoluteXstartArrowLine, yStartArrowLine, absoluteXArrowTip, yArrowTip);
		g.drawLine(absoluteXEndArrowLine, yStartArrowLine, absoluteXArrowTip, yArrowTip);

		// draw middle line of the arrow , but not as extended as the triangle lines -
		// it looks nicer so
		double yArrowCenterCorrection = arrowHeight / 3 - 0.5; // without the -0.5 , there is a gap visible when zooming
																// in

		g.drawLine(absoluteXArrowTip, yStartArrowLine + yArrowCenterCorrection, absoluteXArrowTip, yArrowTip);

		// The arc

		// define the coordinates and sizes of the bounding box that will contain the
		// arc
		double xStartArcBoxTopLeft = xArrowTip;
		double yStartArcBoxTopLeft = ystart + xStartArcBoxTopLeft;
		double arcBoxWidth = cellSize - xStartArcBoxTopLeft - 2 * margin;
		double arcBoxHeight = cellSize - 2 * margin;

		// The arc has to be moved slightly up in order to align with the start of the
		// line of the center of the arrow (see above)
		yStartArcBoxTopLeft -= yArrowCenterCorrection;
		arcBoxHeight -= yArrowCenterCorrection;

		arcBoxHeight -= 1; // looks better when the cell size is small

		double arcSpan = 270;
		double startAngle = 0;
		double absoluteXxtartArcBoxTopLeft = 0;
		if (undo) {
			absoluteXxtartArcBoxTopLeft = xstart + xStartArcBoxTopLeft;
			startAngle = 270;
		} else {
			absoluteXxtartArcBoxTopLeft = xEnd - arcBoxWidth - xStartArcBoxTopLeft;
			arcSpan *= -1;
			startAngle = -90;
		}
		// draw an arc inside the box
		g.drawArc(absoluteXxtartArcBoxTopLeft, yStartArcBoxTopLeft, arcBoxWidth, arcBoxHeight, startAngle, arcSpan);
	}

	// To ease debugging this method, the menuCellSize can be set to a higher value
	// , e.g 120
	/**
	 * draw two vertical blue arrows to symbolize output / input, arrows are
	 * simplified as triangles
	 * 
	 * @param g
	 * @param xstart
	 * @param ystart
	 * @param cellSize
	 * @param undo
	 */
	void drawInputOutputArrowsMenuCell(PreciseGraphicsAWT g, double xstart, double ystart, double cellSize) {

		// arrows are simplified as triangle
		double arrowWidth = this.ioArrowWidth;
		double arrowHeight = arrowWidth;
		double margin = this.ioMargin;
		double xStartArrowLine = margin + xstart;
		double xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		double xEndArrowLine = xStartArrowLine + arrowWidth;

		double yStartArrowLine = ystart + margin;
		double yArrowTip = yStartArrowLine + arrowHeight;

		g.setColor(Color.BLUE);

		g.fillPolygon(new double[] { xStartArrowLine, xArrowTip, xEndArrowLine },
				new double[] { yStartArrowLine, yArrowTip, yStartArrowLine }, 3);

		/* 2nd triangle */
		xStartArrowLine = xArrowTip;
		xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		xEndArrowLine = xStartArrowLine + arrowWidth;

		yArrowTip = yStartArrowLine + arrowHeight / 2.0;
		yStartArrowLine = yArrowTip + arrowHeight;

		g.fillPolygon(new double[] { xStartArrowLine, xArrowTip, xEndArrowLine },
				new double[] { yStartArrowLine, yArrowTip, yStartArrowLine }, 3);

	}

	/**
	 * Draw the drag and drop symbol at the bottom right of the JSME container
	 * 
	 * @param g                       : either the infor bar or the molecular area
	 * @param graphicsContainerWidth
	 * @param graphicsContainerHeight
	 */
	void drawDragAndDropIcon(PreciseGraphicsAWT g, double iconScale) {
		// arrows are simplified as triangle

		double graphicsContainerWidth = g.getWidth();
		double graphicsContainerHeight = g.getHeight();

		// Use the same size as I/O arrows

		double margin = this.ioMargin * iconScale;
		double arrowWidth = this.ioArrowWidth * iconScale;
		double arrowHeight = arrowWidth;

		if (dragAndDropIcon == null)
			dragAndDropIcon = new Icon(g);
		else
			dragAndDropIcon.pg = g;

		if (this.isDepict()) {
			margin = 0; // put the arrow at the extreme left and bottom without any margin
		}

		double xStartArrowLine = graphicsContainerWidth - margin - arrowWidth;
		double xArrowTip = xStartArrowLine + arrowWidth;

		double yArrowBottom;

		double yArrowTop;
		double yArrowMiddle;

		if (!this.isDepict()) { // non depict mode: the arrow is Y centered in the middle of the info bar
			yArrowMiddle = graphicsContainerHeight / 2;
			yArrowBottom = yArrowMiddle + arrowHeight / 2;
			yArrowTop = yArrowMiddle - arrowHeight / 2;
		} else { // arrow is placed at the bottom right
			yArrowBottom = graphicsContainerHeight;

			yArrowTop = yArrowBottom - arrowHeight;
			yArrowMiddle = (yArrowTop + yArrowBottom) / 2;
		}

		g.setColor(Color.BLUE);

		g.fillPolygon(new double[] { xStartArrowLine, xArrowTip, xStartArrowLine },
				new double[] { yArrowTop, yArrowMiddle, yArrowBottom }, 3);

		dragAndDropIcon.setRect(xStartArrowLine, yArrowTop, arrowWidth, arrowHeight);

	}

	// isFullScreen() is overiden is JSME
	public boolean isFullScreen() {
		return this.isFullScreen;
	}

	/**
	 * Draw the icon for toggling between normal and fullscreen
	 * 
	 * @param g
	 * @param graphicsContainerWidth
	 * @param graphicsContainerHeight
	 * @param iconScale
	 * @param expand
	 */
	void drawFullScreenIcon(PreciseGraphicsAWT g, double iconScale, Icon rightIcon) {

		boolean expand = !isFullScreen();

		// the icon is needed for event handling
		if (this.fullScreenIcon == null) {
			this.fullScreenIcon = new Icon(g);
		} else {
			this.fullScreenIcon.pg = g;
		}

		double margin = this.ioMargin * iconScale;
		double iconHeight = this.ioArrowWidth * iconScale; // same height as the DnD icon

		// the icon will placed at the bottom right
		double rightX = g.getWidth();
		double graphicsContainerHeight = g.getHeight();
		if (rightIcon != null) {
			rightX = rightIcon.x;// put the icon to left side of the DnD icon if present
			iconHeight = rightIcon.height; // same height as the DnD icon
			// move further to the left of the DnD icon
			rightX -= 2 * margin;
		}

		// icon will look like a monitor display with 16:9 ratio
		double rectangleWidth = iconHeight * 16 / 9;

		double startSize = 1.0;
		double endSize = 0.3;
		double startColor = 0;
		double endColor = 1.0;
		int steps = 20;
		boolean firstLoop = true;

		// create a gradient blue to white (or vice versa) by stacking rectangles of
		// decreasing sizes
		for (double relativeSize = startSize; relativeSize >= endSize; relativeSize -= (startSize - endSize) / steps) {
			float c = (float) ((startSize - relativeSize) * (endColor - startColor) / (startSize - endSize));

			// reverse the icon color scheme when the applet is in full screen mode
			if (!expand) {
				c = (float) endColor - c;
			}
			Color color = new Color(c, c, 1.0f);
			g.setColor(color);

			double h = iconHeight * relativeSize;
			double w = h / iconHeight * rectangleWidth;
			double x = rightX - rectangleWidth + (rectangleWidth - w) / 2;
			double y;
			if (!this.isDepict()) { // non depict mode: the icon is Y centered in the middle of the info bar
				y = graphicsContainerHeight / 2 - h / 2;
			} else {
				y = graphicsContainerHeight - iconHeight / 2 - h / 2;
			}
			g.fillRect(x, y, w, h);

			if (firstLoop) {
				// save the position of the icon on the graphics - will be used for event
				// handling
				firstLoop = false;
				fullScreenIcon.setRect(x, y, w, h); // for event handling
			}

		}

	}

	// --------------------------------------------------------------------------
	void squareText(PreciseGraphicsAWT g, double xstart, double ystart, String text) {

		// Smaller font is needed to display NEW and 123

		// g.setFont(menuCellFontSmaller);
		// int hSmall = menuCellFontSmallerMet.getBoxUppercaseHeight(); // vyska fontu
		// int w = menuCellFontSmallerMet.stringWidth(text);

		FontMetrics fm = menuCellFontMet;
		int w = fm.stringWidth(text);

		// Smaller font is needed to display NEW and 123
		// If the text is too wide for the cell, then use a smaller font
		if (w >= menuCellSize - 1) {
			int size = fm.getFont().getSize();
			// TODO: font cache does not work here
			// decrease font size until the text fits in the cell
			while (w >= menuCellSize - 1 && size > 1) {
				size--;
				Font smallerFont = new Font(fm.getFont().getName(), fm.getFont().getStyle(), size);
				fm = getFontMetrics(smallerFont);
				w = fm.stringWidth(text);
				g.setFont(smallerFont);

			}
		} else {
			g.setFont(menuCellFont);
		}
		double h = this.stringHeight(fm); // vyska fontu

		g.drawString(text, xstart + (menuCellSize - w) / 2, ystart + (menuCellSize - h) / 2 + h);

	}

	// --------------------------------------------------------------------------
	void squareTextBold(PreciseGraphicsAWT g, double xstart, double ystart, Color col, String text) {
		// Used for the atom symbols on the left side menu
		double h = this.stringHeight(menuCellFontBoldMet); // vyska fontu
		double w = menuCellFontBoldMet.stringWidth(text);
		g.setFont(menuCellFontBold);
		g.setColor(col);
//		if (bwMode)
//			g.setColor(Color.black);
		g.drawString(text, xstart + (menuCellSize - w) / 2, ystart + (menuCellSize - h) / 2 + h);
		// poor man's BOLD
		// g.drawString(text,xstart+(sd-w)/2+1,ystart+(sd-h)/2+h);
	}

	// --------------------------------------------------------------------------
	void drawRingIcon(PreciseGraphicsAWT g, double xstart, double d, int n) {
		double m = menuCellSize / 4; // margin
		boolean ph = false;
		double xp[] = new double[9];
		double yp[] = new double[9]; // polygon coordinates
		double xcenter = xstart + menuCellSize / 2;
		double ycenter = d + menuCellSize / 2;
		double rc = menuCellSize / 2 - m / 2;
		if (n == 1) {
			n = 6;
			ph = true;
		}
		for (int i = 0; i <= n; i++) {
			double uhol = Math.PI * 2. / n * (i - .5);
			xp[i] = xcenter + rc * Math.sin(uhol);
			yp[i] = ycenter + rc * Math.cos(uhol);
		}
		g.drawPolygon(xp, yp, n + 1);
		if (ph) { // double bonds in Ph icon
			for (int i = 0; i <= n; i++) {
				double uhol = Math.PI * 2. / n * (i - .5);
				xp[i] = xcenter + (rc - 3) * Math.sin(uhol);
				yp[i] = ycenter + (rc - 3) * Math.cos(uhol);
			}
			g.drawLine(xp[0], yp[0], xp[1], yp[1]);
			g.drawLine(xp[2], yp[2], xp[3], yp[3]);
			g.drawLine(xp[4], yp[4], xp[5], yp[5]);
		}
	}

	// ----------------------------------------------------------------------------

	void clearInfo() {
		info(customDefaultInfoText);
	}

	protected void info(String text) {
		if (text == null)
			text = customDefaultInfoText;
		mustReDrawInfo = true;
		infoText = text;
		this.log("info: " + text);

		// co s doMenu a repaintom
	}

	// ----------------------------------------------------------------------------
	// Will do an immediate repaint
	public void showInfo(String text) {

		info(text);
		repaint();
	}

	public void setCustomDefaultInfoText(String text) {
		showInfo(text);
		customDefaultInfoText = text;
	}

	/**
	 * select one of the menu action without having to click on the menu
	 * 
	 * @param action
	 */
	public void setAction(int action) {
		this.action = action;
	}

	/**
	 * BB
	 * 
	 * Find out which button-action matches the mouse coordinates
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	public int determineMenuAction(int x, int y, boolean ignoreDisabledActions) {
		int action = 0;

		// convert the x,y event coordinate to the menu scale
		x = (int) Math.round((double) x / this.menuScale);
		y = (int) Math.round((double) y / this.menuScale);

		if (x < leftMenuWidth(1.0) || y < topMenuHeight(1.0)) { // --- inside the menu area

			int xbutton = 0;
			for (int i = 1; i <= TOP_MENU_NUMBER_OF_CELLS; i++)
				if (x < i * (menuCellSize + menuCellBorder())) {
					xbutton = i;
					break;
				}
			int ybutton = 0;
			for (int i = 1; i <= LEFT_MENU_NUMBER_OF_CELLS + 2; i++)
				if (y < i * (menuCellSize + menuCellBorder())) {
					ybutton = i;
					break;
				}
			if (xbutton > 0 && ybutton > 0) {
				action = ybutton * 100 + xbutton;
			}
		}

		// TODO: filter out all actions that are disabled
		if (ignoreDisabledActions) {
			switch (action) {
			case ACTION_REACP:
				if (!this.reaction)
					action = 0;
				break;
			case ACTION_FG:
				if (!this.fgMenuOption)
					action = 0;
				break;
			
			case ACTION_MARK:
				if (starNothing) {
					action = 0;
				}
				break;
			}

		}
		return action;
	}

	@Override
	public void mouseWheelMoved(MouseWheelEvent e) {
		double newScale;

		if (!allowZooming)
			return;

		double notches = e.getWheelRotation();

		String message;
		String newline = "\n";
		if (notches < 0) {
			message = "Mouse wheel moved UP " + -notches + " notch(es)" + newline;
		} else {
			message = "Mouse wheel moved DOWN " + notches + " notch(es)" + newline;
		}
		if (e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL) {
			message += "    Scroll type: WHEEL_UNIT_SCROLL" + newline;
			message += "    Scroll amount: " + e.getScrollAmount() + " unit increments per notch" + newline;
			message += "    Units to scroll: " + e.getUnitsToScroll() + " unit increments" + newline;
			message += "    Vertical unit increment: " + " pixels" + newline;
		} else { // scroll type == MouseWheelEvent.WHEEL_BLOCK_SCROLL
			message += "    Scroll type: WHEEL_BLOCK_SCROLL" + newline;
			message += "    Vertical block increment: " + " pixels" + newline;
		}
		//System.out.println(message);

		notches *= -1; // to give the same zoom direction as googlemaps

		int x = e.getX();
		int y = e.getY();
		double sizeChange = (100.0 + 2 * notches) / 100;
		if (isInMolecularArea(x, y)) {
			newScale = this.molecularAreaScale * sizeChange;
			if ((newScale > this.molecularAreaScale && newScale <= maxMolecularAreaScale) // size increased, but not too
																							// much
					|| (newScale < this.molecularAreaScale && newScale >= minmolecularAreaScale) // size decreased, but
																									// not too much
			) {
				lastAction = LA_SCALE;

				if (this.reaction) {
					// do not move around object because the arrow will move out of center
					// and it is difficult to recenter all objects
					setMolecularAreaScale(newScale); // will call repaint()
				} else {
				// previous zoom method
				// center around the atom closes to the x,y position
					setMolecularAreaScale(newScale, x, y);
					repaint();
				}
				
			}

		} else {
			if (allowGUIzooming) {
				newScale = this.menuScale * sizeChange;
				if (newScale >= minMenuScale && newScale <= maxMenuScale) {
					setMenuScale(newScale); // setMenuScale will do a repaint
				}
			}
		}

	}

	public boolean isInMolecularArea(int x, int y) {
		if (this.isDepict()) {
			return true;
		}

		if (x < leftMenuWidth() || y < topMenuHeight() || y > (this.dimension.height - this.infoAreaHeight())
				|| x > (this.dimension.width - rightBorder())) {
			return false;
		}
		return true;
	}

	/**
	 * rescale around the the nearest molecule to the given position does not call
	 * repaint()!
	 * 
	 * @param scale
	 * @param x     (GUI coordinate)
	 * @param y
	 */
	// used by mouse wheel event in non reaction mode
	public void setMolecularAreaScale(double scale, int x, int y) {
		// should we limit scaling if one molecule becomes invisible?
		//if (!reaction) {
			// mol.center(0.1); //should move progressively to center
			// The center position varies with the scale !!!!!!! FIXME

			Box previousAreaSize = getMolecularAreaBoundingBoxCoordinate();
			this.molecularAreaScale = scale;
			Box newAreaSize = getMolecularAreaBoundingBoxCoordinate();

			TouchedMol touchedMol = new TouchedMol();
			// find the closest mol - use a large distance radius
			this.findMolAndAtomOrBondWithinRadius(x, y, Integer.MAX_VALUE, touchedMol);
			// this.findClosestMol(x, y)
			Point.Double shiftXY = this.findTranslationToCenterAfterScaling(touchedMol, previousAreaSize, newAreaSize);

			if (shiftXY != null) {
				this.graphicalObjectList().move(shiftXY);
			}
		//} else {
			// What to do?
			// reaction TODO
			// multipart
		//}
		this.setMustRedrawMolecularArea(true);

	}

	
	// don't use this in reaction mode because the arrow
//	protected void moveAllMolecules(double x, double y) {
//		moleculePartsList.moveXY(x, y);

//	}

//	protected void moveAllMolecules(Point.Double shiftXY) {
//		moveAllMolecules(shiftXY.x, shiftXY.y);

//	}

	/**
	 * Compute the translation X,Y needed for the molecule to stay centered after
	 * scaling
	 * 
	 * @param atomIndex
	 * @param previousAreaSize
	 * @param newAreaSize
	 * @return
	 */
	public Point.Double findTranslationToCenterAfterScaling(TouchedMol closestTouchedMol,  Box previousAreaSize, Box newAreaSize) {
		Point.Double result = new Point.Double();

		JMEmol closestMolecule = closestTouchedMol.mol;
		if(closestMolecule == null || closestMolecule.nAtoms() == 0) {
			return result;
		}
		assert previousAreaSize.width > 0;
		assert previousAreaSize.height > 0;
		
		double x;
		double y;
		if( closestTouchedMol.atomIndex > 0) {
			x= closestMolecule.atoms[closestTouchedMol.atomIndex].x;
			y= closestMolecule.atoms[closestTouchedMol.atomIndex].y;
		} else {
			//closestMolecule.findBondCenters();
			x = closestMolecule.bonds[closestTouchedMol.bondIndex].bondCenterX;
			y = closestMolecule.bonds[closestTouchedMol.bondIndex].bondCenterY;
			
		}
		
		
		double newX = x /previousAreaSize.width * newAreaSize.width;
		double newY = y /previousAreaSize.height * newAreaSize.height;
		
		double shiftX = newX - x;
		double shiftY = newY - y;
	
		
		result.setLocation(shiftX, shiftY);
		
		
		return result;

	}

	/**
	 * Invoked when a mouse button has been pressed on a component.
	 */
//	@Override
//	public void mousePressed(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//
//	}

	/**
	 * Invoked when the mouse button has been clicked (pressed and released) on a
	 * component.
	 */
//	@Override
//	public void mouseClicked(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//
//	}

	/**
	 * Invoked when a mouse button has been released on a component.
	 */
//	@Override
//	public void mouseReleased(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	/**
	 * Invoked when the mouse enters a component.
	 */
//	@Override
//	public void mouseEntered(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	/**
	 * Invoked when the mouse exits a component.
	 */
//	@Override
//	public void mouseExited(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	protected boolean canDoAtomOrBondAction(int action) {
		return (!isDepict() || (isDepict() && action == ACTION_MARK));
	}

	// ----------------------------------------------------------------------------
//	@Override
	public boolean mouseDown(MouseEvent e, int x, int y) {
		// 02.06 niektotre return true zmenene na false (aby events aj v mipc)

		// this.mouseDownWasUsed = false;
		this.mouseDownWasUsed = false;
		// BB popup menu for copy&paste
		if (contextMenuEnabledOption && this.handleCopyPasteJPopupMenu(e, x, y)) {
			this.mouseDownWasUsed = true;
			// FIXME
			movePossible = false; // to avoid bug is my JSapplet lib with popup menu disabled, the mouseUp event
									// is not registered and a mouseDrag event is generated
			return true; // event has been consumed
		}

//Dec 2016: allow mol to move 
//		if (depict && !(this.canHandleBondClickedCallBack() || this.canHandleBondClickedCallBack() || depictActionEnabled))
//			//return true; //no action is performed in depict mode
//			return false; //no action is performed in depict mode - BB changed March 2013

		// the return value of this method
		// set to true if the event was consumed and does not need to be propagated
		boolean eventNotUsed = false;

		// experiment: to ease switching to the applet for copy paste with the system
		// clipboard
		boolean eventUsed = true;
		// boolean eventUsed = !isSystemClipBoardSupportedByBrowser();
		boolean returnStatus = eventUsed; // 2206

		// BB
		// this.isContextMenu = this.isEventContextMenu(e); //will be used in the
		// addRing() method to decide if a spiro ring should be added

		xold = x;// used later in mouseDrag
		// yold = y - (2 * (int)menuCellSize + menuCellBorder());
		yold = y; // used later in mouseDrag

		// log("mouseDown(): xold=" + xold + " yold=" + yold);

		clearInfo();
		// int x = e.getX(); int y = e.getY();
		this.mouseShift = e.isShiftDown(); // because of numbering

		movePossible = false;

		if (!isDepict() && (x < leftMenuWidth() || y < topMenuHeight())) { // --- menu pressed
			int action = this.determineMenuAction(x, y, true);

			// Code written by PE
			// Should this be moved to menuAction(action)?
			// empty buttons not considered
			if (action == ACTION_SPIRO) {
				spiroAdding = true;
				info("Next ring will be added as spiro");
				repaint();
				this.mouseDownWasUsed = true;
				return eventUsed;
			}

			// Code written by BB
			// Should this be moved to menuAction(action)?
			if (action == ACTION_MOVE_AT) {
				if (this.showAtomMoveJButton) {
					info("Move one atom");
					repaint();
				} else {
					this.mouseDownWasUsed = true;
					return eventUsed;
				}

			}

			// BB: xbutton handling
			if (!xJButton && action == ACTION_AN_X) {
				return eventNotUsed;
			}

			if (!query && action == ACTION_QRY)
				return eventNotUsed;
			if (!stereo && action == ACTION_STEREO)
				return eventNotUsed;
			if (!multipart && action == ACTION_NEW)
				return eventNotUsed;
			if (!(this.moleculeHandlingParameters.number || autonumber) && action == ACTION_MARK)
				return eventNotUsed;
			if (!reaction && action == ACTION_REACP)
				return eventNotUsed;
			// if(action == ACTION_EMPTY_CELL){
			// return eventNotUsed;
			// }

			returnStatus = menuAction(action); // has its own paint() call
		}

		else if (!isDepict() && (y > dimension.height - infoAreaHeight())) { // --- info area clicked
			return eventNotUsed;
		}

		else { // --- mouse click in the drawing area
			// ---------------------------
			activeGraphicalObject = findClosestGraphicalObject(xold, yold);
//			if(m>0) {
//				actualMoleculePartIndex = m;
//				mol = moleculeParts[m];
//			} else {
//				actualMoleculePartIndex = 0;
//				
//			}
			// OKK

			
			//March 2016
			// the closest mol becomes the active one - needed for table to move one of the fragments
			//int m = findClosestMol(x,y);
			activeMol = findClosestMol(xold,yold);

			if (activeGraphicalObject == reactionArrow) {
				activeMol.touchedAtom = 0; // probably not needed
				activeMol.touchedBond = 0;

				//movePossible = true;
				//return true;
			}
			

			// June 2015
			if (this.canHandleAtomClickedCallBack()) {
				if (activeMol.touchedAtom > 0) { // touchedAtom means mouse over?

					this.handleAtomClickedCallBack(activeMolIndex(), activeMol.touchedAtom); // not sure that
																								// actualMoleculePartIndex
																								// is set correctly in
																								// case of a multi
																								// structure
					if (isDepict() && !depictActionEnabled) {
						return true;
					}
				}

				if (activeMol.touchedBond > 0) {
					this.handleBondClickedCallBack(activeMolIndex(), activeMol.touchedBond); // not sure that
																								// actualMoleculePartIndex
																								// is set correctly in
																								// case of a multi
																								// structure
					if (isDepict() && !depictActionEnabled) {
						return true;
					}

				}
			}

			movePossible = true;
			// x -= menuCellSize; //menuCellSize is 0 in depict mode
			// y -= 2 * menuCellSize + menuCellBorder();
			// y -= topMenuHeight();

			// atom clicked

			if (activeMol.touchedAtom > 0 && canDoAtomOrBondAction(action)) {
				lastTouchedMol.mol = activeMol;
				if (action == ACTION_DELETE) {
					this.actionDeleteTouchedAtomOrBond();
//					mol.preSave();
//					mol.deleteAtom(mol.touchedAtom);
//					this.recordAtomEventAndPostSave(JME.DEL_ATOM2);
//
//					mol.touchedAtom = 0;

				} else if (action == ACTION_DELGROUP) {
					return true; // do nothing
				} else if (action == ACTION_CHARGE) {
					if (activeMol.changeCharge(activeMol.touchedAtom, 0))
						this.recordAtomEvent(JME.CHARGE_ATOM0);
//this is never called from the JME gui since it has only a toggle button
//				} else if (action == ACTION_CHARGE_PLUS) {
//					if(mol.changeCharge(mol.touchedAtom, 1))
//						this.recordAtomEventAndPostSave(JME.CHARGE_ATOM_PLUS);
//				} else if (action == ACTION_CHARGE_MINUS) {
//					if(mol.changeCharge(mol.touchedAtom, -1))
//						this.recordAtomEventAndPostSave(JME.CHARGE_ATOM_MINUS);
				} else if (action == ACTION_BOND_SINGLE || action == ACTION_BOND_DOUBLE || action == ACTION_BOND_TRIPLE
						|| action == ACTION_STEREO || action == ACTION_CHAIN) {
					lastAction = LA_BOND; // in addBond may be set to 0
					activeMol.addBond();
					activeMol.touched_org = activeMol.touchedAtom;

					if (action == ACTION_CHAIN) {
						activeMol.nchain = 1; // pre CHAIN rubberbanding
						activeMol.chain[1] = activeMol.natoms;
						activeMol.chain[0] = activeMol.touchedAtom;
						activeMol.touchedBond = 0; // 2005.02
						// mol.avoidTouch(1);
						//this.recordBondEvent(JME.ADD_BOND); //postpone until finished
						this.willPostSave(false); // for the CHAIN, save the state at mouseUp event

					} else {
						this.recordBondEvent(JME.ADD_BOND);

					}

				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					lastAction = LA_RING; // in addRing may be set to 0
					activeMol.addRing();
					this.recordAtomEvent(JME.ADD_RING);

				} else if (action == ACTION_TEMPLATE) {
					// mol.addTemplate(template);
					lastAction = LA_GROUP;
					this.recordAtomEvent(JME.ADD_TEMPLATE);

				} else if (action >= ACTION_GROUP_MIN && action < ACTION_GROUP_MAX) {

					activeMol.addGroup(false);
					this.recordAtomEvent(JME.ADD_GROUP);

					lastAction = LA_GROUP; // may be set to 0
				} else if (action == ACTION_QRY) { // setting atom as query atom
					if (queryBox.isBondQuery())
						return true;
					activeMol.setAtom(activeMol.touchedAtom, queryBox.getSmarts());
					activeMol.isQuery = true; // 2013.09

					this.recordAtomEvent(JME.ADD_ATOM_QUERY);

				} else if (action == ACTION_MARK) { // either color marking or atom map

					boolean marked;

					if (!pseudoMark && ! starNothing) {

						int newMap = -1;
						if (markFromKeyboardInput) {
							newMap = keyboradInputMark;
							resetExtendAtomMark = true;
							markFromKeyboardInput = false;
							clearInfo(); // reset the info message generated by updateMark()
							
							if (this.moleculeHandlingParameters.mark) {
								this.activateMarkerColor(newMap);
							}
						}
						
						if (moleculeHandlingParameters.mark) {
							
							marked = activeMol.markAtom(
									newMap > 0 ? newMap: activeMarkerColorIndex // set the color index from a keyboard shortcut
											);
						} else {
							if (newMap == -1) {
								if (reaction) {
									int reactionRole = activeMol.getReactionRole();
									newMap = findMaxAtomMapOfMoleculeParts(moleculePartsList, reactionRole);
								} else {
									newMap = activeMol.geMaxAtomMap();
								}
								// allow same atom map for several atoms of the group is shift is pressed
								if (!this.mouseShift 
										|| newMap == 0) // BB june 2020: if shift is on and new mapping: must be 1
									newMap++;
							}
							
							marked = activeMol.markAtom(newMap);
							
						}
						
						
					} else {
						marked = true; // equivalent to an atom click event but can be tracked using JME.MARK_ATOM
					}
					if (marked)
						this.recordAtomEvent(JME.MARK_ATOM);
					else
						// happens if newMap == -1
						this.recordAtomEvent(JME.UN_MARK_ATOM);

					if (pseudoMark) {
						this.willPostSave(false); // do not put on the undo stack
					}

				} else if (action == ACTION_MOVE_AT) {
					// System.out.println("Move atom started");
				} else if (action > 300) { // atoms
					if (active_an != activeMol.an(activeMol.touchedAtom) || active_an == AN_X) {
						activeMol.AN(activeMol.touchedAtom, active_an);
						activeMol.Q(activeMol.touchedAtom, 0); // resetne naboj
						// mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
						activeMol.atoms[activeMol.touchedAtom].iso = 0; // BB: reset isotop
						// mol.nh[mol.touchedAtom] = 0;
						activeMol.atoms[activeMol.touchedAtom].nh = 0;

						// special processing pre AN_X, osetrene, ze moze byt aj
						// ""
						if (active_an == AN_X) {
							String xx = MultiBox.atomicSymbol.getText();
							if (xx.length() < 1)
								xx = "X";
							activeMol.setAtom(activeMol.touchedAtom, xx);

						}
						//this.recordAtomEvent(JME.SET_ATOM + active_an); // active_an is an arbitrary number, should be
																		// changed to the string of the atom type
						this.recordAtomEvent(JME.SET_ATOM ); 
					}
				} else { // BB: nothing happened to the clicked atom
					returnStatus = eventNotUsed;

				}
				// BB:moved
				// status = false; // 2206

			}

			// bond clicked
			else if (activeMol.touchedBond > 0 && canDoAtomOrBondAction(action)) {
				lastTouchedMol.mol = activeMol;
				if (action == ACTION_DELETE) {
					this.actionDeleteTouchedAtomOrBond(); // record the event as well

				} else if (action == ACTION_DELGROUP) {
					activeMol.deleteAtomGroup();
					activeMol.cleanAfterChanged(this.polarnitro);
					this.recordBondEvent(JME.DEL_BOND_GROUP);
					activeMol.touchedBond = 0;
				} else if (action == ACTION_STEREO) {
					activeMol.stereoBond(activeMol.touchedBond);
					this.recordBondEvent(JME.SET_BOND_STEREO);
				} else if (action == ACTION_BOND_SINGLE || action == ACTION_CHAIN) { // ACTION_CHAIN should be removed?
					if (activeMol.bonds[activeMol.touchedBond].bondType == JMEmol.SINGLE
							&& activeMol.bonds[activeMol.touchedBond].stereo == 0) {// nie pre
						// stereo
						activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.DOUBLE;
						this.recordBondEvent(JME.SET_BOND_DOUBLE);

					} else {
						activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.SINGLE;
						activeMol.bonds[activeMol.touchedBond].stereo = 0; // BB: remove stereo flag - bug fix - was creating a
																// problem with undo/redo
						
						
						this.recordBondEvent(JME.SET_BOND_SINGLE);

					}
					activeMol.bonds[activeMol.touchedBond].stereo = 0; // zrusi stereo
				} else if (action == ACTION_BOND_DOUBLE) {
					boolean differentBondOrder = activeMol.bonds[activeMol.touchedBond].bondType != JMEmol.DOUBLE;

					activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.DOUBLE;

					if (!differentBondOrder) {
						activeMol.bonds[activeMol.touchedBond].toggleNormalCrossedDoubleBond();
					} else {
						activeMol.bonds[activeMol.touchedBond].stereo = 0; // zrusi stereo
					}
					activeMol.cleanAfterChanged(this.polarnitro);

					this.recordBondEvent(JME.SET_BOND_DOUBLE);

				} else if (action == ACTION_BOND_TRIPLE) {
					activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.TRIPLE;
					activeMol.bonds[activeMol.touchedBond].stereo = 0; // zrusi stereo
					activeMol.cleanAfterChanged(this.polarnitro);

					this.recordBondEvent(JME.SET_BOND_TRIPLE);

				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					// fusing ring to bond
					lastAction = LA_RING; // in addRing may be set to 0
					activeMol.addRing();
					this.recordBondEvent(JME.ADD_RING_BOND);
					activeMol.cleanAfterChanged(this.polarnitro); // FIXME: add to addRing

				} else if (action == ACTION_QRY) {
					if (!queryBox.isBondQuery())
						return true;
					String bondQuery = queryBox.getSmarts();
					activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.QUERY;
					// mol.stereob[mol.touchedBond] = JMEmol.QUERY;
					activeMol.bonds[activeMol.touchedBond].btag = bondQuery;
					/*
					 * if ("~".equals(bondQuery)) mol.stereob[mol.touchedBond] = JMEmol.QB_ANY; if
					 * (":".equals(bondQuery)) mol.stereob[mol.touchedBond] = JMEmol.QB_AROMATIC; if
					 * ("@".equals(bondQuery)) mol.stereob[mol.touchedBond] = JMEmol.QB_RING; if
					 * ("!@".equals(bondQuery)) mol.stereob[mol.touchedBond] = JMEmol.QB_NONRING;
					 */

					this.recordBondEvent(JME.SET_QUERY_BOND);

				} else if (action == ACTION_MARK) {
					// info("Only atoms may be marked !");
					// March 2014

					{
						boolean marked;

						
						// some duplicated code logic with marking of atom
						if (!pseudoMark) {
						
							marked = activeMol.markBond(
									 activeMarkerColorIndex 
											);
						} else {
							marked = true;
						}
						// some duplicated code logic with marking of atom
						if (marked)
							this.recordBondEvent(JME.MARK_BOND);
						else
							this.recordBondEvent(JME.UN_MARK_BOND);
	
						if (pseudoMark) {
							this.willPostSave(false); // do not put on the undo stack
						}

					}
					
					
					
					
					
					
				} else {
					// no bond were changed
					returnStatus = false; // 2206
				}
				// BB removed and replaced by above
				// status = false; // 2206
			}

			// free space clicked - new molecule
			// creating new molecule only on start or when ACTION_NEW is on
			else if ((moleculePartsList.isReallyEmpty() || newMolecule == true) && ! isDepict()) {
				if (action <= ACTION_STEREO)
					return eventNotUsed;

				moleculePartsList.removeEmptyMolecules(); //Jan 2019
				//numberofMoleculeParts++;
				//actualMoleculePartIndex = numberofMoleculeParts;
				activeMol = new JMEmol(this, this.moleculeHandlingParameters);
				moleculePartsList.add(activeMol);
				
				lastTouchedMol.mol = activeMol;

//				if(newMolecule == true) {
//					newMolecule = false; //will be done in draw
//					this.mustReDrawTopMenu = true;
//				}

				smol = null; // kvoli undo

				// BB: TODO : lot of duplicated code
				if (action >= ACTION_BOND_SINGLE && action <= ACTION_BOND_TRIPLE || action == ACTION_CHAIN) {
					activeMol.createAtom();
					activeMol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(activeMol, 1, x, y);
					activeMol.touchedAtom = 1;
					activeMol.touched_org = 1; // needed for checkNewBond();
					lastAction = LA_BOND;
					activeMol.addBond();
					// orienting chain
					if (action == ACTION_CHAIN) {
//						mol.x[2] = x + JMEmol.RBOND * .866;
//						mol.y[2] = y - JMEmol.RBOND * .5;
//						XY(mol, 2, x + JMEmol.RBOND * .866, 
//								 y - JMEmol.RBOND * .5);
						activeMol.XY(2, // TODO : JMEMol sould handle this
								screenToDrawingX(x) + JMEmol.RBOND * .866, screenToDrawingY(y) - JMEmol.RBOND * .5);

						activeMol.chain[0] = 1;
						activeMol.chain[1] = 2;
						activeMol.nchain = 1;
						this.recordBondEvent(JME.ADD_CHAIN);

					} else {
						this.recordBondEvent(JME.ADD_BOND);

					}
				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					activeMol.xorg = screenToDrawingX(x);
					activeMol.yorg = screenToDrawingY(y);
					lastAction = LA_RING;
					activeMol.addRing();
					this.recordAfterStructureChangedEvent(JME.ADD_RING);
				} else if (action > 300) { // adding 1st atom
					activeMol.createAtom();
					activeMol.AN(1, active_an);
					activeMol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(activeMol, 1, x, y);
					activeMol.touchedAtom = 1;
					if (active_an == AN_X) {
						String xx = MultiBox.atomicSymbol.getText();
						if (xx.length() < 1)
							xx = "X";
						activeMol.setAtom(1, xx);
					}
					this.recordAtomEvent(JME.ADD_ATOM);

				} else if (action == ACTION_TEMPLATE) {
					readMolecule(template);
					this.recordAfterStructureChangedEvent(JME.ADD_TEMPLATE);

				} else if (action >= ACTION_GROUP_MIN && action < ACTION_GROUP_MAX) {
					// adding first atom (to which group will be connected)
					activeMol.createAtom();
					activeMol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(activeMol, 1, x, y);

					activeMol.touchedAtom = 1;
					// adding group
					activeMol.addGroup(true);
					this.recordAfterStructureChangedEvent(JME.ADD_GROUP);
				} else {
					System.err.println("error -report fall through bug !");
				}
				// BB changed
				// returnStatus = eventNotUsed; // 2206

			} else { // BB nothing happened
				returnStatus = false;
			}

			if (returnStatus != eventNotUsed) {// BB: if nothing has changed - there is no need to repaint
				// BB
				// mol.cleanAfterChanged(); //FIXME: sacveState already called this method
				
				this.setMustRedrawMolecularArea(true);
				// any showInfo() call will be taken into account
				this.repaint();

//				this.mustReDrawLeftMenu = false;
//				this.mustReDrawTopMenu = false;
//				
//				this.setMustRedrawMolecular(true);
//				//don't touch info - automatic
//				repaint(); // ciastocne zbytocne repaintuje, ale asi nechat tak
			}
		}

		this.mouseDownWasUsed = returnStatus;

		return returnStatus;
	}

	// ----------------------------------------------------------------------------
	public boolean mouseUp(MouseEvent e, int x, int y) {

		boolean eventUsed = false;

		// DUPLICATED CODE WITH BELOW
//		if (depict && !depictActionEnabled) {
//			if(toggleDepictEdit == true) {
//				this.options("nodepict");
//				this.handleAfterAfterDepictEditToggleEvent();
//			}
//			return true;
//			
//		}

		if (this.movingAtom) {
			// end of atom move
			this.movingAtom = false;
			// mol.findBondCenters(); //BB: aton has been moved, thus the bond centers must
			// be updated
			// this.recordAtomEvent(MOVE_ATOM); //this is not a structure change
			this.willPostSave(true);
			eventUsed = true;
		}

		// BB
		this.mustReDrawInfo = false;
		lastRotation = 0; // needed?

		// LA_GROUP netreba, tam nemoze byt atom overlap
		if (lastAction == LA_BOND) {
			if (action == ACTION_CHAIN) {
				activeMol.checkChain();
				this.recordBondEvent(ADD_CHAIN);
				this.willPostSave(true);
				

			} else {

				// find out if the last touched mol is the same
				// findMolAndAtomOrBondInDrawingAreaFromEventXY(x, y, this.newTouchedMol);
				// System.out.println("@@@mouseUp: newTouchedMol: " + newTouchedMol.molIndex + "
				// " + newTouchedMol.atomIndex + " x:" + x + " y: " + y);
				// System.out.println("@@@mouseUp: numberofMoleculeParts: " +
				// numberofMoleculeParts + " actualMoleculePartIndex: " +
				// actualMoleculePartIndex);
				// System.out.println("@@@mouseUp: lastTouchedMol: " + lastTouchedMol.molIndex +
				// " " + lastTouchedMol.atomIndex + " x:" + x + " y: " + y);

				// lastTouchedMol was set during mouseDrag
				if(lastTouchedMol.mol != null && activeMol != lastTouchedMol.mol) {
					
					// merge the current mol and the other mol
					
					activeMol.deleteAtom(activeMol.natoms);
					// remove the last atom because it will be replaced by the atoms of the new mol
					int atom1 = activeMol.touched_org; // first atom of the new bond to be created
					int atom2 = lastTouchedMol.atomIndex + activeMol.natoms;// second atom of the new bond to be created

					assert atom1 != activeMol.natoms + 1;

					JMEmol otherMol = lastTouchedMol.mol;
					JMEmol merged = new JMEmol(this, new JMEmol[] { activeMol, otherMol });
					merged.atoms[0] = new Atom(); // needed by rubberbanding()

					// bug: the user selected bond order is not taken into account
					merged.createAndAddNewBond(atom1, atom2);

					moleculePartsList.remove(otherMol);
					moleculePartsList.replace(activeMol, merged);
					
					//
//					JMEmol[] newMoleculeParts = new JMEmol[moleculeParts.length];
//					for(int p = 0, newP = 0; p < moleculeParts.length; p++) {
//						if(moleculeParts[p] == activeMol) {
//							newMoleculeParts[newP++] = merged; //replace mol with merged
//						} else if (moleculeParts[p] == otherMol ) { //skip
//							continue;
//						} else {
//							newMoleculeParts[newP++] = moleculeParts[p];
//						}
//						
//					}
//					
//					moleculeParts = newMoleculeParts;
//					numberofMoleculeParts --;
					
					activeMol = merged;// replace mol with merged
					lastTouchedMol.reset();

				} else {
					// as before - no merge
					// checkBond create or increase bond order
					activeMol.checkBond(); // standard bond check
				}
			}
			// don in createAndAddNewBond
			// mol.findBondCenters(); // zbytocne vela, ale tu kvoli r.b.

			// BB :
			if (this.bondRubberBanding) {
				// a bond had been added and the state saved
				// to keep only the bond stabilized after the rubberbanding,
				// remove the previous state
				
				if (action != ACTION_CHAIN) {
					this.molChangeManager.removeLast();
					this.recordBondEvent(ADD_BOND);
				}

				

				this.bondRubberBanding = false;
			}
			eventUsed = true;
		} else if (lastAction == LA_MOVE) {
			// !!! mal by sem este prist check na touched
			// mol.findBondCenters();

			// BB
			this.willPostSave(true);
			eventUsed = true;

		}
		if (lastAction > 0) {

			// BB - this seems to be a duplcated of doMenu
			// mustRedrawNothing();
			// this.setMustRedrawMolecular(true);

			if (lastAction != LA_MOVE && lastAction != LA_ROTATE) {
				// mol.cleanAfterChanged();
				// nevola sa vzdy ked treba !!!!!
				// mol.cleanPolarBonds(); // nie je to privela action ??? nie az pri
			}
			if (lastAction == LA_MOVE && this.reaction) {
				// check if the reaction roles have changed
				//int parts[][] = getReactionParts();
				//if(reactionParts == null)
				//reactionParts = parts;
				//int changedPart = findFirstMoleculeIndexWithDifferentReactionRole(reactionParts, parts);
				int changedPart = updateReactionRoles();
				changedPart++;
				if(changedPart != 0) {
					//send an update message
					this.recordMoleculePartEvent(CHANGE_REACTION_ROLE, changedPart);
				}
			}
			// canon
			// repaint(); // napr po zdvojeni vazby ju nakresli
			this.redrawMolecularAreaOnly();
			lastAction = 0;
			afterClear = false;
			eventUsed = true;
		}

		// BB: useful for touch devices to avoid showing the marked atom after edition
		if (isTouchSupported && (activeMol.touchedBond != 0 || activeMol.touchedAtom != 0)) {
			activeMol.touchedBond = 0;
			activeMol.touchedAtom = 0;
			this.redrawMolecularAreaOnly();
			eventUsed = true;

		}

		// mouse click on the full screen icon
		if (eventUsed == false && !this.mouseDownWasUsed && this.fullScreenIcon != null) {
			if (fullScreenIcon.contains(x, y)) {
				eventUsed = true;
				// Rectangle dim1 = this.getMolecularAreaSizeWithScalingForDepiction();
				toggleFullScreen();
				// mol.needRecentering = true;
				// Rectangle dim2 = this.getMolecularAreaSizeWithScalingForDepiction();
				// recenterMoleculesAfterMolecularAreaChange(dim1, dim2);
				// this.redrawMoleculartAreaOnly();

			}
		}

		// handle toggle depict/edit
		if (this.toggleDepictEdit && !this.mouseDownWasUsed && !eventUsed) {
			if (this.isDepict()) {
				this.options("nodepict"); // menu is ready and paintedafter this call
				//new Feb 2020
				this.centerAllMoleculesAsAgroup(this.graphicalObjectList(), dimension, menuScale, molecularAreaScale);
				this.redrawMolecularAreaOnly();

			} else {
				this.options("depict");
			}
			this.handleAfterAfterDepictEditToggleEvent();
			eventUsed = true;
		}

		return eventUsed;
	}

	protected void willPostSave(boolean b) {
		this.saveCurrentState = b;

	}

//	protected void updateReactionParts() {
//		if (reaction)
//			reactionParts = getReactionParts();
//	}

	/**
	 * screen pixel to molecular drawing area coordinate
	 * 
	 * @param coord
	 * @return
	 */
	@Deprecated
	protected int scaleCoordinate_(int coord) {
		double newCoord = scaleCoordinate_((double) coord);

		return (int) Math.round(newCoord);
	}

	/**
	 * screen coordinate to molecular drawing area coordinate
	 * 
	 * @param coord
	 * @return
	 */
	@Deprecated
	protected double scaleCoordinate_(double coord) {
		if (this.scalingIsPerformedByGraphicsEngine) {
			return coord / molecularAreaScale;
		}
		return coord;
	}

	protected double scaleScreenToDrawing(int pos) {
		return (double) pos / molecularAreaScale;
	}

	protected int scaleDrawingToScreen(double coord) {
		return (int) Math.round(coord * molecularAreaScale);
	}

	/**
	 * convert the applet screen position to the coordinate of the drawing area
	 * 
	 * @param pixelPosition
	 * @return
	 */
	// TODO: drawing should not revert the Y axis
	protected double screenToDrawingX(int appletPixelPositionX) {
		int x = appletPixelPositionX - leftMenuWidth();// leftMenuWidth() returns 0 in depict mode

		return scaleScreenToDrawing(x);
	}

	/**
	 * convert the applet screen position to the coordinate of the drawing area
	 * 
	 * @param pixelPosition
	 * @return
	 */
	protected double screenToDrawingY(int appletPixelPositionY) {
		int y = appletPixelPositionY - topMenuHeight(); // topMenuHeight() returns 0 in depict mode

		return scaleScreenToDrawing(y);
	}

	/**
	 * Convert a drawing x coordinate to the pixel coordinate
	 * 
	 * @param xCoord
	 * @return
	 */
	protected int drawingToScreenX(double xCoord) {
		int screenX = scaleDrawingToScreen(xCoord);

		screenX += leftMenuWidth(); // leftMenuWidth() returns 0 in depict mode

		return screenX;
	}

	/**
	 * Convert a drawing y coordinate to the pixel coordinate
	 * 
	 * @param x
	 * @return
	 */
	protected int drawingToScreenY(double yCoord) {
		int screenY = scaleDrawingToScreen(yCoord);

		screenY += topMenuHeight();// topMenuHeight() returns 0 in depict mode

		return screenY;
	}

//	/**
//	 * convert a the applet screen position to the coordinate of the drawing area
//	 * @param pixelPosition
//	 * @return
//	 */
//	protected double screenToDrawing(int appletPixelPositionX) {
//		
//		return (double)appletPixelPositionX*molecularAreaScale;
//	}

	// ----------------------------------------------------------------------------
	public boolean mouseDrag(MouseEvent e, int x, int y) {
		// public void mouseDragged(MouseEvent e) {

//		System.out.println("@@@@ mouseDrag");
		// Commented because if zooming is allopwed in depict mode, then moving should
		// as well
//		if (depict && ! depictActionEnabled)
//			return true;
		// 2Banding possible only after succesfull addition of the bond
		if (!movePossible)
			return true;

		// BB popup menu for copy&paste
		boolean meta = e.isMetaDown(); // true if right mouse click
		if (meta) {
			return true;
		}

		// BB
		this.mustReDrawInfo = false;

		// ??? MS-Win toto volaju aj len pri MouseClick (handled here)
		// int x = e.getX()-sd; int y = e.getY()-sd*2;
		// x -= leftMenuWidth();
		// y -= topMenuHeight();
		double drawingAreaMoveX = scaleScreenToDrawing(x - xold);
		double drawingAreaMoveY = scaleScreenToDrawing(y - yold);
		//info("mouseDrag(): xold=" + xold + " yold=" + yold + " lastAction=" + lastAction);
		// log("mouseDrag(): x=" + x + " y=" + y);

		double drawingAreaX = screenToDrawingX(x);
		double drawingAreaY = screenToDrawingY(y);

		if (lastAction == LA_RING || lastAction == LA_GROUP || lastAction == LA_FAILED) {
			return true;
		} else if (lastAction == LA_BOND) {
			// mol.rubberBanding(drawingAreaX, drawingAreaY);
			info("mouseDrag(): lasaction = LA_BOND " + lastAction);

			// code copied and adapted from mol.rubberBanding
			// goal: to crerate bond between two different molecule parts
			boolean done = false;
			this.lastTouchedMol.mol.touchedAtom = 0;

			// to be used for adding a bond with another part
			// need to differentiate the temporary moving atom that was created during
			// mousedown
			// from the atom of another fragment because they can overlap
			// the temp atom is the last one
			activeMol.natoms--;
			findMolAndAtomOrBondInDrawingArea(x, y, this.newTouchedMol);
			activeMol.natoms++; // restore

			// System.out.println("@@@ mouseDrag: mol.natoms: " + mol.natoms);
			// System.out.println("@@@ mouseDrag: newTouchedMol: " + newTouchedMol.molIndex
			// + " " + newTouchedMol.atomIndex);

			if(this.newTouchedMol.mol != null && this.newTouchedMol.atomIndex > 0) {
				JMEmol touched_JMEmol = newTouchedMol.mol;
				touched_JMEmol.touchedAtom = this.newTouchedMol.atomIndex;

				if (touched_JMEmol != activeMol || this.newTouchedMol.atomIndex != activeMol.touched_org) { // make bond towards
																								// existing atom
					activeMol.XY(activeMol.natoms, touched_JMEmol.x(newTouchedMol.atomIndex),
							touched_JMEmol.y(newTouchedMol.atomIndex)); // move the new atom to the coordinate of the
																		// closest touched atom "snap"
					// actually it does not move while it still close to the touched atom
					// System.out.println("SNAP otheratom");
					touched_JMEmol.touchedAtom = newTouchedMol.atomIndex;

					done = true;
					// lastTouchedMol will be used by mouseUp() to create the new bnond between the
					// two
					//
					this.lastTouchedMol.initMyselfWith(this.newTouchedMol);
				}
//				else { // this was standard position of the bond
//					mol.XY(mol.natoms, mol.xorg, mol.yorg);//move the new atom to the coordinate of the origin atom "snap"
//				}
//				this.lastTouchedMol.init(this.newTouchedMol);
//				System.out.println("@@@ mouseDrag: lastTouchedMol: " + lastTouchedMol.molIndex + " " + lastTouchedMol.atomIndex);
//
//			} else {
//				// bond width normal length follows mouse pointer
//				double dx=drawingAreaX-mol.x(mol.touched_org); 
//				double dy=drawingAreaY-mol.y(mol.touched_org);
//				double rx=Math.sqrt(dx*dx+dy*dy); if (rx < 1.0) rx=1.0;
//				double sina=dy/rx; double cosa=dx/rx;
//				
//				mol.XY(mol.natoms, 
//						mol.x(mol.touched_org)+JMEmol.RBOND*cosa, 
//						mol.y(mol.touched_org)+JMEmol.RBOND*sina
//					);

			}
			if (!done) {
				// perform the rubberbanding within the same mol - old code
				activeMol.rubberBanding(drawingAreaX, drawingAreaY);
			}
			this.bondRubberBanding = true; // BB
		}
		// BB
		else if (action == ACTION_MOVE_AT && activeMol.touchedAtom > 0) {
			if (this.movingAtom == false) {
				this.movingAtom = true;
			}
			// mol.atomRubberBanding(drawingAreaX, drawingAreaY);
			activeMol.XY(activeMol.touchedAtom, drawingAreaX, drawingAreaY);

		} else if (e.isShiftDown() || e.isMetaDown()) {
			// else if (e.isShiftDown() || e.isMetaDown()) {
			activeMol.rotate(drawingAreaMoveX);
			lastAction = LA_MOVE; // BB: should it be changed to LA_ROTATE?
			// info("Rotation: " + x ); //BB

		} else if (activeMol.touchedAtom == 0 && activeMol.touchedBond == 0) { // if no atom or bond are touched, then the touched
																	// mol can be moved
			// Start molecue move only if the mousedrag event started within the drawing
			// area

			// avoid unwanted sudden large moves after a rotation on a touch device
			// if(lastAction != LA_MOVE) {
			// drawingAreaMoveX = drawingAreaMoveY=0;
			// }

			// Do not move the molecule if the dragging start is not within the drawing area
			if (  ! isOutsideDrawingArea(x, y)) {
				Rectangle2D.Double boundingBox = this.getMolecularAreaBoundingBoxCoordinate();
				//activeMol.move(drawingAreaMoveX, drawingAreaMoveY, boundingBox);
				activeGraphicalObject.move(drawingAreaMoveX, drawingAreaMoveY, boundingBox);

				lastAction = LA_MOVE;
			}
		}

		// BB
		this.redrawMolecularAreaOnly();

		xold = x;
		yold = y;
		return true;
	}

	protected boolean isMoleculeCompletelyOutsideDrawingArea(JMEmol mol) {

		if (mol.nAtoms() == 0)
			return false;

		for (Atom atom : mol.atoms) {

			if (!isOutsideDrawingArea(drawingToScreenX(atom.x), drawingToScreenY(atom.y)))
				return false;
		}

		return true;
	}

	protected boolean isOutsideDrawingArea(int x, int y) {
		x -= leftMenuWidth();
		y -= topMenuHeight();
		return (x < 0 || y < 0 || y > this.molecularAreaHeight || x > this.molecularAreaWidth);

	}

	/**
	 * Return the molecule index of the molecule that is the closest to the provided
	 * screen position
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	JMEmol findClosestMol(int x, int y) {

		//if (isOutsideDrawingArea(x, y))
		//	return molIndex;

		JMEmol found = null;

		if(moleculePartsList.size() == 1)
			return moleculePartsList.first();
		
		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double min  = Double.MAX_VALUE;


		for(JMEmol mol : moleculePartsList){
			double d = mol.closestDistance(xCoord, yCoord);

			if(d < min) {
				min = d;
				found = mol;
			}
			//System.out.println("@@@@ findClosestMol: " + moleculePartsList.indexOf(found) + " d=" + d + " min=" + min);

		}

		//System.out.println("@@@@ findClosestMol: " + moleculePartsList.indexOf(found));
		
		return found;
	}

	Graphical2DObject findClosestGraphicalObject(int x, int y) {

		//if (isOutsideDrawingArea(x, y))
		//	return molIndex;

		Graphical2DObject found = null;

	
		
		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double min  = Double.MAX_VALUE;

		if (reaction) {
			min = this.reactionArrow.closestDistance(xCoord, yCoord);
			found = this.reactionArrow;
		}
		for(JMEmol mol : moleculePartsList){
			double d = mol.closestDistance(xCoord, yCoord);

			if(d < min) {
				min = d;
				found = mol;
			}
			//System.out.println("@@@@ findClosestMol: " + moleculePartsList.indexOf(found) + " d=" + d + " min=" + min);

		}

		//System.out.println("@@@@ findClosestMol: " + moleculePartsList.indexOf(found));
		
		return found;
	}

	/**
	 * find the touched atom or bond
	 * 
	 * @param x
	 * @param y
	 * @param result
	 */
//	void  findMolAndAtomOrBondWithinRadius(int x, int y, double radius,  TouchedMol result) {
//
//		x = scaleCoordinate(x);
//		y = scaleCoordinate(y);
//		for (int m = 1; m <= numberofMoleculeParts; m++) {
//			//a_or_b > 0 if atom , < 0 if bond and 0 if neither
//			int a_or_b = moleculeParts[m].testAtomAndBondTouch(x, y, new DoubleWrapper(radius));
//			//a_or_b = moleculeParts[m].testAtomAndBondTouch(x, y);
//			//info("" + x + " " + y + " " +a_or_b);				
//			if(a_or_b != 0 ) {
//				
//				result.molIndex = m;
//				if(a_or_b > 0) {
//					result.atomIndex = a_or_b;
//				} else {
//					result.bondIndex = a_or_b * -1;
//					
//				}
//				break;
//				
//			}
//		}

//	}
//	@Deprecated
//	void findMolAndAtomOrBondInDrawingAreaFromEventXY(int event_x, int event_y,TouchedMol result ) {
//		int x =  event_x - (int)menuCellSize;
//		//int y = event_y - (2 * (int)menuCellSize + menuCellBorder());
//		int y = event_y - topMenuHeight();
//		findMolAndAtomOrBondInDrawingArea(x, y, result);
//
//	}
	void findMolAndAtomOrBondInDrawingArea(int x, int y, TouchedMol result) {

		if (this.isOutsideDrawingArea(x, y)) {
			result.reset();
			// System.out.println("isOutsideDrawingArea x=" + x + " y=" + y);
			return;
		}
		findMolAndAtomOrBondWithinRadius(x, y, getHumanInteractionTouchRadius(), result);
	}

	/**
	 * find the closest touched atom or bond within the given radius. Store the
	 * results in the argumet result
	 * 
	 * @param x
	 * @param y
	 * @param result
	 */
	void findMolAndAtomOrBondWithinRadius(int x, int y, int radius, TouchedMol result) {

		result.reset();

		// x = scaleCoordinate(x);
		// y = scaleCoordinate(y);
		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double minDistance = radius;
			
		
		for(JMEmol eachMol: this.moleculePartsList) {
			DoubleWrapper minDistanceFound = new DoubleWrapper(radius);
			int a_or_b = eachMol.testAtomAndBondTouch(xCoord, yCoord, this.ignoreAtoms(), this.ignoreBonds(), minDistanceFound);

			if(minDistanceFound.value <  minDistance) {
				minDistance = minDistanceFound.value;
				result.reset();
				result.mol = eachMol ;
				result.distance = minDistance;
				assert a_or_b != 0;;
				if(a_or_b > 0) {
					result.atomIndex = a_or_b;
				} else {
					result.bondIndex = a_or_b * -1;
					
				}
			}
		}
		

	}

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	/**
	 * BB Compute the radius for human interaction around an atom or a bond. This
	 * radius should be larger for touch device than for pointer based system.
	 * 
	 * The drawback of a larger radius is that one has to be more precise when
	 * moving the structure.
	 * 
	 * @return a radius
	 */
	static final int TOUCH_LIMIT = 50;

	protected int getHumanInteractionTouchRadius() {
		if (JME.isTouchSupported) {
			return TOUCH_LIMIT + 300; // determined by trial and error on an iPad 4 by BB
		}
		return TOUCH_LIMIT + 120;
	}

	// ----------------------------------------------------------------------------
//	@Override
	public boolean mouseMove(MouseEvent e, int x, int y) {
		
	
		// public void mouseMoved(MouseEvent e) {
		// System.out.println("@@@@ mouseMove");
		// is depictActionEnabled test needed here? if depictActionEnabled is used only
		// for the toggle edit/depict, then no
		if (isDepict() && !(this.canHandleAtomHighLightCallBack() || this.canHandleBondHighLightCallBack()
				|| depictActionEnabled)) // notifyAtomHighLightJSfunction: Luc P request to show atom highlight in
											// depict mode
			return true;
		// int x = e.getX()-sd; int y = e.getY()-sd*2;

		
		// BB popup menu for copy&paste has been opened
		// boolean meta = e.metaDown() ; //true if right mouse click
		if (this.isEventContextMenu(e)) {
			// do nothing to avoid the molecule moving while popup menu is displayed
			return true;
		}


		
		boolean repaintFlag = false;
		mustRedrawNothing(); // shoInfo() will change that

		int action = this.determineMenuAction(x, y, true);

		if (this.isActionEnabled(action)) {
			if (action != this.mouseWasOverAction) {
				// kind of new event
				repaintFlag |= this.handleMouseLeaveActionMenu(this.mouseWasOverAction);
				repaintFlag |= this.handleMouseEnterActionMenu(action);
				this.mouseWasOverAction = action;
			}
		}

		// BB
		// this.mustReDrawInfo = false; //whenpaste operation fails, a mouse move can
		// still occur, and there will be no error message.

		// System.out.println("X:Y: " + x +" " + y + " " + menuCellSize);

		// BB: bug found by Oli: with structure underneath the menu region: highlight
		// must dissapear

		// boolean outsideDrawingArea = !depict && ( x < menuCellSize || y <
		// topMenuHeight() || y > dimension.height - menuCellSize - 1 || x >=
		// dimension.width-1);

		// x -= leftMenuWidth();
		// y -= topMenuHeight();

		// don't create any new object during a mouse move to
		// avoid stressing the garbage colector
		// BB: bug found by Oli: with structure underneath the menu region: highlight
		// must dissapear
		findMolAndAtomOrBondInDrawingArea(x, y, newTouchedMol);

		// Don't allow bond touching in ACTION_MOVE_AT
		// if(action == ACTION_MOVE_AT && newTouchedMol.bondIndex > 0) {
		// newTouchedMol.bondIndex = 0;
		// }
		// System.out.println(newTouchedMol.molIndex + " " + newTouchedMol.atomIndex + "
		// " + newTouchedMol.bondIndex);

		if (!newTouchedMol.equals(lastTouchedMol) && (newTouchedMol.isTouched() || lastTouchedMol.isTouched())) {

			// necekuje, ci sa nedotyka 2 molekul naraz, ale to by bolo asi zbytocne

			//int m  = lastTouchedMol.molIndex;
			JMEmol tm = lastTouchedMol.mol;
			
			if( tm != null) {
				tm.touchedAtom = 0;
				tm.touchedBond = 0;
			}
			
			tm  = newTouchedMol.mol;
			if(tm != null) {
				tm.touchedAtom = newTouchedMol.atomIndex;
				tm.touchedBond = newTouchedMol.bondIndex;
				//touched mol becomes the mol for edition
				activeMol = tm;
				// this must be changed!!!!!
//				if (m != actualMoleculePartIndex ) {
//					actualMoleculePartIndex = m;
//					activeMol = moleculeParts[actualMoleculePartIndex];
//				}
			}
			

			repaintFlag = true;
			// June 2018: fire the leave event first
			if (newTouchedMol.atomIndex == 0) {
				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);
				notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
			} else if (newTouchedMol.bondIndex == 0) {
				notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);
			} else {
				// should never happen
				notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);

			}

			// BB changed: notify only if it is an atom highlight

			// Design issue: notifyAtomHighLightJSfunction does not provide the molecule
			// part number
			// presently notifyAtomHighLightJSfunction handle the minimal change reporting
			// if(newTouchedMol.atomIndex != lastTouchedMol.atomIndex || m !=
			// lastTouchedMol.molIndex) {
			// notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);
			// }
			// if(newTouchedMol.bondIndex != lastTouchedMol.bondIndex|| m !=
			// lastTouchedMol.molIndex) {
			// notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
			// }

//			if(newTouchedMol.atomIndex > 0) {
//				if(lastTouchedMol.bondIndex >0) {
//					notifyBondHighLightJSfunction(0);//used to notify that the cursor has moved away from the bond
//				}
//				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex); //used by LP to highlight NMR spectrum part
//								
//			} else if (newTouchedMol.bondIndex>0) { //bond was touched
//				if(lastTouchedMol.atomIndex>0) {
//					notifyAtomHighLightJSfunction(0);//used to notify that the cursor has moved away from the atom
//				}
//				notifyBondHighLightJSfunction(newTouchedMol.bondIndex); //used by LP to highlight NMR spectrum part
//				
//			}

			// System.out.println(actualMoleculePartIndex + " "+ m );

			lastTouchedMol.initMyselfWith(newTouchedMol);
			assert lastTouchedMol.equals(newTouchedMol);

		}
//		else {
//			if(this.atomWasTouched) { //NEW 06 2015!!!!!
//				notifyAtomHighLightJSfunction(0); //used to notify that the cursor has moved away from the atom
//				this.atomWasTouched = false;
//			}
//
//			if(this.bondWasTouched) { //NEW 06 2015!!!!!
//				notifyBondHighLightJSfunction(0); //used to notify that the cursor has moved away from the bond
//				this.bondWasTouched = false;
//			}

//			if (moleculeParts[m].touchedAtom > 0 || moleculeParts[m].touchedBond > 0) {
//				moleculeParts[m].touchedAtom = 0;
//				moleculeParts[m].touchedBond = 0;
//				repaintFlag = true;
//			}
//		}

		if (repaintFlag) {
			// vynuluje pripadny predosly touch
//			for (int m = actualMoleculePartIndex + 1; m <= numberofMoleculeParts; m++) {
//				moleculeParts[m].touchedAtom = 0;
//				moleculeParts[m].touchedBond = 0;
//			}
			// BB
			setMustRedrawMolecularArea(true);
			repaint();

		}
		// added after
		// if (depict && this.notifyStructuralChangeJSfunction == null)
		// above was changed
//		if (depict) {
//			return true;
//		}

		return repaintFlag;
	}


	/*
	 * * to be redefined in JS subclass (JSME)
	 * 
	 */
	public boolean isMacintosh() {
		return false;
	}

//	@Override
	public boolean keyDown(KeyEvent e, int key) {

		// BB
		this.mustReDrawInfo = false;
		// this.log("Key code: " + key);
		
		// handling numeric keypad
		if (key >= 96 && key <= 105 ) { // number
			key = key -96 + 48;
		}
		
		
		// public void keyPressed(KeyEvent e) {
		if (isDepict() && !depictActionEnabled)
			return false;
		clearInfo();
		
		
		boolean shift = e.getModifiers() == Event.SHIFT_MASK;
		boolean alt = e.getModifiers() == Event.ALT_MASK;
		// On Mac: meta is down for system copy
		boolean meta = isMacintosh() ? e.isMetaDown() : e.isControlDown();
		
		
		// In GWT debug mode, key is always  uppercase
		System.out.println("@@@@ keyDown: " + key + ' ' + Character.toString((char) key) + " shift=" + shift);
				
		int pressed = 0;

		// custom shortcuts
		if (this.menuXShortcuts != null && this.menuXShortcuts.length() > 0) {
			char shortcut = (char) key;
			if (! shift ) {
				shortcut = Character.toLowerCase(shortcut);
			} else {
				shortcut = Character.toUpperCase(shortcut);
			}
			if (this.menuXShortcuts.indexOf(shortcut) >= 0) {
				// duplicated code
				MultiBox.atomicSymbol.setText(Character.toString(shortcut));
				this.xJButton = true;
				info(MultiBox.atomicSymbol.getText());
				pressed = ACTION_AN_X;
				active_an = AN_X;			
				return menuAction(pressed);
			}
		}
		
		// key shortcuts
		// treba to disabled, ked input do elementu;
		// if (elementInput) return false;
		// int key = e.getKeyChar();

		// System.err.println("key " + key + " " + alt);
		switch (key) {
		// case 'e': case 'E': JMEmol.TESTDRAW = !JMEmol.TESTDRAW; break;
		case 'c':
		case 'C':

			// NOT USED IN JS !!!!!
			if (meta) { // try a Ctrl C for copy. does not work in Java due to java security policy
				this.copyFileToClipboard();
				break;
			}
			pressed = ACTION_AN_C;

			break;

		// May 2019: shortcut for '*'
		case '*':
		case 106: // keyboard numeric pad
		case 'g':
		case 'G':
			MultiBox.atomicSymbol.setText("*");
			this.xJButton = true;

		case 'x':
		case 'X':
			if (meta) { //
				this.cutSelectedMoleculeForSystemClipBoard();
				break;
			}
			if (this.xJButton) {
				info(MultiBox.atomicSymbol.getText());
				pressed = ACTION_AN_X;
				active_an = AN_X;
			}
			break;

		case 'v':
		case 'V':

			// paste with Ctrl V
			// does not work in Java in a browser due to java security policy
			if (meta && this.paste) {
				this.pasteMolFileFromClipboard();
				break;
			}
			break;

		case 'n':
		case 'N':
			pressed = ACTION_AN_N;
			break;
		case 'o':
		case 'O':
			pressed = ACTION_AN_O;
			break;
		case 's':
		case 'S':
			pressed = ACTION_AN_S;
			break;
		case 'p':
		case 'P':
			pressed = ACTION_AN_P;
			break;
		case 'f':
		case 'F':
			pressed = ACTION_AN_F;
			break;
		case 'l':
		case 'L':
			pressed = ACTION_AN_CL;
			break;
		case 'b':
		case 'B':
			pressed = ACTION_AN_BR;
			break;
		case 'i':
		case 'I':
			pressed = ACTION_AN_I;
			break;
		case 'h':
		case 'H':
			info("H");
			pressed = ACTION_AN_H;
			break;
		case 'r':
		case 'R':
			info("-R");
			pressed = ACTION_AN_R;
			break; // if (rJButton) ?
		case 't':
		case 'T':
			if (action == ACTION_AN_F) {
				pressed = ACTION_GROUP_CF3;
				info("-CF3");
			} else if (action == ACTION_AN_CL) {
				pressed = ACTION_GROUP_CCL3;
				info("-CCl3");
			} else {
				pressed = ACTION_GROUP_TBU;
				info("-tBu"); // TODO: consistent naming with the FG's
			}
			break;
		case 'y':
		case 'Y':
			if (meta) { // BB - does not work in Java
				pressed = ACTION_REDO;
			} else {
				pressed = ACTION_GROUP_NITRO;
				info("-NO2");
			}
			break;
		case 'z':
		case 'Z':
			if (meta) { // BB - does not work in Java
				pressed = ACTION_UNDO;
			} else {
				pressed = ACTION_GROUP_SULFO;
				info("-SO3H");
			}

			break;

		case 'a':
		case 'A':
			pressed = ACTION_GROUP_COO;
			info("-COOH");
			break;
		case 'e':
		case 'E':
			pressed = ACTION_GROUP_CC;
			info("-C#CH");
			break;
		case 'u':
		case 'U':
			pressed = ACTION_UNDO;
			break;
		case 'q':
		case 'Q':
			pressed = ACTION_GROUP_CYANO;
			info("-C#N");
			break;
		// case 'g': // used for testing
		// return true;
		case 27: // esc
			pressed = ACTION_BOND_SINGLE;
			break;
		case '-':
			// check here that an was changed and then cancell this -X ???
			if (action == ACTION_AN_F) {
				pressed = ACTION_GROUP_CF;
				info("-F");
			} else if (action == ACTION_AN_CL) {
				pressed = ACTION_GROUP_CL;
				info("-Cl");
			} else if (action == ACTION_AN_BR) {
				pressed = ACTION_GROUP_CB;
				info("-Br");
			} else if (action == ACTION_AN_I) {
				pressed = ACTION_GROUP_CI;
				info("-I");
			} else if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_CO;
				info("-OH");
			} else if (action == ACTION_AN_N) {
				pressed = ACTION_GROUP_CN;
				info("-NH2");
			} else
				pressed = ACTION_BOND_SINGLE;
			break;
		// BB merged '=' and '
		/*
		 * case '=':'
		 * 
		 * if (action == ACTION_AN_O) { pressed = ACTION_GROUP_dO; info("=O"); } else
		 * pressed = ACTION_BOND_DOUBLE; break;
		 */
		// new BB shortcut
		case '+':
		case 107: // numeric keypad
			// toggle charge - same as clicking on the +/- icon
			// note that there is already a shortcut for '-'
			pressed = ACTION_CHARGE;
			break;
		case '#':
			pressed = ACTION_BOND_TRIPLE;
			break;
		case '0':
			if (action == ACTION_MARK)
				updateMark(0);
			else {
				if (!alt) {
					pressed = ACTION_RING_FURANE;
					info("-Furyl");
				} else {
					pressed = ACTION_RING_3FURYL;
					info("-3-Furyl");
				}
			}
			break;
		case '1':
			if (action == ACTION_MARK)
				updateMark(1);
			else
				pressed = ACTION_RING_PH;
			break;
		case '2':
		case '=':
			if (key == '2' && action == ACTION_MARK)
				updateMark(2);
			// BB added October 2015 : create a double bond
			// duplacade code with = TODO:
			else if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_dO;
				info("=O");
			} else
				pressed = ACTION_BOND_DOUBLE;
			break;
		case '3':
			if (action == ACTION_MARK)
				updateMark(3);
			else
				pressed = ACTION_RING_3;
			break;
		case '4':
			if (action == ACTION_MARK)
				updateMark(4);
			else
				pressed = ACTION_RING_4;
			break;
		case '5':
			if (action == ACTION_MARK)
				updateMark(5);
			else
				pressed = ACTION_RING_5;
			break;
		case '6':
			if (action == ACTION_MARK)
				updateMark(6);
			else
				pressed = ACTION_RING_6;
			break;
		case '7':
			if (action == ACTION_MARK)
				updateMark(7);
			else
				pressed = ACTION_RING_7;
			break;
		case '8':
			if (action == ACTION_MARK)
				updateMark(8);
			else
				pressed = ACTION_RING_8;
			break;
		case '9':
			if (action == ACTION_MARK)
				updateMark(9);
			else {
				info("9 ring");
				pressed = ACTION_RING_9;
			}
			break;
		case 'd':
		case 'D':
		case 8:
		case 127:
			pressed = ACTION_DELETE;
			break;
		case 32:
			pressed = ACTION_CHAIN;
			break; // SPACE
		case 'm': // BB
		case 'M': // BB
		case Event.PGUP:
			pressed = ACTION_PGUP;
			break; // PgUp

		case 'w': // BB
		case 'W': // BB
		case Event.PGDN:
			pressed = ACTION_PGDN;
			break; // PgDn
		// default: System.out.println("key "+key); break;

		case Event.HOME:
			pressed = ACTION_HOME;
			break;
		case Event.END:
			pressed = ACTION_END;
			break;

		}

		// handling R #
		int digit_key = key + 1 - '1';
		// if number between 0 and 9 was entered
		if (digit_key >= 0 && digit_key <= 9 && activeMol.touchedAtom > 0) {
			int an = activeMol.an(activeMol.touchedAtom);
			if (an >= AN_R && an <= AN_R_LAST) {
				pressed = ACTION_AN_R + digit_key;
			}
		}
		if (pressed != 0)
			return menuAction(pressed); // will redraw if needed, will change this.action

		return false; // did not use the event: will be forwarded to other apps
	}

	// --------------------------------------------------------------------------
	// called when number key clicked and marking active
	// updates actual mark which will be used for marking
	private void updateMark(int n) {
		// need to know when new number and when combination of 2 presses i.e.
		// 12
		if (autonumber) {
			if (n == 0) {
				keyboradInputMark = 0;
				showInfo("click marked atom to delete map");
				markFromKeyboardInput = true;

				// repaint(); // updates status line
				
				return; // BB June 2020: moved from level below, otherwise atom mapping can not be used from the keyboard
			}
			
		}

		// markUsed true: accumulate the mark number, which allows to get number >= 10
		if (resetExtendAtomMark) {
			keyboradInputMark = n;
			resetExtendAtomMark = false;
		} else {
			if (keyboradInputMark > -1 && keyboradInputMark < 100)
				keyboradInputMark = keyboradInputMark * 10 + n;
			else {
				keyboradInputMark = n; // mark cannot be > 999
				resetExtendAtomMark = false;

			}
		}

		String action_type = "map";
		String target = "atom";
		String reset_action = "delete map";
		
		if (this.moleculeHandlingParameters.mark) {
			reset_action = "remove background color";
			action_type = "color index";
			if (starAtomOnly) {
				
			} else if (starBondOnly) {
				target = "bond";
			} else {
				target = "atom or bond";
			}
			if (keyboradInputMark <= 0) {
				keyboradInputMark = 1 ; // reset to default color index
			}
		}
		
		if (keyboradInputMark == 0) {
			//keyboradInputMark = -1; //BUG? Novenber 2020
			keyboradInputMark = 0;
			showInfo("click marked " + target + " to " + reset_action);
		} else {
			if (this.moleculeHandlingParameters.mark) {	
				this.activateMarkerColor(keyboradInputMark);
			}
			showInfo("Click " + target + " to set " + action_type + " to " + keyboradInputMark);
				
			
		}

		markFromKeyboardInput = true;
	}

	// --------------------------------------------------------------------------
	// BB used for copy paste and setSubtituents
	@Override
	public void actionPerformed(ActionEvent evt) {
		mustRedrawNothing();

		String cmd = evt.getActionCommand();
		
		ColorInfo colorInfo = this.colorManager.getColorInfoOfColorHash(cmd);
		if( colorInfo != null) {
			int colorIndex = colorInfo.index;
			this.activateMarkerColor(colorIndex);
			this.showInfo(colorInfo.name);
			
			return;
		}

		if (cmd.equals(CopyPasteAction.SMILES.toString())) {
			clipBoardManager.setClipboardContents(this.smiles());
		} else if (cmd.equals(CopyPasteAction.MOL.toString())) {
			this.copyMolFileToClipboard(false);
		} else if (cmd.equals(CopyPasteAction.MOL_V3000.toString())) {
			this.copyMolFileToClipboard(true);
			
		} else if (cmd.equals(CopyPasteAction.JME.toString())) {
			this.copyJmeStringToClipboard();
			
		} else if (cmd.equals(CopyPasteAction.PASTE.toString())) {
			if (this.paste)
				this.pasteMolFileFromClipboard();
		} else if (cmd.equals(CopyPasteAction.INCHI.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI);
		} else if (cmd.equals(CopyPasteAction.INCHI_KEY.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI_KEY);
		} else if (cmd.equals(CopyPasteAction.INCHI_AUXINFO.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI_AUXINFO);
		} else if (cmd.equals(CopyPasteAction.OCLCODE.toString())) {
			this.copyOclCodetoClipboard();
		}

		else if (cmd.equals(CopyPasteAction.SEARCH_INCHI_KEY.toString())) {
			this.searchChemicalStructureUsingInchiKey();
		}

		else if (cmd.equals(CopyPasteAction.SVG.toString())) {
			this.copySVGToClipboard();
		}

		else if (this.isJavaScript && cmd.equals(CopyPasteAction.RAW_STRING_GRAPHIC.toString())) {
			this.copyRawGraphicToClipboard();
		}

		// BB : rotation coming from the touch handling
		else if (cmd.equals("rotation")) { // used by touch devices
			if (lastAction != LA_ROTATE) {
				lastRotation = 0;
			}
			long rotation = evt.getWhen(); // I had to store the rotation somewhere
			rotation *= -1; // feels more natural
			long deltaRotation = rotation - lastRotation;

			if (Math.abs(deltaRotation) < 10) {
				activeMol.rotate((int) deltaRotation);
			}
			// mustRedrawNothing();
			setMustRedrawMolecularArea(true);
			// info("Rotation: " + rotation + " deltaRotation " + deltaRotation);

			// repaint(); //done at the end
			lastAction = LA_ROTATE;
			lastRotation = rotation;

		} else if (cmd == unSetChiralFlagAction || cmd == setChiralFlagAction) {
			boolean changed = this.activeMol.setChiralFlag(cmd == setChiralFlagAction);
			if (changed) {
				int n = this.moleculePartsList.size();
				String additional = "";
				if (n > 1) {
					int index = this.moleculePartsList.indexOf(this.activeMol);
					index ++;
					additional = " for molecule " + index ;
					
				}

				if (this.activeMol.chiralFlag) {
					info("Chiral flag is set" + additional);
				} else {
					info("No Chiral flag" + additional);

				}
				// this.postSave(); //idea: recordMoleculePartEvent could be used to perform the
				// postSave, + giving a name to saved state
				// that could be used for displaying in info() when mouse over undo button
				this.recordMoleculePartEvent(CHANGE_CHIRAL, this.activeMolIndex());
				setMustRedrawMolecularArea(true); // not really needed but the event will be written out only when
												// redrawing the molecular area
			}

		} else if (cmd == autoAtomMapMoleculeAction) {

			// find the highest atom map
			int max = this.findMaxAtomMapAmongAllMolecules();
			boolean changed = false;
			for (int at = 1; at <= activeMol.natoms; at++) {
				Atom atom = activeMol.atoms[at];
				if (!atom.hasBeenMapped()) {
					max++;
					atom.setMap(max);
					changed = true;
				}
			}

			if (changed) {
				setMustRedrawMolecularArea(true);
				this.recordMoleculePartEvent(CHANGE_MANY_ATOM_MAP, this.activeMolIndex());
			}
		} else if (cmd == deleteAtomMapMoleculeAction) {
			if ((setMustRedrawMolecularArea(activeMol.resetAtomMaps()))) {
				this.recordMoleculePartEvent(DELETE_ATOM_MAPS, this.activeMolIndex());
			}

		} else if (cmd == bondSetCoordinationAction || cmd == bondUnSetCoordinationAction) {
			setMustRedrawMolecularArea(true);
			int bondIndex = this.inspectorEvent.bondIndex;
			assert (bondIndex > 0);
			Boolean isCoordination = this.inspectorEvent.mol.getBond(bondIndex).toggleCoordination().isCoordination();
			this.recordBondEvent(isCoordination ? SET_BOND_COORDINATION : UNSET_BOND_COORDINATION);
			// TODO: the event name could be the same as the action

		} else if (cmd == deleteHydrogensMoleculeAction) {
			
			// From the user interaction, thus it is not using the settings from options()
			HydrogenHandlingParameters options = new MoleculeHandlingParameters().hydrogenHandlingParameters;
			options.removeHs = true;
			options.removeOnlyCHs = false;
			
			setMustRedrawMolecularArea(activeMol.deleteHydrogens(options)); // mustReDrawMolecularArea is flase if there are no deleted hydrogens

			if (mustReDrawMolecularArea) {
				this.recordMoleculePartEvent(DELETE_HYDROGENS, this.activeMolIndex());
			}
		}
		else if (cmd == compute2DcoordinatesMoleculeAction) {

			// compute2Dcoordinates needs openchemlib
			JMEUtil.runAsync(new JSME_RunAsyncCallback() {
				
				@Override
				public void onSuccess() {
					if (activeMol.nAtoms() > 1) {
						int index = activeMolIndex();
						
						double centerX = activeMol.centerX();
						double centerY = activeMol.centerY();
						
						//newActiveMol may or may not be activeMol
						JMEmol newActiveMol = moleculePartsList.compute2Dcoordinates(activeMol);
						
						if (newActiveMol != null) {
							double dx = centerX - newActiveMol.centerX();
							double dy = centerY - newActiveMol.centerY();
							newActiveMol.moveXY(dx, dy);
							
							moleculePartsList.set(index, newActiveMol);
							recordMoleculePartEvent(COMPUTE_2D, index);
							setMustRedrawMolecularArea(true);
							
							JME.this.info("2D coordinates provided by OpenChemLib");
	
							repaint();
						} else {
							JME.this.info("2D coordinates computation failed");

						}
					}
				}
				
			});
			
			
		}

		// BB : rotation coming from the touch handling
		// problem: unwanted interaction with the rotation
		// Chemdoodle rotation & scaling works nice
		else if (cmd.equals("scale100")) { // used by touch devices
			if (false && this.moleculePartsList.size() == 1) {
				long scale100 = evt.getWhen(); // I had to store the scale somewhere

				setMustRedrawMolecularArea(true);

				double delta = 0.05;
				if (scale100 != 100) {
					if (scale100 < 100) {
						delta *= -1;
					}
					this.molecularAreaScale = scale100 / 100.0;
					// Todo : compute center of mol
					//activeMol.scaling();
					activeMol.center(); // TODO : translate back to previous center
					// info("Scale " + this.depictScale );
					lastAction = LA_SCALE;

				}
			}
		} else if (cmd.equals("end_gesture")) {
			this.willPostSave(true);
		} else {
			this.setSubstituent(cmd);
		}

		if (mustReDrawMolecularArea || mustReDrawInfo) {
			repaint();
		}

	}

	
	/**
	 * nEW tbc, SHOULD ENCAPSULATED THE RUN asYn WHEN NEEDED
	 * tO BE USED IN ACTIO  MENU AND DIRECT COPY AND DIRECT CUT AND d&d
	 * @param format
	 * @param callBack
	 */
	public void exportFile(SupportedFileFormat format, final RunWhenDataReadyCallback callBack) {
		
		switch(format) {
		case INCHI:
			break;
		case INCHI_AUXINFO:
			break;
		case INCHI_KEY:
			break;
		case JME:
			break;
		case MOL:
			break;
		case MOL_V3000:
			break;
		case OCLCODE:
			break;
		case RAW_STRING_GRAPHIC:
			break;
		case SMILES:
			break;
		case SVG:
			break;
		default:
			break;
		
		
		
		}
	}
	
	// not used?
	public void copyFileToClipboard() {
		switch(this.clipboardFormat) {
		case MOL:
			this.copyMolFileToClipboard(false);
			break;
		
		case MOL_V3000:
			this.copyMolFileToClipboard(true);
			break;
		
		case JME:
			this.copyJmeStringToClipboard();
			break;
		case SVG:
			this.copySVGToClipboard();
			break;
		case RAW_STRING_GRAPHIC:
			this.copyRawGraphicToClipboard();
			break;
		case SMILES:

			clipBoardManager.setClipboardContents(this.smiles());
			break;
		case INCHI:
			this.copyInchiToClipboard(CopyPasteAction.INCHI);
			break;
		case INCHI_AUXINFO:
			this.copyInchiToClipboard(CopyPasteAction.INCHI_AUXINFO);
			break;
		case INCHI_KEY:
			this.copyInchiToClipboard(CopyPasteAction.INCHI_KEY);
			break;
		case OCLCODE:
			this.copyOclCodetoClipboard();
		default:
			clipBoardManager.setClipboardContents("incorrect or unsupported export format");
		}
	}
	
	/**
	 * Work for all upported file formats, even thos that require loading code dynamically, hence the callback argument
	 * @param format
	 */
	public void generateOuttputFile( final RunWhenDataReadyCallback callBack) {
		this.generateOuttputFile(this.clipboardFormat, callBack);
	
	}
	
	/**
	 * Work for all upported file formats, even thos that require loading code dynamically, hence the callback argument
	 * @param format
	 * @param callBack
	 */
		
	public void generateOuttputFile(SupportedFileFormat format, final RunWhenDataReadyCallback callBack) {

			
			
			
		String output = null;
		
		switch(format) {
		case MOL:
			output =this.molFile(false);
			break;
		
		case MOL_V3000:
			output =this.molFile(true);
			break;
		
		case JME:
			output =this.jmeFile();
			break;

		case SVG:
//			GWT.runAsync(new JSME_RunAsyncCallback() {
//
//				@Override
//				public void onSuccess() {
//					callBack.onSuccess(JME.this.getOclSVG());
//				}
//				
//			});
			break;
			
		case RAW_STRING_GRAPHIC:
			output =  this.getMolecularAreaGraphicsString();
			break;
		case SMILES:
			output = this.smiles();
			break;
			
		case INCHI:
		case INCHI_AUXINFO:
		case INCHI_KEY:
		case INCHI_JSON:
			this.computeInchi(format, callBack);
			break;
			
		case OCLCODE:
			JMEUtil.runAsync(new JSME_RunAsyncCallback() {

				@Override
				public void onSuccess() {
					callBack.onSuccess(JME.this.getOclCode());
				}

			});
			break;

		default:
			Throwable error = new Throwable("incorrect or unsupported export format");
			callBack.onFailure(error);
		}
		
		if (output != null ) {
			callBack.onSuccess(output);
		}
	}

	public void computeInchi(final SupportedFileFormat action, final RunWhenDataReadyCallback callBack) {}

	// BB
	// should use new gneral methodexportFile
	@Deprecated
	public void copyMolFileToClipboard(boolean isV3000) {
		clipBoardManager.setClipboardContents(this.molFile(isV3000));
	}

	//April 2020
	// should use new gneral methodexportFile

	public void copyJmeStringToClipboard() {
		clipBoardManager.setClipboardContents(this.jmeFile());
	}
	// BB
	// should use new gneral methodexportFile

	public void copyOclCodetoClipboard() {
		// use RunAsyncCallback to trigger a code split to download openchemlib
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				clipBoardManager.setClipboardContents(JME.this.getOclCode());
			}

		});

	}

	// should use new gneral methodexportFile

	public void copySVGToClipboard() {
		// use RunAsyncCallback to trigger a code split to download openchemlib
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				clipBoardManager.setClipboardContents(JME.this.getOclSVG());
			}

		});

	}

	// should use new gneral methodexportFile

	public void copyRawGraphicToClipboard() {
		String result = this.getMolecularAreaGraphicsString();
		if (result != null) {
			clipBoardManager.setClipboardContents(result);
		}
	}

	// should use new gneral methodexportFile

	public void copyInchiToClipboard(CopyPasteAction action) {
		// for subclasses
		// clipBoardManager.setClipboardContents(this.computeInchi(isKey));
	}

	public void searchChemicalStructureUsingInchiKey() { // for subclasses

	}

	//
	public void pasteMolFileFromClipboard() {
		// String molecule = clipBoardManager.getClipboardContents();
		// if(molecule != null) {
		// molecule = molecule.replace("\n", "|");
		// this.readMolFile(molecule);
		// }
		this.afterStructureChangeEvent.setOrigin_PASTE();

		// asynchronous action is needed for non IE browsers
		clipBoardManager.getAsyncClipboardContents(this.getPasteAction());

	}

	// used by drag and drop and system clipboard paste
	public void pasteDirect(String molString, boolean originIsDrop) {
		// if pasting is allowed
		if (!this.paste) {
			return;
		}
		if (molString != null && molString.length() > 0) {
			// OK if only DnD uses this function
			if (originIsDrop)
				this.afterStructureChangeEvent.setOrigin_DROP();
			else
				this.afterStructureChangeEvent.setOrigin_PASTE();

			this.getPasteAction().paste(molString);
		} else {
			this.showError("empty or null structure");
		}
	}

	protected PasteAction getPasteAction() {
		return this.createPasteActionInstanceIfNeeded();
	}

	protected PasteAction createPasteActionInstanceIfNeeded() {
		if (this.pasteAction == null) {
			this.pasteAction = new PasteAction() {

				@Override
				public void paste(final String clipboardContent) {
					// final String molecule = clipboardContent;

					if (clipboardContent != null) {

						// customized paste
						if (JME.this.getPrePasteJSfunction() != null) {
							JSObject jsObject = JSObject.getWindow(JME.this);
							jsObject.call(JME.this.getPrePasteJSfunction(), new String[] { clipboardContent });
							return;
						}

						/// customized paste only for JSME
						if (JME.this.handleBeforePasteEvent(clipboardContent)) { // if the callback is set
							return;
						}
						JME.this.pasteGenericInput(clipboardContent, true, new RunAsyncCallback() {

							@Override
							public void onFailure(Throwable reason) {
								// read_MOL_SDF_RXN has already handled the error
							}

							@Override
							public void onSuccess() {
								// callback to client
								JME.this.handleAfterPasteEvent(clipboardContent);

							}

						});
					}

				}

			};
		}
		return this.pasteAction;
	}

	class StringWrapper {
		public String innnerString;
	};

	// TODO the input error handling has to be redesigned
	// test cases with invalid MOL
	final StringWrapper sdfPastedMessage = new StringWrapper();

	public void pasteGenericInput(String chemicalString, boolean recordEvent, final RunAsyncCallback sucessAndFailureHandle) {

		sdfPastedMessage.innnerString = "";
		this.afterStructureChangeEvent.setOrigin_API();

		// todo: handle RDF
		int countSDF = JME.this.sdfStack.addEntries(chemicalString);
		if (countSDF > 0) {
			// sdfPastedMessage = ". " + countSDF + " structures in stack .Use Page Up/Down
			// for SDF access";
			sdfPastedMessage.innnerString = " Use Page Up/Down for SDF access (" + countSDF + ")";

			// emit an event that says that a SDF mutiple structure was added sept 2019
			this.afterStructureChangeEvent.setAction(READ_MULTI_SDF);
			notifyStructuralChangeToJS();

		}

		RunAsyncCallback localSucessAndFailureHandle = new RunAsyncCallback() {

			@Override
			public void onFailure(Throwable reason) {
				info("ERROR: " + reason.getMessage()); // the readMolFile() method has already generated a message
				JME.this.alert(JME.this.infoText); // this.infotext has be set on thye line above
				JME.this.reset();
				JME.this.repaint();

			}

			@Override
			public void onSuccess() {
				info("Structure pasted. " + sdfPastedMessage.innnerString);
				// JME.this.postSave(); //add it to the undo/redo manager
				JME.this.setMustRedrawMolecularArea(true);
				JME.this.repaint();

				sucessAndFailureHandle.onSuccess();
			}
		};
		try {
			JME.this.handleReadGenericInput(chemicalString, localSucessAndFailureHandle, false, recordEvent); // do not repaint because
																								// localSucessAndFailureHandle
																								// does it
		} catch (Exception e) {
			localSucessAndFailureHandle.onFailure(e);
		}
	}

	/*
	 * Same functionality as prePasteJSfunction but only for JSME Advantage: the
	 * argument is a JS function, not a JS function name. The JS fyunction will have
	 * two arguments: my self and the string to process before pasting For JME,
	 * always return false - meaning that there is no callback set
	 */
	protected boolean handleBeforePasteEvent(String molecule) {

		return false;
	}

	/**
	 * Called when pasting has been sucessful. Method intended for a subclass.
	 */
	protected void handleAfterPasteEvent(String pasteContent) {
		// Do nothing

	}

	/**
	 * Called after swith to edit / depict mode using the toggle option. Method
	 * intended for a subclass.
	 */
	protected void handleAfterAfterDepictEditToggleEvent() {
		// do nothing
	}

	@Deprecated
	public String cutSelectedMoleculeForSystemClipBoard() {
		if (this.activeMol.natoms == 0) {
			return "";
		}

		this.activeMol.forceUniColor(Color.RED); // need a delay for that??
		String s = activeMol.createMolFile("");
		this.redrawMolecularAreaOnly();
		clear();

		this.redrawMolecularAreaOnly();

		return s;
	}
	public void cutSelectedMoleculeForSystemClipBoard(RunWhenDataReadyCallback callBack) {
		if (this.activeMol.natoms == 0) {
			return ;
		}

		//this.activeMol.forceUniColor(Color.RED); // need a delay for that?? no visible effect
		this.generateOuttputFile(callBack);
		//this.redrawMolecularAreaOnly();
		clear();

		this.redrawMolecularAreaOnly();
	}

	
	
	/**
	 * This code is incompleted
	 * it is needed for showing mouse over info (see handleMouseEnterActionMenu())
	 * @param action
	 * @return
	 */
	protected boolean isActionEnabled(int selectedAction) {
		
		
		// treba, aby nekreslilo neaktivne buttons
		if (selectedAction == ACTION_AN_R && !rJButton)
			return false;

		// if (square == ACTION_END && !isStandAloneApplication)
		// return;
		if (selectedAction == ACTION_QRY && !query)
			return false;
		if (selectedAction == ACTION_STEREO && !stereo)
			return false;
		if (selectedAction == ACTION_NEW && !multipart)
			return false;
		
		// WHEN marker option is set than, number is set but not automumber
		if (selectedAction == ACTION_MARK && !(this.moleculeHandlingParameters.number || autonumber))
			return false;
		if (selectedAction == ACTION_REACP && !reaction)
			return false;

		// new code
		switch(selectedAction) {
			case ACTION_MARK:
				return (!starNothing && moleculeHandlingParameters.mark) || this.moleculeHandlingParameters.number || autonumber;
			case ACTION_MOVE_AT:
				return showAtomMoveJButton;
			case ACTION_REACP:
				return reaction;
		
		}
		return true;
	}

	/**
	 * mouse cursor move over the button square: special action
	 * @param action
	 * @return
	 */
	boolean handleMouseEnterActionMenu(int action) {

		// idea: show info for each button
		// each actoon used here must also be decalred in handleMouseLeaveActionMenu()
		switch (action) {
		case ACTION_NEW:
			this.info("Add new molecule");
			return true;
		
		case ACTION_MOVE_AT:
			this.info("Move atom");
			return true;
		case ACTION_SPIRO:
			this.info("Activate spiro ring");
			return true;
		case ACTION_STEREO:
			this.info("Stereo bond single or double");
			return true;
		case ACTION_CHAIN:
			this.info("Create alkyl chain");
			return true;
		case ACTION_DELETE:
			this.info("Delete atom or bond");
			return true;

		case ACTION_DELGROUP:
			this.info("Click bond to delete smallest fragment");
			return true;
		
		case ACTION_SMI:
			this.info("Show SMILES or SMIRKS");
			return true;

		case ACTION_QRY:
			this.info("Open query box for SMARTS");
			return true;
			
		case ACTION_AN_X:
			this.info("Select other atom type");
			return true;

		case ACTION_AN_R:
			this.info("Select R group");
			return true;
			
		}
		// if there is no atoms, then there is nothing to highlight
		if (this.activeMol == null || this.activeMol.natoms == 0) {
			return false;
		}

		String note = null;

		switch (action) {
			case ACTION_CLEAR:
				if (this.moleculePartsList.size() > 1) {
					note = "Delete selected molecule (red)";
				} else {
					note = "Clear canvas";
				}
				this.activeMol.forceUniColor(Color.RED);
				this.uniColorMolecule = this.activeMol;
				break;
			case ACTION_REACP:
				note = "Copy selected (blue) molecule to the other side of the reaction";
				this.activeMol.forceUniColor(Color.BLUE);
				this.uniColorMolecule = this.activeMol;

		}

		if (note != null) {
			this.info(note);
			this.setMustRedrawMolecularArea(true); // new oct 2016
			this.mustReDrawTopMenu = true;
		} else {
			this.setMustRedrawMolecularArea(false); // new oct 2016
			this.mustReDrawTopMenu = false;
		}

		return note != null; // || this.mustReDrawMolecularArea || this.mustReDrawTopMenu;
	}

	/**
	 * 
	 * @param action
	 * @return true if repaint needed
	 */
	boolean handleMouseLeaveActionMenu(int action) {
		
		switch (action) {
		case ACTION_NEW:
		case ACTION_MOVE_AT:
		case ACTION_SPIRO:
		case ACTION_STEREO:
		case ACTION_CHAIN:
		case ACTION_DELGROUP:
		case ACTION_DELETE:
		case ACTION_SMI:
		case ACTION_QRY:
		case ACTION_AN_X:
		case ACTION_AN_R:

			
			this.clearInfo();
			return true;
			//break;
		}

		
		if (this.uniColorMolecule != null && (action == ACTION_CLEAR || (this.reaction && action == ACTION_REACP))) {

			this.uniColorMolecule.resetForceUniColor();
			this.uniColorMolecule = null;

			for(JMEmol mol: moleculePartsList) {
				mol.resetForceUniColor();
			}
			
			this.clearInfo();
			this.setMustRedrawMolecularArea(true);
			this.mustReDrawTopMenu = true;

		} else {
			this.setMustRedrawMolecularArea(false); // new october2016
			this.mustReDrawTopMenu = false;
		}

		// this.mustReDrawTopMenu = true;

		return this.mustReDrawMolecularArea;// || this.mustReDrawTopMenu;

	}

	/*
	 * Save the current molecules to the change manager
	 */
	protected void postSave() {

		if (!this.canMultipleUndo) {
			return;
		}

		System.out.println("@@@@ save state");
		SavedState state = this.createState();
		// if(state != null) {
		this.molChangeManager.insertItem(state);
		// }

	}

	/*
	 * Create a state to store the chemical state of the editor. Return null if
	 * there is nothing to save.
	 */
	protected SavedState createState() {

		//state.actualMoleculePartIndex = activeMolIndex1();
		//state.numberofMoleculeParts = this.numberofMoleculeParts();
		
		
		// we have two options:
		// return null: do not save an empty state
		// or save the empty save
		
		if(true) {
			while(moleculePartsList.isReallyEmpty() && moleculePartsList.size() > 1) {
				moleculePartsList.remove(0);
			}
		} else {
			if(moleculePartsList.isReallyEmpty()) {
				return null;
			}
		}
		
		
		
		SavedState state = new SavedState();
		state.moleculePartsList = this.moleculePartsList.deepCopy();
		//FIXME: some code call createState() before cleanup of the valence!!!! e.g. mouseDown
		//most don't so instead of adding mol.cleanAfterChanged() everywhere ...
		//state.moleculeParts.get(i).cleanAfterChanged();

//		for(int i=1; i < JME.maxParts; i++) {
//			JMEmol part = this.moleculeParts.get(i);
//			if(part != null) {
//				if(part.natoms > 0) {
//					mustBeSaved = true;
//				}
//				state.moleculeParts.get(i) = part.deepCopy();
//			} else {
//				break;
//			}
//		}

		state.reaction = this.reaction;
		state.multipart = this.multipart;

		state.depictScale = this.molecularAreaScale;
		state.lastAction = this.lastAction;

		
		
//		if(mustBeSaved) {
//			return state;
//		} else {
//			return null;
//		}
		
		return state;
	}

	protected void retoreState(SavedState state) {
		basicRetoreState(state);

		// Notifify the JavaScript world that my structure has changed
		switch (state.lastAction) {
		case LA_MOVE:
		case LA_ROTATE:
		case LA_FAILED:
			break;
		default:
			this.notifyStructuralChangeToJS();
		}

	}

	protected void basicRetoreState(SavedState state) {
		
		// BUG: this should not happen!!!
		if(state == null) {
			// go back to the first state that is null/empty?
			//TODO: simplify
			do {
				this.clear(false);
			}while(!this.moleculePartsList.isReallyEmpty());
			
			return;
		}
		//this.actualMoleculePartIndex = state.actualMoleculePartIndex;
		//this.numberofMoleculeParts = state.numberofMoleculeParts;

		moleculePartsList = state.moleculePartsList.deepCopy();
		
		/*
		for(int i=1; i < JME.maxParts; i++) {
			JMEmol part = state.moleculeParts.get(i);
			if(part != null) {
				this.moleculeParts.get(i) = part.deepCopy();
			} else {
				this.moleculeParts.get(i) = null;
			}
		}
		*/
		//issue: this can create a null mol
		if (state.activeMol != null) {
			this.activeMol = state.activeMol;
		} else {
			this.activeMol = new JMEmol(this, this.moleculeHandlingParameters); //avoid a null pointer, for state saved after a clear or reset
		}

		this.reaction = state.reaction;
		this.multipart = state.multipart;

		this.molecularAreaScale = state.depictScale;
	}

	public JPopupMenu getCopyPasteJPopupMenuMol() {
		// if(this.copyPasteJPopupMenuMol == null) {
		this.copyPasteJPopupMenuMol = this.createCopyPasteJPopupMenu(false);
		// }
		return copyPasteJPopupMenuMol;
	}

	public JPopupMenu getCopyPasteJPopupMenuReaction() {
		// if(this.copyPasteJPopupMenuReaction == null) {
		this.copyPasteJPopupMenuReaction = this.createCopyPasteJPopupMenu(true);
		// }
		return copyPasteJPopupMenuReaction;
	}

	// return true if event has been used
	public boolean handleCopyPasteJPopupMenu(MouseEvent e, int x, int y) {

		// detect mol and atom under the cursor: needed for tablet?

		if (e == null || this.isEventContextMenu(e)) {

			// Tablet: needed for touch screen because they cannot detect a mouse move
			// Does not work: the delay for the context menu is too long and is needed
//			if(isTouchSupported) {
//				findMolAndAtomOrBondInDrawingArea(x, y, newTouchedMol);
//				if(newTouchedMol.molIndex > 0) {
//					mol = this.moleculeParts[newTouchedMol.molIndex];
//					mol.touchedAtom = newTouchedMol.atomIndex;
//					mol.touchedBond = newTouchedMol.bondIndex;
//					
//				}
//
//			}
			boolean isTouched = activeMol.touchedAtom > 0 || activeMol.touchedBond > 0;
			if (isTouched && (action == ACTION_DELETE || action == ACTION_DELGROUP)) {
				return true; // true: do not use the context menu to delete atom or bond
			}
//			this.info("isTouched = " + isTouched);
//			repaint();

			if (isTouched && !isDepict()) {
				// set shiral flag to the mol
				if (this.touchedMolPopuMenu != null) {
					this.remove(this.touchedMolPopuMenu);

				}
				touchedMolPopuMenu = this.createMolJPopupMenu(activeMol, x, y);
				this.add(touchedMolPopuMenu); // set the parent the popup
				touchedMolPopuMenu.show(this, x, y);
			} else {

				{
					JPopupMenu pm;
					if (reaction) {
						pm = this.getCopyPasteJPopupMenuReaction();
					} else {
						pm = this.getCopyPasteJPopupMenuMol();
					}
					if (this.isEventContextMenu(e)) {
						pm.show(this, x, y);
					} else { // click performed on the menu
						this.showJPopupMenuRealtiveToScaledMainMenu(pm, x, y);
					}

				}

			}

			// the atom or bond highlight must disappear =-to be improved
			Event ne = new Event(null, 0, 0);
			this.mouseMove(ne, 1000000, 100000); // large number to be sure that no mouse over menu action would be detected

			return true;
		}
		return false;

	}

	/*
	 * Show the JPopupMenu at the given coordinate relative to the GUI menu The GUI
	 * menu might have been scaled up or down, thus the x,y coordinates must be
	 * changed accordingly
	 */
	protected void showJPopupMenuRealtiveToScaledMainMenu(JPopupMenu pm, int x, int y) {
		pm.show(this, (int) (x * this.menuScale + 0.5), (int) (y * this.menuScale + 0.5));

	}

	public boolean isEventContextMenu(MouseEvent e) {
		if (e == null)
			return false;

		boolean meta = e.isMetaDown(); // true if right mouse click
		boolean ctrl = e.isControlDown(); // Safari Mac

		return meta || ctrl;

	}

	public JPopupMenu getFunctionalGroupPopumemu() {
		if (this.functionalGroupPopumemu == null) {
			this.functionalGroupPopumemu = this.createFunctionalGroupPopumemu();
		}
		return this.functionalGroupPopumemu;
	}

	public JPopupMenu createFunctionalGroupPopumemu() {

		JPopupMenu popup = new JPopupMenu();

		for (String eachFG : functionalGroups) {
			JMenuItem mi = new JMenuItem(eachFG);
			popup.add(mi);
			mi.setActionCommand(eachFG);
			mi.addActionListener(this);
		}
		// setSubstituent(r);

		this.add(popup); // set the parent the popup

		return popup;
	}

	public JPopupMenu createFBackgroundColorPopumemu() {

		JPopupMenu popup = new JPopupMenu();

		for (int i = 1; i < this.colorManager.psColor.length; i++) {
			ColorInfo ci = this.colorManager.getColorInfo(i);
			Color color = ci.color;
			String label = ci.name;
			String colorrHash = ci.hash;;
			JMenuItem mi = new JMenuItem(label + "\t" + this.colorManager.makeHexColor(color)); // JSapplet awt JMenuItem will create SVG with color circle
			popup.add(mi);
			mi.setActionCommand(colorrHash);
			mi.addActionListener(this);

		}
		// setSubstituent(r);

		this.add(popup); // set the parent the popup

		return popup;
	}

	/*
	 * Provide the ideal height of a string consisting of usual upper case
	 * characters. Purpose: centering of String in the center of a box. Does not
	 * work for $ , y ; and others
	 */
	public double stringHeight(FontMetrics fm) {
		return fm.getAscent() - fm.getDescent();
		// return fm.getAscent();
	}

	// public int stringHeight(FontMetrics fm, String text) {
	// int h = stringHeight(fm);
	// //Correction for a string that is only lower case - NO working : i is as high
	// as a L
	// if(text.equals(text.toLowerCase()) ) {
	// h = h *2 /3;
	// }
	// return h;
	// }

	/**
	 * 
	 * @return the notifyAtomHighLightJSfunction
	 */
	public String getNotifyAtomHighLightJSfunction() {
		return this.notifyAtomHighLightJSfunction;
	}

	/**
	 * Set the name of the JavaScript function that will be called each time the
	 * mouse move over an atom. To cancel, set to null.
	 * 
	 * @param notifyAtomHighLightJSfunction
	 */
	public void setNotifyAtomHighLightChangeJSfunction(String notifyAtomHighLightJSfunction) {
		this.notifyAtomHighLightJSfunction = notifyAtomHighLightJSfunction;
	}

	/**
	 * Notify the JavaScript envirronement that the mouse over atom has changed
	 * 
	 * @param touchedAtom
	 */
	protected int previousTouchedAtomForHighlight = 0;
	protected int previousTouchedBondForHighlight = 0;
	protected int previousActualMoleculePartIndex = 0;

	/**
	 * return -1 if no action should be taken or the touchedAtomOrBond, which might
	 * have been set to 0 in case the curssor has moved away from the atom or bond
	 * 
	 * @param touchedAtomOrBond
	 * @param previousTouchedAtomOrBondForHighlight
	 * @return
	 */
	public int notifyAtomOrBondHighLightJSfunction(int touchedAtomOrBond, int previousTouchedAtomOrBondForHighlight) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		// send an event only if it is about a new atom
		// otherwise each small mouse move will send an event

		// case 1: cursor moved away from atom previous atom is not defined -> do
		// nothing
		if (touchedAtomOrBond <= 0 && previousTouchedAtomOrBondForHighlight == 0) {
			// System.out.println("case 1");
			return -1;
		}

		// case 2: cursor moved around the same atom -> do nothing
		if (touchedAtomOrBond == previousTouchedAtomOrBondForHighlight
				&& this.activeMolIndex() == previousActualMoleculePartIndex) {
			// System.out.println("case 2");

			return -1;
		}

		// case 3: cursor moved away from the atom that was highlighted - send 0 to the
		// callback function
		// to notify that the atom has been deselected
		if (touchedAtomOrBond <= 0 && previousTouchedAtomOrBondForHighlight > 0) {
			// System.out.println("case 3");
			touchedAtomOrBond = 0;
		}

		this.previousActualMoleculePartIndex = this.activeMolIndex();
		return touchedAtomOrBond;

	}

	// TODO
	// potentila bug? this.previousTouchedAtomForHighlight does not depend on the
	// molecular part????
	public void notifyAtomHighLightJSfunction(int touchedAtom) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		if (this.canHandleAtomHighLightCallBack()) {
			touchedAtom = this.notifyAtomOrBondHighLightJSfunction(touchedAtom, this.previousTouchedAtomForHighlight);
			if (touchedAtom == -1)
				return;

			this.previousTouchedAtomForHighlight = touchedAtom;
			// do the function call - will work in a real Java applet
			if (this.notifyAtomHighLightJSfunction != null) {
				JSObject jsObject = JSObject.getWindow(this);
				jsObject.call(this.notifyAtomHighLightJSfunction,
						new Integer[] { new Integer(this.activeMolIndex()), new Integer(touchedAtom) });
			}
			// this is for the new callback mechanism - June 2015
			handleAtomHighLightCallBack(this.activeMolIndex(), touchedAtom);

		}
	}

	public void notifyBondHighLightJSfunction(int touchedBond) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		if (this.canHandleBondHighLightCallBack()) {
			touchedBond = this.notifyAtomOrBondHighLightJSfunction(touchedBond, this.previousTouchedBondForHighlight);
			if (touchedBond == -1)
				return;
			this.previousTouchedBondForHighlight = touchedBond;

			// this is for the new callback mechanism - June 2015
			handleBondHighLightCallBack(this.activeMolIndex(), touchedBond);

		}
	}

	public Boolean canHandleAtomHighLightCallBack() {
		return this.notifyAtomHighLightJSfunction != null;
	}

	public Boolean canHandleBondHighLightCallBack() {
		return false;
	}

	public Boolean canHandleAtomClickedCallBack() {
		return false;
	}

	public Boolean canHandleBondClickedCallBack() {
		return false;
	}

	/**
	 */
	public void handleAtomClickedCallBack(int actualMoleculePartIndex, int clickedAtom) {
		/* do nothing */

	}

	public void handleBondClickedCallBack(int actualMoleculePartIndex, int clickedBond) {
		/* do nothing */

	}

	/**
	 * For subclasses
	 * 
	 * @param actualMoleculePartIndex2
	 * @param touchedAtom
	 */
	public void handleAtomHighLightCallBack(int actualMoleculePartIndex, int touchedAtom) {
		/* do nothing */

	}

	/**
	 * For subclasses
	 * 
	 * @param actualMoleculePartIndex2
	 * @param touchedBond
	 */
	public void handleBondHighLightCallBack(int actualMoleculePartIndex, int touchedBond) {
		/* do nothing */

	}

	/**
	 * Highlight atom like a mouse over. If the atom index is 0, then remove any
	 * atom highlight. If molIndex is zero, that means that the atom index is an
	 * ensemble index
	 * 
	 * @param molIndex  (first index is 1, not 0)
	 * @param atomIndex (first index is 1, not 0)
	 */
	public void setAtomToHighLight(int molIndex, int atomIndex) {

		//JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

		this.moleculePartsList.resetTouchedAtomAndBond();
//		for (int i = 1; i <= this.numberofMoleculeParts; i++) {
//			this.moleculeParts[i].touchedAtom = 0;
//			this.moleculeParts[i].touchedBond = 0;
//		}

		if (atomIndex != 0) {
			// 0 means reset highlight

			JMEmolList.EnsembleAtom ea = this.getEnsembleAtom(molIndex, atomIndex);

			if (ea == null) {
				this.showError("invalid atom index or molecule index");
				return;
			}
			ea.mol.touchedAtom = ea.atomIndex;
		}
		this.redrawMolecularAreaOnly();

	}

	/**
	 * Highlight bond like a mouse over. If the bond index is 0, then remove any
	 * bond highlight. If molIndex is zero, that means that the bond index is an
	 * ensemble index
	 * 
	 * @param molIndex  (first index is 1, not 0)
	 * @param bondIndex (first index is 1, not 0)
	 */
	public void setBondToHighLight(int molIndex, int bondIndex) {
		
		//JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);
		
		this.moleculePartsList.resetTouchedAtomAndBond();

		// 0 means reset highlight
		if (bondIndex != 0) {
			

			JMEmolList.EnsembleBond ea = this.getEnsembleBond(molIndex, bondIndex);

			if (ea == null) {
				this.showError("invalid bond index or molecule index");
				return;
			}
			ea.mol.touchedBond = ea.bondIndex;
		}
		this.redrawMolecularAreaOnly();

	}

	public void changeAtomMap(int molIndex, int atomIndex, int newMap) {
		JMEmol mol = this.selectMolIfValidOrShowError(molIndex);
		changeAtomMap(mol, atomIndex, newMap);
		

	}

	
	public void changeAtomMap(JMEmol mol, int atomIndex, int newMap) {
		Atom at  = mol.getAtom(atomIndex);
		if (newMap <= 0) {
			at.resetObjectMark();//Nov 2020 bug fix: set atom ap to 0 reset it
		} else {
			at.setMapOrMark(newMap, ! this.moleculeHandlingParameters.mark); //Nov 2020 bug fix: !
		}
		this.recordAtomEvent(JME.CHANGE_ATOM_MAP, atomIndex);
		// this.setAtomToHighLight(molIndex, atomIndex);
		this.redrawMolecularAreaOnly();

	}

	public void changeAtomCharge(JMEmol mol, int atomIndex, int newCharge) {
		Atom at  = mol.getAtom(atomIndex);
		at.Q(newCharge);
		
		this.recordAtomEvent(JME.CHARGE_ATOM0, atomIndex);
		// this.setAtomToHighLight(molIndex, atomIndex);
		this.redrawMolecularAreaOnly();

	}

	/**
	 * @return the notifyStructuralChangeJSfunction
	 */
	public String getNotifyStructuralChangeJSfunction() {
		return notifyStructuralChangeJSfunction;
	}

	/**
	 * @param notifyStructuralChangeJSfunction the notifyStructuralChangeJSfunction
	 *                                         to set
	 */
	public void setNotifyStructuralChangeJSfunction(String notifyStructuralChangeJSfunction) {
		this.notifyStructuralChangeJSfunction = notifyStructuralChangeJSfunction;
	}

	/**
	 * Notify the JavaScript envirronement that the chemical structure has changed
	 */
	public void notifyStructuralChangeToJS() {
		
		// the 2nd implementation for JSME that uses event
		if (this.afterStructureChangeEvent != null && this.afterStructureChangeEvent.action != null) {
			if (this.afterStructureChangeEvent.stackLevel == 0) {
				this.afterStructureChangeEvent.stackLevel++; 		// avoid infinite loop

				this.handleAftertructureModifiedEvent();
			} else {
				this.afterStructureChangeEvent.reset();
				return;
			}
		}

		
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		if (this.notifyStructuralChangeJSfunction != null) {
			JSObject jsObject = JSObject.getWindow(this);
			jsObject.call(this.notifyStructuralChangeJSfunction, null);
		}

	}

	public String getPrePasteJSfunction() {
		return prePasteJSfunction;
	}

	/**
	 * Set a JS function that will be called before the paste is performed. THis
	 * function will receive one argument: a string that a represent a molecular
	 * structure. The return value of the fuinction is a string. Purpose: convert a
	 * name or a SMILES or an InchI into a MOL.
	 * 
	 * @param prePasteJSfunction
	 */
	public void setPrePasteJSfunction(String prePasteJSfunction) {
		this.prePasteJSfunction = prePasteJSfunction;
	}

	/**
	 * 
	 * @return the height in pixel of the top menu
	 */
	int topMenuHeight() {
		return (int) Math.round(topMenuHeight(this.menuScale));
	}

	/**
	 * 
	 * @return the height in pixel of the top menu
	 */
	double topMenuHeight(double scale) {
		return this.isDepict() ? 0.0 : (menuCellSize * 2 + menuCellBorder()) * scale;
	}

	/**
	 * 
	 * @return the width in pixel of the top menu
	 */
	int leftMenuWidth() {
		return (int) Math.round(leftMenuWidth(this.menuScale));
	}

	/**
	 * 
	 * @return the scaled width in pixel of the left menu
	 */
	double leftMenuWidth(double scale) {

		return this.isDepict() ? 0.0 : (menuCellSize * 1 + menuCellBorder()) * scale;
	}

	/**
	 * 
	 * @return the height in pixel of the bottom bar (info bar) = 0 in depict mode
	 */
	public int infoAreaHeight() {
		return (int) Math.round(infoAreaHeight(this.menuScale));
	}

	public double infoAreaHeight(double scale) {
		return this.isDepict() ? 0.0 : menuCellSize * scale;
	}

	/**
	 * the right border differs in new and old look
	 * 
	 * @return
	 */
	int rightBorder() {
		return (int) Math.round(rightBorder(this.menuScale)); // the width of the line on the right of the molecular
																// area in edit mode
	}

	double rightBorder(double scale) {
		return this.isDepict() ? 0.0 : (newLook ? rightBorderNewLook : rightBorderOldLook) * scale; // the width of the
																									// line on the right
																									// of the molecular
																									// area in edit mode
	}

	/*
	 * 
	 * @return the height in pixel of the bottom bar (info bar) > 0 also in depict
	 * mode
	 */
	public int getDefaultInfoBarHeight() {
		return (int) this.standardMenuCellSize;
	}

	public void redrawMolecularAreaOnly() {
		this.mustRedrawNothing();
		this.setMustRedrawMolecularArea(true);
		this.repaint();

	}

	boolean setMustRedrawMolecularArea(boolean b) {
		return true;
//		return (mustReDrawMolecularArea = b);
		
	}

	public void redrawMolecularAreaOnylForGettingSVG() {
		int savedTouchedAtom = this.activeMol.touchedAtom;
		int savedTouchedBond = this.activeMol.touchedBond;

		// hide the touched atom or bond
		this.activeMol.touchedAtom = 0;
		this.activeMol.touchedBond = 0;
		this.afterStructureChangeEvent.reset(); // oct 2016: avoid an infinite loop when
												// redrawMoleculartAreaOnlForGettingSVG is called within js notification
												// of a structure change

		this.redrawMolecularAreaOnly();

		this.activeMol.touchedAtom = savedTouchedAtom;
		this.activeMol.touchedBond = savedTouchedBond;
	}

	/**
	 * if mol index is 0, than set the colors for all molecules
	 * 
	 * @param molIndex 1 based
	 * @param atomAndColorCSV : at,c,at,c,at,c, ... at: atom index; c: color index
	 */
	public void setAtomColors(int molIndex, String atomAndColorCSV) {

		// TODO Use EnsembleAtom
		// if the mol index has not been specified - then assume that the atom indices
		// are valid for the whole ensemble
		if (molIndex == 0) {

			int cumulAtomCount = 0;
			for (int i = 1; i <= moleculePartsList.size(); i++) {
				JMEmol mol = this.selectMolIfValidOrShowError(i);
				mol.setAtomColors(atomAndColorCSV, cumulAtomCount);
				cumulAtomCount += mol.nAtoms();
			}

		} else {
			// select the molecule to color
			JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

			if (molToHighLight == null) {
				return;
			}

			// color its atoms according to the parameters
			molToHighLight.setAtomColors(atomAndColorCSV, 0);
		}

		// repaint
		this.redrawMolecularAreaOnly();
	}

	/**
	 * Get ensemble information about the atom index. If molIndex is zero. then
	 * atomIndex is an ensemble index
	 * 
	 * @param molIndex - 0 based
	 * @param atomIndex
	 * @return
	 */
	public JMEmolList.EnsembleAtom getEnsembleAtom(int molIndex, int atomIndex) {

		if (molIndex < 0 || atomIndex < 0) {
			GWT.log("Invalid index for getEnsembleAtom()");
			return null;
		}

		return new JMEmolList.EnsembleAtom(this.moleculePartsList,  molIndex, atomIndex);

	}

	/**
	 * 
	 * @param molIndex - 0 based
	 * @return
	 */
	public JMEmol getMolecule(int molIndex) {
		if (molIndex < 0 || molIndex >= this.moleculePartsList.size()) {
			GWT.log("Invalid index for getMolecule()");
			return null;
		}
		
		return this.moleculePartsList.get(molIndex);

	}
	
	int lastValidColorIndex = 1; //TODO: use the default color
	/**
	 * Choose the background color to be used for the atom or bond. The marker symbol will get this color as well.
	 * The index is the index of the color of current color palette.
	 * @param colorIndex (first value is 1)
	 */
	public void activateMarkerColor(int colorIndex) {
		//this.moleculeHandlingParameters.mark = true;
		
		if (colorIndex < 1 || colorIndex > this.colorManager.numberOfBackgroundColors()) {
			this.alert("Invalid color index: " + colorIndex);
			resetExtendAtomMark = true; // June 2020: do not accumulate large numbers with keyboard input (see updateMark() )
			markFromKeyboardInput = false;
			this.activeMarkerColorIndex = lastValidColorIndex;
			this.clearInfo();
			this.repaint();
		} else {
			lastValidColorIndex = this.activeMarkerColorIndex = colorIndex;
			this.setAction(105);
			this.options("marker");

			this.mustReDrawTopMenu = true; //the marker symbol is in the top menu
			this.repaint();
		}
	}

	public void setStarColor(String hexColor) {
		this.alert("methods setStarColor and setMarkerColor have been replaced by activateMarkerColor");
		
	}


	
	/**
	 * Get the Atom object using an ensemble based index
	 * 
	 * @param atomE
	 * @return
	 */
	public Atom getAtomE(int atomE) {
		return this.getEnsembleAtom(0, atomE).atom;
	}

	public int totalNumberOfAtoms() {
		
		return this.moleculePartsList.totalNumberOfAtoms();
//		int cumulAtomCount = 0;
//		for (int i = 1; i <= numberofMoleculeParts; i++) {
//			JMEmol mol = this.selectMolIfValidOrShowError(i);
//			cumulAtomCount += mol.nAtoms();
//		}
//
//		return cumulAtomCount;
	}

	/**
	 * Just replace. Assume that the new Atom is the same with some extra data
	 * field. No further checking
	 * 
	 * @param oldAtom
	 * @param newAtom
	 */
	public void replaceAtom(AtomBondCommon oldAtom, Atom newAtom) {
		for (int i = 1; i <= moleculePartsList.size(); i++) {
			JMEmol mol = this.selectMolIfValidOrShowError(i);
			for (int at = 0; at < mol.atoms.length; at++) {
				if (mol.atoms[at] == oldAtom) {
					mol.atoms[at] = newAtom;
					return;
				}
			}
		}
	}

	/**
	 * Reset background atom colors
	 * 
	 * @param molIndex
	 */
	public void resetAtomColors(int molIndex) {

		if (molIndex == 0) { // new May 2018
			//this.atomColors = "";

			
			for (int i = 1; i <= moleculePartsList.size(); i++) {
				this.resetAtomColors(i);
			}

			return;
		} else {

			// select the molecule to decolor
			JMEmol selectedMol = this.selectMolIfValidOrShowError(molIndex);

			if (selectedMol == null) {
				return;
			}

			//
			selectedMol.resetChemicalObjectColors(selectedMol.atoms);
		}

		// repaint
		this.redrawMolecularAreaOnly();

		// clear the atom colors from the option

	}

	/**
	 * Reset background atom colors
	 * 
	 * @param molIndex
	 */
	public void resetBondColors(int molIndex) {

		if (molIndex == 0) { // new Sepetmber 2019
			this.atomBgColors = "";

			for (int i = 1; i <= moleculePartsList.size(); i++) {
				this.resetBondColors(i);
			}

			return;
		} else {

			// select the molecule to decolor
			JMEmol selectedMol = this.selectMolIfValidOrShowError(molIndex);

			if (selectedMol == null) {
				return;
			}

			//
			selectedMol.resetChemicalObjectColors(selectedMol.bonds);
		}

		// repaint
		this.redrawMolecularAreaOnly();

		// clear the atom colors from the option

	}

	public int totalNumberOfBonds() {
//		int cumulBOndCount = 0;
//		for (int i = 1; i <= numberofMoleculeParts; i++) {
//			JMEmol mol = this.selectMolIfValidOrShowError(i);
//			cumulBOndCount += mol.nBonds();
//		}
//
//		return cumulBOndCount;
		
		return this.moleculePartsList.totalNumberOfBonds();
	}

	/**
	 * Get ensemble information about the atom index. If molIndex is zero. then
	 * atomIndex is an ensemble index
	 * 
	 * @param molIndex - 0 based
	 * @param bondIndex - 1 based
	 * @return
	 */
	public JMEmolList.EnsembleBond getEnsembleBond(int molIndex, int bondIndex) {

		if (molIndex < 0 || bondIndex < 0) {
			GWT.log("Invalid index for getEnsembleBond()");
			return null;
		}


		return new JMEmolList.EnsembleBond(this.moleculePartsList, molIndex, bondIndex);

	}

	/**
	 * Get the Atom object using an ensemble based index
	 * 
	 * @param bondE
	 * @return
	 */
	public Bond getBondE(int bondE) {
		return this.getEnsembleBond(0, bondE).bond;
	}

	/**
	 * Just replace. Assume that the new Bond is the same with some extra data
	 * field. No further checking
	 * 
	 * @param oldBond
	 * @param newBond
	 */
	public void replaceBond(AtomBondCommon oldBond, Bond newBond) {
		for (JMEmol mol :  moleculePartsList) {
			for (int b = 0; b < mol.bonds.length; b++) {
				if (mol.bonds[b] == oldBond) {
					mol.bonds[b] = newBond;
					return;
				}
			}
		}
	}

	// molIndex is based 1
	public void setBondColors(int molIndex, String bondAndColorCSV) {

		// if the mol index has not been specified - then assume that the aom indices
		// ave valid for the whole ensemble
		if (molIndex == 0) {

			int cumulBondCount = 0;
			for (JMEmol mol :  moleculePartsList) {
				mol.setBondColors(bondAndColorCSV,  cumulBondCount);
				cumulBondCount += mol.nBonds();
			}

		} else {
			// select the molecule to color
			JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

			if (molToHighLight == null) {
				return;
			}

			// color its atoms according to the parameters
			molToHighLight.setBondColors(bondAndColorCSV, 0);
		}

		// repaint
		this.redrawMolecularAreaOnly();
	}

	/**
	 * JME accepts a SDF with multiple records. This method returns the list of the
	 * SDF records that were input
	 * 
	 * @return a string array, which could be empty
	 */
	public String[] getMultiSDFstack() {
		return this.sdfStack.getMultiSDFstack();
	}

	/**
	 * Return an array of RGB (0-255) values
	 * 
	 * @return int[n][3]
	 */
//	@Deprecated
//	public int[][] getDefaultBackGroundColorPalette() {
//		return this.colorManager.getBackGroundColorPalette();
//		
//	}

	/**
	 * Return the selected mol. If the index is not valid, show an error
	 * 
	 * @param molIndex - 1 based
	 * @return JMEmol
	 */
	protected JMEmol selectMolIfValidOrShowError(int molIndex) {
		this.clearInfo(); // clear the info in case an error would occur
		if (molIndex < 1 || molIndex > this.moleculePartsList.size()) {
			this.showError("invalid mol index: " + molIndex);
			return null;
		}

		return this.moleculePartsList.get(molIndex - 1);

	}

	/**
	 * 
	 * @param action
	 * @param moleculePartIndex
	 * @param atomIndex
	 * @param bondIndex
	 */
	protected void recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex,
			int bondIndex) {

		this.recordAfterStructureChangedEvent(action, moleculePartIndex, atomIndex, bondIndex, true);

	}

	/**
	 * 
	 * @param action
	 * @param moleculePartIndex
	 * @param atomIndex
	 * @param bondIndex
	 */
	protected void recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex, int bondIndex,
			boolean willSaveOnUndoStack) {

		if (this.afterStructureChangeEvent != null) {
			this.updateReactionRoles(); //will do nothing if not reaction mode
			this.afterStructureChangeEvent.setAction(action).setAtomAndBondAndMol(moleculePartsList,
					atomIndex, bondIndex, moleculePartIndex);
		}
		// this.notifyStructuralChangeToJS();
		
		// for the undo/redo manager
		this.willPostSave(willSaveOnUndoStack); // happens after redraw?

	}

	protected void recordMoleculePartEvent(String action, int moleculePartIndex) {
		this.recordAfterStructureChangedEvent(action, moleculePartIndex, 0, 0);

	}

	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * 
	 * @param action
	 */
	protected void recordAtomEvent(String action) {
		this.recordAtomEvent(action, this.activeMol.touchedAtom);

	}

//	protected void recordAtomEventAndPostSave(String action) {
//		this.recordAtomEvent(action, this.mol.touchedAtom);
//		this.postSave();
//
//	}
	protected void recordAtomEvent(String action, int atom) {
		this.recordAfterStructureChangedEvent(action, this.activeMolIndex(), atom, 0);

	}

	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * 
	 * @param action
	 */
	protected void recordBondEvent(String action) {
		this.recordAfterStructureChangedEvent(action, this.activeMolIndex(), 0, this.activeMol.touchedBond);

	}

	protected void recordAfterStructureChangedEvent(String action) {
		this.recordAfterStructureChangedEvent(action, 0, 0, 0);

	}

	protected void handleAftertructureModifiedEvent() {
		// clear the event after it has been used
		// (afterStructureChangeEvent != null)
		// fterStructureChangeEvent.reset(); //not needed anymore because of using
		// recordAfterStructureChangedEvent(String action, int moleculePartIndex, int
		// atomIndex, int bondIndex)

		// subclass do something more

		System.out.println("Structure modified event: " + afterStructureChangeEvent.getAction());
		//updateReactionParts(); //June 2017
		updateReactionRoles();
	}

	/**
	 * 
	 * @return true if the editor is in depict mode
	 */
	public boolean isDepictMode() {
		// alert("isDepictMode: "+ this.depict);
		return this.isDepict();
	}

	/**
	 * @return the depict
	 */
	public boolean isDepict() {
		return depict;
	}

	/**
	 * @param depict the depict to set
	 */
	public void setDepict(boolean depict) {
		this.depict = depict;
	}
	
	public boolean isEmpty() {
		return this.moleculePartsList.isReallyEmpty();
	}
	

	public static void main(String args[]) {
		isStandAloneApplication = true;
		JME jme = new JME();
		JFrame frame = new JFrame("JME Molecular Editor");
		jme.setFrame(frame);
		// frame.resize(24*18,24*16); // urcuje dimensions pre aplikaciu
		frame.setBounds(300, 200, 24 * 18, 24 * 16); // urcuje dimensions pre
		frame.add("Center", jme);
		// aplikaciu
		jme.initialize();
		if (args.length == 1)
			jme.options(args[0]);
		frame.setVisible(true);
		// po frame.show, aby boli zname dimension
		jme.start();

		// reads molecule (from 2008.12)
		String fileName = null;
		for (int i = 0; i < args.length; i++) {
			if (args[i].startsWith("-f")) {
				fileName = args[++i];
			} else if (args[i].startsWith("-o")) {
				jme.options(args[++i]);
			}
		}
		/*
		 * if (fileName != null) { jme.dimension = jme.size(); jme.readFile(fileName); }
		 */

		// BB
		// Add a window listener JDK 1.1 for closing the window using the X button of
		// the window
		// Note: BB removed the END button
		frame.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent evt) {
				System.exit(0);
			}
		});

		// works
		// frame.addMouseWheelListener(jme);

	}

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		String name = evt.getPropertyName();
		try {
			if (name == FileDropper.PROPERTY_FILEDROPPER_FILE) {
				readDroppedTextFile((String) evt.getNewValue());
			} else if (name == FileDropper.PROPERTY_FILEDROPPER_INLINE) {
				readDroppedData(evt.getNewValue());
			}
		} catch (Throwable t) {
			System.err.println("JME couldn't load data for drop " + name);
		}
	}

	private void readDroppedData(Object newValue) {
		String data = newValue.toString().trim();
		try {
			if (data.indexOf("\n") >= 0)
				readMolFile(data);			
			else if (data.indexOf(" ") >= 0)
				readMolecule(data);
			else
				readSmiles(data);
		} catch (Exception e) {
			System.err.println("JME error reading data starting with " + data.substring(Math.min(data.length(), 100)));
		}
	}

	private void readSmiles(String data) {
		try {
			readMolFile(newParser().SMILEStoMOL(data));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void readDroppedTextFile(String fileName) {
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(fileName);
			byte[] bytes = new byte[0x100];
			int n;
			while ((n = fis.read(bytes)) > 0) {
				bos.write(bytes, 0, n);
			}
			fis.close();			
		} catch (Exception e) {
			System.err.println("JME error reading file " + fileName);
		}
		readDroppedData(new String(bos.toByteArray())); 
	}

} // End of JME class

// Options:

//		addNewPart
//		atommovebutton
//		autoez
//		border
//		canonize
//		contextMenu
//		depictaction
//		exportInchi
//		exportInchiAuxInfo
//		exportInchiKey
//		exportRXNmerge
//		exportSVG
//		fgmenu
//		fullScreenIcon
//		hydrogens
//		markAtomOnly
//		markBondOnly
//		markerMenu
//		markNothing
//		multipart
//		newlook
//		oldlook
//		paste
//		polarnitro
//		pseudoMark
//		query
//		rbutton
//		reaction
//		searchInchiKey
//		showDragAndDropIconInDepictMode
//		showDragAndDropSymbolInDepictMode
//		showFullScreenIconInDepictMode
//		stereo
//		toggle
//		useOclIDCode
//		useopenchemlib
//		valenceState
//		xbutton
//		zoom
//		zoomgui
//		star,
//		star1,
//		autonumber
//		number
//		showAtomMapNumberWithBackgroundColor

