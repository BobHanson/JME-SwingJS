package jme;

// BH 2023.01.25 fixed mouseShift never resetting
// BH 2023.01.25 adds smilesAromatic option (def true)

// BH 2023.01.20:

// - adds headless creation of PNG images
// - adds JmolD.jar (could use JmolData.jar, ufnless one wants to show the Jmol frame).
// - JME constructor clean-up and expansion
// - centralizes options in Options class
// - adds hooks for subclass JmolJME to write CDXML, MOL, and PNG images using a file dialog

// BH 2023.01.15:
// - moved OCL-dependent methods to OclParser implements Parser
//   -- these are generated by reflection, so a subclass could change that 
// - switched to Swing
//   -- changes java.applet.Applet (deprecated) to JPanel, so JFrame required (but in SwingJS this can be embedded in a div)
//   -- changes Button to JButton, Choice to JComboBox, etc.
//   -- no bypassing simple paints -- just paint everything, since Swing will manage painting itself.
// - corrected missing dimension "2D" in MOL V2000 and V3000 writers.

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;

import javax.swing.JApplet;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;

import jme.ColorManager.ColorInfo;
import jme.JMEmol.ReactionRole;
import jme.core.Atom;
import jme.core.AtomBondCommon;
import jme.core.Bond;
import jme.core.Box;
import jme.core.JMECore;
import jme.core.JMECore.Parameters;
import jme.core.JMECore.Parameters.HydrogenParams;
import jme.event.InspectorEvent;
import jme.event.JMEStatusListener;
import jme.event.JMEevent;
import jme.gui.Actions;
import jme.gui.AlertBox;
import jme.gui.GUI;
import jme.gui.JMEBuilder;
import jme.gui.MultiBox;
import jme.gui.QueryBox;
import jme.io.FileDropper;
import jme.io.JMEReader;
import jme.io.JMEReader.MajorChemicalFormat;
import jme.io.JMEWriter;
import jme.io.SDFstack;
import jme.io.TextTransfer;
import jme.io.TextTransfer.PasteAction;
import jme.js.JSFunction;
import jme.js.JSME_RunAsyncCallback;
import jme.js.RunAsyncCallback;
import jme.js.RunWhenDataReadyCallback;

// ----------------------------------------------------------------------------
// ****************************************************************************
@SuppressWarnings("serial")
public class JME extends JPanel implements ActionListener, MouseWheelListener, MouseListener, KeyListener,
		MouseMotionListener, PropertyChangeListener, DragGestureListener, JMEStatusListener {

	public static final String version = "2023-01-27";
	public final static String helpUrl = "https://jsme-editor.github.io/help.html";
	public final static String websiteUrl = "https://jsme-editor.github.io/";
	public final static String programName; // JSME or JME

	/**
	 * JmolJME will do this to allow a later initialization
	 */
	public static final String NO_INIT = "$NOINIT$";

	public interface HTML5Applet {
		public Object getParameter(String s);
	}

	class Touched {
		JMEmol mol;
		int atomIndex;
		int bondIndex;
		double distance;

		public boolean equals(Touched other) {
			return this.mol == other.mol && this.atomIndex == other.atomIndex && this.bondIndex == other.bondIndex;

		}

		public void reset() {
			mol = null;
			atomIndex = 0;
			bondIndex = 0;
		}

		public void initMyselfWith(Touched other) {
			this.mol = other.mol;
			this.atomIndex = other.atomIndex;
			this.bondIndex = other.bondIndex;

		}

		public boolean isTouched() {
			return this.mol != null && (this.atomIndex > 0 || this.bondIndex > 0);
		}

		@Override
		public String toString() {
			return ("[TOUCH " + atomIndex + " " + bondIndex + "]");
		}
	}

	public final Options options = new Options();

	// customization
	// static final String startInfoText =e "JSME Molecular Editor by Peter Ertl and
	// Bruno Bienfait";
	static final String startInfoText = "Molecular Editor by Peter Ertl and Bruno Bienfait";
	// JSME or JME selected according to the run-time environment
	public static final String copyright[] = {
			"Copyright (c) 2014-2023, Peter Ertl, Bruno Bienfait, and Robert Hanson.", "All rights reserved." };
	// Note: the copyright is too long for the info()

	// used for parsing input
	public static final String NumberParsingErrorMsg = "Number parsing";
	public static final String NotEnoughDataMsgError = "Not enough data";

	protected static String parserImpl = "jme.ocl.OclAdapter";

	public static final String OCL_ID_CODE_LABEL = "OCL ID code" /* + " to the clipboard" */;
	public static final String UN_MARK_ATOM = "unMarkAtom";
	public static final String MARK_ATOM = "markAtom";
	public static final String ADD_ATOM_QUERY = "addAtomQuery";
	public static final String CHARGE_ATOM_MINUS = "chargeAtom-";
	public static final String CHARGE_ATOM_PLUS = "chargeAtom+";
	public static final String CHARGE_ATOM0 = "chargeAtom0";
	public static final String DEL_ATOM2 = "delAtom";
	public static final String SET_ATOM = "setAtom";
	public static final String DEL_BOND2 = "delBond";
	public static final String DEL_ATOM = DEL_ATOM2;
//	public static final String MARK = "mark";
	public static final String AUTO_NUMBER = "autonumber";
	public static final String SD_FSTACK = "SDFstack";
	public static final String REDO = "redo";
	public static final String UNDO = "undo";
	public static final String READ_MOL_FILE = "readMolFile";
	public static final String READ_RXN_FILE = "readRXNFile";
	public static final String READ_JME = "readJME";
	public static final String READ_SMILES = "readSMILES";
	public static final String READ_SMIRKS = "readSMIRKS";
	public static final String READ_OCLCODE = "readOCLCode";
	public static final String READ_MULTI_SDF = "readMultiSDF";

	public static final String CLEAR = "clear";
	public static final String RESET = "reset";

	/* for recording events to external program */
	public static final String ADD_GROUP = "addGroup";
	public static final String ADD_TEMPLATE = "addTemplate";
	public static final String ADD_ATOM = "addAtom";
	public static final String ADD_RING = "addRing";
	public static final String ADD_BOND = "addBond";
	public static final String ADD_CHAIN = "addChain";
	public static final String UN_MARK_BOND = "unMarkBond";
	public static final String MARK_BOND = "markBond";
	public static final String SET_QUERY_BOND = "setQueryBond";
	public static final String ADD_RING_BOND = "addRingBond";
	public static final String SET_BOND_TRIPLE = "setBondTriple";
	public static final String SET_BOND_SINGLE = "setBondSingle";
	public static final String SET_BOND_COORDINATION = "setBondCoordination";
	public static final String UNSET_BOND_COORDINATION = "unSetBondCoordination";
	public static final String SET_BOND_DOUBLE = "setBondDouble";
	public static final String SET_BOND_STEREO = "setBondStereo";
	public static final String DEL_BOND_GROUP = "delBondGroup";
	public static final String DEL_BOND = DEL_BOND2;

	public static final String MOVE_ATOM = "moveAtom";
	public static final String CHANGE_CHIRAL = "changeChiral";
	public static final String CHANGE_ATOM_MAP = "changeAtomMap";
	public static final String CHANGE_MANY_ATOM_MAP = "changeManyAtomMap";
	public static final String DELETE_HYDROGENS = "deleteHydrogens";
	public static final String COMPUTE_2D = "compute2D";
	public static final String DELETE_ATOM_MAPS = "deleteAtomMaps";

	public static final String SET_ATOM_ADDITIONAL_DATA = "setAtomAdditionalData";
	public static final String SET_BOND_ADDITIONAL_DATA = "setBondAdditionalData";

	public static final String CHANGE_REACTION_ROLE = "changeReactionRole";
	public static final String REACTION_COPY = "reactionCopy";

	protected final static String separator = "\n";

	public static boolean isStandAloneApplication = false; // by default the program starts as an applet

	public static enum SupportedFileFormat {
		JME, SMILES, MOL, MOL_V3000, JMOL, INCHI, INCHI_KEY, INCHI_AUXINFO, INCHI_JSON, OCLCODE, SVG, RAW_STRING_GRAPHIC
	}

	// should extend CopyOnClipboard
	// - not possible in Java ??
	// BH -- What's the question here?

	public static enum CopyPasteAction {
		JME, SMILES, MOL, MOL_V3000, INCHI, INCHI_KEY, INCHI_AUXINFO, INCHI_JSON, OCLCODE, SVG, RAW_STRING_GRAPHIC,
		SEARCH_INCHI_KEY, PASTE;

		public SupportedFileFormat getFormat() {
			return SupportedFileFormat.valueOf(toString());
		}
	}

	// editor state
	public int action;

	Touched lastTouched = new Touched();
	Touched newTouched = new Touched();
	Touched keyTouched = new Touched();

	int reactionParts[][]; // computed with getReactionParts()
	public int active_an;

	public String infoText = null;
	String customDefaultInfoText = ""; // may be changed by the JS call

	int arrowWidth = 24 * 2;
	ReactionArrow reactionArrow = new ReactionArrow(36 * 2);

	// in depict mode, make the DnD and full screen icons smaller
	double smallerIconsForDepictMode = 0.6;

	public Color bgColor = Color.lightGray;
	public Color brightColor = bgColor.brighter();
	public Color leftMenuAtomColor = null;

	// File format for Ctrl C
	protected SupportedFileFormat clipboardFormat = SupportedFileFormat.MOL;

	protected JMEevent afterStructureChangeEvent = new JMEevent();

	// icons
	protected boolean isFullScreen = false;
	protected boolean fullScreenEnterOrExit = false;

	protected boolean appletHasBeenResized = false;
	Rectangle2D.Double previousScaledScreenArea = null;

	protected float molecularAreaLineWidth = (float) 1.0;

	public boolean molecularAreaAntiAlias = true;

	boolean depict = false;

	// tieto parametere sa naplnaju v init (aby sa vynulovali pri starte)
	// boolean bwMode = false;

	public Parameters params = new Parameters();

	boolean pasteFromSDFstack = false;

	boolean jmeh = false; // used in jSME

	Color canvasBg = Color.white;
	// Color starColor = Color.cyan;

	// index in the color manager palette, 0 based index
	public final static int DefaultMarkerColorIndex = 1;
	public int activeMarkerColorIndex = DefaultMarkerColorIndex;

	// String atomColors = null; // atom coloring
	String atomBgColors = null; // background coloring
	final static double defaultAtomBGcircleRelativeSize = 0.8;
	final static double defaultBondBGrectRelativeSize = 0.5;

	public final static double defaultMolecularAreaScale = 1.0;

	protected double molecularAreaScalePixelsPerCoord = defaultMolecularAreaScale; // ked scaling viacero moleculeParts,
																					// alebo
	// reaction
	protected final double minmolecularAreaScale = 0.3;
	protected final double maxMolecularAreaScale = 10;

	public double menuScale = 1.0; // BB scaling the menu
	protected final double minMenuScale = 0.7;
	protected final double maxMenuScale = 2;

	public final static boolean scalingIsPerformedByGraphicsEngine = true; // BB, gives nicer looking depiction

	boolean nocenter = false;
	boolean showAtomNumbers = false; // only when starting with a molecule
	// scaling pri depict, nacitanie molekul (jme + mol)

	boolean allowFullScreenToggle = true;

	// files na nacitanie (2002.06)

	// Java applet code but can also be retrieved in JavaScript application

	// pouziva v double bufferingu
	public Dimension dimension;

	protected PreciseImage molecularAreaImage;
	public Dimension molecularArea;
	// these images are not used in depict mode
	public PreciseImage topMenuImage;
	public PreciseImage leftMenuImage;
	public PreciseImage infoAreaImage;
	public PreciseImage rightBorderImage;

	// pre repaint()
	// boolean doMenu = true; // ci draw menu pri repaint()
	boolean movePossible; // not to move when dragg in menu

	// BB - avoid unnecessary redraw - speed optimization for slow browsers

	protected JSFunction notifyStructuralChangeJSfunction = null;
	protected JSFunction notifyAtomHighLightJSfunction = null;
	protected JSFunction prePasteJSfunction = null;

	protected String pasteJLabel = null;

	// boolean atomWasTouched = false;
	// boolean bondWasTouched = false;

	// the ACTION code on which the mouse was during mouse move
	int mouseWasOverAction = 0;

	public ColorManager colorManager = new ColorManager();

	// actions 2 riadky s ACTIONX a atomy s ACTIONA
	public static final Color color[] = new Color[Atom.AN_R_LAST + 1];

	// info about last action & undo
	public int lastAction = 0; // trva len po mouse up
	public static final int LA_BOND = 1;
	public static final int LA_RING = 2;
	public static final int LA_GROUP = 3;
	public static final int LA_MOVE = 5;
	public static final int LA_ROTATE = 7; // BB used for rotation on touch event
	public static final int LA_SCALE = 8; // BB used for scaling on touch event
	public static final int LA_FAILED = 9; // failed to create bond or ring

	final protected Dimension nonFullScreenSize = new Dimension();

	final static protected double fullScreenScale = 3;

	public boolean newMolecule = false; // enable to start new molecule
	private int mouseX, mouseY; // position of mousePressed, updated in mouseDragged
	private boolean afterClear = false; // info pre undo
	private boolean mouseShift = false; // kvoli numbering

	// boolean isContextMenu = false; //right mouse click

	private Actions actions;
	private JMEBuilder builder;
	private Dimension nonFullFrameSize;
	private double nonFullScreenMenuScale;
	private Point nonFullFrameLocation;
	private double nonFullFrameMolecularAreaScalePixelsPerCoord;

	MultiBox smilesBox = null, atomxBox = null, aboutBox = null;
	QueryBox queryBox;
	boolean movingAtom = false; // BB

	String molText = null;
	protected JMEmol activeMol; // BB: the molecule JME is presently working on
	Graphical2DObject activeGraphicalObject;

	// protected int numberofMoleculeParts = 0;
	// int actualMoleculePartIndex = 0;
	int saved = 0; // ktora molekula jindexe saved pri multipart

	InspectorEvent inspectorEvent;

	public static final int maxParts = 99;

	// protected JMEmol moleculeParts[] = new JMEmol[maxParts]; // when multipart,
	// nealokuje !!
	public JMEmolList moleculePartsList = new JMEmolList(); // when multipart, nealokuje !!
	JMEmol smol; // save

	// BB undo & redo section
	final boolean canMultipleUndo = true; // when false, use Peter's original implementation, otherwise use the
											// changeManager
	ChangeManager<SavedState> molChangeManager;

	List<JMEmol> molStack = new ArrayList<JMEmol>();

	// BB
	SDFstack sdfStack = new SDFstack();

	int stackPointer = -1;
	final static boolean webme = false; // compatibility with JMEPro
	public int[] apointx, apointy, bpointx, bpointy; // coordinates for webme
	boolean revertStereo = false; // down stereo bond (only 1 action)
	// boolean relativeStereo = false; // not implemented
	// boolean allHs = false;
	// for key marking 2009.04
	boolean resetExtendAtomMark = true;
	int keyboradInputMark = -100;
	boolean markFromKeyboardInput = false;

	// images
	// Image infoImage, clearImage, deleteImage, deleterImage, chargeImage;
	// Image templatesImage, rtemplatesImage, undoImage, endImage, smiImage,
	// smitImage, smartsImage, stereoImage, stereoxImage;

	// BB
	// true if the Java code has been compiled to JavaScript
	final static boolean isJavaScript = System.getProperty("java.vm.name").equals("JavaScript");

	final static double precision;

	public static final double mouseWheelFactor = 10; // BH 2023 - now this works on my computer.

	static {

		if (isJavaScript) {
			programName = "JSME";
			precision = 30; // 10 looks good with FF at maximum zoom
		} else {
			programName = "JME";
			precision = 1.0;
		}
	}

	// BB for copy & paste
	protected TextTransfer clipBoardManager = new TextTransfer();
	JPopupMenu copyPasteJPopupMenuMol;
	JPopupMenu copyPasteJPopupMenuReaction;

	// local popup menu for the touched molecule/atom
	JPopupMenu touchedMolPopuMenu;
	static String setChiralFlagAction = "Set molecule chiral flag";
	static String unSetChiralFlagAction = "Unset molecule chiral flag";
	public static String changeAtomChargeAction = "Change atom charge";

	public static String changeAtomMapAction = "Change atom map";
	public static String changeAtomMarkAction = "Change atom mark value";
	static String autoAtomMapMoleculeAction = "Auto atom map molecule";
	static String deleteAtomMapMoleculeAction = "Delete all atom map molecule";
	private static Parser oclAdapter;
	final static String deleteHydrogensMoleculeAction = "Delete hydrogens";
	final static String compute2DcoordinatesMoleculeAction = "Compute 2D coordinates";

	final static String bondCoordination = "et coordination bond";
	final static String bondSetCoordinationAction = "S" + bondCoordination;
	final static String bondUnSetCoordinationAction = "Uns" + bondCoordination;

	// functional group selection coming from the HTML example page
	public String functionalGroups[] = new String[] { "-C(=O)OH", "-C(=O)OMe", "-OC(=O)Me", "-C(=O)N", "-NC=O", "-CMe3",
			"-CF3", "-CCl3", "-NO2", "-SO2-NH2", "-NH-SO2-Me", "-NMe2", "-C#N", "-C#CH", "-C#C-Me" };

	protected long lastRotation;
	protected boolean bondRubberBanding = false;
	protected PasteAction pasteAction;
	protected boolean mouseDownWasUsed;
	protected boolean saveCurrentState = false; // when true means the current state of the chemical structures must be
												// saved in the undo state manager

	protected String searchInchiKeyMenuJLabel = "Search chemical structure (through InChIKey)";
	protected boolean alignMoleculesHasBeenPerformedByReadingStructure;
	// protected Rectangle2D.Double reactionArrowBoundingBox;
	protected JFrame myFrame;
	protected boolean application;

	protected boolean embedded;

	protected boolean isPostInitialized = false;

	protected boolean headless;

	protected String menuXShortcuts = null;


	public JME() {
		this(null, false, null);
	}

	public JME(JFrame frame) {
		this(frame, false, null);
	}

	public JME(JFrame frame, boolean embedded, String[] args) {
		this.embedded = embedded;
		activeMol = new JMEmol(this, params);
		lastTouched.mol = activeMol;
		newTouched.mol = activeMol;
		moleculePartsList.add(activeMol);
		inspectorEvent = new InspectorEvent(this);

		// this.alert("isTouchSupported: " + isTouchSupported);
		// reactionArrowBoundingBox = new Box();
		setFrame(frame);
		boolean doInit = true;
		if (args.length > 0 && !args[0].startsWith("-")) {
			if (args[0].indexOf(NO_INIT) >= 0) {
				doInit = false;
			}
		}
		if (doInit)
			initialize(args);
	}

	public void setFrame(JFrame frame) {
		if (frame == null)
			return;
		myFrame = frame;
		isStandAloneApplication = true;
		frame.setName("JME"); // for embedding in <div id="testApplet-JME-div">
		frame.add("Center", this);
		frame.addKeyListener(this);
		addKeyListener(this);
		addMouseListener(this);
		addMouseMotionListener(this);
		new FileDropper(this);
		application = true;
	}

	// ----------------------------------------------------------------------------
	public void initialize(String[] args) {
		params.keepSameCoordinatesForOutput = false;
		params.internalBondScalingForInput = true;
		params.showAtomMapNumberWithBackgroundColor = false;

		options.registerJS(this);

		if (args.length > 0 && !args[0].startsWith("-")) {
			options(args[0]);
		}

		DragSource ds = new DragSource();
		ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY, this);

		Container parent = this.getParent();
		if (parent != null) {
			parent.addMouseWheelListener(this); // works
		}
		dimension = getSize(); // will be 0,0 in Java and JavaScript;

		setLayout(null);

		options.getAppletOptions(this);

		gui = new GUI(this);

		action = Actions.ACTION_BOND_SINGLE; // musi to tu but, inak nic

		validate();

		mustRedrawEverything();
		if (myFrame != null) {
			myFrame.setResizable(true);
			myFrame.setVisible(true);
		}

		// BB
		if (this.canMultipleUndo) {
			this.molChangeManager = new ChangeManager<SavedState>();
			this.postSave(); // no effects because mol is not part of the array molparts
			// and because it has no atoms
		}

		// Show the copyright stuff at the bottom of the page when the applet starts
		info(programName + " " + startInfoText);

	}

	public void start() {
		start(new String[0]);
	}

	public void start(String[] args) {
		actions = new Actions(this);
		actions.setActions();
		int pt = 0;
		if (args.length > 0 && !args[0].startsWith("-"))
			pt++;

		dimension = getSize();
		// no repaint because the applet viewer will call repaint() after start()
		// this was changed because the molecule is always loaded with a GWT.runasync
		boolean repaint = true;
		if (options.jmeString != null) {
			readMolecule(options.jmeString, repaint);
			// co s colring multipart a reactions ???
			// only 1 coloring scheme (atoms || bg) may be applied
			if (atomBgColors != null && activeMol != null)
				activeMol.setAtomColors(atomBgColors, 0);
			postSave(); // June 2021
		} else if (options.molString != null) {
			readMolFile(options.molString, repaint);
			postSave(); // June 2021
		} else if (options.genericChemicalInputFromInit != null && options.useOpenChemLib) {

			// with a local or global instance of RunAsyncCallback, then code split does not
			// work
			// this.read_MOL_SDF_RXN(smilesString, null); // works also

			// async conversion with open chemlib
			// redraiwng the molecular area will be performed by the async call
			// after the OCL code is loaded and the smiles converted to MOL

			// the function calling this function will call paint in parallel,
			setMustRedrawMolecularArea(false);
			// DOES NOT WORK test_depict_many_smiles_in_table.html
			// this.handleReadGenericInput(genericChemicalInputFromInit, null, repaint,
			// false); // will call paint to redraw the
			// June 2021: last argument set to true to endure undo stack state is added
			//
			// molecular area after the smiles
			handleReadGenericInput(options.genericChemicalInputFromInit, null, repaint, true);
			// will call paint to redraw the has been decoded
		}

		process(args, pt);
		repaint();
	}

	public void process(String[] args, int i) {
		if (i < 0 || i >= args.length)
			return;
		// reads molecule (from 2008.12)
		for (; i < args.length; i++) {
			if (args[i].startsWith("-f")) {
				readDroppedTextFile(args[++i]);
			} else if (args[i].startsWith("-o")) {
				options(args[++i]);
			} else if (args[i].startsWith("-c")) {
				options.callback(args[++i], args[++i]);
			}
		}

	}

	public static String makeErrorMessage(Exception e) {
		String errorMsg = null;

		if (e instanceof NumberFormatException) {
			errorMsg = NumberParsingErrorMsg;
		} else if (e instanceof NoSuchElementException) { // if there are no more tokens in this tokenizer's string.)
			errorMsg = NotEnoughDataMsgError;
		}

		if (errorMsg == null) {
			errorMsg = e.toString();
		} else if (e.getMessage() != null) {
			errorMsg += ":" + e.getMessage();
		}

		return errorMsg;

	}

	public float getMolecularAreaLineWidth() {
		return molecularAreaLineWidth;
	}

	/**
	 * Line width in pixel
	 * 
	 * @param molecularAreaLineWidth
	 */
	public void setMolecularAreaLineWidth(float molecularAreaLineWidth) {
		this.molecularAreaLineWidth = molecularAreaLineWidth;
		this.drawMolecularAreaRightNow();

	}

	public boolean isMolecularAreaAntiAlias() {
		return molecularAreaAntiAlias;
	}

	/**
	 * Set antialias for the molecular drawing area
	 * 
	 * @param molecularAreaAntiAlias
	 */
	public void setMolecularAreaAntiAlias(boolean molecularAreaAntiAlias) {
		this.molecularAreaAntiAlias = molecularAreaAntiAlias;
		this.drawMolecularAreaRightNow();
	}

	/**
	 * This method is used only in a batch mode test suite in order to have an
	 * instance of JME that has a this.dimension that is not null
	 * 
	 * @param width
	 * @param height
	 */
	public void setDirectSizeForTesting(int width, int height) {
		setDimension(width, height);
		updateMyMolecularAreaSize();
	}

	/**
	 * Used for the test suite
	 * 
	 * @param width
	 * @param height
	 */
	public JME setDimension(int width, int height) {
		if (this.dimension == null) {
			this.dimension = new Dimension();
		}
		this.dimension.setSize(width, height);
		return this;
	}

	public String getPasteJLabel() {
		return pasteJLabel;
	}

	/**
	 * Customization of the paste label
	 * 
	 * @param pasteJLabel
	 */
	public void setPasteJLabel(String pasteJLabel) {
		this.pasteJLabel = pasteJLabel;
		// rebuild the menu each time the pasteJLabel is changed
		copyPasteJPopupMenuMol = createCopyPasteJPopupMenu(false);
	}

	// coud have used a HAshMap, but the code to initialize a hashmap is about the
	// same - JS is much better here for simple dict
	public int mapActionToAtomNumberXorR(int action) {
		int result = Actions.mapActionToAtomNumberX(action);
		return (result == Atom.AN_X && !options.xButton && options.rButton ? Atom.AN_R : result);
	}

	public int getLeftMenuCellCount() {
		return Actions.LEFT_MENU_ELEMENT_COUNT + (options.rButton ? 1 : 0) + (options.xButton ? 1 : 0);

	}

	public int numberOfMolecules() {
		return this.moleculePartsList.size();
	}

	// protected int lastTouchedMoleculePart;

	public double getMolecularAreaScale() {
		return molecularAreaScalePixelsPerCoord;
	}

	// used by mouse wheel event in reaction mode
	public void setMolecularAreaScale(double newScale) {
		// should we limit scaling if one molecule becomes invisible?
		if (newScale != this.molecularAreaScalePixelsPerCoord) {
			Rectangle2D.Double dim1 = this.getMolecularAreaCoordBoundingBox();
			this.molecularAreaScalePixelsPerCoord = newScale;
			Rectangle2D.Double dim2 = this.getMolecularAreaCoordBoundingBox();
			recenterMoleculesAfterMolecularAreaChange(dim1, dim2);
			this.redrawMolecularAreaOnly();
		}
	}

	public void recenterMoleculesAfterMolecularAreaChange(Rectangle2D.Double before, Rectangle2D.Double after) {
		double moveX = after.getCenterX() - before.getCenterX();
		double moveY = after.getCenterY() - before.getCenterY();

		this.graphicalObjectList().moveXY(moveX, moveY);

	}

	public double getMenuScale() {
		return menuScale;
	}

	public void setMenuScale(double menuScale) {
		if (menuScale != this.menuScale) {
			;
			this.menuScale = menuScale;
			this.resetAllGraphics();
			this.repaint();
		}
	}

	public void setNewJButtonStatus(boolean newStatus) {
		this.newMolecule = newStatus;
		gui.mustReDrawTopMenu = true;
		this.repaint();

	}

	public boolean getNewJButtonStatus() {
		return this.newMolecule;
	}

	/**
	 * Move to atom
	 * 
	 * @param mol
	 * @param atomIndex
	 * @param x
	 * @param y
	 */
	protected void moveXY(JMEmol mol, int atomIndex, int x, int y) {
		mol.moveXY(atomIndex, screenToDrawingX(x), screenToDrawingY(y));
	}

	// ----------------------------------------------------------------------------
	protected JPopupMenu createCopyPasteJPopupMenu(boolean isReaction) {

		JPopupMenu popup = new JPopupMenu();

		String smilesOrSmirks = "SMILES";
		String molOrReaction = "MOL";
		String molOrReactionForPasting = "MOL or SDF";
		Boolean hasAtom = !this.isMolecularAreEmpty();

		// String what = "chemical structure(s)";
		if (isReaction) {
			smilesOrSmirks = "SMIRKS";
			molOrReaction = "RXN";
			// what = "reaction";
			molOrReactionForPasting = molOrReaction;
		}

		if (options.useOpenChemLib) {
			molOrReactionForPasting += " or " + smilesOrSmirks;
			if (!isReaction && options.useOclIdCode) {
				molOrReactionForPasting += " or " + OCL_ID_CODE_LABEL;
			}
		}

		// COPY SMILES
		addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + smilesOrSmirks /* + " to the clipboard" */,
				CopyPasteAction.SMILES);
		// COPY MOL
		addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + molOrReaction /* + " to the clipboard" */,
				CopyPasteAction.MOL);

		// COPY V3000 MOL
		if (!isReaction) {
			addMenuItem(popup, hasAtom,
					"Copy " /* + what */ + "as " + molOrReaction + " V3000" /* + " to the clipboard" */,
					CopyPasteAction.MOL_V3000);

			// handling Inchi: only available for JSME - use the inchi-js
			if (this.canComputeInchi()) {
				if (options.exportInchi) {
					addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "InChI" /* + " to the clipboard" */,
							CopyPasteAction.INCHI);
				}

				if (options.exportInchiKey) {
					addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "InChI key" /* + " to the clipboard" */,
							CopyPasteAction.INCHI_KEY);

				}
				if (options.searchInchiKey) {
					addMenuItem(popup, hasAtom, this.searchInchiKeyMenuJLabel, CopyPasteAction.SEARCH_INCHI_KEY);
				}
				if (options.exportInchiAuxInfo) {
					addMenuItem(popup, hasAtom,
							"Copy " /* + what */ + "as " + "InChI auxinfo" /* + " to the clipboard" */,
							CopyPasteAction.INCHI_AUXINFO);
				}
			}

		}

		// COPY JME
		addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "JME" /* + " to the clipboard" */,
				CopyPasteAction.JME);
		if (options.useOpenChemLib && options.exportSVG && !isReaction) {
			addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "OCL Scalar Vector Graphics",
					CopyPasteAction.SVG);

		}

		// on IE7, one would get VML instead of SVG - nobody is using IE7 now
		if (isJavaScript && options.exportSVG) {
			addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "raw Scalar Vector Graphics",
					CopyPasteAction.RAW_STRING_GRAPHIC);

		}

		if (options.useOpenChemLib && options.useOclIdCode && !isReaction) {
			addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + OCL_ID_CODE_LABEL, CopyPasteAction.OCLCODE);
		}

		subclassAddToCopyMenu(popup, hasAtom);

		// PASTE
		if (options.paste) {
			popup.addSeparator();
			String localPasteJLabel = this.getPasteJLabel();
			if (localPasteJLabel == null) {
				localPasteJLabel = "Paste " + molOrReactionForPasting; // default, no customization
			}
			addMenuItem(popup, true, localPasteJLabel, CopyPasteAction.PASTE);

		}
		this.add(popup); // set the parent the popup

		return popup;

	}

	protected void addMenuItem(JPopupMenu popup, boolean enabled, String text, Object cmd) {
		JMenuItem mi = new JMenuItem(text);
		mi.setActionCommand(cmd.toString());
		mi.addActionListener(this);
		mi.setEnabled(!enabled);
		popup.add(mi);
	}

	protected void subclassAddToCopyMenu(JPopupMenu popup, boolean hasAtom) {
	}

	/**
	 * To be redefined in subclass
	 * 
	 * @return true if this implementation can compute inchi
	 */
	protected boolean canComputeInchi() {
		return true;
	}

	/**
	 * return a based 1 index
	 * 
	 * @return
	 */
	protected int activeMolIndex() {
		return this.moleculePartsList.indexOf(this.activeMol);
	}

	/**
	 * Create a popup menu with additional action for the selected molecule
	 * 
	 * @return
	 */
	protected JPopupMenu createMolJPopupMenu(int eventX, int eventY) {
		JMEmol mol = activeMol;
		JPopupMenu popup = new JPopupMenu();
		JMenuItem item = new JMenuItem(mol.getChiralFlag() ? unSetChiralFlagAction : setChiralFlagAction);
		item.setEnabled(mol.canBeChiral());
		popup.add(item);
		item.addActionListener(this);

		if (mol.touchedAtom > 0) {
			this.inspectorEvent.reset();
			this.inspectorEvent.atomIndex = mol.touchedAtom;
			this.inspectorEvent.mol = mol;
			this.inspectorEvent.x = eventX;
			this.inspectorEvent.y = eventY;
			this.inspectorEvent.molIndex = this.activeMolIndex();

		}
		boolean showAtomMappingToolsInMenu = this.params.number || options.autonumber || options.reaction;
		if (showAtomMappingToolsInMenu && mol.touchedAtom > 0) {
			item = new JMenuItem(this.params.mark ? changeAtomMarkAction : changeAtomMapAction);
			item.addActionListener(this.inspectorEvent);
			popup.add(item);
		}

		// charge handling
		if (mol.touchedAtom > 0) {
			// BB July 2022: renable the charge change
			item = new JMenuItem(changeAtomChargeAction);
			item.addActionListener(this.inspectorEvent);
			popup.add(item);
		}

		// add a 2D computation only if Openchemlib is enabled
		if (options.useOpenChemLib && !mol.has2Dcoordinates()) {
			// BH 2023 added check for has2Dcoordinates because
			// computation will return null anyway in this case
			item = new JMenuItem(compute2DcoordinatesMoleculeAction);
			popup.add(item);
			item.addActionListener(this);
		}

		item = new JMenuItem(deleteHydrogensMoleculeAction);
		item.setEnabled(mol.hasHydrogen());

		popup.add(item);
		item.addActionListener(this);
		if (showAtomMappingToolsInMenu) {
			item = new JMenuItem(autoAtomMapMoleculeAction);
			item.addActionListener(this);
			popup.add(item);
			item = new JMenuItem(deleteAtomMapMoleculeAction);
			item.addActionListener(this);
			popup.add(item);
			item.setEnabled(mol.getMaxAtomMap() > 0);

		}
		item = new JMenuItem();
		String label = bondSetCoordinationAction;
		item.setEnabled(false);
		if (mol.touchedBond > 0) {
			Bond bond = mol.bonds[mol.touchedBond];
			if (bond.isSingle() || bond.isCoordination()) {
				label = bond.isCoordination() ? bondUnSetCoordinationAction : bondSetCoordinationAction;
				// bondInspectoJMenuItem.addActionListener(this.inspectorEvent); //not used
				this.inspectorEvent.reset();
				this.inspectorEvent.bondIndex = mol.touchedBond;
				this.inspectorEvent.mol = mol;
				this.inspectorEvent.x = eventX;
				this.inspectorEvent.y = eventY;
				this.inspectorEvent.molIndex = this.activeMolIndex();
				item.setEnabled(true);
				item.addActionListener(this);
			}
		}
		item.setText(label);
		popup.add(item);
		return popup;
	}

	// BB - this method can be used only by input events methods
	void mustRedrawNothing() {
		mustRedrawImages(false);
	}

	// BB
	public void mustRedrawEverything() {
		mustRedrawImages(true);
	}

	public void mustRedrawImages(boolean yesOrNo) {
		if (gui == null)
			return;
		gui.mustReDrawLeftMenu = yesOrNo;
		gui.mustReDrawTopMenu = yesOrNo;
		setMustRedrawMolecularArea(yesOrNo);
		gui.mustReDrawInfo = yesOrNo;
		gui.mustReDrawRightBorderImage = yesOrNo;

	}

	public void mustReDrawMolecularArea() {
		setMustRedrawMolecularArea(true);
	}

	public void redrawEverything() {
		this.mustRedrawEverything();
		this.repaint();
	}

	// --------------------------------------------------------------------------
	public Color getColor() {
		return bgColor; // it may be used to color other stuff with mi colors
	}

	// --------------------------------------------------------------------------
	public void activateQuery() {
		// v JME menu nastavi na query (ak bolo medzitym ine)
		if (action != Actions.ACTION_QRY) {
			action = Actions.ACTION_QRY;
			repaint();
		}
	}

	/*
	 * 
	 * For subclassses
	 */
	protected void handleAdditionalParameters() {

	}

	public SupportedFileFormat getCopyToClipboardFormat() {
		return this.clipboardFormat;
	}

	public void setCopyToClipboardFormat(SupportedFileFormat format) {
		this.clipboardFormat = format;
	}

	/**
	 * Perform postinitalization after the editor is completely initialized SMILES
	 * has been read and is ready to be edited
	 *
	 * @return
	 */
	protected void postInitializeIfNeeded() {
		if (!this.isPostInitialized) {
			this.isPostInitialized = true; // aboid infinite loop
			this.postInitialize();
		}
	}

	protected void postInitialize() {

	}

//	@Override
//    public void repaint() {
//        super.repaint();
//        this.postInitializeIfNeeded();
//    }

	// ----------------------------------------------------------------------------
	public void stop() {
		if (smilesBox != null)
			smilesBox.dispose();
		if (atomxBox != null)
			atomxBox.dispose();
		if (aboutBox != null)
			aboutBox.dispose();
		if (queryBox != null)
			queryBox.dispose();
		if (actions != null)
			actions.dispose();
		if (gui != null)
			gui.dispose();
		builder = null;
		// moleculeParts = null; // memory leak ?

	}

	// for JavaScript to establish connection with JME
	public void ping() {
	}

	// ----------------------------------------------------------------------------
	public String smiles() {
		String smiles;
		try {
			smiles = getSmiles();
			// this.mustRedrawNothing(); //BB - info will be redrawed if changed
		} catch (Exception e) {
			this.info(e.getMessage());

			return null;
		}
		return smiles;
	}

	// ----------------------------------------------------------------------------
	/**
	 * Compute and update the reactions roles for each molecule
	 * 
	 * @return the index (0 based) of the first molecule that has a different
	 *         reaction role or -1 if no changes
	 */
	protected int updateReactionRoles() {

		moleculePartsList.isReaction = options.reaction;
		int firstChangedIndex = -1;

		if (options.reaction) {
			for (JMEmol mol : moleculePartsList) {

				int previousRole = mol.getReactionRole();
				int newRole = this.computeReactionRole(mol);

				mol.setReactionRole(newRole);

				if (firstChangedIndex == -1 && newRole != previousRole) {
					firstChangedIndex = moleculePartsList.indexOf(mol);
				}

			}
		}

		return firstChangedIndex;
	}

	/**
	 * Find the reaction roles in the JME canvas based on my relative position to
	 * the reaction arrow
	 * 
	 * @return ReactionRole,
	 */
	protected int computeReactionRole(JMEmol mol) {
		if (mol.nAtoms() == 0) {
			return ReactionRole.NOROLE;
		}
		Rectangle2D.Double bbox = mol.computeBoundingBoxWithAtomLabels(null);
		// May 2020 improvement for the agent
		Rectangle2D.Double reactionArrowBox = reactionArrow.updateBoundingBox();
		if (bbox.getCenterX() < reactionArrowBox.x)
			return ReactionRole.REACTANT;
		else if (bbox.getCenterX() > reactionArrowBox.x + reactionArrowBox.width)
			return ReactionRole.PRODUCT;
		else
			return ReactionRole.AGENT;

	}

	public String nonisomericSmiles() {
		boolean originalStereo = options.stereo;
		options.stereo = false;
		String smiles = getSmiles();
		options.stereo = originalStereo;
		// BB: I commented the line below
		// repaint(); // aby ked je chyba v smilesi, aby sa objavilo info

		return smiles;
	}

	// ----------------------------------------------------------------------------
	public String getSmiles() {
		return getSmiles(null);
	}

	String getSmiles(Parameters params) {
		updateReactionRoles();
		if (params == null) {
			params = this.params;
		}
		return moleculePartsList.generateSmilesOrSmirks(params);
	}

	public void reset(boolean repaint) {
		// volane zvonka - vymaze vsetko
		action = Actions.ACTION_BOND_SINGLE;
		newMolecule = false;

		clearMyMolecularContent();
		clearInfo();

		molText = null;
		// BB
		resetMolecularAreaScale();

		this.recordAfterStructureChangedEvent(RESET);
		if (repaint)
			repaint();

	}

	@Override
	public void repaint() {
		if (!headless && gui != null)
			super.repaint();
	}

	public void reset() {
		this.reset(true);
	}

	public void resetMolecularAreaScale() {
		if (this.isFullScreen()) {
			molecularAreaScalePixelsPerCoord = fullScreenScale;
		} else {
			molecularAreaScalePixelsPerCoord = 1.; // ??? ked depict viac molekul po sebe
		}
	}

	public void clearMyMolecularContent() {
		activeMol = new JMEmol(this, this.params); // treba
		moleculePartsList.removeAll();
		moleculePartsList.add(activeMol);
		molText = null;
		mustReDrawMolecularArea();

	}
	// ----------------------------------------------------------------------------

	public void clear() {
		clear(true);
	}

	// delete the active molecule, reselect the active molecule
	public void clear(boolean recordEvent) {
		// zmaze actualMoleculePartIndex, zmensi pocet molekul, actual bude najvyssia

		action = Actions.ACTION_BOND_SINGLE;
		newMolecule = false;
		clearInfo();

		if (moleculePartsList.size() == 0)
			return;

		moleculePartsList.remove(activeMol);

		if (moleculePartsList.size() > 0) {
			// Feb 2020: the closes mol to the deleted one becomes the active one
			activeMol = this.findClosestMol(scaleDrawingToScreen(activeMol.centerX()),
					scaleDrawingToScreen(activeMol.centerY()));
		} else {
			activeMol = new JMEmol(this, this.params);
			moleculePartsList.add(activeMol);
		}

		// BB
		setMustRedrawMolecularArea(true);

		afterClear = true;

		if (recordEvent) {
			this.recordAfterStructureChangedEvent(CLEAR);
		}
	}

	// ----------------------------------------------------------------------------
	public String jmeFile() {
		// returns molecule(s) in jme format
		this.updateReactionRoles();
		String result = moleculePartsList.generateJMEstring(false,
				this.computeMoleculeEnsembleCoordinate2DboundingBox());
		return result;
	}

	/**
	 * Useful to find the max atom map of e.g. all reactants
	 * 
	 * @param moleculeParts
	 * @param whichMolecules
	 * @return
	 */
	int findMaxAtomMapOfMoleculeParts(JMEmolList moleculeParts, int reactionRole) {

		this.updateReactionRoles();
		return moleculeParts.findMaxAtomMap(reactionRole);

	}

	/**
	 * Read a molecule string in JME format
	 * 
	 * @param molecule
	 * @param repaint
	 */
	public boolean readMolecule(String molecule, boolean repaint) {
		boolean success;
		try {
			if (success = this.handleReadMolecule(molecule, repaint)) {

			} else {
				repaint(); // to show errors
			}
		} catch (Exception e) {
			success = false;
			repaint(); // for showing the error
		}

		return success;
	}

	/**
	 * Read a molecule string in JME format
	 * 
	 * @param molecule
	 */
	public void readMolecule(String molecule) {
		this.readMolecule(molecule, true);
	}

	// Read a molecule or reaction in JME format
	// this code is almost never used and is problably buggy because it was not
	// tested
	// especialy molecule align
	// ----------------------------------------------------------------------------
	// makos
	protected boolean handleReadMolecule(String molecule, boolean repaint) {

		// duplicated code, a pointer to a function would solve the problem?
		JMEmolList inputMolList = new JMEmolList();
		boolean success = inputMolList.readJMEstringInput(molecule, this.params);
		if (success && !inputMolList.isReallyEmpty()) {
			this.processIncomingMolecules(inputMolList, repaint);
		}
		return success;
	}

	protected boolean handleReadJmolAdaptorInput(Object[] iterators, boolean repaint) {

		// duplicated code, a pointer to a function would solve the problem?
		JMEmolList inputMolList = new JMEmolList();
		boolean success = inputMolList.readJmolAdaptorInput(iterators, this.params);
		if (success && !inputMolList.isReallyEmpty()) {
			this.processIncomingMolecules(inputMolList, repaint);
		}
		return success;
	}

	public void showError(String errorMessage) {
		this.showInfo("ERROR - " + errorMessage);

	}

	private JMEBuilder getBuilder(JMEmol mol) {
		return getBuilder(mol, action);
	}

	private JMEBuilder getBuilder(JMEmol mol, int action) {
		if (builder == null)
			builder = new JMEBuilder(this);
		return builder.set(mol, action, mouseShift);
	}

	// ----------------------------------------------------------------------------
	// adding template from JavaScript
	// template menu is actually JME string
	public void setTemplate(String t, String name) {
		// clear();
		afterClear = false; // otherwise problems in undo
		try {
			String err = getBuilder(activeMol).setTemplate(t);
			if (err == null) {
				info(name);
				action = Actions.ACTION_GROUP_TEMPLATE;
			} else {
				showError(err);
			}
			// parameter rom readJMEstringInput?
		} catch (Exception e) {
			info(e.getMessage());
			return;
		}
		repaint(); // needed to display status line
	}

	public void setUserInterfaceBackgroundColor(Color bgColor) {
		this.bgColor = bgColor;
		this.brightColor = this.bgColor.brighter();
		this.redrawEverything();
	}

	public void setLeftMenuAtomColor(Color color) {
		this.leftMenuAtomColor = color;
		this.redrawEverything();
	}

	/**
	 * Choose another background color for the GUI frame and the dialog boxes
	 * 
	 * @param bgColor : string like #FFFBBCC
	 */

	public void setUserInterfaceBackgroundColor(String hexColor) {
		this.setUserInterfaceBackgroundColor(ColorManager.parseHexColor(hexColor));
	}

	/**
	 * Same color for all atoms of the left menu, e.g. black
	 * 
	 * @param hexColor
	 */
	public void setLeftMenuAtomColor(String hexColor) {
		if (color != null && color.length > 5)
			this.setLeftMenuAtomColor(ColorManager.parseHexColor(hexColor));
		else
			this.setLeftMenuAtomColor((Color) null);

	}

	/**
	 * not for reaction
	 * 
	 * @return
	 */
//	double scaleAndCenterForDepictMode(JMEmolList molList) {
	double scaleAndCenterForDepictMode(Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList) {

		// when reading a molfile and creating a JMEmol, the compound is already
		// internally scaled
		// such that its average bond length is equal the RBOND

		double scaleToFit = molecularAreaScalePixelsPerCoord;

		double margin = JMECore.RBOND;

		Rectangle2D.Double cdbb = getChemicalDrawingPixelBoundingBox(graphicalObjecList); // is empty if no molecules
		Dimension mabb = getMolecularAreaPixelDimensions();

		if (cdbb.isEmpty() || mabb == null || mabb.getWidth() == 0 || mabb.getHeight() == 0) {
			return scaleToFit; // no change
		}

		double ratioWidth = mabb.getWidth() / (cdbb.getWidth() + margin);
		double ratioHeight = mabb.getHeight() / (cdbb.getHeight() + margin);

		if (ratioWidth == 0 || ratioHeight == 0) {
			return scaleToFit;
		}

		// first case: the molecule is too big
		if (ratioWidth <= 1 || ratioHeight <= 1) {
			scaleToFit = Math.min(ratioWidth, ratioHeight);
			// shrink
		} else {
			scaleToFit = molecularAreaScalePixelsPerCoord;
			//BH?? 1.0 does not work when full screen -- or does it??
			// no need to increase the size because of internal bond scaling
		}

		centerAllMoleculesAsAgroup(graphicalObjecList, scaleToFit);

		return scaleToFit;
	}

	/**
	 * New BB method developed for SMIRKS INPUT molecules internal scaling must have
	 * been performed based on JMEmol.RBOND the reactionRole will determine if the
	 * molecules must be aligned horizontally of vertically Assume that the size of
	 * the drawing canvas is infinite
	 * 
	 * @param m1           0 based
	 * @param m2           0 based
	 * @param reactionRole
	 */
	void alignAndDistributeMolecules(int m1, int m2, int reactionRole) {
		int nm = m2 - m1 + 1;
		if (nm <= 0 || m1 >= moleculePartsList.size() || m2 >= moleculePartsList.size())
			return;

		double spaceBetweenMolecules = JMECore.RBOND;

		double lastMove = 0;

		for (int i = m1; i <= m2; i++) {
			JMEmol mol = moleculePartsList.get(i);
			Rectangle2D.Double moleculeBox = mol.computeBoundingBoxWithAtomLabels(null);
			double dx = moleculeBox.x * -1;
			double dy = moleculeBox.y * -1;

			if (reactionRole != JMEmol.ReactionRole.AGENT) {
				dx -= moleculeBox.getWidth() / 2;
				dy += lastMove;
				lastMove += moleculeBox.getHeight();

			} else {
				dy -= moleculeBox.getHeight() / 2;
				dx += lastMove;
				lastMove += moleculeBox.getWidth();

			}

			mol.moveXY(dx, dy);

			lastMove += spaceBetweenMolecules;
		}

	}

	/**
	 * 
	 * @param m1           0 based
	 * @param m2           0 based
	 * @param reactionRole ??
	 */
	void alignMolecules(int m1, int m2, int reactionRole) {
		alignMolecules(m1, m2, reactionRole, false);
	}

	// --------------------------------------------------------------------------
	// BB side effects: compute the depictScale correctly for only one time if it is
	// different than 1.0
	// recenter molecule in depict mode
	// m1 and m2 are indices of the molecules in molecularParts: align molecules m1
	// to m2 inclusive
	void alignMolecules(int m1, int m2, int reactionRole, boolean donotAlignJustScale) {

		if (nocenter)
			return; // aj pre depict ???
		int nm = m2 - m1 + 1;
		if (nm <= 0 || m1 >= moleculePartsList.size() || m2 >= moleculePartsList.size())
			return;
		// double previousDepictScale = molecularAreaScale;

		// double center[] = new double[4];

		double RBOND = JMECore.RBOND;
		double[] share = new double[99]; // share na 1 mol (used pri posune)
		double sumx = 0., sumy = 0., maxy = 0.;
		for (int i = m1; i <= m2; i++) {
			if (moleculePartsList.get(i).nAtoms() == 0)
				continue; // boundingBox() returns null if no atoms
			Rectangle2D.Double moleculeBox = moleculePartsList.get(i).computeBoundingBoxWithAtomLabels(null); // zisti
			// dimenzie
			sumx += moleculeBox.getWidth();// center[2]; //width of mol
			sumy += moleculeBox.getHeight(); // ; //height of mol
			maxy = Math.max(maxy, moleculeBox.getHeight());

			share[i] = moleculeBox.getWidth();
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				share[i] = moleculeBox.getHeight();
		}

		// prida medzery (na oboch stranach a medzi), pri !depict to netreba
		if (isDepict()) {
			sumx += RBOND * (nm + 1); // add enough space between molecules
			sumy += RBOND * (nm + 1);
			maxy += RBOND; // malo by byt * 2, ale potom su velke okraje
		}

		double scalex = 1., scaley = 1.;

		// compute the size of the available display box for the molecular area
		Rectangle2D.Double widthAndHeight;
		if (isDepict()) // in depict mode, the scale will be recomputed, therefore we use the original
						// size
			widthAndHeight = this.getMolecularAreaPixelBoundingBox();
		else
			widthAndHeight = this.getMolecularAreaCoordBoundingBox();

		int xsize = (int) widthAndHeight.width;
		int ysize = (int) widthAndHeight.height;

		if (reactionRole == JMEmol.ReactionRole.REACTANT || reactionRole == JMEmol.ReactionRole.PRODUCT)
			xsize = (xsize - arrowWidth) / 2;
		else if (reactionRole == JMEmol.ReactionRole.AGENT)
			ysize = ysize / 2;

		if (sumx >= xsize)
			scalex = (xsize) / sumx;
		if (maxy >= ysize)
			scaley = (ysize) / maxy;

		double space = 0.;
		if (isDepict()) { // cize == 1.
			molecularAreaScalePixelsPerCoord = Math.min(scalex, scaley); // inak dS = 1.
			space = RBOND * xsize / sumx;
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				space = RBOND * ysize / sumy;

		}

		for (int i = m1; i <= m2; i++) {
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				share[i] = share[i] * ysize / sumy; // share[i] was the y size of the molecule
			else
				share[i] = share[i] * xsize / sumx;// share[i] was the x size of the molecule
		}

		double shiftx = -xsize / 2.;
		double shifty = 0.;
		if (reactionRole == JMEmol.ReactionRole.REACTANT)
			shiftx = -xsize - arrowWidth / 2.;
		else if (reactionRole == JMEmol.ReactionRole.PRODUCT)
			shiftx = arrowWidth / 2.;
		else if (reactionRole == JMEmol.ReactionRole.AGENT) {
			shiftx = 0.;
			shifty = -ysize;
		} // preco nie ..+2*sd ???

		for (int i = m1; i <= m2; i++) {

			// ??? toto sposobuje problemy depictScale = 0 ???
			if (isDepict()) { // pri depicte zmensuje
				// assert(false);
				if (!scalingIsPerformedByGraphicsEngine) {
					moleculePartsList.get(i).scaleXY(molecularAreaScalePixelsPerCoord);
				}
				moleculePartsList.get(i).center(); // Once again, now reduced
			}

			// pri depict urobi aj medzeru
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				shifty += (share[i] / 2. + space);
			else
				// part == JMEmol.ReactionRole.REACTANT, JMEmol.ReactionRole.PRODUCT, or 0
				shiftx += (share[i] / 2. + space);

			// BB correction afterwards, otherwise the shiftx and shifty are too small
//			if(this.scalingIsPerformedByGraphicsEngine) {
//				shiftx /= depictScale;
//				shifty /= depictScale;
//			}

			if (!donotAlignJustScale) { // bad patch to fix a bug
				moleculePartsList.get(i).moveXY(shiftx, shifty);
				// for (int a = 1; a <= moleculeParts[i].natoms; a++) {
				// moleculeParts[i].moveXY(a, shiftx, shifty);
				// moveXY(moleculeParts[i],a, shiftx, shifty);
				// moleculeParts[i].x(a) += shiftx;
				// moleculeParts[i].y(a) += shifty;
				// }
			}

			if (reactionRole == JMEmol.ReactionRole.AGENT)
				shifty += share[i] / 2.;
			else
				shiftx += share[i] / 2.;

		}

		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// BB correction: the depictScale must be absolute
		// molecularAreaScale *= previousDepictScale; //used with iPad scaling
	}

	/**
	 * compute the space needed to display the molecular structures in the molecular
	 * area return null if there is nothing displayed includes the reaction arrow if
	 * present
	 * 
	 * @return
	 */
	public static Rectangle2D.Double getChemicalDrawingPixelBoundingBox(Graphical2DObjectGroup<?> graphicalObjecList) {

		// leave a margin around the molecule
		double margin = JMECore.RBOND / 2;
		Rectangle2D.Double boundingBox = Graphical2DObject.newBoundingBox(graphicalObjecList);
		if (boundingBox != null && !boundingBox.isEmpty()) {
			boundingBox.x -= margin;
			boundingBox.y -= margin;
			boundingBox.width += margin * 2;
			boundingBox.height += margin * 2;
		}
		return boundingBox;
	}

	/**
	 * Molecule ensemble bounding box atom label size not taken into account
	 * 
	 * @return
	 */
	public Rectangle2D.Double computeMoleculeEnsembleCoordinate2DboundingBox() {
		return this.moleculePartsList.computeCoordinate2DboundingBox();
	}

	public Boolean isMolecularAreEmpty() {
		for (JMEmol mol : moleculePartsList) {
			if (mol.natoms > 0)
				return true;
		}

		return false;

	}

	public boolean hasMarkedAtom() {
		return this.moleculePartsList.hasMarkedAtom();
	}

	/**
	 * compute the maximum scale that can be used to fit all objects in the
	 * molecular drawing area
	 * 
	 * return -1 if there is nothing to display
	 */
	public double maximumScaleDisplayArea() {
		Rectangle2D.Double boundingBox = getChemicalDrawingPixelBoundingBox(this.graphicalObjectList());

		if (boundingBox == null)
			return -1;

		Dimension box = getMolecularAreaPixelDimensions();

		double maxScale = Math.min(box.width / boundingBox.width, box.height / boundingBox.height);

		return maxScale;

	}

	protected Graphical2DObjectGroup<Graphical2DObject> graphicalObjectList(JMEmolList molList) {
		Graphical2DObjectGroup<Graphical2DObject> results = new Graphical2DObjectGroup<Graphical2DObject>();

		for (JMEmol mol : molList) {
			results.add((Graphical2DObject) mol);
		}
		if (options.reaction) {
			results.add((Graphical2DObject) reactionArrow);
		}

		return results;
	}

	protected Graphical2DObjectGroup<Graphical2DObject> graphicalObjectList() {

		return this.graphicalObjectList(this.moleculePartsList);
	}

	// --------------------------------------------------------------------------
	/**
	 * Create a V2000 MOL
	 * 
	 * @return
	 */
	public String molFile() {
		return this.molFile(false);
	}

	public String molFile(boolean isV3000) {
		return this.molFileOrRxn(null, true, isV3000, options.exportRXNmergeOption);
	}

	public String molFile(JMEWriter.MolFileOrRxnParameters pars) {

		if (pars.debugDoNotUpdateReactionRole) {
			moleculePartsList.isReaction = true;
			;
		} else {
			this.updateReactionRoles();
		}

		return moleculePartsList.generateMolFileOrRxn(pars);

	}

	public String molFileOrRxn(String header_, boolean stampDate_, boolean isV3000_, boolean mergeReationComponents) {

		JMEWriter.MolFileOrRxnParameters pars = new JMEWriter.MolFileOrRxnParameters() {
			{
				header = header_; // 1st line of the MOL
				stampDate = stampDate_;
				isV3000 = isV3000_;
				mergeReationComponents = options.exportRXNmergeOption;
			}
		};

		return this.molFile(pars);

//		// creates mol file, multipart sd file or reaction (rxn file)
//
//		if (header == null) {
//			header = smiles(); // now, otherwise for multipart cuts them
//		}
//
//		String s = "";
//		if (options.reaction) {
//			int nReactants;
//			int nProducts;
//			int nAgents;
//			int part[][] = getReactionParts();
//			if (mergeReationComponents) {
//				nReactants = 1;
//				nProducts = 1;
//				nAgents = 1;
//			} else {
//				nReactants = part[JMEmol.ReactionRole.REACTANT][0];
//				nProducts = part[JMEmol.ReactionRole.PRODUCT][0];
//				nAgents = part[JMEmol.ReactionRole.PRODUCT][0];
//
//			}
//
//			s += "$RXN" + separator + separator + separator + "JME Molecular Editor" + separator;
//			s += JMEmol.iformat(nReactants, 3) + JMEmol.iformat(nProducts, 3);
//			if (part[2][0] > 0) { // if agents are present
//				s += JMEmol.iformat(nAgents, 3);
//			}
//			s += separator;
//
//			// reactants products, agents
//			for (int role : new int[] { JMEmol.ReactionRole.REACTANT, JMEmol.ReactionRole.PRODUCT,
//					JMEmol.ReactionRole.AGENT }) {
//				if (mergeReationComponents && part[role][0] > 1) {
//					JMEmol toMerge[] = new JMEmol[part[role][0] + 1];
//					for (int mol : part[role]) {
//						toMerge[mol] = moleculeParts[mol];
//					}
//
//					JMEmol merged = new JMEmol(this, toMerge, toMerge.length);
//					s += "$MOL" + separator + merged.createMolFile(header, stampDate);
//				} else {
//					for (int i = 1; i <= part[role][0]; i++) {
//						s += "$MOL" + separator + moleculeParts[part[role][i]].createMolFile(header, stampDate);
//					}
//				}
//			}
//
//		} else { // viac molekul do 1 mol file
//			if (moleculePartsList.size() > 1)
//				// merge the molecules into one ensemble
//				activeMol = new JMEmol(this, (JMEmol[]) moleculePartsList.toArray(), moleculePartsList.size());
//			if (!isV3000)
//				s = activeMol.createMolFile(header, stampDate);
//			else // BB
//				s = activeMol.createExtendedMolFile(header, stampDate);
//
//			// ???? WHY DOES THIS CHANGE THE IN MEMORY MOL?
//			if (numberofMoleculeParts > 1)
//				activeMol = moleculeParts[actualMoleculePartIndex];
//		}
//		return s;
	}

	// --------------------------------------------------------------------------

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * 
	 * @param molecule string
	 */
	public void readMolFile(String molecule) {
		readMolFile(molecule, true);
	}

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * 
	 * @param molecule string
	 */
	public void readMolFile(String molecule, boolean repaint) {
		try {
			if (this.handleReadMolFileRXN(molecule, repaint)) {

			} else {
				repaint(); // to show errors
			}
		} catch (Exception e) {
			repaint(); // for showing the error
		}
	}

	/**
	 * Read the molfile and repaint the applet when done
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	protected boolean handleReadMolFile(String s) {
		return handleReadMolFileRXN(s, true);
	}

	/**
	 * repaint and record event
	 * 
	 * @param s
	 * @param sucessAndFailureHandler
	 */
	public void handleReadGenericInput(String s, RunAsyncCallback sucessAndFailureHandler) {
		handleReadGenericInput(s, sucessAndFailureHandler, true, true);
	}

	/**
	 * input can be a MOL, RXN, smiles or SMIRKS or OCL
	 * 
	 * @param s
	 */
	public void handleReadGenericInput(String s, RunAsyncCallback sucessAndFailureHandler, boolean repaint,
			boolean recordEvent) {

		if (s == null || s.trim().length() == 0) {
			return;
		}

		JMEReader cfd = new JMEReader(s);
		String error = null;
		boolean runAsync = false;

		this.afterStructureChangeEvent.setOrigin_API();
		// will not overwrite if already set for instance if the call is
		// coming from the GUI

		clearInfo(); // clear previous error message if any
		String afterStructureChangedEvent = null;

		do {

			if (cfd.majorChemicalFormat == JMEReader.MajorChemicalFormat.SVG && cfd.embeddedChemicalFormat != null) {
				// copy the embedded chemical format to cfd
				cfd.init(cfd.embeddedChemicalFormat);
			}
			if (cfd.author == JMEReader.Author.MDL && cfd.minorChemicalFormat != JMEReader.MinorChemicalFormat.V3000) {
				// bug: handling "|" as a line separator

				// TODO : handleReadMolFileRXN is async because of the 2D coordinate computation
				if (!JME.this.handleReadMolFileRXN(cfd.chemicalString, false)) // will do repaint later after event
																				// recording
					error = "Invalid V2000 molfile";
				else {
					afterStructureChangedEvent = cfd.isReaction() ? READ_RXN_FILE : READ_MOL_FILE;
				}
				break;
			}

			if (cfd.author == JMEReader.Author.P_ERTL) {
				if (!readMolecule(cfd.chemicalString, false)) { // will do repaint later after event recording
					error = "Invalid JME string";
				} else {
					afterStructureChangedEvent = READ_JME;
				}
				break;
			}
			if (cfd.author == JMEReader.Author.IUPAC
					|| cfd.majorChemicalFormat == JMEReader.MajorChemicalFormat.CSRML) {
				// GWT: <set-configuration-property name="compiler.enum.obfuscate.names"
				// value="false" /> otherwise the number of the enum is shown instead of its
				// name
				error = "Reading " + cfd.majorChemicalFormat + " is not supported";
				break;
			}

			if (options.useOpenChemLib) {
				runAsync = true;
				// code splitting used to run OpenChemlib code
				JMEUtil.runAsync(new JSME_RunAsyncCallback() {

					/**
					 * @j2sAlias onSuccess
					 */
					@Override
					public void onSuccess() {
						oclSuccess(cfd, sucessAndFailureHandler, recordEvent, repaint);
					}
				});

				break;
			}

		} while (false);

		if (!runAsync) {

			if (error == null && recordEvent && afterStructureChangedEvent != null) {
				JME.this.recordAfterStructureChangedEvent(afterStructureChangedEvent); // the event will be fired after
																						// the repaint() has completed
			}

			// duplicated code with the one inside the runAsync block
			// used for debugging JS code
			setMustRedrawMolecularArea(error == null);
			if (sucessAndFailureHandler != null) {
				if (error == null) {
					sucessAndFailureHandler.onSuccess();
				} else {
					sucessAndFailureHandler.onFailure(new Exception(error));
				}
			} else {
				if (error != null) {
					showError(error);
				}

			}

			if (error == null && repaint) {
				repaint();

			}
		}

	}

	protected void oclSuccess(JMEReader cfd, RunAsyncCallback sucessAndFailureHandler, boolean recordEvent,
			boolean repaint) {
		String error = null;
		String convertedmolFile = null;
		String afterStructureChangedEvent = null;

		if (cfd.author == JMEReader.Author.MDL && cfd.minorChemicalFormat == JMEReader.MinorChemicalFormat.V3000) {
			try {
				convertedmolFile = v3000toV2000MOL(cfd.chemicalString);
				if (convertedmolFile == null) {
					throw new Exception("V3000 read failed.");
				}
				afterStructureChangedEvent = READ_MOL_FILE;
				sdfPastedMessage.innnerString = "V3000 conversion provided by OpenChemLib";
			} catch (Exception e) {
				error = e.getMessage();
			}
		} else {
			if (cfd.author == JMEReader.Author.DAYLIGHT) {
				try {
					convertedmolFile = SMILESorSMIRKStoMolOrRXN(cfd.chemicalString);
					if (cfd.majorChemicalFormat == MajorChemicalFormat.SMIRKS)
						afterStructureChangedEvent = READ_SMIRKS;
					else if (cfd.majorChemicalFormat == MajorChemicalFormat.SMILES)
						afterStructureChangedEvent = READ_SMILES;

					sdfPastedMessage.innnerString = "SMILES conversion provided by OpenChemLib";

				} catch (Exception e) {
					error = "SMILES parsing error:" + e.getMessage();
				}
			} else {
				error = "Invalid or unsupported input";
				if (options.useOclIdCode && cfd.couldBeOclIdCode()) {
					// try to parse OCL if not SMILES
					// ChemicalFormatDetector can not detect OCLcode
					try {
						convertedmolFile = OclCodeToMOL(cfd.chemicalString);
						afterStructureChangedEvent = READ_OCLCODE;
						error = null;
					} catch (Exception e) {

					}
				}
			}
		}

		boolean success = false;
		if (convertedmolFile != null && error == null) {
			try {
				success = handleReadMolFileRXN(convertedmolFile, false);
				if (success && recordEvent) {
					assert (afterStructureChangedEvent != null);
					recordAfterStructureChangedEvent(afterStructureChangedEvent);

				}
			} catch (Exception e) {
				error = "Invalid converted molfile";
			}
		}
		setMustRedrawMolecularArea(success);

		if (sucessAndFailureHandler != null) {
			if (success) {
				sucessAndFailureHandler.onSuccess();
			} else {
				assert (error != null);
				sucessAndFailureHandler.onFailure(new Exception(error));
			}
		} else {
			if (error != null) {
				showError(error);
			}

		}
		if (repaint) {
			repaint();
			// drawMolecularAreaRightNow(); //does not work if called from start(),
			// molecularAreaImage is not initialized
		}

	}

	/**
	 * Returns the graphics representation used in the molecular area, either a SVG
	 * or a VML string This is avalailable only in JavaScript implementation
	 * 
	 * @return a string that can be used in a DOM element innerHTML
	 */

	public String getMolecularAreaGraphicsString() {
		return null;
	}

	/**
	 * Read the input structure (all chemical structure formats supported by JSME)
	 * Update the editor display. An event will be reported if successful.
	 * 
	 * @param s
	 */
	// public JSME interface
	public void readGenericMolecularInput(String s) {
		this.readGenericMolecularInput(s, true);
	}

	/**
	 * Read the input structure (all chemical structure formats supported by JSME)
	 * Update the editor display.
	 * 
	 * @param s
	 * @param recordEvent
	 */
	public void readGenericMolecularInput(String s, boolean recordEvent) {
		this.handleReadGenericInput(s, null, true, recordEvent);
	}

	public String getOclCode() {
		String molFile = this.molFileOrRxn(null, false, true, false);
		return getParser().getOclCode(molFile);
	}

	/**
	 * Generate SVG representation of the molecule Use OpenChem lib SVG generator.
	 * 
	 * @return
	 */
	public String getOclSVG() {
		String molFile = this.molFileOrRxn(null, false, true, false); // use v3000
		return getParser().getOclSVG(molFile);
	}

	/**
	 * Use the openchemlib to convert a OCL code to a molfile string TODO: what
	 * about 2D coordinates?
	 * 
	 * @param oclCode
	 * @return
	 */
	public String OclCodeToMOL(String oclCode) {
		return getParser().OclCodeToMOL(oclCode);
	}

	/**
	 * Use the openchemlib to convert a smiles to a molfile string 2D coordinates
	 * are generated
	 * 
	 * @param smiles
	 * @return
	 * @throws Exception
	 */
	public String SMILEStoMOL(String smiles) throws Exception {
		return getParser().SMILEStoMOL(smiles);
	}

	/**
	 * Use the openchemlib to convert a smirks to a rxn string 2D coordinates are
	 * generated. The individual reaction components are not further split into
	 * molecules (see handleReadMolFileRXN() )
	 * 
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	public String SMIRKStoRXN(String smirks) throws Exception {
		String[] parts = smirks.split(">");
		assert parts.length >= 1 && parts.length <= 3;

		// JS and Java behave differently for string split
		// "bla>>" => 3 parts in JS
		// => 1 part in Java

		// JMEmol newParts[] = mol.splitMultiparts()

		boolean hasProducts = parts.length >= 3 && parts[2].length() > 0;
		boolean hasAgents = parts.length >= 2 && parts[1].length() > 0;

		String reactants = this.SMILEStoMOL(parts[0]);

		String products = hasProducts ? this.SMILEStoMOL(parts[2]) : this.SMILEStoMOL("");
		String agents = hasAgents ? this.SMILEStoMOL(parts[1]) : this.SMILEStoMOL("");

		String s = "";

		s += "$RXN" + separator + separator + separator + "JME Molecular Editor" + separator;
		s += JMEUtil.iformat(1, 3) + JMEUtil.iformat(1, 3);
		if (hasAgents)
			s += JMEUtil.iformat(1, 3);

		s += separator;
		s += "$MOL" + separator + reactants;
		s += "$MOL" + separator + products;
		// not standard
		if (hasAgents)
			s += "$MOL" + separator + agents;

		return s;
	}

	/**
	 * to be completed - used only for the test suite read the modulator as well,
	 * should we (re)use the JME string input code for reaction?
	 * 
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	public boolean readSmirks(String smirks) throws Exception {

		String convertedmolFile = SMILESorSMIRKStoMolOrRXN(smirks);

		this.handleReadMolFileRXN(convertedmolFile, false);

		return true;
	}

	/**
	 * Use the openchemlib to convert a V3000 MOL to a V2000 molfile string
	 * 
	 * @param v3000
	 * @return
	 * @throws Exception
	 */
	public String v3000toV2000MOL(String v3000Mol) throws Exception {
		return getParser().v3000toV2000MOL(v3000Mol);
	}

	public static Parser getParser() {
		return (oclAdapter == null ? (oclAdapter = (Parser) getInterface(parserImpl)) : oclAdapter);
	}

	protected static Object getInterface(String name) {
		try {
			Class<?> x = Class.forName(name);
			return (x == null ? null : x.newInstance());
		} catch (Exception e) {
			System.out.println("Interface.getInterface Error creating instance for " + parserImpl + ": \n" + e);
			return null;
		}
	}

	/**
	 * Use the openchemlib to convert a smiles or a smirks to a mol or rxn string 2D
	 * coordinates are generated
	 * 
	 * @param smilesOrsmirks
	 * @return
	 * @throws Exception
	 */
	public String SMILESorSMIRKStoMolOrRXN(String smilesOrsmirks) throws Exception {
		if (smilesOrsmirks.contains(">")) {
			return this.SMIRKStoRXN(smilesOrsmirks);
		} else {
			return this.SMILEStoMOL(smilesOrsmirks);
		}

	}

	/**
	 * Used for testing without GUI
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	public boolean readMolFileOrRXN(String s) {
		return this.handleReadMolFileRXN(s, false);
	}

	boolean canBeAddedToExistingMultipartOrReaction() {
		return ((options.reaction || options.multipart) && options.addNewPart) || newMolecule;
		// newMolecule is true if NEW button is pushed
	}

	void processIncomingMolecules(JMEmolList newMolecules, boolean repaint) {

		if (!newMolecules.isReallyEmpty()) {

			if (this.params.internalBondScalingForInput) {
				newMolecules.internalBondLengthScaling();
			}
			activeMol = processIncomingMolecules(newMolecules);
			if (newMolecule) {
				newMolecule = false; // addition performed, cancel NEW option
				gui.mustReDrawTopMenu = true;
			}
			if (repaint && !headless) {
				drawMolecularAreaRightNow();
				if (gui.mustReDrawTopMenu) {
					gui.drawTopMenu(getGraphics());
				}

			}

		}

	}

	/**
	 * For all molecules:
	 * 
	 * 1) assign the JME field
	 * 
	 * 2) recompute aromaticity
	 * 
	 * 3) compute 2D coord if they are missing
	 * 
	 * 4) scale, color, and add it to the list of mols
	 * 
	 * @param newMolecules
	 * @return the new mol
	 */
	JMEmol processIncomingMolecules(JMEmolList newMolecules) {

		if (newMolecules.isReallyEmpty()) {
			return activeMol;
		}

		// New Jan 2019
		for (int i = 0; i < newMolecules.size(); i++) {
			JMEmol mol = newMolecules.get(i);
			mol.jme = this;

			//// HERE USE OCL LIB !!!!!!
			mol = mol.reComputeBondOrderIfAromaticBondType();

			if (mol != null) {
				newMolecules.set(i, mol);
			}

			//// HERE USE OCL LIB !!!!!!
			// Bug: ensemble does not work correctly
			// Feb 2020
			mol = mol.compute2DcoordinatesIfMissing();
			if (mol != null) {
				newMolecules.set(i, mol);
			}

		}
		// Feb 2020
		newMolecules.scaleInternalBondMolList();
		if (newMolecules.isReaction()) {
			processIncomingReaction(newMolecules);
		} else {
			processIncomingMoleculeGroup(newMolecules);
		}

		// coloring tu, inak pri multiupart problemy
		moleculePartsList.setAtomBackGroundColors(atomBgColors);
		assert (moleculePartsList.size() > 0);
		return newMolecules.first();
	}

	private void processIncomingMoleculeGroup(JMEmolList newMolecules) {
		if (isDepict() || pasteFromSDFstack) { // BB let the incoming structure determine the editor mode when in
			// depict mode
			options.reaction = false;
			// multipart = false;
		}
		boolean addedToExistingMultipartOrReaction = canBeAddedToExistingMultipartOrReaction();

		if (!addedToExistingMultipartOrReaction) {
			moleculePartsList.removeAll(); 
			// the new parts will not be appended to the moleculeParts[]
			resetMolecularAreaScale(); 
			// could be an option
		}

		double scale = isDepict() ? 1.0 : molecularAreaScalePixelsPerCoord; // in depict mode, the scale will be
		// recomputed afterwards
		centerAllMoleculesAsAgroup(graphicalObjectList(newMolecules), scale);

		if (!isDepict()) { 
			// solve the cross fragment issue with atom highlighting based on atom indices
			// (CT3 chemotyper-like display)
			newMolecules.splitFragments(true);
		}
		moleculePartsList.addAll(newMolecules); 
		// newMolecules must be internal scaled and centered as a group
		// before addition
		if (isDepict()) {
			// if the molecules are too big to fit => recompute the scale
			molecularAreaScalePixelsPerCoord = scaleAndCenterForDepictMode(graphicalObjectList(moleculePartsList));
		}
	}

	private void processIncomingReaction(JMEmolList newMolecules) {
		options.reaction = true;
		options.multipart = true;
		double spacing = JMECore.RBOND;
		Graphical2DObjectGroup<Graphical2DObjectGroup<Graphical2DObject>> groups = new Graphical2DObjectGroup<Graphical2DObjectGroup<Graphical2DObject>>();

		Graphical2DObjectGroup<Graphical2DObject> agentGroup = null;

		for (int role : JMEmol.ReactionRole.all) {
			JMEmolList mols = newMolecules.reactionParts(role);

			Graphical2DObjectGroup<Graphical2DObject> group = new Graphical2DObjectGroup<Graphical2DObject>();
			group.addAll(mols.asGroup());

			if (role != JMEmol.ReactionRole.AGENT) {
				group.distributePositions(Box.Axis.X, spacing, true);
				group.alignCenter(Box.Axis.Y);

			} else {

				// reaction agents on top and below the arrow
				int pos = (int) ((0.5 * group.size()) + 0.5);
				group.add(pos, reactionArrow);
				group.distributePositions(Box.Axis.Y, spacing, false);
				group.alignCenter(Box.Axis.X);// this is centering along Y axis

				agentGroup = group;

			}

			groups.add(group);

		}

		groups.distributePositions(Box.Axis.X, spacing, false);
		groups.alignCenter(Box.Axis.Y); // this is centering along x axis

		// move the agent group such that it is aligned with the center of the two other
		// groups
		assert (agentGroup != null && agentGroup.size() >= 1); // the agent group contains the arrow
		Graphical2DObject.move(agentGroup, Box.Axis.Y, agentGroup.centerY() - reactionArrow.centerY());

		// new June 2017: split the reaction components if needed after the alignment is
		// done
		// such that each molecule can be moved individually
		// the coordinates are not changed
		newMolecules.splitFragments(true);

		// addedToExistingMultipartOrReaction is not implemented
		// would be much more complex
		moleculePartsList.removeAll();
		moleculePartsList.addAll(newMolecules);

		// For reaction, it is better to scale down if this a big reaction
		molecularAreaScalePixelsPerCoord = this.scaleAndCenterForDepictMode(graphicalObjectList(moleculePartsList));

	}

	/**
	 * generate an afterStructureChangedEvent
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	boolean handleReadMolFileRXN(String s, boolean repaint) {

		JMEmolList inputMolList = new JMEmolList();
		boolean success = inputMolList.readMDLstringInput(s, this.params);
		if (success && !inputMolList.isReallyEmpty()) {
			this.processIncomingMolecules(inputMolList, repaint);
		}

		return success;
	}

	public int findMaxAtomMapAmongAllMolecules() {
		return moleculePartsList.findMaxAtomMap();
	}

	public boolean isActionEnabled(int action) {

		switch (action) {
		case Actions.ACTION_AN_R:
			return options.rButton;
		case Actions.ACTION_QRY:
			return options.query;
		case Actions.ACTION_STEREO:
			return options.stereo;
		case Actions.ACTION_NEW:
			return options.multipart;
		case Actions.ACTION_MARK:
			// WHEN marker option is set than, number is set but not automumber
			// BH?? this description does not fit the logic:
//			if (selectedAction == Actions.ACTION_MARK && !(this.params.number || options.autonumber))
//				return false;
			if (!(this.params.number || options.autonumber))
				return false;
			// from below.
			// BH?? Then is the logic in mouseDown wrong? without params.mark?
			return !options.starNothing && params.mark;
		case Actions.ACTION_REACP:
			return options.reaction;
		case Actions.ACTION_MOVE_AT:
			return options.showAtomMoveJButton;
		}
		return true;
	}

	public void dialogActionX() {
		if (action != Actions.ACTION_AN_X) {
			action = Actions.ACTION_AN_X;
			active_an = Atom.AN_X;
		}
	}

	/**
	 * Filter out actions based on options.
	 * 
	 * @param action
	 * @return false only if explicitly disallowed
	 */
	private boolean isMouseDownActionAllowed(int action) {
		// something subtle about this and isActionEnabled
		switch (action) {
		default:
			return true;
		case Actions.ACTION_AN_X:
			return options.xButton;
		case Actions.ACTION_QRY:
			return options.query;
		case Actions.ACTION_STEREO:
			return options.stereo;
		case Actions.ACTION_NEW:
			return options.multipart;
		case Actions.ACTION_MARK:
			// BH?? What about !options.starNothing && params.mark in isActionEnabled() ?
			return (params.number || options.autonumber);
		case Actions.ACTION_REACP:
			return options.reaction;
		}
	}

	// called from JavaScript menu, sets Rgroup
	public void setSubstituent(String s) {
		// substituent menu
		if (s.equals("Select substituent")) {
			action = Actions.ACTION_BOND_SINGLE;
			s = "";
		} else if (s.equals("-C(=O)OH"))
			action = Actions.ACTION_GROUP_COO;
		else if (s.equals("-C(=O)OMe"))
			action = Actions.ACTION_GROUP_COOME;
		else if (s.equals("-C(=O)N"))
			action = Actions.ACTION_GROUP_CON;
		else if (s.equals("-NC=O"))
			action = Actions.ACTION_GROUP_NCO;
		else if (s.equals("-OC(=O)Me"))
			action = Actions.ACTION_GROUP_OCOME;
		else if (s.equals("-CMe3"))
			action = Actions.ACTION_GROUP_TBU;
		else if (s.equals("-CF3"))
			action = Actions.ACTION_GROUP_CF3;
		else if (s.equals("-CCl3"))
			action = Actions.ACTION_GROUP_CCL3;
		else if (s.equals("-NO2"))
			action = Actions.ACTION_GROUP_NITRO;
		else if (s.equals("-NMe2"))
			action = Actions.ACTION_GROUP_NME2;
		else if (s.equals("-SO2-NH2"))
			action = Actions.ACTION_GROUP_SO2NH2;
		else if (s.equals("-NH-SO2-Me"))
			action = Actions.ACTION_GROUP_NHSO2ME;
		else if (s.equals("-SO3H"))
			action = Actions.ACTION_GROUP_SULFO;
		else if (s.equals("-PO3H2"))
			action = Actions.ACTION_GROUP_PO3H2;
		else if (s.equals("-C#N"))
			action = Actions.ACTION_GROUP_CYANO;
		else if (s.equals("-C#C-Me"))
			action = Actions.ACTION_GROUP_CCC;
		else if (s.equals("-C#CH"))
			action = Actions.ACTION_GROUP_CC;

		if (action > 0) {
			processMenuAction(action);
		} else
			s = "Not known group!";
		info(s);
		repaint();
	}

	protected void setRemoveHsC() {
		this.params.hydrogenParams.removeHs = true;
		this.params.hydrogenParams.removeOnlyCHs = true;
	}

	public void log(String string) {
		System.err.println(string);
	}

	protected void resetAllGraphics() {
		// for subclass
		this.mustRedrawEverything();

		this.molecularAreaImage = null;
		this.topMenuImage = null;
		this.leftMenuImage = null;
		this.infoAreaImage = null;
		this.rightBorderImage = null;

	}

	/**
	 * See also getCopyPasteJPopupMenuMol() and getCopyPasteJPopupMenuReaction()
	 */
	protected void resetJPopupMenu() {
		this.copyPasteJPopupMenuMol = null;
		this.copyPasteJPopupMenuReaction = null;

	}

	/**
	 * Ignore bonds during mouse over
	 * 
	 * @return
	 */
	protected boolean ignoreBonds() {
		return action == Actions.ACTION_MARK && (options.starNothing || options.starAtomOnly)
				|| action == Actions.ACTION_MOVE_AT || action == Actions.ACTION_CHAIN || action == Actions.ACTION_SPIRO
				|| action == Actions.ACTION_CHARGE
				|| (action >= Actions.ACTION_GROUP_MIN && action <= Actions.ACTION_AN_R_LAST
						|| (action == Actions.ACTION_MARK && !params.mark)
				// case for 123 button - atom
				// mapping June 2020

				);
	}

	/**
	 * ignore atoms during mouse over
	 * 
	 * @return
	 */
	protected boolean ignoreAtoms() {
		return (/* action == Actions.ACTION_STEREO || */
		((options.starNothing || options.starBondOnly) && action == Actions.ACTION_MARK));
	}

	// --------------------------------------------------------------------------
	public void setText(String text) {
		molText = text;
		repaint();
	}

	// --------------------------------------------------------------------------
	public void showAtomNumbers() {
		// shows canonical atom numbering
		// numbers only actual molecule !!!
		if (activeMol != null)
			activeMol.numberAtomsSequentially();
	}

	// ----------------------------------------------------------------------------
	// --- end of public functions
	// ------------------------------------------------
	// ----------------------------------------------------------------------------
	@Override
	public void paint(Graphics g) {
		if (gui == null || dimension.width == 0)
			return;
		/* The java applet viewer calls this method when the applet window is resized */
		// Graphics g2 = g.create();
		update(g);
		// requestFocus(); // kvoli key action
		// g2.dispose();
	}

	/**
	 * for mouse actions
	 * 
	 * @param screenX
	 * @param screenY
	 * @return
	 */
	protected boolean isOutsideDrawingArea(int screenX, int screenY) {
		screenX -= leftMenuWidth();
		screenY -= topMenuHeight();
		return (screenX < 0 || screenX > molecularArea.width || screenY < 0 || screenY > molecularArea.height);
	}

	public boolean isInMolecularArea(int x, int y) {
		return (isDepict() || x >= leftMenuWidth() && x <= dimension.width - rightBorder() && y >= topMenuHeight()
				&& y <= dimension.height - infoAreaHeight());
	}

	/**
	 * Should be called after any applet size change
	 * 
	 * @param d
	 */
	protected void updateMyMolecularAreaSize() {
		if (dimension == null) {
			dimension = getSize();
		}
		molecularArea = getMolecularAreaPixelDimensions();
	}

	protected Dimension getMolecularAreaPixelDimensions() {
		return new Dimension(
				dimension.width - (int) (isDepict() ? 0 : leftMenuWidth(menuScale) + rightBorder(menuScale)),
				dimension.height - (int) (isDepict() ? 0 : topMenuHeight(menuScale) + infoAreaHeight(menuScale)));
	}

	/**
	 * Return the bounding box of the molecular area (screen pixel, including menu
	 * offsets)
	 * 
	 */
	Rectangle.Double getMolecularAreaPixelBoundingBox() {
		Dimension d = getMolecularAreaPixelDimensions();
		return new Rectangle.Double(isDepict() ? 0 : leftMenuWidth(menuScale),
				isDepict() ? 0 : topMenuHeight(menuScale), d.width, d.height);

	}

	protected Rectangle.Double getMolecularAreaBoundingBoxCoordinate(double pixelsPerCoord) {
		Rectangle.Double bbox = getMolecularAreaPixelBoundingBox();
		assert (pixelsPerCoord > 0);
		bbox.x = 0;
		bbox.y = 0;
		bbox.width /= pixelsPerCoord;
		bbox.height /= pixelsPerCoord;
		return bbox;

	}

	/**
	 * Return the width and height of the molecular area with scaling
	 * 
	 */
	protected Rectangle.Double getMolecularAreaCoordBoundingBox() {
		return getMolecularAreaBoundingBoxCoordinate(molecularAreaScalePixelsPerCoord);
	}

	// ----------------------------------------------------------------------------
	@Override
	public void update(Graphics g2d) {
		// pri fill ma rectangle sirku a vysku presne, pri draw o 1 vacsiu
		// Dimension d = getSize();

		// BB" try to avoid mutilple calls to size() and alignMolecules()

		// Note: Applet has a resize method() that we could override
		boolean initOrResize;
		appletHasBeenResized = false;
		assert (dimension != null); // dimension was initialized by init()()
		if (molecularAreaImage == null) {
			initOrResize = true;
		} else {
			Dimension newDimension = getSize();

			// find out if the size of the applet has changed
			initOrResize = (newDimension.width != dimension.width) || (newDimension.height != dimension.height);

			if (initOrResize) { // if applet has a new size

				dimension = newDimension;
				appletHasBeenResized = true;
			}
		}

		if (initOrResize) {
			mustRedrawEverything();
			updateMyMolecularAreaSize();
//			log("update(): " + dimension + " " + "initOrResize: " + initOrResize + " " + molecularAreaWidth + " "
//					+ molecularAreaHeight);

			// compute or resize the graphics
			molecularAreaImage = createOrResizePreciseImage(molecularAreaImage, molecularArea.width,
					molecularArea.height);

			if (isDepict()) {
				// depict mode
				double oldMolecularAreaScale = this.molecularAreaScalePixelsPerCoord;

				// will recompute the molecular area scale
				this.molecularAreaScalePixelsPerCoord = this.scaleAndCenterForDepictMode(this.graphicalObjectList());

				log("update() in depict mode: oldMolecularAreaScale = " + oldMolecularAreaScale
						+ " new   molecularAreaScale = " + molecularAreaScalePixelsPerCoord);

				assert topMenuImage == null;
				assert leftMenuImage == null;
				assert infoAreaImage == null;
				assert rightBorderImage == null;

			} else {
				// update the menu's and the info area

				topMenuImage = createOrResizePreciseImage(topMenuImage, dimension.width, topMenuHeight());
				double imageh = dimension.height - topMenuHeight();
				if (imageh < 1)
					imageh = 1;
				// leftMenu = createOrResizeImage(leftMenu, menuCellSize, imageh);
				this.leftMenuImage = createOrResizePreciseImage(this.leftMenuImage, this.leftMenuWidth(), imageh);

				infoAreaImage = createOrResizePreciseImage(infoAreaImage, molecularArea.width + rightBorder(),
						infoAreaHeight());

				rightBorderImage = createOrResizePreciseImage(rightBorderImage, rightBorder(),
						this.molecularArea.height);
			}
		}

		// draw the parts
		drawMolecularArea(g2d, null);

		// draw the parts
		if (!isDepict()) {
			gui.draw(g2d);
		}
		this.postInitializeIfNeeded();

	}

	/**
	 * Method that is overridden in JSME in order to avoid the creation of multiple
	 * SVG's during a window resize
	 * 
	 * @param img
	 * @param width
	 * @param height
	 * @return a new Image in JME or the same image if the argument img is not null
	 *         in JSME
	 */
	public Image createOrResizeImage(Image img, int width, int height) {
		return createImage(width, height);
	}

	public PreciseImage createOrResizePreciseImage(PreciseImage img, double width, double d) {
		return new PreciseImage(createOrResizeImage(img == null ? null : img.getImage(), (int) (Math.round(width)),
				(int) (Math.round(d))));
	}

	public static void atomicData() {
		for (int i = Atom.AN_METAL1_START; i <= Atom.AN_R_LAST; i++) {
			if (Atom.chargedMetalType(i) > 0) {
				color[i] = Color.darkGray;
			} else {
				color[i] = Color.orange;
			}
		}
		color[Atom.AN_H] = Color.darkGray;
		color[Atom.AN_B] = Color.orange;
		color[Atom.AN_C] = Color.darkGray;
		color[Atom.AN_N] = Color.blue;
		color[Atom.AN_O] = Color.red;
		color[Atom.AN_F] = Color.magenta;
		color[Atom.AN_CL] = Color.magenta;
		color[Atom.AN_BR] = Color.magenta;
		color[Atom.AN_I] = Color.magenta;
		color[Atom.AN_S] = Color.yellow.darker();
		color[Atom.AN_P] = Color.orange;
		color[Atom.AN_SI] = Color.darkGray;
		color[Atom.AN_SE] = Color.darkGray;
		color[Atom.AN_X] = Color.darkGray;
	}

	static {
		atomicData();
	}

	// direct
	public void drawMolecularAreaRightNow() {
		this.setMustRedrawMolecularArea(true);
		if (molecularAreaImage != null) { // must be initialized
			Graphics g = getGraphics().create();
			drawMolecularArea(g, null);
			g.dispose();
			this.setMustRedrawMolecularArea(false);
		} else {
			this.repaint();
		}

	}

	// ----------------------------------------------------------------------------
	/**
	 * Draw the molecule either to this panel's graphics or to the specified image.
	 * 
	 * When drawing to an image, use the coordOffsets.
	 * 
	 * @param g
	 * @param margin
	 */
	BufferedImage drawMolecularArea(Graphics g, Point margins) {

		// BB
		BufferedImage img = null;
		Point coordOffset = null;
		boolean needRecenter = activeMol.needRecentering;
		if (g == null) {
			Rectangle.Double coordBox = activeMol.computeBoundingBoxWithAtomLabels(null);
			double f = molecularAreaScalePixelsPerCoord;
			img = new BufferedImage((int) (coordBox.getWidth() * f) + margins.x * 2,
					(int) (coordBox.getHeight() * f) + margins.y * 2, BufferedImage.TYPE_INT_ARGB);
			activeMol.needRecentering = false;
			coordOffset = new Point((int) (margins.x / f - coordBox.x), (int) (margins.y / f - coordBox.y));
		} else if (g != null && !gui.mustReDrawMolecularArea) {
			return null;
		}

		// new sept 2016
		// FIXme: should not be done here
		if (this.params.computeValenceState) {
			if (this.afterStructureChangeEvent != null && this.afterStructureChangeEvent.action != null) {
				if (this.afterStructureChangeEvent.action != UNDO && this.afterStructureChangeEvent.action != REDO) {
					for (JMEmol mol : moleculePartsList) {
						mol.cleanAfterChanged(options.polarnitro);
					}
				}
			}
		}

		double imgWidth = (img != null ? img.getWidth() : molecularArea.width);
		double imgHeight = (img != null ? img.getHeight() : molecularArea.height);

		// screen area in pixel
		Rectangle2D.Double molecularScreenArea = new Rectangle2D.Double(leftMenuWidth(), topMenuHeight(), imgWidth,
				imgHeight);

		PreciseGraphicsAWT og = GUI.getScaledGraphicsOfPreciseImage(
				(img == null ? molecularAreaImage : new PreciseImage(img)), molecularAreaScalePixelsPerCoord,
				molecularScreenArea);

		og.setColor(canvasBg);

		double coordWidth = imgWidth / this.molecularAreaScalePixelsPerCoord;
		double coordHeight = imgHeight / this.molecularAreaScalePixelsPerCoord;

		og.fillRect(0, 0, coordWidth, coordHeight);

		if (coordOffset != null) {
			og.translate(coordOffset.x, coordOffset.y);
		}

		// BB custom antialias and line width for the molecular drawing area
		Object valueAntiAlias = molecularAreaAntiAlias ? RenderingHints.VALUE_ANTIALIAS_ON
				: RenderingHints.VALUE_ANTIALIAS_OFF;
		og.setRenderingHint(RenderingHints.KEY_ANTIALIASING, valueAntiAlias);

		og.setStroke(new BasicStroke(molecularAreaLineWidth));

		if (img == null && (fullScreenEnterOrExit || (this.appletHasBeenResized && previousScaledScreenArea != null))) {
			Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList = this.graphicalObjectList();
			centerAllMoleculesAsAgroup(graphicalObjecList, molecularAreaScalePixelsPerCoord);
			fullScreenEnterOrExit = false;
		}

		for (JMEmol mol : moleculePartsList) {
			mol.draw(og);
		}

		if (img != null) {
			activeMol.needRecentering = needRecenter;
			return img;
		}

		if (previousScaledScreenArea == null)
			previousScaledScreenArea = new Rectangle2D.Double();
		previousScaledScreenArea.width = coordWidth;
		previousScaledScreenArea.height = coordHeight;

		// arrow
		if (options.reaction) {
			// if the reaction arrow is not initialized
			if (!this.reactionArrow.hasBeenPlaced) { // FIXME: to be removed?
				this.reactionArrow.XY(imgWidth / 2, imgHeight / 2);
			}
			this.reactionArrow.draw(og);
		}

		// molText and DnD icon
		if (isDepict()) { // kvoli molText, ale aj depict dalsej molekuly
			if (molText != null) {
				int w = GUI.menuCellFontMet.stringWidth(molText);
				double xstart = (imgWidth - w) / 2.;
				double ystart = imgHeight - GUI.fontSize;
				og.setColor(Color.black);
				og.setFont(GUI.menuCellFont);
				og.drawString(molText, xstart, ystart);
			}

			// draw the DnD icon
			if (options.showDragAndDropIconInDepictMode)
				// DnD icom is made smaller than the non depict one
				gui.drawDragAndDropIcon(og, smallerIconsForDepictMode / this.molecularAreaScalePixelsPerCoord);
			else
				gui.dragAndDropIcon = null;

			// FIXME
			// on the left of the DnD icon
			// scaling does not work - because a resize event recomputed the
			// molecularAreaScale
//			if(fullScreenIconOption && showFullScreenIconInDepictMode)
//				this.drawFullScreenIcon(og, imgWidth, imgHeight, smallerIconsForDepictMode /this.molecularAreaScale, this.dragAndDropIcon);
		}

		g.drawImage(molecularAreaImage.getImage(), og.screenX(), og.screenY(), this);
		this.setMustRedrawMolecularArea(false);

		// New September 2016
		// handle the postSave and the event to JS
		if (this.saveCurrentState) {
			this.postSave();
			this.saveCurrentState = false;
		}
		if (this.afterStructureChangeEvent != null && this.afterStructureChangeEvent.action != null) {
			// mol.cleanAfterChanged();
			notifyStructuralChange("draw");
			// this.afterStructureChangeEvent.reset();

			// BB new Feb 2017
			// disable the NEW button after structure change
			if (newMolecule == true) {
				newMolecule = false;
				gui.mustReDrawTopMenu = true;
				repaint();
			}
		}
		return null;
	}

	public void centerAllMoleculesAsAgroup(Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList,
			double molecularAreaScalePixelsPerCoord) {

		if (dimension == null)
			return;
//		if (options.reaction)
//			return; // not implemented yet
		// this.appletHasBeenResized = false;

		Rectangle2D.Double chemicalDrawingBoundingBox = getChemicalDrawingPixelBoundingBox(graphicalObjecList);
		if (chemicalDrawingBoundingBox == null)
			return;
		// molecule coordinate
		Rectangle2D.Double appletMolBoundingBox = this
				.getMolecularAreaBoundingBoxCoordinate(molecularAreaScalePixelsPerCoord);
		double dx = appletMolBoundingBox.getCenterX() - chemicalDrawingBoundingBox.getCenterX();
		double dy = appletMolBoundingBox.getCenterY() - chemicalDrawingBoundingBox.getCenterY();

		for (Graphical2DObject each : graphicalObjecList.group) {
			each.moveXY(dx, dy);
		}
		// molecules.moveXY(dx, dy);

	}

	/*
	 * to be redefined in JSME
	 */
	public static boolean isFullScreenSupported() {
		//
		return true;
	}

	/**
	 * Java applet only. FIXME: recompute bond center?
	 */
	protected void toggleFullScreen() {
		this.mustRedrawEverything();
		Dimension newDim;
		Dimension frameSize = (myFrame == null ? null : myFrame.getSize());
		if (!isFullScreen && myFrame != null && myFrame.getExtendedState() == JFrame.MAXIMIZED_BOTH)
			return;
		if (isFullScreen) {
			molecularAreaScalePixelsPerCoord = nonFullFrameMolecularAreaScalePixelsPerCoord;
			menuScale = nonFullScreenMenuScale;
			newDim = nonFullScreenSize;
			if (myFrame != null) {
				myFrame.setResizable(true);
				myFrame.setVisible(false);
				myFrame.setSize(nonFullFrameSize);
				myFrame.setLocation(nonFullFrameLocation);
				myFrame.setVisible(true);
			}
		} else {
			// save current dimension
			nonFullScreenMenuScale = menuScale;
			nonFullScreenSize.setSize(this.dimension.width, this.dimension.height);
			nonFullFrameMolecularAreaScalePixelsPerCoord = molecularAreaScalePixelsPerCoord;
			if (myFrame != null) {
				nonFullFrameSize = frameSize;
				nonFullFrameLocation = myFrame.getLocation();
				myFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);
				myFrame.setResizable(false);
				newDim = myFrame.getContentPane().getSize();
			} else {
				newDim = Toolkit.getDefaultToolkit().getScreenSize();
			}
			molecularAreaScalePixelsPerCoord = Math.min(molecularAreaScalePixelsPerCoord * fullScreenScale,
					maxMolecularAreaScale);
			menuScale = Math.min(menuScale * fullScreenScale, maxMenuScale);
		}
		isFullScreen = !isFullScreen;
		this.setSize(newDim);
	
	}

	// ----------------------------------------------------------------------------
	boolean processMenuAction(int thisAction) {
		// calling actions after pressing menu button or actions initiated
		// from mousePressed() or keyPressed()

		// idea: this.atomTypeChangeAction = true; //atom type selected or FG or query
		// box
		// mouseover would only highlight the atoms

		if (thisAction == 0)
			return false; // moze to byt ? ano, napr z keyTyped

		// BB
		this.mustRedrawNothing();

		int actionOld = action;
		action = thisAction;
		boolean structureChangePerformed = 
				(thisAction < Actions.ACTION_AN_C ? topMenuAction(actionOld)
				: thisAction < 2000 ? leftMenuAction() : false);
		if (!structureChangePerformed && (activeMol.touchedAtom > 0 || activeMol.touchedBond > 0)) {
			// from mouse down in drawing area and atom or bond touched
			structureChangePerformed = bondRingAction();
		}
		if (structureChangePerformed) {
			action = actionOld;
		}
		postAction(structureChangePerformed);
		return true;
	}

	private void postAction(boolean changed) {
		if (changed) {
			setMustRedrawMolecularArea(true);
			activeMol.setBondCenters();
		}
		if (gui.mustReDrawMolecularArea) {
			this.drawMolecularAreaRightNow();
		}
		repaint();
	}

	private boolean topMenuAction(int actionOld) {
		// also includes _FG and _IO from the second row
		gui.mustReDrawTopMenu = true;
		gui.mustReDrawLeftMenu = true; // deselection possible on the left menu
		clearInfo(); // clear any messages

		switch (action) {
		case Actions.ACTION_CLEAR:
			clear();
			// idea: double click would do a complete cleaning of the undo and redo stack
			// this.molChangeManager.clear(); //delete all undo's
			// this.sdfStack.clear(); //delete all entries from the SDF stack
			// this.recordAfterStructureChangedEvent(CLEAR); //already performed by
			// clear()n

			// reset the red highlight correctly
			handleMouseLeaveActionMenu(Actions.ACTION_CLEAR);
			handleMouseEnterActionMenu(Actions.ACTION_CLEAR);
			return true;
		case Actions.ACTION_UNDO:
			action = actionOld;
			return doUndoRedo(-1);
		case Actions.ACTION_REDO:
			action = actionOld;
			return doUndoRedo(1);
		case Actions.ACTION_SMI:
			this.handleSmilesBox();
			action = actionOld;
			return false;
		case Actions.ACTION_QRY:
			this.handleQueryBox();
			// stay commented
			// action = Actions.ACTION_old;
			return false;
		case Actions.ACTION_JME:
			this.handleAboutBox();
			action = actionOld;
			return false;
		case Actions.ACTION_NEW:
			newMolecule = true;
			action = actionOld; // ak nie je bond alebo ring, malo by
			return false;
		case Actions.ACTION_MARK:
			if (options.markerMenu) {
				action = actionOld;
				this.showJPopupMenuRealtiveToScaledMainMenu(gui.createFBackgroundColorPopumemu(),
						gui.markerJPopupMenuPosition.x, gui.markerJPopupMenuPosition.y);
				return false;
			}
			// BB
			// setMustRedrawMolecular(true);
			if (options.autonumber && mouseShift) {
				// automark all atoms, zrusi stare mark
				// autonumber added in 2009.09
				mouseShift = false; // aby pridavalo cisla
				activeMol.numberAtomsSequentially();
				// added Oct 2015 - not tested
				setMustRedrawMolecularArea(true);
				this.recordAfterStructureChangedEvent(AUTO_NUMBER);
				action = actionOld;
				return true;
			}
			// set na Actions.ACTION_mark
			keyboradInputMark = 1; // starts from 1 ????????????????/
			return false;
		case Actions.ACTION_REACP:
			// save ???
			action = actionOld;
			this.updateReactionRoles();
			if (activeMol.getReactionRole() == JMEmol.ReactionRole.AGENT) {
				info("Copying the agent not possible !");
				return false;
			}
			// compute the bounding box of the source molecule
			Rectangle2D.Double cad = activeMol.computeBoundingBoxWithAtomLabels(null);
			if (cad == null)
				return false;
			setMustRedrawMolecularArea(true);
			activeMol = new JMEmol(activeMol);
			Rectangle.Double molArea = this.getMolecularAreaCoordBoundingBox();
			double dx = molArea.getCenterX() - cad.getCenterX(); // dx can be negative or positive
			activeMol.moveXY(dx * 2, 0); // move the new created molecule to the other side
			moleculePartsList.add(activeMol);
			this.recordAfterStructureChangedEvent(REACTION_COPY);
			// reset the blue highlight correctly
			handleMouseLeaveActionMenu(Actions.ACTION_REACP);
			handleMouseEnterActionMenu(Actions.ACTION_REACP);
			return true;
		case Actions.ACTION_DELETE:
			if (activeMol.touchedAtom == 0 && activeMol.touchedBond == 0)
				return false;
			doDeleteAtomOrBond();
			return true;
		case Actions.ACTION_CHARGE:
			if (activeMol.touchedAtom == 0)
				return false;
			if (!doChangeCharge())
				return false;
			return true;
		case Actions.ACTION_SPIRO:
			getBuilder(null).spiroAdding = true;
			info("Next ring will be added as spiro");
			repaint();
			return true; // don't highlight this button; revert to previous (ring, for example)
		case Actions.ACTION_MOVE_AT:
			if (options.showAtomMoveJButton) {
				info("Move one atom");
				repaint();
			}
			return false;
		case Actions.ACTION_DELGROUP:
			// just a message; just setting the action does this
			return false;
		case Actions.ACTION_FG:
			action = actionOld;
			this.showJPopupMenuRealtiveToScaledMainMenu(gui.getFunctionalGroupPopumemu(),
					gui.functionalGroupJPopupMenuPosition.x, gui.functionalGroupJPopupMenuPosition.y);
			return false;
		case Actions.ACTION_IO: /* open popup menu with IO */
			this.handleCopyPasteJPopupMenu(null, gui.fixedCopyPasteJPopupMenuPosition.x,
					gui.fixedCopyPasteJPopupMenuPosition.y);
			action = actionOld;
			return false;
		}
		return false;
	}

	public boolean doUndoRedo(int direction) {
		switch (direction) {
		case -1:
			return undo();
		default:
			case 1:
			return redo();
		}
	}
		
	private boolean undo() {
		setMustRedrawMolecularArea(true); // needed for e.g. undo

		// multiple undo handling
		if (!this.molChangeManager.canUndo()) {
			info("No more undo");

			// actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
			// clear();
		} else if (afterClear) {
			// saved = ++numberofMoleculeParts;
			// actualMoleculePartIndex = numberofMoleculeParts;
			activeMol = moleculePartsList.last();
			afterClear = false;
		}
		if (!this.molChangeManager.canUndo())
			return false; // no molecule in undo stack

		this.restoreState(this.molChangeManager.undo());
		this.recordAfterStructureChangedEvent(UNDO);
		this.willPostSave(false);

		setMustRedrawMolecularArea(true);
		// System.out.println("*********** undo " + mol.natoms);
		return false; // BH??
	}

	private boolean redo() {
		if (!this.canMultipleUndo) {
			this.alert("The redo feature is not implemented yet");
			return false;
		}
		// BB this code is copied from the undo part and adapted
		if (!this.molChangeManager.canRedo()) {
			// actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
			// clear();
			info("No more redo");
			return false;
		}
		if (afterClear) {
			// saved = ++numberofMoleculeParts;
			// actualMoleculePartIndex = numberofMoleculeParts;
			activeMol = moleculePartsList.last();
			afterClear = false;
		}
		// undo po standard change (aj po delete s upravenym saved)
		if (!this.molChangeManager.canRedo())
			return false; // no molecule in undo stack
		this.restoreState(this.molChangeManager.redo());
		this.recordAfterStructureChangedEvent(REDO);
		this.willPostSave(false);
		setMustRedrawMolecularArea(true);
		return false;
	}

	private boolean doChangeCharge() {
		getBuilder(activeMol).checkAtomOrBondAction();
		return true;
	}

	private void doDeleteAtomOrBond() {
		getBuilder(activeMol).checkAtomOrBondAction();
	}

	private boolean handleMouseLeaveActionMenu(int action) {
		return gui.handleMouseLeaveActionMenu(action);
	}

	private boolean handleMouseEnterActionMenu(int action) {
		return gui.handleMouseEnterActionMenu(action, activeMol);
	}

	private boolean bondRingAction() {
		// only executed while mouse is in the drawing area and an atom or bond is
		// selected.
		switch (action) {
		case Actions.ACTION_BOND_SINGLE:
		case Actions.ACTION_BOND_DOUBLE:
		case Actions.ACTION_BOND_TRIPLE:
			// BB Oct 2015: add bond & change bond without switch to double bond bond tool

			if (activeMol.touchedAtom > 0) {
				lastAction = 0;
				// correction - otherwise, mouse drag will move the end of
				// the new added bond instead of moving the molecule
				getBuilder(activeMol).addBond();
				this.recordBondEvent(ADD_BOND);
				return true;
			}
			Bond bond = activeMol.bonds[activeMol.touchedBond];
			int bondType = Bond.SINGLE;
			String eventType = SET_BOND_SINGLE;
			boolean changed; // BB
			switch (action) {
			case Actions.ACTION_BOND_DOUBLE:
				bondType = Bond.DOUBLE;
				eventType = SET_BOND_DOUBLE;
				break;
			case Actions.ACTION_BOND_TRIPLE:
				bondType = Bond.TRIPLE;
				eventType = SET_BOND_TRIPLE;
				break;
			}
			changed = (bondType != bond.bondType);
			if (changed) {
				activeMol.setBondType(activeMol.touchedBond, bondType);
				recordBondEvent(eventType);
				bond.stereo = 0; // zrusi stereo
				return true;
			}
			if (bondType == Bond.DOUBLE) {
				// no change but clicked a second time on a double bond with the double bond
				// tool
				// change normal double bond into crossed bond or vice versa
				activeMol.toggleDoubleBondStereo(bond);
				return true;
			}
			return false;
		default:
			if (action < Actions.ACTION_RING_3 
					|| action > Actions.ACTION_RING_9)
				return false;
			// the addRing function can handle both bond and atom

			// BB Sept 2015: add ring addition
			// extend with other actions:
			// phenyl ring (shortcut is "1"
			// 2 for double bond?, see the help for the shortcucts
			//
			// atoms C, N, O, P, S, F, L (for Cl), B (for Br), I, H, R bonds - for single
			// bond, = for double bond rings 3..8 for 3 to 8 membered rings, 1 for phenyl
			// and 0 for furyl groups a - COOH, y - NO2, z - SO3H, t - tert. butyl, ft - CF3
			//
			// fusing ring to bond
			lastAction = LA_RING; // in addRing may be set to 0
			getBuilder(activeMol).addRing();
			recordBondEvent(ADD_RING_BOND);
			return true;
		}

	}

	private boolean leftMenuAction() {
		// actions 300+
		gui.mustReDrawLeftMenu = true;
		gui.mustReDrawTopMenu = true;
		// deselection of an item in the top menu
		// if the action is coming from a keyboard structure change, then there is no
		// need to redraw the the menu
		active_an = mapActionToAtomNumberXorR(action);
		clearInfo(); // clear any messages
		if (active_an == Atom.AN_X) {
			this.handleAtomXbox();
		}
		// BB : handling R group
		if (action >= Actions.ACTION_AN_R && action <= Actions.ACTION_AN_R_LAST) {
			active_an = Atom.AN_R + (action - Actions.ACTION_AN_R);
		}

		// 2009.09 if touchedAtom, changes it
		if (activeMol.touchedAtom == 0)
			return false;
		// BB
		if (active_an != activeMol.an(activeMol.touchedAtom) && active_an != Atom.AN_X) {
			activeMol.AN(activeMol.touchedAtom, active_an);
			activeMol.Q(activeMol.touchedAtom, 0); // resetne naboj
			// mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
			activeMol.atoms[activeMol.touchedAtom].iso = 0; // BB: reset isotop
			// mol.nh[mol.touchedAtom] = 0;
			activeMol.atoms[activeMol.touchedAtom].nh = 0;
			this.recordAtomEvent(SET_ATOM); // useless since the JSME_Event has the atom number
			return true;
		}
		if (active_an == Atom.AN_X) {
			String xx = atomicSymbol.getText();
			activeMol.setAtom(activeMol.touchedAtom, xx);
			this.recordAtomEvent(SET_ATOM);
			return true;
		}
		return false;
	}

	/**
	 * Adjust moleculePartsList if necessary after a bond or atom addition
	 * 
	 */
	public void updatePartsList() {
		if (moleculePartsList.isEmpty()) {
			// can happen when there are no molecule left, e.g, the last one had a
			// single atom that was deleted
			moleculePartsList.add(new JMEmol());
		}
		activeMol = moleculePartsList.get(0);
		// if an atom or a bond is deleted, then create new molecule if needed
		moleculePartsList.splitFragments(true); // true: remove any empty molecule
	}

	/**
	 * Create an alert box with an OK button to display a message
	 * 
	 * @param message
	 */
	public void alert(final String message) {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			/**
			 * @j2sAlias onSuccess
			 */
			@Override
			public void onSuccess() {

				new AlertBox(message, JME.this, JME.this.bgColor).setVisible(true);

			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAboutBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			/**
			 * @j2sAlias onSuccess
			 */
			@Override
			public void onSuccess() {

				if (aboutBox != null) {
					aboutBox.disposeIfShowing();
				}
				aboutBox = new MultiBox(MultiBox.BOX_ABOUT, JME.this);

			}
		});
	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleQueryBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			/**
			 * @j2sAlias onSuccess
			 */
			@Override
			public void onSuccess() {

				// if (queryBox != null) {
				// queryBox.disposeIfShowing();
				// }
				// queryBox = new QueryBox(this);

				// BB: it is better that the query box keeps its selection when brought back -
				// dispose() erase everything
				// however, it might be hidden behind another window, thus it has to show in
				// front
				if (queryBox == null) {
					queryBox = new QueryBox(JME.this);
				} else {
					if (queryBox.isShowing()) {
						queryBox.toFront(); // not tested wihthin a browser window, works fine with Eclipse/Linux
						// queryBox.setVisible(false);
						// queryBox.setVisible(true);
					} else {
						queryBox.setVisible(true);
					}
				}

			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleSmilesBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			/**
			 * @j2sAlias onSuccess
			 */
			@Override
			public void onSuccess() {
				if (smilesBox != null) {
					smilesBox.disposeIfShowing();
				}
				smilesBox = new MultiBox(MultiBox.BOX_SMILES, JME.this);
			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAtomXbox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			/**
			 * @j2sAlias onSuccess
			 */
			@Override
			public void onSuccess() {

				if (!webme) {
					if (atomxBox != null) {
						atomxBox.disposeIfShowing();
						atomxBox = null;
					}
					if (activeMol.touchedAtom == 0)
						atomxBox = new MultiBox(MultiBox.BOX_ATOMX, JME.this);
				}
			}

		});

	}

	// ----------------------------------------------------------------------------
	// isFullScreen() is overiden is JSME
	public boolean isFullScreen() {
		return this.isFullScreen;
	}

	public void clearInfo() {
		info(customDefaultInfoText);
	}

	@Override
	public void info(String text) {
		if (text == null)
			text = customDefaultInfoText;
		gui.mustReDrawInfo = true;
		if (infoText != text && text != "")
			this.log("info: " + text);
		infoText = text;
	}

	// ----------------------------------------------------------------------------
	// Will do an immediate repaint
	public void showInfo(String text) {

		info(text);
		repaint();
	}

	public void setCustomDefaultInfoText(String text) {
		showInfo(text);
		customDefaultInfoText = text;
	}

	/**
	 * select one of the menu action without having to click on the menu
	 * 
	 * @param action
	 */
	public void setAction(int action) {
		this.action = action;
	}

	/**
	 * rescale around the the nearest molecule to the given position does not call
	 * repaint()!
	 * 
	 * @param scale
	 * @param x     (GUI coordinate)
	 * @param y
	 */
	// used by mouse wheel event in non reaction mode
	public void setMolecularAreaScale(double scale, int x, int y) {
		// should we limit scaling if one molecule becomes invisible?
		// if (!reaction) {
		// mol.center(0.1); //should move progressively to center
		// The center position varies with the scale !!!!!!! FIXME

		Rectangle.Double previousAreaSize = getMolecularAreaCoordBoundingBox();
		this.molecularAreaScalePixelsPerCoord = scale;
		Rectangle.Double newAreaSize = getMolecularAreaCoordBoundingBox();

		Touched touchedMol = new Touched();
		// find the closest mol - use a large distance radius
		this.findMolAndAtomOrBondWithinRadius(x, y, Integer.MAX_VALUE, touchedMol);
		// this.findClosestMol(x, y)
		Point.Double shiftXY = getTranslationToCenterAfterScaling(touchedMol, previousAreaSize, newAreaSize);

		if (shiftXY != null) {
			Graphical2DObject.move(graphicalObjectList(), shiftXY);
		}
		this.setMustRedrawMolecularArea(true);

	}

	/**
	 * Compute the translation X,Y needed for the molecule to stay centered after
	 * scaling
	 * 
	 * @param atomIndex
	 * @param previousAreaSize
	 * @param newAreaSize
	 * @return
	 */
	public static Point.Double getTranslationToCenterAfterScaling(Touched mol, Rectangle.Double previousAreaSize,
			Rectangle.Double newAreaSize) {
		Point.Double result = new Point.Double();

		JMEmol closestMolecule = mol.mol;
		if (closestMolecule == null || closestMolecule.nAtoms() == 0) {
			return result;
		}
		assert previousAreaSize.width > 0;
		assert previousAreaSize.height > 0;

		double x;
		double y;
		if (mol.atomIndex > 0) {
			x = closestMolecule.atoms[mol.atomIndex].x;
			y = closestMolecule.atoms[mol.atomIndex].y;
		} else {
			// closestMolecule.findBondCenters();
			x = closestMolecule.bonds[mol.bondIndex].centerX;
			y = closestMolecule.bonds[mol.bondIndex].centerY;

		}

		double newX = x / previousAreaSize.width * newAreaSize.width;
		double newY = y / previousAreaSize.height * newAreaSize.height;

		double shiftX = newX - x;
		double shiftY = newY - y;

		result.setLocation(shiftX, shiftY);

		return result;

	}

	protected boolean canDoAtomOrBondAction(int action) {
		return (!isDepict() || (isDepict() && action == Actions.ACTION_MARK));
	}

	@Override
	public void mouseEntered(MouseEvent e) {
		requestFocusInWindow();
	}

	@Override
	public void mouseExited(MouseEvent e) {
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}

	@Override
	public void keyTyped(KeyEvent e) {
	}

	@Override
	public void keyReleased(KeyEvent e) {
	}

	@Override
	public void keyPressed(KeyEvent e) {
		if (keyDown(e, e.getKeyCode())) {
			e.consume();
		}
	}

	@Override
	public void mouseMoved(MouseEvent e) {
		// is depictActionEnabled test needed here?
		// if depictActionEnabled is used only
		// for the toggle edit/depict, then no
		if (isDepict() && !(this.canHandleAtomHighLightCallBack() || this.canHandleBondHighLightCallBack()
				|| options.depictActionEnabled))
			// notifyAtomHighLightJSfunction: Luc P request to show atom highlight
			// in
			// depict mode
			return;
		if (isEventContextMenu(e)) {
			// BB popup menu for copy&paste has been opened
			// do nothing to avoid the molecule moving while popup menu is displayed
			return;
		}
		moveTo(e.getX(), e.getY(), 0);
	}

	@Override
	public void mousePressed(MouseEvent e) {
		if (mouseDown(e, e.getX(), e.getY())) {
			// e.consume();
		}
	}

	@Override
	public void mouseDragged(MouseEvent e) {
		if (mouseDrag(e, e.getX(), e.getY())) {
			// e.consume();
		}
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		if (mouseUp(e, e.getX(), e.getY())) {
			// e.consume();
		}
	}

	@Override
	public void mouseWheelMoved(MouseWheelEvent e) {
		double newScale;

		if (!options.allowZooming)
			return;

		double notches = e.getPreciseWheelRotation() * mouseWheelFactor;
		if (notches == 0)
			return;

		notches *= -1; // to give the same zoom direction as googlemaps

		int x = e.getX();
		int y = e.getY();
		double sizeChange = (100.0 + 2 * notches) / 100;
		if (isInMolecularArea(x, y)) {
			newScale = this.molecularAreaScalePixelsPerCoord * sizeChange;

			if ((newScale > this.molecularAreaScalePixelsPerCoord && newScale <= maxMolecularAreaScale) // size
																										// increased,
																										// but not too
					// much
					|| (newScale < this.molecularAreaScalePixelsPerCoord && newScale >= minmolecularAreaScale) // size
																												// decreased,
																												// but
			// not too much
			) {
				lastAction = LA_SCALE;

				if (options.reaction) {
					// do not move around object because the arrow will move out of center
					// and it is difficult to recenter all objects
					setMolecularAreaScale(newScale); // will call repaint()
				} else {
					// previous zoom method
					// center around the atom closes to the x,y position
					setMolecularAreaScale(newScale, x, y);
					repaint();
				}

			}

		} else {
			if (options.allowGUIzooming) {
				newScale = this.menuScale * sizeChange;
				if (newScale >= minMenuScale && newScale <= maxMenuScale) {
					setMenuScale(newScale); // setMenuScale will do a repaint
				}
			}
		}

	}

	public boolean mouseDown(MouseEvent e, int x, int y) {
		// 02.06 niektotre return true zmenene na false (aby events aj v mipc)

		// this.mouseDownWasUsed = false;
		this.mouseDownWasUsed = false;
		// BB popup menu for copy&paste
		if (options.contextMenuEnabledOption && this.handleCopyPasteJPopupMenu(e, x, y)) {
			this.mouseDownWasUsed = true;
			// FIXME
			movePossible = false; // to avoid bug is my JSapplet lib with popup menu disabled, the mouseUp event
									// is not registered and a mouseDrag event is generated
			return true; // event has been consumed
		}

		// the return value of this method
		// set to true if the event was consumed and does not need to be propagated
		boolean eventNotUsed = false;

		clearInfo();

		mouseX = x;// used later in mouseDrag
		mouseY = y; // used later in mouseDrag
		mouseShift = e.isShiftDown(); // because of numbering

		movePossible = false;

		if (!isDepict() && (y > dimension.height - infoAreaHeight())) {
			// --- info area clicked
			return eventNotUsed;
		}
		if (!isInMolecularArea(x, y)) {
			// --- menu pressed
			int action = gui.determineMenuAction(x, y, true);
			return (action == 0 || isMouseDownActionAllowed(action) 
					&& (mouseDownWasUsed = processMenuAction(action)));
		}

		// --- mouse click in the drawing area
		// ---------------------------
		activeGraphicalObject = findClosestGraphicalObject(mouseX, mouseY);
		activeMol = findClosestMol(mouseX, mouseY);
		activeMol.clearRotation();

		if (activeGraphicalObject == reactionArrow) {
			activeMol.touchedAtom = 0; // probably not needed
			activeMol.touchedBond = 0;
		}
		if (this.canHandleAtomClickedCallBack()) {
			if (activeMol.touchedAtom > 0) { // touchedAtom means mouse over?
				this.handleAtomClickedCallBack(activeMolIndex(), activeMol.touchedAtom);
				// not sure that
				// actualMoleculePartIndex
				// is set correctly in
				// case of a multi
				// structure
				if (isDepict() && !options.depictActionEnabled) {
					return true;
				}
			}
			if (activeMol.touchedBond > 0) {
				this.handleBondClickedCallBack(activeMolIndex(), activeMol.touchedBond);
				// not sure that
				// actualMoleculePartIndex
				// is set correctly in
				// case of a multi
				// structure
				if (isDepict() && !options.depictActionEnabled) {
					return true;
				}
			}
		}

		movePossible = true;
		boolean returnStatus;
		if (activeMol.touchedAtom > 0 && canDoAtomOrBondAction(action)) {
			int an = activeMol.an(activeMol.touchedAtom);
			actions.setAtomVariableAction(an >= Atom.AN_R && an <= Atom.AN_R_LAST, action);
			processAtomPicked(action);
			returnStatus = true;
		} else if (activeMol.touchedBond > 0 && canDoAtomOrBondAction(action)) {
			processBondPicked(0);
			returnStatus = true;
		} else if ((moleculePartsList.isReallyEmpty() || newMolecule == true) && !isDepict()) {
			if (action <= Actions.ACTION_STEREO)
				return true;
			// free space clicked - new molecule
			// creating new molecule only on start or when Actions.ACTION_NEW is on

			moleculePartsList.removeEmptyMolecules(); // Jan 2019
			activeMol = new JMEmol(this, this.params);
			moleculePartsList.add(activeMol);
			lastTouched.mol = activeMol;
			smol = null; // kvoli undo
			getBuilder(activeMol).newMolecule(screenToDrawingX(x), screenToDrawingY(y));
			activeMol.setBondCenters();
			returnStatus = true;
		} else {
			returnStatus = false;
		}
		if (returnStatus) {
			// BB: if nothing has changed - there is no need to repaint
			this.setMustRedrawMolecularArea(true);
			this.repaint();
		}

		// set a flag to all depict toggling
		mouseDownWasUsed = returnStatus;
		return returnStatus;
	}

	private boolean processAtomPicked(int action) {
		if (activeMol.touchedAtom == 0)
			return false;
		// atom clicked
		lastTouched.mol = activeMol;
		if (action == Actions.ACTION_QRY) { // setting atom as query atom
			if (queryBox.isBondQuery())
				return true;
			activeMol.setAtom(activeMol.touchedAtom, queryBox.getSmarts());
			activeMol.isQuery = true; // 2013.09
			this.recordAtomEvent(ADD_ATOM_QUERY);
		} else if (action == Actions.ACTION_MARK) { // either color marking or atom map
			boolean marked;
			if (!options.pseudoMark && !options.starNothing) {
				int newMap = -1;
				if (markFromKeyboardInput) {
					newMap = keyboradInputMark;
					resetExtendAtomMark = true;
					markFromKeyboardInput = false;
					clearInfo(); // reset the info message generated by updateMark()
					if (this.params.mark) {
						this.activateMarkerColor(newMap);
					}
				}
				if (params.mark) {
					marked = activeMol.markAtom(newMap > 0 ? newMap : activeMarkerColorIndex
					// set the color
					// index from a
					// keyboard
					// shortcut
					);
				} else {
					if (newMap == -1) {
						if (options.reaction) {
							int reactionRole = activeMol.getReactionRole();
							newMap = findMaxAtomMapOfMoleculeParts(moleculePartsList, reactionRole);
						} else {
							newMap = activeMol.getMaxAtomMap();
						}
						// allow same atom map for several atoms of the group is shift is pressed
						if (!this.mouseShift || newMap == 0) // BB june 2020: if shift is on and new mapping:
																// must be 1
							newMap++;
					}
					marked = activeMol.markAtom(newMap);
				}

			} else {
				marked = true; // equivalent to an atom click event but can be tracked using MARK_ATOM
			}
			recordAtomEvent(marked ? MARK_ATOM : UN_MARK_ATOM);
			if (options.pseudoMark) {
				this.willPostSave(false); // do not put on the undo stack
			}
		} else if (action == Actions.ACTION_MOVE_AT) {
			// nothing to do except set the action
		} else {
			getBuilder(activeMol, action).checkAtomAction();
			activeMol.setBondCenters();
			return true;
		}
		return true;
	}

	/**
	 * 
	 * @return TRUE to exit caller true, FALSE to set returnstatus false, null to
	 *         leave true
	 */
	private boolean processBondPicked(int action) {
		if (activeMol.touchedBond == 0)
			return false;
		int actionOld = 0;
		if (action == 0) {
			action = this.action;
		} else {
			actionOld = this.action;
			this.action = action;
		}
		// bond clicked
		lastTouched.mol = activeMol;
		if (action == Actions.ACTION_QRY) {
			if (!queryBox.isBondQuery())
				return Boolean.TRUE;
			String bondQuery = queryBox.getSmarts();
			activeMol.bonds[activeMol.touchedBond].bondType = Bond.QUERY;
			activeMol.bonds[activeMol.touchedBond].btag = bondQuery;
			recordBondEvent(SET_QUERY_BOND);
		} else if (action == Actions.ACTION_MARK) {
			boolean marked;

			// some duplicated code logic with marking of atom
			if (!options.pseudoMark) {
				marked = activeMol.markBond(activeMarkerColorIndex);
			} else {
				marked = true;
			}
			// some duplicated code logic with marking of atom
			if (marked)
				recordBondEvent(MARK_BOND);
			else
				recordBondEvent(UN_MARK_BOND);

			if (options.pseudoMark) {
				willPostSave(false); // do not put on the undo stack
			}
		} else {
			getBuilder(activeMol).checkBondAction();
			activeMol.setBondCenters();
			return true;
		}
		if (actionOld != 0)
			this.action = actionOld;
		repaint();
		return true;
	}

	public String getAtomSymbolForX() {
		String xx = atomicSymbol.getText();
		return (xx.length() == 0 ? "X" : xx);
	}

	// ----------------------------------------------------------------------------
	public boolean mouseUp(MouseEvent e, int x, int y) {

		boolean eventUsed = false;
		if (this.movingAtom) {
			// end of atom move
			this.movingAtom = false;
			// mol.findBondCenters(); //BB: aton has been moved, thus the bond centers must
			// be updated
			// this.recordAtomEvent(MOVE_ATOM); //this is not a structure change
			this.willPostSave(true);
			eventUsed = true;
		}

		// BB
		gui.mustReDrawInfo = false;
		lastRotation = 0; // needed?

		// LA_GROUP netreba, tam nemoze byt atom overlap
		if (lastAction == LA_BOND) {
			if (action == Actions.ACTION_CHAIN) {
				activeMol.checkChain();
				this.recordBondEvent(ADD_CHAIN);
				this.willPostSave(true);
			} else {

				// find out if the last touched mol is the same
				// lastTouchedMol was set during mouseDrag
				if (lastTouched.mol != null && activeMol != lastTouched.mol) {
					activeMol = mergeMols(lastTouched, activeMol);
				} else {
					// as before - no merge
					// checkBond create or increase bond order
					activeMol.checkBond(); // standard bond check
					activeMol.setBondCenters();
				}
			}
			// BB :
			if (this.bondRubberBanding) {
				// a bond had been added and the state saved
				// to keep only the bond stabilized after the rubberbanding,
				// remove the previous state

				if (action != Actions.ACTION_CHAIN) {
					this.molChangeManager.removeLast();
					this.recordBondEvent(ADD_BOND);
				}

				this.bondRubberBanding = false;
			}
			eventUsed = true;
		} else if (lastAction == LA_MOVE) {
			// !!! mal by sem este prist check na touched
			// mol.findBondCenters();

			// BB
			this.willPostSave(true);
			eventUsed = true;

		}
		if (lastAction > 0) {

			// BB - this seems to be a duplcated of doMenu

			if (lastAction != LA_MOVE && lastAction != LA_ROTATE) {
			}
			if (lastAction == LA_MOVE && options.reaction) {
				int changedPart = updateReactionRoles();
				changedPart++;
				if (changedPart != 0) {
					// send an update message
					this.recordMoleculePartEvent(CHANGE_REACTION_ROLE, changedPart);
				}
			}
			// canon
			// repaint(); // napr po zdvojeni vazby ju nakresli
			this.redrawMolecularAreaOnly();
			lastAction = 0;
			afterClear = false;
			eventUsed = true;
		}

		// BB: useful for touch devices to avoid showing the marked atom after edition
		if (GUI.isTouchSupported() && (activeMol.touchedBond != 0 || activeMol.touchedAtom != 0)) {
			activeMol.touchedBond = 0;
			activeMol.touchedAtom = 0;
			this.redrawMolecularAreaOnly();
			eventUsed = true;

		}

		// mouse click on the full screen icon
		if (!eventUsed && gui.fullScreenIcon != null && gui.fullScreenIcon.contains(x, y)) {
				eventUsed = true;
				toggleFullScreen();
		} else if (!eventUsed && !mouseDownWasUsed && options.toggleDepictEdit) {
			// handle toggle depict/edit
			toggleDepict();
			eventUsed = true;
		}
		mouseShift = false; // BH added ? right?
		return eventUsed;
	}

	private void toggleDepict() {
		if (this.isDepict()) {
			this.options("nodepict"); // menu is ready and paintedafter this call
			this.centerAllMoleculesAsAgroup(this.graphicalObjectList(), molecularAreaScalePixelsPerCoord);
			this.redrawMolecularAreaOnly();

		} else {
			this.options("depict");
		}
		this.handleAfterAfterDepictEditToggleEvent();
	}

	public boolean mouseDrag(MouseEvent e, int x, int y) {
		if (!movePossible || e.isMetaDown())
			return true;

		// BB
		gui.mustReDrawInfo = false;
		double drawingAreaMoveX = scaleScreenToDrawing(x - mouseX);
		double drawingAreaMoveY = scaleScreenToDrawing(y - mouseY);
		double drawingAreaX = screenToDrawingX(x);
		double drawingAreaY = screenToDrawingY(y);

		if (lastAction == LA_RING || lastAction == LA_GROUP || lastAction == LA_FAILED) {
			return true;
		}
		if (lastAction == LA_BOND) {
			boolean done = false;
			this.lastTouched.mol.touchedAtom = 0;

			// to be used for adding a bond with another part
			// need to differentiate the temporary moving atom that was created during
			// mousedown
			// from the atom of another fragment because they can overlap
			// the temp atom is the last one
			activeMol.natoms--;
			findMolAndAtomOrBondInDrawingArea(x, y, newTouched);
			activeMol.natoms++; // restore
			if (this.newTouched.mol != null && this.newTouched.atomIndex > 0) {
				JMEmol touched_JMEmol = newTouched.mol;
				touched_JMEmol.touchedAtom = this.newTouched.atomIndex;

				if (touched_JMEmol != activeMol || this.newTouched.atomIndex != activeMol.touched_org) {
					// make bond
					// towards
					// existing atom
					activeMol.XY(activeMol.natoms, touched_JMEmol.x(newTouched.atomIndex),
							touched_JMEmol.y(newTouched.atomIndex));
					// move the new atom to the coordinate of the
					// closest touched atom "snap"
					// actually it does not move while it still close to the touched atom
					// System.out.println("SNAP otheratom");
					touched_JMEmol.touchedAtom = newTouched.atomIndex;

					done = true;
					// lastTouchedMol will be used by mouseUp() to create the new bnond between the
					// two
					//
					this.lastTouched.initMyselfWith(this.newTouched);
				}
			}
			if (!done) {
				// perform the rubberbanding within the same mol - old code
				activeMol.rubberBanding(drawingAreaX, drawingAreaY);
			}
			this.bondRubberBanding = true; // BB
		} else if (action == Actions.ACTION_MOVE_AT && activeMol.touchedAtom > 0) {
			movingAtom = true;
			activeMol.XY(activeMol.touchedAtom, drawingAreaX, drawingAreaY);
			activeMol.setBondCenters();
		} else if (e.isShiftDown() || e.isMetaDown()) {
			activeMol.rotate(drawingAreaMoveX);
			lastAction = LA_MOVE; // BB: should it be changed to LA_ROTATE?
		} else if (activeMol.touchedAtom == 0 && activeMol.touchedBond == 0) {
			// if no atom or bond are touched, then
			// the touched
			// mol can be moved
			// Start molecue move only if the mousedrag event started within the drawing
			// area
			// Do not move the molecule if the dragging start is not within the drawing area
			if (!isOutsideDrawingArea(x, y)) {
				Rectangle2D.Double boundingBox = this.getMolecularAreaCoordBoundingBox();
				Graphical2DObject.move(activeGraphicalObject, drawingAreaMoveX, drawingAreaMoveY, boundingBox);
				lastAction = LA_MOVE;
			}
		}

		// BB
		this.redrawMolecularAreaOnly();

		mouseX = x;
		mouseY = y;
		return true;
	}

	/**
	 * Process a mouse move or a keyboard navigation.
	 * 
	 * @param screenX for mouse move
	 * @param screenY for mouse move
	 * @param newAtom non-null only from a keyboard navigation
	 * @return
	 */
	public boolean moveTo(int screenX, int screenY, int newAtom) {
		mustRedrawNothing(); // shoInfo() will change that
		boolean repaintFlag = false;
		if (newAtom != 0) {
			// keyboard navigation
			keyTouched.mol = newTouched.mol = activeMol;
			keyTouched.atomIndex = newTouched.atomIndex = (newAtom > 0 ? newAtom : 0);
			keyTouched.bondIndex = newTouched.bondIndex = (newAtom < 0 ? -newAtom : 0);
		} else if (isInMolecularArea(screenX, screenY)) {
			findMolAndAtomOrBondInDrawingArea(screenX, screenY, newTouched);
		} else {
			// menu (or info, I guess)
			int action = gui.determineMenuAction(screenX, screenY, true);
			if (action > 0 && isActionEnabled(action)) {
				if (action != this.mouseWasOverAction) {
					// kind of new event
					repaintFlag = handleMouseLeaveActionMenu(this.mouseWasOverAction);
					repaintFlag = handleMouseEnterActionMenu(action) || repaintFlag;
					this.mouseWasOverAction = action;
				}
			}
		}

		// Don't allow bond touching in Actions.ACTION_MOVE_AT
		if ((newTouched.isTouched() || lastTouched.isTouched()) && !newTouched.equals(lastTouched)) {
			repaintFlag = setTouched();
		}
		if (repaintFlag) {
			setMustRedrawMolecularArea(true);
			repaint();
		}
		return repaintFlag;
	}

	private boolean setTouched() {
		if (lastTouched.mol != null) {
			lastTouched.mol.touchedAtom = 0;
			lastTouched.mol.touchedBond = 0;
		}
		if (newTouched.mol != null) {
			newTouched.mol.touchedAtom = newTouched.atomIndex;
			newTouched.mol.touchedBond = newTouched.bondIndex;
			// touched mol becomes the mol for edition
			activeMol = newTouched.mol;
		}
		
		notifyAtomHighLightJSfunction(newTouched.atomIndex);
		notifyBondHighLightJSfunction(newTouched.bondIndex);

		
		// BH?? these are all the same
//		if (newTouched.atomIndex == 0) {
//			notifyAtomHighLightJSfunction(newTouched.atomIndex);
//			notifyBondHighLightJSfunction(newTouched.bondIndex);
//		} else if (newTouched.bondIndex == 0) {
//			notifyAtomHighLightJSfunction(newTouched.atomIndex);
//			notifyBondHighLightJSfunction(newTouched.bondIndex);
//		} else {
//			// should never happen
//			notifyAtomHighLightJSfunction(newTouched.atomIndex);
//			notifyBondHighLightJSfunction(newTouched.bondIndex);
//		}

		lastTouched.initMyselfWith(newTouched);
		assert lastTouched.equals(newTouched);

		return true;
	}

	public boolean keyDown(KeyEvent e, int key) {
		if (gui == null)
			return false; // somehow this can happen -- Frame is showing too early?
		switch (key) {
		case KeyEvent.VK_SHIFT:
			activeMol.clearRotation();
			return false;
		case KeyEvent.VK_CONTROL:
		case KeyEvent.VK_META:
		case KeyEvent.VK_ALT:
			return false;
		}
		// BB
		gui.mustReDrawInfo = false;
		// this.log("Key code: " + key);

		char ch = e.getKeyChar();
		// handling numeric keypad
		boolean allowModify = false;
		if (key >= 96 && key <= 105) { // number
			allowModify = true;
			key = key - 96 + 48;
		} else if (Character.isAlphabetic(key)) {
			allowModify = true;
		} else if (ch != KeyEvent.CHAR_UNDEFINED) {
			key = 0 + ch;
		}
		// public void keyPressed(KeyEvent e) {
		if (isDepict() && !options.depictActionEnabled)
			return false;
		
		clearInfo();
		int modifiers = e.getModifiers();
		// On Mac: meta is down for system copy
		boolean meta = e.isMetaDown() || e.isControlDown();
		boolean shift = (allowModify && modifiers == KeyEvent.SHIFT_MASK);

		if (activeMol.touchedAtom > 0) {
			actions.setAtomVariableAction(false, action);
		} else if (activeMol.touchedBond > 0) {
			actions.setBondVariableAction(true);
		}
		
		if (meta) {
			return actions.doAction(actions.getKeyStroke(key, InputEvent.CTRL_MASK), 0);
		}
		int action = 0;
		if (modifiers == 0) {
			action = checkKeyPressLeftMenu(key);
			if (action != 0) {
				this.action = action;
				return true;
			}
		}
		// just about anything should be caught in the next method call
		action = checkKeyBinding(key, shift);
		if (action == Actions.ACTION_UNCHANGED)
			return true;
		// unlikely anything here
		if (action == 0 && menuXShortcuts != null && menuXShortcuts.length() > 0) {
			action = checkKeyPressMenuX(key, shift);
		}
		return (action != 0 
				&& processMenuAction(action));
	}

	/**
	 * The central method 
	 * @param key
	 * @param shift
	 * @return
	 */
	private int checkKeyBinding(int key, boolean shift) {
		if (actions.doAction(actions.getKeyStroke(key, (shift ? KeyEvent.SHIFT_MASK : 0)), 0)) {
			return Actions.ACTION_UNCHANGED;
		}
		return 0;
	}

	/**
	 * Target of paging actions.
	 * 
	 * @param action
	 */
	public void doPage(int action) {
		String sdf = null;
		switch (action) {
		case Actions.ACTION_PGDN:
			sdf = this.sdfStack.previous();
			break;
		case Actions.ACTION_PGUP:
			sdf = this.sdfStack.next();
			break;
		case Actions.ACTION_END:
			sdf = this.sdfStack.last();
			break;
		case Actions.ACTION_HOME:
			sdf = this.sdfStack.first();
			break;
		default:
			assert (false);
		}
		if (sdf == null) {
			info("No more molecules in SDF buffer");
			return;
		}
		// sdf = sdf.replace("\n", "|");
		this.clearMyMolecularContent();
		// to avoid any merging with the current molecule
		pasteFromSDFstack = true;
		// Does not work with V3000!!!!
		// this.readMolFile(sdf, false);//do not copy in undo
		this.handleReadGenericInput(sdf, null, false, false);
		// do not repaint and record event here
		pasteFromSDFstack = false;

		if (this.infoText.equals("")) { // no error mesage from readMolFile
			info("MOL n. " + this.sdfStack.getCurrentDisplayIndex() + " of " + this.sdfStack.size());
			this.recordAfterStructureChangedEvent(SD_FSTACK);
			this.willPostSave(false);
		}
	}

	public void doAtomBond(int action) {
		getBuilder(activeMol, action == Actions.ACTION_UNCHANGED ? updateLeftMenuActions() : action).checkAtomOrBondAction();
	}

	private int updateLeftMenuActions() {
		switch (action) {
		case Actions.ACTION_AN_F:
			info("-F");
			return Actions.ACTION_GROUP_CF;
		case Actions.ACTION_AN_CL:
			info("-Cl");
			return Actions.ACTION_GROUP_CL;
		case Actions.ACTION_AN_BR:
			info("-Br");
			return Actions.ACTION_GROUP_CB;
		case Actions.ACTION_AN_I:
			info("-I");
			return Actions.ACTION_GROUP_CI;
		case Actions.ACTION_AN_O:
			info("-OH");
			return Actions.ACTION_GROUP_CO;
		case Actions.ACTION_AN_N:
			info("-NH2");
			return Actions.ACTION_GROUP_CN;
		default:
			return Actions.ACTION_BOND_SINGLE;
		}
	}

	public void doAtomG() {
		if (activeMol.touchedAtom > 0) {
			atomicSymbol.setText("*");
			options.xButton = true;
			doAtomX();
		}
	}

	public void doAtomX() {
		if (activeMol.touchedAtom > 0 && options.xButton) {
			info(atomicSymbol.getText());
			active_an = Atom.AN_X;
			getBuilder(activeMol, Actions.ACTION_AN_X).checkAtomAction();
		}
	}

	/***
	 * 
	 * Navigate with arrow keys around the molecule, alternating between atoms and
	 * bonds.
	 * 
	 * 
	 * @param key
	 * @param shift
	 * 
	 * @author hansonr
	 */
	public void doNavigate(int key) {
		int dir = 0;
		switch (key) {
		case KeyEvent.VK_UP:
			dir = JMEmol.NAV_UP;
			break;
		case KeyEvent.VK_DOWN:
			dir = JMEmol.NAV_DOWN;
			break;
		case KeyEvent.VK_RIGHT:
			dir = JMEmol.NAV_RIGHT;
			break;
		case KeyEvent.VK_LEFT:
			dir = JMEmol.NAV_LEFT;
			break;
		default:
			return;
		}
		int aorb = (activeMol.touchedAtom > 0 ? activeMol.touchedAtom : -activeMol.touchedBond);
		boolean isMove = (aorb != 0);
		if (!isMove) {
			aorb = (keyTouched.mol != activeMol ? 0
					: keyTouched.atomIndex > 0 ? keyTouched.atomIndex : -keyTouched.bondIndex);
		}
		if (aorb == 0) {
			isMove = true;
			aorb = -1;
		}
		int a = (!isMove ? aorb : activeMol.navigateBonds(aorb, dir));
		if (a != 0) {
			moveTo(0, 0, a);
		}
	}

	/**
	 * Get the custom keyboard shortcuts letters that have been set using the
	 * {@link #setMenuXShortcuts(String)} method
	 * 
	 * @return
	 */

	public String getMenuXShortcuts() {
		return this.menuXShortcuts;
	}

	/**
	 * Specify custom keyboard shortcuts letters for the X menu box. These new
	 * shortcuts will have a higher priority than predefined shortcuts. For
	 * instance, to specify polymers shortcuts e , d , t , and g, the argument would
	 * be "edtg"
	 * 
	 * @param shortcuts
	 */

	public void setMenuXShortcuts(String shortcuts) {
		this.menuXShortcuts = shortcuts;
	}

	/**
	 * custom shortcuts for elements; very minimal -- just looking for a key and
	 * setting the atomic symbol for that one upper- or lower-case character.
	 * 
	 * @param key
	 * @param shift
	 * @return
	 */
	private int checkKeyPressMenuX(int key, boolean shift) {
		char shortcut = (shift ? Character.toUpperCase((char) key) : Character.toLowerCase((char) key));
		if (menuXShortcuts.indexOf(shortcut) < 0)
			return 0;
		atomicSymbol.setText(Character.toString(shortcut));
		options.xButton = true;
		info(atomicSymbol.getText());
		active_an = Atom.AN_X;
		return Actions.ACTION_AN_X;
	}

	/**
	 * Standard "immutable" "unnegotiable" key bindings can stay like this.
	 * These are the only key bindings not handled by AbstractAction calls.
	 * 
	 * @param key
	 * @return
	 */
	private int checkKeyPressLeftMenu(int key) {
		switch (key) {
		case 'C':
			return Actions.ACTION_AN_C;
		case 'N':
			return Actions.ACTION_AN_N;
		case 'O':
			return Actions.ACTION_AN_O;
		case 'S':
			return Actions.ACTION_AN_S;
		case 'P':
			return Actions.ACTION_AN_P;
		case 'F':
			return Actions.ACTION_AN_F;
		case 'L':
			return Actions.ACTION_AN_CL;
		case 'B':
			return Actions.ACTION_AN_BR;
		case 'I':
			return Actions.ACTION_AN_I;
		case 'H':
			info("H");
			return Actions.ACTION_AN_H;
		case 'R':
			info("-R");
			return Actions.ACTION_AN_R;
		}
		return 0;
	}

	protected JMEmol mergeMols(final Touched last, final JMEmol active) {
		// merge the current mol and the other mol

		active.deleteAtom(active.natoms);
		// remove the last atom because it will be replaced by the atoms of the new mol
		int atom1 = active.touched_org; // first atom of the new bond to be created
		int atom2 = last.atomIndex + active.natoms;// second atom of the new bond to be created

		assert atom1 != active.natoms + 1;

		JMEmol otherMol = last.mol;
		JMEmol merged = new JMEmol(this, new JMEmol[] { active, otherMol });
		merged.atoms[0] = new Atom(); // needed by rubberbanding()

		// bug: the user selected bond order is not taken into account
		merged.createAndAddNewBond(atom1, atom2, Bond.SINGLE);

		moleculePartsList.remove(otherMol);
		moleculePartsList.replace(active, merged);

		last.reset();
		return merged;
	}

	public void willPostSave(boolean b) {
		this.saveCurrentState = b;

	}

	protected double scaleScreenToDrawing(double pos) {
		return pos / molecularAreaScalePixelsPerCoord;
	}

	protected int scaleDrawingToScreen(double coord) {
		return (int) Math.round(coord * molecularAreaScalePixelsPerCoord);
	}

	/**
	 * convert the applet screen position to the coordinate of the drawing area
	 * 
	 * @param pixelPosition
	 * @return
	 */
	// TODO: drawing should not revert the Y axis
	public double screenToDrawingX(double appletPixelPositionX) {
		// leftMenuWidth() returns 0 in depict mode
		return scaleScreenToDrawing(appletPixelPositionX - leftMenuWidth());
	}

	/**
	 * convert the applet screen position to the coordinate of the drawing area
	 * 
	 * @param pixelPosition
	 * @return
	 */
	public double screenToDrawingY(double appletPixelPositionY) {
		// topMenuHeight() returns 0 in depict mode
		return scaleScreenToDrawing(appletPixelPositionY - topMenuHeight());
	}

	/**
	 * Convert a drawing x coordinate to the pixel coordinate
	 * 
	 * @param xCoord
	 * @return
	 */
	protected int drawingToScreenX(double xCoord) {
		int screenX = scaleDrawingToScreen(xCoord);

		screenX += leftMenuWidth(); // leftMenuWidth() returns 0 in depict mode

		return screenX;
	}

	/**
	 * Convert a drawing y coordinate to the pixel coordinate
	 * 
	 * @param x
	 * @return
	 */
	protected int drawingToScreenY(double yCoord) {
		int screenY = scaleDrawingToScreen(yCoord);

		screenY += topMenuHeight();// topMenuHeight() returns 0 in depict mode

		return screenY;
	}

	/**
	 * Return the molecule index of the molecule that is the closest to the provided
	 * screen position
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	JMEmol findClosestMol(int x, int y) {
		JMEmol found = null;

		if (moleculePartsList.size() == 1)
			return moleculePartsList.first();

		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double min = Double.MAX_VALUE;

		for (JMEmol mol : moleculePartsList) {
			double d = mol.closestDistance(xCoord, yCoord);

			if (d < min) {
				min = d;
				found = mol;
			}

		}
		return found;
	}

	Graphical2DObject findClosestGraphicalObject(int x, int y) {
		Graphical2DObject found = null;
		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double min = Double.MAX_VALUE;

		if (options.reaction) {
			min = this.reactionArrow.closestDistance(xCoord, yCoord);
			found = this.reactionArrow;
		}
		for (JMEmol mol : moleculePartsList) {
			double d = mol.closestDistance(xCoord, yCoord);

			if (d < min) {
				min = d;
				found = mol;
			}
		}
		return found;
	}

	/**
	 * for mouse actions
	 * 
	 * @param x
	 * @param y
	 * @param result
	 */
	void findMolAndAtomOrBondInDrawingArea(int x, int y, Touched result) {

		if (this.isOutsideDrawingArea(x, y)) {
			result.reset();
			return;
		}
		findMolAndAtomOrBondWithinRadius(x, y, GUI.getHumanInteractionTouchRadius(), result);
	}

	/**
	 * find the closest touched atom or bond within the given radius. Store the
	 * results in the argumet result
	 * 
	 * @param screenX
	 * @param screenY
	 * @param result
	 */
	synchronized void findMolAndAtomOrBondWithinRadius(int screenX, int screenY, int radius, Touched result) {
		result.reset();
		double xCoord = screenToDrawingX(screenX);
		double yCoord = screenToDrawingY(screenY);
		double minDistance = radius;
		double[] retMin = new double[1];
		boolean ignoreAtoms = ignoreAtoms();
		boolean ignoreBonds = ignoreBonds();
		for (JMEmol eachMol : this.moleculePartsList) {
			retMin[0] = radius;
			int a_or_b = eachMol.testAtomAndBondTouch(xCoord, yCoord, ignoreAtoms, ignoreBonds, retMin);
			if (retMin[0] < minDistance) {
				minDistance = retMin[0];
				result.reset();
				result.mol = eachMol;
				result.distance = minDistance;
				if (a_or_b > 0)
					result.atomIndex = a_or_b;
				else
					result.bondIndex = -a_or_b;
			}
		}
	}

	/*
	 * * to be redefined in JS subclass (JSME)
	 * 
	 */
	public boolean isMacintosh() {
		return false;
	}

	// --------------------------------------------------------------------------
	// called when number key clicked and marking active
	// updates actual mark which will be used for marking
	protected void updateMark(int n) {
		// need to know when new number and when combination of 2 presses i.e.
		// 12
		if (options.autonumber) {
			if (n == 0) {
				keyboradInputMark = 0;
				showInfo("click marked atom to delete map");
				markFromKeyboardInput = true;

				// repaint(); // updates status line

				return; // BB June 2020: moved from level below, otherwise atom mapping can not be used
						// from the keyboard
			}

		}

		// markUsed true: accumulate the mark number, which allows to get number >= 10
		if (resetExtendAtomMark) {
			keyboradInputMark = n;
			resetExtendAtomMark = false;
		} else {
			if (keyboradInputMark > -1 && keyboradInputMark < 100)
				keyboradInputMark = keyboradInputMark * 10 + n;
			else {
				keyboradInputMark = n; // mark cannot be > 999
				resetExtendAtomMark = false;

			}
		}

		String action_type = "map";
		String target = "atom";
		String reset_action = "delete map";

		if (this.params.mark) {
			reset_action = "remove background color";
			action_type = "color index";
			if (options.starAtomOnly) {

			} else if (options.starBondOnly) {
				target = "bond";
			} else {
				target = "atom or bond";
			}
			if (keyboradInputMark <= 0) {
				keyboradInputMark = 1; // reset to default color index
			}
		}

		if (keyboradInputMark == 0) {
			// keyboradInputMark = -1; //BUG? Novenber 2020
			keyboradInputMark = 0;
			showInfo("click marked " + target + " to " + reset_action);
		} else {
			if (this.params.mark) {
				this.activateMarkerColor(keyboradInputMark);
			}
			showInfo("Click " + target + " to set " + action_type + " to " + keyboradInputMark);

		}

		markFromKeyboardInput = true;
	}

	// --------------------------------------------------------------------------
	// BB used for copy paste and setSubtituents
	@Override
	public void actionPerformed(ActionEvent evt) {
		mustRedrawNothing();

		String cmd = evt.getActionCommand();

		if (subclassHandleMenuAction(cmd)) {
			return;
		}

		ColorInfo colorInfo = this.colorManager.getColorInfoOfColorHash(cmd);
		if (colorInfo != null) {
			int colorIndex = colorInfo.index;
			this.activateMarkerColor(colorIndex);
			this.showInfo(colorInfo.name);

			return;
		}

		if (cmd.equals(CopyPasteAction.SMILES.toString())) {
			clipBoardManager.setClipboardContents(this.smiles());
		} else if (cmd.equals(CopyPasteAction.MOL.toString())) {
			this.copyMolFileToClipboard(false);
		} else if (cmd.equals(CopyPasteAction.MOL_V3000.toString())) {
			this.copyMolFileToClipboard(true);

		} else if (cmd.equals(CopyPasteAction.JME.toString())) {
			this.copyJmeStringToClipboard();

		} else if (cmd.equals(CopyPasteAction.PASTE.toString())) {
			if (options.paste)
				this.pasteMolFileFromClipboard();
		} else if (cmd.equals(CopyPasteAction.INCHI.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI);
		} else if (cmd.equals(CopyPasteAction.INCHI_KEY.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI_KEY);
		} else if (cmd.equals(CopyPasteAction.INCHI_AUXINFO.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI_AUXINFO);
		} else if (cmd.equals(CopyPasteAction.OCLCODE.toString())) {
			this.copyOclCodetoClipboard();
		}

		else if (cmd.equals(CopyPasteAction.SEARCH_INCHI_KEY.toString())) {
			this.searchChemicalStructureUsingInchiKey();
		}

		else if (cmd.equals(CopyPasteAction.SVG.toString())) {
			this.copySVGToClipboard();
		}

		else if (isJavaScript && cmd.equals(CopyPasteAction.RAW_STRING_GRAPHIC.toString())) {
			this.copyRawGraphicToClipboard();
		}

		// BB : rotation coming from the touch handling
		else if (cmd.equals("rotation")) { // used by touch devices
			if (lastAction != LA_ROTATE) {
				lastRotation = 0;
			}
			long rotation = evt.getWhen(); // I had to store the rotation somewhere
			rotation *= -1; // feels more natural
			long deltaRotation = rotation - lastRotation;

			if (Math.abs(deltaRotation) < 10) {
				activeMol.clearRotation();
				activeMol.rotate((int) deltaRotation);
			}
			// mustRedrawNothing();
			setMustRedrawMolecularArea(true);
			// info("Rotation: " + rotation + " deltaRotation " + deltaRotation);

			// repaint(); //done at the end
			lastAction = LA_ROTATE;
			lastRotation = rotation;

		} else if (cmd == unSetChiralFlagAction || cmd == setChiralFlagAction) {
			boolean changed = this.activeMol.setChiralFlag(cmd == setChiralFlagAction);
			if (changed) {
				int n = this.moleculePartsList.size();
				String additional = "";
				if (n > 1) {
					int index = this.moleculePartsList.indexOf(this.activeMol);
					index++;
					additional = " for molecule " + index;

				}

				if (this.activeMol.chiralFlag) {
					info("Chiral flag is set" + additional);
				} else {
					info("No Chiral flag" + additional);

				}
				// this.postSave(); //idea: recordMoleculePartEvent could be used to perform the
				// postSave, + giving a name to saved state
				// that could be used for displaying in info() when mouse over undo button
				this.recordMoleculePartEvent(CHANGE_CHIRAL, this.activeMolIndex());
				setMustRedrawMolecularArea(true); // not really needed but the event will be written out only when
													// redrawing the molecular area
			}

		} else if (cmd == autoAtomMapMoleculeAction) {

			// find the highest atom map
			int max = this.findMaxAtomMapAmongAllMolecules();
			boolean changed = false;
			for (int at = 1; at <= activeMol.natoms; at++) {
				Atom atom = activeMol.atoms[at];
				if (!atom.hasBeenMapped()) {
					max++;
					atom.setMap(max);
					changed = true;
				}
			}

			if (changed) {
				setMustRedrawMolecularArea(true);
				this.recordMoleculePartEvent(CHANGE_MANY_ATOM_MAP, this.activeMolIndex());
			}
		} else if (cmd == deleteAtomMapMoleculeAction) {
			if ((setMustRedrawMolecularArea(activeMol.resetAtomMaps()))) {
				this.recordMoleculePartEvent(DELETE_ATOM_MAPS, this.activeMolIndex());
			}

		} else if (cmd == bondSetCoordinationAction || cmd == bondUnSetCoordinationAction) {
			setMustRedrawMolecularArea(true);
			int bondIndex = this.inspectorEvent.bondIndex;
			assert (bondIndex > 0);
			Boolean isCoordination = this.inspectorEvent.mol.getBond(bondIndex).toggleCoordination().isCoordination();
			this.recordBondEvent(isCoordination ? SET_BOND_COORDINATION : UNSET_BOND_COORDINATION);
			// TODO: the event name could be the same as the action

		} else if (cmd == deleteHydrogensMoleculeAction) {

			// From the user interaction, thus it is not using the settings from options()
			HydrogenParams options = new Parameters().hydrogenParams;
			options.removeHs = true;
			options.removeOnlyCHs = false;

			setMustRedrawMolecularArea(activeMol.deleteHydrogens(options)); // mustReDrawMolecularArea is flase if there
																			// are no deleted hydrogens

			if (gui.mustReDrawMolecularArea) {
				this.recordMoleculePartEvent(DELETE_HYDROGENS, this.activeMolIndex());
			}
		} else if (cmd == compute2DcoordinatesMoleculeAction) {

			// compute2Dcoordinates needs openchemlib
			JMEUtil.runAsync(new JSME_RunAsyncCallback() {

				/**
				 * @j2sAlias onSuccess
				 */
				@Override
				public void onSuccess() {
					compute2DSuccess();
				}

			});

		} else if (cmd.equals("scale100")) { // used by touch devices
			// BB : rotation coming from the touch handling
			// problem: unwanted interaction with the rotation
			// Chemdoodle rotation & scaling works nice
//			if (false && this.moleculePartsList.size() == 1) {
//				long scale100 = evt.getWhen(); // I had to store the scale somewhere
//
//				setMustRedrawMolecularArea(true);
//
//				double delta = 0.05;
//				if (scale100 != 100) {
//					if (scale100 < 100) {
//						delta *= -1;
//					}
//					this.molecularAreaScalePixelsPerCoord = scale100 / 100.0;
//					// Todo : compute center of mol
//					// activeMol.scaling();
//					activeMol.center(); // TODO : translate back to previous center
//					// info("Scale " + this.depictScale );
//					lastAction = LA_SCALE;
//
//				}
//			}
		} else if (cmd.equals("end_gesture")) {
			this.willPostSave(true);
		} else {
			this.setSubstituent(cmd);
		}

		if (gui.mustReDrawMolecularArea || gui.mustReDrawInfo) {
			repaint();
		}

	}

	protected boolean subclassHandleMenuAction(String cmd) {
		return false;
	}

	protected void compute2DSuccess() {
		if (activeMol.nAtoms() > 1) {
			int index = activeMolIndex();

			double centerX = activeMol.centerX();
			double centerY = activeMol.centerY();

			// newActiveMol may or may not be activeMol
			JMEmol newActiveMol = activeMol.compute2DcoordinatesIfMissing();

			if (newActiveMol != null) {
				double dx = centerX - newActiveMol.centerX();
				double dy = centerY - newActiveMol.centerY();
				newActiveMol.moveXY(dx, dy);

				moleculePartsList.set(index, newActiveMol);
				recordMoleculePartEvent(COMPUTE_2D, index);
				setMustRedrawMolecularArea(true);
				info("2D coordinates provided by OpenChemLib");
				repaint();
			} else {
				info("2D coordinates computation failed");
			}
		}
	}

	/**
	 * nEW tbc, SHOULD ENCAPSULATED THE RUN asYn WHEN NEEDED tO BE USED IN ACTIO
	 * MENU AND DIRECT COPY AND DIRECT CUT AND d&d
	 * 
	 * @param format
	 * @param callBack
	 */
	public void exportFile(SupportedFileFormat format, final RunWhenDataReadyCallback callBack) {
		// TODO NOTE IMPLEMENTED
		switch (format) {
		case INCHI:
			break;
		case INCHI_AUXINFO:
			break;
		case INCHI_KEY:
			break;
		case JME:
			break;
		case MOL:
			break;
		case MOL_V3000:
			break;
		case OCLCODE:
			break;
		case RAW_STRING_GRAPHIC:
			break;
		case SMILES:
			break;
		case SVG:
			break;
		default:
			break;

		}
	}

	// not used?
	public void copyFileToClipboard() {
		switch (this.clipboardFormat) {
		case MOL:
			this.copyMolFileToClipboard(false);
			break;

		case MOL_V3000:
			this.copyMolFileToClipboard(true);
			break;

		case JME:
			this.copyJmeStringToClipboard();
			break;
		case SVG:
			this.copySVGToClipboard();
			break;
		case RAW_STRING_GRAPHIC:
			this.copyRawGraphicToClipboard();
			break;
		case SMILES:
			clipBoardManager.setClipboardContents(this.smiles());
			break;
		case INCHI:
			this.copyInchiToClipboard(CopyPasteAction.INCHI);
			break;
		case INCHI_AUXINFO:
			this.copyInchiToClipboard(CopyPasteAction.INCHI_AUXINFO);
			break;
		case INCHI_KEY:
			this.copyInchiToClipboard(CopyPasteAction.INCHI_KEY);
			break;
		case OCLCODE:
			this.copyOclCodetoClipboard();
		default:
			clipBoardManager.setClipboardContents("incorrect or unsupported export format");
		}
	}

	/**
	 * Work for all upported file formats, even thos that require loading code
	 * dynamically, hence the callback argument
	 * 
	 * @param format
	 */
	public void generateOuttputFile(final RunWhenDataReadyCallback callBack) {
		this.generateOuttputFile(this.clipboardFormat, callBack);

	}

	/**
	 * Work for all upported file formats, even thos that require loading code
	 * dynamically, hence the callback argument
	 * 
	 * @param format
	 * @param callBack
	 */

	public void generateOuttputFile(SupportedFileFormat format, final RunWhenDataReadyCallback callBack) {

		String output = null;

		switch (format) {
		case MOL:
			output = this.molFile(false);
			break;

		case MOL_V3000:
			output = this.molFile(true);
			break;

		case JME:
			output = this.jmeFile();
			break;

		case SVG:
			JMEUtil.runAsync(new JSME_RunAsyncCallback() {

				@Override
				public void onSuccess() {
					callBack.onSuccess(JME.this.getOclSVG());
				}

			});
			break;

		case RAW_STRING_GRAPHIC:
			output = this.getMolecularAreaGraphicsString();
			break;
		case SMILES:
			output = this.smiles();
			break;

		case INCHI:
		case INCHI_AUXINFO:
		case INCHI_KEY:
		case INCHI_JSON:
			this.computeInchi(format, callBack);
			break;

		case OCLCODE:
			JMEUtil.runAsync(new JSME_RunAsyncCallback() {

				@Override
				public void onSuccess() {
					callBack.onSuccess(JME.this.getOclCode());
				}

			});
			break;

		default:
			Throwable error = new Throwable("incorrect or unsupported export format");
			callBack.onFailure(error);
		}

		if (output != null) {
			callBack.onSuccess(output);
		}
	}

	public void computeInchi(final SupportedFileFormat action, final RunWhenDataReadyCallback callBack) {

	}

	// BB
	// should use new gneral methodexportFile
	@Deprecated
	public void copyMolFileToClipboard(boolean isV3000) {
		clipBoardManager.setClipboardContents(this.molFile(isV3000));
	}

	// April 2020
	// should use new gneral methodexportFile

	public void copyJmeStringToClipboard() {
		clipBoardManager.setClipboardContents(this.jmeFile());
	}
	// BB
	// should use new gneral methodexportFile

	public void copyOclCodetoClipboard() {
		// use RunAsyncCallback to trigger a code split to download openchemlib
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				clipBoardManager.setClipboardContents(JME.this.getOclCode());
			}

		});

	}

	// should use new gneral methodexportFile

	public void copySVGToClipboard() {
		// use RunAsyncCallback to trigger a code split to download openchemlib
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				clipBoardManager.setClipboardContents(JME.this.getOclSVG());
			}

		});

	}

	// should use new gneral methodexportFile

	public void copyRawGraphicToClipboard() {
		String result = this.getMolecularAreaGraphicsString();
		if (result != null) {
			clipBoardManager.setClipboardContents(result);
		}
	}

	// should use new gneral methodexportFile

	public void copyInchiToClipboard(CopyPasteAction action) {
		// for subclasses
		// clipBoardManager.setClipboardContents(this.computeInchi(isKey));
	}

	public void searchChemicalStructureUsingInchiKey() { // for subclasses

	}

	//
	public void pasteMolFileFromClipboard() {
		// String molecule = clipBoardManager.getClipboardContents();
		// if(molecule != null) {
		// molecule = molecule.replace("\n", "|");
		// this.readMolFile(molecule);
		// }
		this.afterStructureChangeEvent.setOrigin_PASTE();

		// asynchronous action is needed for non IE browsers
		clipBoardManager.getAsyncClipboardContents(this.getPasteAction());

	}

	// used by drag and drop and system clipboard paste
	public void pasteDirect(String molString, boolean originIsDrop) {
		// if pasting is allowed
		if (!options.paste) {
			return;
		}
		if (molString != null && molString.length() > 0) {
			// OK if only DnD uses this function
			if (originIsDrop)
				this.afterStructureChangeEvent.setOrigin_DROP();
			else
				this.afterStructureChangeEvent.setOrigin_PASTE();

			this.getPasteAction().paste(molString);
		} else {
			this.showError("empty or null structure");
		}
	}

	protected PasteAction getPasteAction() {
		return this.createPasteActionInstanceIfNeeded();
	}

	protected PasteAction createPasteActionInstanceIfNeeded() {
		if (this.pasteAction == null) {
			this.pasteAction = new PasteAction() {

				@Override
				public void paste(String clipboardContent) {
					if (clipboardContent != null) {
						handleClipboardPasteAction(clipboardContent);
					}
				}

			};
		}
		return this.pasteAction;
	}

	protected void handleClipboardPasteAction(String clipboardContent) {

		// customized paste
		if (getPrePasteJSfunction() != null) {
			getPrePasteJSfunction().apply(this, new String[] { clipboardContent });
			return;
		}

		/// customized paste only for JSME
		if (handleBeforePasteEvent(clipboardContent)) { // if the callback is set
			return;
		}
		pasteGenericInput(clipboardContent, true, new RunAsyncCallback() {

			/**
			 * @j2sAlias onFailure
			 */
			@Override
			public void onFailure(Throwable reason) {
				// read_MOL_SDF_RXN has already handled the error
			}

			/**
			 * @j2sAlias onSuccess
			 */
			@Override
			public void onSuccess() {
				// callback to client
				JME.this.handleAfterPasteEvent(clipboardContent);

			}

		});
	}

	class StringWrapper {
		public String innnerString;
	};

	// TODO the input error handling has to be redesigned
	// test cases with invalid MOL
	final StringWrapper sdfPastedMessage = new StringWrapper();

	public final static String JME_EVENT_STRUCTURE_MODIFIED = "JME_StructureModifiedEvent";
	public final static String JME_EVENT_PASTE = "JME_PasteEvent";
	private static final String JME_EVENT_DEPICT_EDIT_TOGGLE = "JME_DepictEditToggleEvent";
	private static final String JME_EVENT_ATOM_CLICKED = "JME_AtomClickedEvent";
	private static final String JME_EVENT_BOND_CLICKED = "JME_BondClickedEvent";
	private static final String JME_EVENT_ATOM_HIGHLIGHT = "JME_AtomHighlightEvent";
	private static final String JME_EVENT_BOND_HIGHLIGHT = "JME_BondHighlightEvent";

	public void pasteGenericInput(String chemicalString, boolean recordEvent,
			final RunAsyncCallback sucessAndFailureHandle) {

		sdfPastedMessage.innnerString = "";
		this.afterStructureChangeEvent.setOrigin_API();

		// todo: handle RDF
		int countSDF = sdfStack.addEntries(chemicalString);
		if (countSDF > 0) {
			// sdfPastedMessage = ". " + countSDF + " structures in stack .Use Page Up/Down
			// for SDF access";
			sdfPastedMessage.innnerString = " Use Page Up/Down for SDF access (" + countSDF + ")";

			// emit an event that says that a SDF mutiple structure was added sept 2019
			this.afterStructureChangeEvent.setAction(READ_MULTI_SDF);
			notifyStructuralChange("paste");

		}

		RunAsyncCallback localSucessAndFailureHandle = new RunAsyncCallback() {

			/**
			 * @j2sAlias onFailure
			 */
			@Override
			public void onFailure(Throwable reason) {
				info("ERROR: " + reason.getMessage()); // the readMolFile() method has already generated a message
				JME.this.alert(JME.this.infoText); // this.infotext has be set on thye line above
				JME.this.reset();
				JME.this.repaint();

			}

			/**
			 * @j2sAlias onSuccess
			 */
			@Override
			public void onSuccess() {
				info("Structure pasted. " + sdfPastedMessage.innnerString);
				// JME.this.postSave(); //add it to the undo/redo manager
				JME.this.setMustRedrawMolecularArea(true);
				JME.this.repaint();

				sucessAndFailureHandle.onSuccess();
			}
		};
		try {
			handleReadGenericInput(chemicalString, localSucessAndFailureHandle, false, recordEvent); // do not
																										// repaint
																										// because
			// localSucessAndFailureHandle
			// does it
		} catch (Exception e) {
			localSucessAndFailureHandle.onFailure(e);
		}
	}

	@Deprecated
	public String cutSelectedMoleculeForSystemClipBoard() {
		if (this.activeMol.natoms == 0) {
			return "";
		}

		this.activeMol.forceUniColor(Color.RED); // need a delay for that??
		String s = activeMol.createMolFile("");
		this.redrawMolecularAreaOnly();
		clear();

		this.redrawMolecularAreaOnly();

		return s;
	}

	public void cutSelectedMoleculeForSystemClipBoard(RunWhenDataReadyCallback callBack) {
		if (this.activeMol.natoms == 0) {
			return;
		}

		// this.activeMol.forceUniColor(Color.RED); // need a delay for that?? no
		// visible effect
		this.generateOuttputFile(callBack);
		// this.redrawMolecularAreaOnly();
		clear();

		this.redrawMolecularAreaOnly();
	}

	/**
	 * This code is incompleted it is needed for showing mouse over info (see
	 * handleMouseEnterActionMenu())
	 * 
	 * @param action
	 * @return
	 */
	/*
	 * Save the current molecules to the change manager
	 */
	protected void postSave() {

		if (!canMultipleUndo) {
			return;
		}

		SavedState state = createState();
		// if(state != null) {
		molChangeManager.insertItem(state);
		// }

	}

	/*
	 * Create a state to store the chemical state of the editor. Return null if
	 * there is nothing to save.
	 */
	protected SavedState createState() {

		// state.actualMoleculePartIndex = activeMolIndex1();
		// state.numberofMoleculeParts = numberofMoleculeParts();

		// we have two options:
		// return null: do not save an empty state
		// or save the empty save

//		if (true) {
		while (moleculePartsList.isReallyEmpty() && moleculePartsList.size() > 1) {
			moleculePartsList.remove(0);
		}
//		} else {
//			if (moleculePartsList.isReallyEmpty()) {
//				return null;
//			}
//		}

		SavedState state = new SavedState();
		state.moleculePartsList = moleculePartsList.deepCopy();
		// FIXME: some code call createState() before cleanup of the valence!!!! e.g.
		// mouseDown
		// most don't so instead of adding mol.cleanAfterChanged() everywhere ...
		// state.moleculeParts.get(i).cleanAfterChanged();

//		for(int i=1; i < JME.maxParts; i++) {
//			JMEmol part = this.moleculeParts.get(i);
//			if(part != null) {
//				if(part.natoms > 0) {
//					mustBeSaved = true;
//				}
//				state.moleculeParts.get(i) = part.deepCopy();
//			} else {
//				break;
//			}
//		}

		state.reaction = options.reaction;
		state.multipart = options.multipart;

		state.depictScale = this.molecularAreaScalePixelsPerCoord;
		state.lastAction = this.lastAction;

//		if(mustBeSaved) {
//			return state;
//		} else {
//			return null;
//		}

		return state;
	}

	protected void restoreState(SavedState state) {
		basicRetoreState(state);

		// Notifify the JavaScript world that my structure has changed
		switch (state.lastAction) {
		case LA_MOVE:
		case LA_ROTATE:
		case LA_FAILED:
			break;
		default:
			this.notifyStructuralChange("restore");
		}

	}

	protected void basicRetoreState(SavedState state) {

		// BUG: this should not happen!!!
		if (state == null) {
			// go back to the first state that is null/empty?
			// TODO: simplify
			do {
				this.clear(false);
			} while (!this.moleculePartsList.isReallyEmpty());

			return;
		}
		// this.actualMoleculePartIndex = state.actualMoleculePartIndex;
		// this.numberofMoleculeParts = state.numberofMoleculeParts;

		moleculePartsList = state.moleculePartsList.deepCopy();

		/*
		 * for(int i=1; i < JME.maxParts; i++) { JMEmol part =
		 * state.moleculeParts.get(i); if(part != null) { this.moleculeParts.get(i) =
		 * part.deepCopy(); } else { this.moleculeParts.get(i) = null; } }
		 */
		// issue: this can create a null mol
		if (state.activeMol != null) {
			this.activeMol = state.activeMol;
		} else {
			this.activeMol = new JMEmol(this, this.params); // avoid a null pointer, for state saved
															// after a clear or reset
		}

		options.reaction = state.reaction;
		options.multipart = state.multipart;

		this.molecularAreaScalePixelsPerCoord = state.depictScale;
	}

	public JPopupMenu getCopyPasteJPopupMenuMol() {
		// if(this.copyPasteJPopupMenuMol == null) {
		this.copyPasteJPopupMenuMol = this.createCopyPasteJPopupMenu(false);
		// }
		return copyPasteJPopupMenuMol;
	}

	public JPopupMenu getCopyPasteJPopupMenuReaction() {
		// if(this.copyPasteJPopupMenuReaction == null) {
		this.copyPasteJPopupMenuReaction = this.createCopyPasteJPopupMenu(true);
		// }
		return copyPasteJPopupMenuReaction;
	}

	// return true if event has been used
	public boolean handleCopyPasteJPopupMenu(MouseEvent e, int x, int y) {

		// detect mol and atom under the cursor: needed for tablet?

		if (e == null || isEventContextMenu(e)) {

			// Tablet: needed for touch screen because they cannot detect a mouse move
			// Does not work: the delay for the context menu is too long and is needed
//			if(isTouchSupported) {
//				findMolAndAtomOrBondInDrawingArea(x, y, newTouchedMol);
//				if(newTouchedMol.molIndex > 0) {
//					mol = this.moleculeParts[newTouchedMol.molIndex];
//					mol.touchedAtom = newTouchedMol.atomIndex;
//					mol.touchedBond = newTouchedMol.bondIndex;
//					
//				}
//
//			}
			boolean isTouched = activeMol.touchedAtom > 0 || activeMol.touchedBond > 0;
			if (isTouched && (action == Actions.ACTION_DELETE || action == Actions.ACTION_DELGROUP)) {
				return true; // true: do not use the context menu to delete atom or bond
			}
//			this.info("isTouched = " + isTouched);
//			repaint();

			if (isTouched && !isDepict()) {
				// set shiral flag to the mol
				if (this.touchedMolPopuMenu != null) {
					this.remove(this.touchedMolPopuMenu);

				}
				touchedMolPopuMenu = createMolJPopupMenu(x, y);
				this.add(touchedMolPopuMenu); // set the parent the popup
				touchedMolPopuMenu.show(this, x, y);
			} else {

				{
					JPopupMenu pm;
					if (options.reaction) {
						pm = this.getCopyPasteJPopupMenuReaction();
					} else {
						pm = this.getCopyPasteJPopupMenuMol();
					}
					if (isEventContextMenu(e)) {
						pm.show(this, x, y);
					} else { // click performed on the menu
						this.showJPopupMenuRealtiveToScaledMainMenu(pm, x, y);
					}

				}

			}

			// the atom or bond highlight must disappear =-to be improved
//			Event ne = new Event(null, 0, 0);
//			this.mouseMove(ne, 1000000, 100000); // large number to be sure that no mouse over menu action would be
//													// detected
			processMouseMotionEvent(new MouseEvent(this, MouseEvent.MOUSE_MOVED, 0, 0, 1000000, 100000, 0, false, 0));

			return true;
		}
		return false;

	}

	/*
	 * Show the JPopupMenu at the given coordinate relative to the GUI menu The GUI
	 * menu might have been scaled up or down, thus the x,y coordinates must be
	 * changed accordingly
	 */
	protected void showJPopupMenuRealtiveToScaledMainMenu(JPopupMenu pm, int x, int y) {
		pm.show(this, (int) (x * this.menuScale + 0.5), (int) (y * this.menuScale + 0.5));

	}

	public static boolean isEventContextMenu(MouseEvent e) {
		return (e != null && (e.isMetaDown() || e.isControlDown()));
	}

	// public int stringHeight(FontMetrics fm, String text) {
	// int h = stringHeight(fm);
	// //Correction for a string that is only lower case - NO working : i is as high
	// as a L
	// if(text.equals(text.toLowerCase()) ) {
	// h = h *2 /3;
	// }
	// return h;
	// }

	/**
	 * 
	 * @return the notifyAtomHighLightJSfunction
	 */
	public JSFunction getNotifyAtomHighLightJSfunction() {
		return this.notifyAtomHighLightJSfunction;
	}

	/**
	 * Set the name of the JavaScript function that will be called each time the
	 * mouse move over an atom. To cancel, set to null.
	 * 
	 * @param notifyAtomHighLightJSfunction
	 */
	public void setNotifyAtomHighLightChangeJSfunction(JSFunction notifyAtomHighLightJSfunction) {
		this.notifyAtomHighLightJSfunction = notifyAtomHighLightJSfunction;
	}

	protected int previousTouchedAtomForHighlight = 0;
	protected int previousTouchedBondForHighlight = 0;
	protected int previousActualMoleculePartIndex = 0;

	/**
	 * return -1 if no action should be taken or the touchedAtomOrBond, which might
	 * have been set to 0 in case the curssor has moved away from the atom or bond
	 * 
	 * @param touchedAtomOrBond
	 * @param previousTouchedAtomOrBondForHighlight
	 * @return
	 */
	public int notifyAtomOrBondHighLightJSfunction(int touchedAtomOrBond, int previousTouchedAtomOrBondForHighlight) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		// send an event only if it is about a new atom
		// otherwise each small mouse move will send an event

		// case 1: cursor moved away from atom previous atom is not defined -> do
		// nothing
		if (touchedAtomOrBond <= 0 && previousTouchedAtomOrBondForHighlight == 0) {
			// System.out.println("case 1");
			return -1;
		}

		// case 2: cursor moved around the same atom -> do nothing
		if (touchedAtomOrBond == previousTouchedAtomOrBondForHighlight
				&& this.activeMolIndex() == previousActualMoleculePartIndex) {
			// System.out.println("case 2");

			return -1;
		}

		// case 3: cursor moved away from the atom that was highlighted - send 0 to the
		// callback function
		// to notify that the atom has been deselected
		if (touchedAtomOrBond <= 0 && previousTouchedAtomOrBondForHighlight > 0) {
			// System.out.println("case 3");
			touchedAtomOrBond = 0;
		}

		this.previousActualMoleculePartIndex = this.activeMolIndex();
		return touchedAtomOrBond;

	}

	// TODO
	// potentila bug? this.previousTouchedAtomForHighlight does not depend on the
	// molecular part????
	public void notifyAtomHighLightJSfunction(int touchedAtom) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		if (this.canHandleAtomHighLightCallBack()) {
			touchedAtom = this.notifyAtomOrBondHighLightJSfunction(touchedAtom, this.previousTouchedAtomForHighlight);
			if (touchedAtom == -1)
				return;

			previousTouchedAtomForHighlight = touchedAtom;
			if (notifyAtomHighLightJSfunction != null) {
				notifyAtomHighLightJSfunction.apply(this, new int[] { activeMolIndex(), touchedAtom });
			}
			// this is for the new callback mechanism - June 2015
			handleAtomHighLightCallBack(this.activeMolIndex(), touchedAtom);
		}
	}

	public void notifyBondHighLightJSfunction(int touchedBond) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		if (this.canHandleBondHighLightCallBack()) {
			touchedBond = this.notifyAtomOrBondHighLightJSfunction(touchedBond, this.previousTouchedBondForHighlight);
			if (touchedBond == -1)
				return;
			this.previousTouchedBondForHighlight = touchedBond;

			// this is for the new callback mechanism - June 2015
			handleBondHighLightCallBack(this.activeMolIndex(), touchedBond);

		}
	}

	public Boolean canHandleAtomHighLightCallBack() {
		return true;// this.notifyAtomHighLightJSfunction != null;
	}

	public Boolean canHandleBondHighLightCallBack() {
		return true;
	}

	public Boolean canHandleAtomClickedCallBack() {
		return true;
	}

	public Boolean canHandleBondClickedCallBack() {
		return true;
	}

	/**
	 */
	public void handleAtomClickedCallBack(int actualMoleculePartIndex, int clickedAtom) {
		notifyEvent(JME_EVENT_ATOM_CLICKED, new int[] { actualMoleculePartIndex, clickedAtom });
	}

	public void handleBondClickedCallBack(int actualMoleculePartIndex, int clickedBond) {
		notifyEvent(JME_EVENT_BOND_CLICKED, new int[] { actualMoleculePartIndex, clickedBond });
	}

	/*
	 * Same functionality as prePasteJSfunction but only for JSME Advantage: the
	 * argument is a JS function, not a JS function name. The JS fyunction will have
	 * two arguments: my self and the string to process before pasting For JME,
	 * always return false - meaning that there is no callback set
	 */
	protected boolean handleBeforePasteEvent(String molecule) {

		return false;
	}

	/**
	 * Called when pasting has been sucessful. Method intended for a subclass.
	 */
	protected void handleAfterPasteEvent(String pasteContent) {
		notifyEvent(JME_EVENT_PASTE, pasteContent);
	}

	/**
	 * Called after swith to edit / depict mode using the toggle option. Method
	 * intended for a subclass.
	 */
	protected void handleAfterAfterDepictEditToggleEvent() {
		notifyEvent(JME_EVENT_DEPICT_EDIT_TOGGLE, Boolean.valueOf(depict));
	}

	protected void handleAftertructureModifiedEvent(String cause) {
		// subclass do something more
		notifyEvent(JME_EVENT_STRUCTURE_MODIFIED, afterStructureChangeEvent);
		updateReactionRoles();
	}

	public void notifyEvent(String name, Object value) {
		firePropertyChange(name, new Object[] { options.getApplet(false) }, value);
	}

	/**
	 * For subclasses
	 * 
	 * @param actualMoleculePartIndex2
	 * @param touchedAtom
	 */
	public void handleAtomHighLightCallBack(int actualMoleculePartIndex, int touchedAtom) {
		notifyEvent(JME_EVENT_ATOM_HIGHLIGHT, new int[] { actualMoleculePartIndex, touchedAtom });
	}

	/**
	 * For subclasses
	 * 
	 * @param actualMoleculePartIndex2
	 * @param touchedBond
	 */
	public void handleBondHighLightCallBack(int actualMoleculePartIndex, int touchedBond) {
		notifyEvent(JME_EVENT_BOND_HIGHLIGHT, new int[] { actualMoleculePartIndex, touchedBond });
	}

	/**
	 * Highlight atom like a mouse over. If the atom index is 0, then remove any
	 * atom highlight. If molIndex is zero, that means that the atom index is an
	 * ensemble index
	 * 
	 * @param molIndex  (first index is 1, not 0)
	 * @param atomIndex (first index is 1, not 0)
	 */
	public void setAtomToHighLight(int molIndex, int atomIndex) {
		this.moleculePartsList.resetTouchedAtomAndBond();
		if (atomIndex != 0) {
			// 0 means reset highlight
			JMEmolList.EnsembleAtom ea = this.getEnsembleAtom(molIndex, atomIndex);

			if (ea == null) {
				this.showError("invalid atom index or molecule index");
				return;
			}
			ea.mol.touchedAtom = ea.atomIndex;
		}
		this.redrawMolecularAreaOnly();

	}

	/**
	 * Highlight bond like a mouse over. If the bond index is 0, then remove any
	 * bond highlight. If molIndex is zero, that means that the bond index is an
	 * ensemble index
	 * 
	 * @param molIndex  (first index is 1, not 0)
	 * @param bondIndex (first index is 1, not 0)
	 */
	public void setBondToHighLight(int molIndex, int bondIndex) {

		// JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

		this.moleculePartsList.resetTouchedAtomAndBond();

		// 0 means reset highlight
		if (bondIndex != 0) {

			JMEmolList.EnsembleBond ea = this.getEnsembleBond(molIndex, bondIndex);

			if (ea == null) {
				this.showError("invalid bond index or molecule index");
				return;
			}
			ea.mol.touchedBond = ea.bondIndex;
		}
		this.redrawMolecularAreaOnly();

	}

	public void changeAtomMap(int molIndex, int atomIndex, int newMap) {
		JMEmol mol = this.selectMolIfValidOrShowError(molIndex);
		changeAtomMap(mol, atomIndex, newMap);

	}

	public void changeAtomMap(JMEmol mol, int atomIndex, int newMap) {
		Atom at = mol.getAtom(atomIndex);
		if (newMap <= 0) {
			at.resetObjectMark();// Nov 2020 bug fix: set atom ap to 0 reset it
		} else {
			at.setMapOrMark(newMap, !this.params.mark); // Nov 2020 bug fix: !
		}
		this.recordAtomEvent(CHANGE_ATOM_MAP, atomIndex);
		// this.setAtomToHighLight(molIndex, atomIndex);
		this.redrawMolecularAreaOnly();

	}

	public void changeAtomCharge(JMEmol mol, int atomIndex, int newCharge) {
		Atom at = mol.getAtom(atomIndex);
		at.Q(newCharge);

		this.recordAtomEvent(CHARGE_ATOM0, atomIndex);
		// this.setAtomToHighLight(molIndex, atomIndex);
		this.redrawMolecularAreaOnly();

	}

	/**
	 * @return the notifyStructuralChangeJSfunction
	 */
	public JSFunction getNotifyStructuralChangeJSfunction() {
		return notifyStructuralChangeJSfunction;
	}

	/**
	 * @param notifyStructuralChangeJSfunction the notifyStructuralChangeJSfunction
	 *                                         to set
	 */
	public void setNotifyStructuralChangeJSfunction(JSFunction notifyStructuralChangeJSfunction) {
		this.notifyStructuralChangeJSfunction = notifyStructuralChangeJSfunction;
	}

	/**
	 * Notify the JavaScript environment that the chemical structure has changed
	 * 
	 * @param cause
	 * 
	 *              BB comment: is cause needed? Seems to bring the same
	 *              functionality as event.origin
	 */
	public void notifyStructuralChange(String cause) {

		// JSME bug fix #33
		// https://github.com/jsme-editor/jsme-editor.github.io/issues/33
		if (this.afterStructureChangeEvent != null && this.afterStructureChangeEvent.action != null) {
			this.afterStructureChangeEvent.stackLevel++;
// 			System.out.println("@@@@ this.afterStructureChangeEvent.stackLevel: " +
// 			this.afterStructureChangeEvent.stackLevel + " " + this.afterStructureChangeEvent.action +
// 			" cause: " + cause + " origin: " + this.afterStructureChangeEvent.origin);

			// the JS client function might trigger a structural change, wee need to prevent
			// an infinite loop
			int MAX_RECURSIVE_LOOP = 1;
			if (this.afterStructureChangeEvent.stackLevel <= MAX_RECURSIVE_LOOP) {
				this.handleAftertructureModifiedEvent(cause); // uses the current event

				// older - deprecated implementation
				try {
					if (notifyStructuralChangeJSfunction != null) {
						notifyStructuralChangeJSfunction.apply(this, null);
					}
				} catch (Throwable t) {
					t.printStackTrace();
				}
			}
			this.afterStructureChangeEvent.stackLevel--;
			if (this.afterStructureChangeEvent.stackLevel <= 0) {
				this.afterStructureChangeEvent.reset();
			}

		}

//		if (afterStructureChangeEvent != null && afterStructureChangeEvent.action != null) {
//			if (afterStructureChangeEvent.stackLevel > 0) {
//				afterStructureChangeEvent.reset();
//				return;
//			}
//			afterStructureChangeEvent.stackLevel++;
//			handleAftertructureModifiedEvent(cause);
//		}
//
//		try {
//			if (notifyStructuralChangeJSfunction != null) {
//				notifyStructuralChangeJSfunction.apply(this, null);
//			}
//		} catch (Throwable t) {
//			t.printStackTrace();
//		}

	}

	public JSFunction getPrePasteJSfunction() {
		return prePasteJSfunction;
	}

	/**
	 * Set a JS function that will be called before the paste is performed. THis
	 * function will receive one argument: a string that a represent a molecular
	 * structure. The return value of the fuinction is a string. Purpose: convert a
	 * name or a SMILES or an InchI into a MOL.
	 * 
	 * @param prePasteJSfunction
	 */
	public void setPrePasteJSfunction(JSFunction prePasteJSfunction) {
		this.prePasteJSfunction = prePasteJSfunction;
	}

	/**
	 * 
	 * @return the height in pixel of the top menu
	 */
	public int topMenuHeight() {
		return (int) Math.round(topMenuHeight(this.menuScale));
	}

	/**
	 * 
	 * @return the height in pixel of the top menu
	 */
	public double topMenuHeight(double scale) {
		return this.isDepict() ? 0.0 : (gui.menuCellSize * 2 + gui.menuCellBorder()) * scale;
	}

	/**
	 * 
	 * @return the width in pixel of the top menu
	 */
	public int leftMenuWidth() {
		return (int) Math.round(leftMenuWidth(this.menuScale));
	}

	/**
	 * 
	 * @return the scaled width in pixel of the left menu
	 */
	public double leftMenuWidth(double scale) {

		if (gui == null)
			System.out.println("???");

		return this.isDepict() ? 0.0 : (gui.menuCellSize * 1 + gui.menuCellBorder()) * scale;
	}

	/**
	 * 
	 * @return the height in pixel of the bottom bar (info bar) = 0 in depict mode
	 */
	public int infoAreaHeight() {
		return (int) Math.round(infoAreaHeight(this.menuScale));
	}

	public double infoAreaHeight(double scale) {
		return this.isDepict() ? 0.0 : gui.menuCellSize * scale;
	}

	/**
	 * the right border differs in new and old look
	 * 
	 * @return
	 */
	public int rightBorder() {
		return (int) Math.round(rightBorder(this.menuScale)); // the width of the line on the right of the molecular
																// area in edit mode
	}

	public double rightBorder(double scale) {
		return this.isDepict() ? 0.0 : (options.newLook ? GUI.rightBorderNewLook : GUI.rightBorderOldLook) * scale; // the
																													// width
		// of the
		// line on the right
		// of the molecular
		// area in edit mode
	}

	public void redrawMolecularAreaOnly() {
		this.mustRedrawNothing();
		this.setMustRedrawMolecularArea(true);
		this.repaint();

	}

	public boolean setMustRedrawMolecularArea(boolean b) {
		// SwingJS will always draw this; it is a sub-millisecond operation
//		return (mustReDrawMolecularArea = b);
		return true;
	}

	public void redrawMolecularAreaOnylForGettingSVG() {
		int savedTouchedAtom = this.activeMol.touchedAtom;
		int savedTouchedBond = this.activeMol.touchedBond;

		// hide the touched atom or bond
		this.activeMol.touchedAtom = 0;
		this.activeMol.touchedBond = 0;
		this.afterStructureChangeEvent.reset(); // oct 2016: avoid an infinite loop when
												// redrawMoleculartAreaOnlForGettingSVG is called within js notification
												// of a structure change

		this.redrawMolecularAreaOnly();

		this.activeMol.touchedAtom = savedTouchedAtom;
		this.activeMol.touchedBond = savedTouchedBond;
	}

	/**
	 * if mol index is 0, than set the colors for all molecules
	 * 
	 * @param molIndex        1 based
	 * @param atomAndColorCSV : at,c,at,c,at,c, ... at: atom index; c: color index
	 */
	public void setAtomColors(int molIndex, String atomAndColorCSV) {

		// TODO Use EnsembleAtom
		// if the mol index has not been specified - then assume that the atom indices
		// are valid for the whole ensemble
		if (molIndex == 0) {

			int cumulAtomCount = 0;
			for (int i = 1; i <= moleculePartsList.size(); i++) {
				JMEmol mol = this.selectMolIfValidOrShowError(i);
				mol.setAtomColors(atomAndColorCSV, cumulAtomCount);
				cumulAtomCount += mol.nAtoms();
			}

		} else {
			// select the molecule to color
			JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

			if (molToHighLight == null) {
				return;
			}

			// color its atoms according to the parameters
			molToHighLight.setAtomColors(atomAndColorCSV, 0);
		}

		// repaint
		this.redrawMolecularAreaOnly();
	}

	/**
	 * Get ensemble information about the atom index. If molIndex is zero. then
	 * atomIndex is an ensemble index
	 * 
	 * @param molIndex  - 0 based
	 * @param atomIndex
	 * @return
	 */
	public JMEmolList.EnsembleAtom getEnsembleAtom(int molIndex, int atomIndex) {

		if (molIndex < 0 || atomIndex < 0) {
			JMEUtil.log("Invalid index for getEnsembleAtom()");
			return null;
		}

		return new JMEmolList.EnsembleAtom(this.moleculePartsList, molIndex, atomIndex);

	}

	/**
	 * 
	 * @param molIndex - 0 based
	 * @return
	 */
	public JMEmol getMolecule(int molIndex) {
		if (molIndex < 0 || molIndex >= this.moleculePartsList.size()) {
			JMEUtil.log("Invalid index for getMolecule()");
			return null;
		}

		return this.moleculePartsList.get(molIndex);

	}

	int lastValidColorIndex = 1; // TODO: use the default color

	public final JTextField atomicSymbol = new JTextField("H", 8);
	public GUI gui;

	/**
	 * Choose the background color to be used for the atom or bond. The marker
	 * symbol will get this color as well. The index is the index of the color of
	 * current color palette.
	 * 
	 * @param colorIndex (first value is 1)
	 */
	public void activateMarkerColor(int colorIndex) {
		// this.parameters.mark = true;

		if (colorIndex < 1 || colorIndex > this.colorManager.numberOfBackgroundColors()) {
			this.alert("Invalid color index: " + colorIndex);
			resetExtendAtomMark = true; // June 2020: do not accumulate large numbers with keyboard input (see
										// updateMark() )
			markFromKeyboardInput = false;
			this.activeMarkerColorIndex = lastValidColorIndex;
			this.clearInfo();
			this.repaint();
		} else {
			lastValidColorIndex = this.activeMarkerColorIndex = colorIndex;
			this.setAction(105);
			this.options("marker");

			gui.mustReDrawTopMenu = true; // the marker symbol is in the top menu
			this.repaint();
		}
	}

	public void setStarColor(String hexColor) {
		this.alert("methods setStarColor and setMarkerColor have been replaced by activateMarkerColor");

	}

	/**
	 * Get the Atom object using an ensemble based index
	 * 
	 * @param atomE
	 * @return
	 */
	public Atom getAtomE(int atomE) {
		return this.getEnsembleAtom(0, atomE).atom;
	}

	public int totalNumberOfAtoms() {
		return this.moleculePartsList.totalNumberOfAtoms();
	}

	/**
	 * Just replace. Assume that the new Atom is the same with some extra data
	 * field. No further checking
	 * 
	 * @param oldAtom
	 * @param newAtom
	 */
	public void replaceAtom(AtomBondCommon oldAtom, Atom newAtom) {
		for (int i = 1; i <= moleculePartsList.size(); i++) {
			JMEmol mol = this.selectMolIfValidOrShowError(i);
			for (int at = 0; at < mol.atoms.length; at++) {
				if (mol.atoms[at] == oldAtom) {
					mol.atoms[at] = newAtom;
					return;
				}
			}
		}
	}

	/**
	 * Reset background atom colors
	 * 
	 * @param molIndex
	 */
	public void resetAtomColors(int molIndex) {

		if (molIndex == 0) { // new May 2018
			// this.atomColors = "";

			for (int i = 1; i <= moleculePartsList.size(); i++) {
				this.resetAtomColors(i);
			}

			return;
		} else {

			// select the molecule to decolor
			JMEmol selectedMol = this.selectMolIfValidOrShowError(molIndex);

			if (selectedMol == null) {
				return;
			}

			//
			AtomBondCommon.resetChemicalObjectColors(selectedMol.atoms);
		}

		// repaint
		this.redrawMolecularAreaOnly();

		// clear the atom colors from the option

	}

	/**
	 * Reset background atom colors
	 * 
	 * @param molIndex
	 */
	public void resetBondColors(int molIndex) {

		if (molIndex == 0) { // new Sepetmber 2019
			this.atomBgColors = "";

			for (int i = 1; i <= moleculePartsList.size(); i++) {
				this.resetBondColors(i);
			}

			return;
		} else {

			// select the molecule to decolor
			JMEmol selectedMol = this.selectMolIfValidOrShowError(molIndex);

			if (selectedMol == null) {
				return;
			}

			//
			AtomBondCommon.resetChemicalObjectColors(selectedMol.bonds);
		}

		// repaint
		this.redrawMolecularAreaOnly();

		// clear the atom colors from the option

	}

	public int totalNumberOfBonds() {
//		int cumulBOndCount = 0;
//		for (int i = 1; i <= numberofMoleculeParts; i++) {
//			JMEmol mol = this.selectMolIfValidOrShowError(i);
//			cumulBOndCount += mol.nBonds();
//		}
//
//		return cumulBOndCount;

		return this.moleculePartsList.totalNumberOfBonds();
	}

	/**
	 * Get ensemble information about the atom index. If molIndex is zero. then
	 * atomIndex is an ensemble index
	 * 
	 * @param molIndex  - 0 based
	 * @param bondIndex - 1 based
	 * @return
	 */
	public JMEmolList.EnsembleBond getEnsembleBond(int molIndex, int bondIndex) {

		if (molIndex < 0 || bondIndex < 0) {
			JMEUtil.log("Invalid index for getEnsembleBond()");
			return null;
		}

		return new JMEmolList.EnsembleBond(this.moleculePartsList, molIndex, bondIndex);

	}

	/**
	 * Get the Atom object using an ensemble based index
	 * 
	 * @param bondE
	 * @return
	 */
	public Bond getBondE(int bondE) {
		return this.getEnsembleBond(0, bondE).bond;
	}

	/**
	 * Just replace. Assume that the new Bond is the same with some extra data
	 * field. No further checking
	 * 
	 * @param oldBond
	 * @param newBond
	 */
	public void replaceBond(AtomBondCommon oldBond, Bond newBond) {
		for (JMEmol mol : moleculePartsList) {
			for (int b = 0; b < mol.bonds.length; b++) {
				if (mol.bonds[b] == oldBond) {
					mol.bonds[b] = newBond;
					return;
				}
			}
		}
	}

	// molIndex is based 1
	public void setBondColors(int molIndex, String bondAndColorCSV) {

		// if the mol index has not been specified - then assume that the aom indices
		// ave valid for the whole ensemble
		if (molIndex == 0) {

			int cumulBondCount = 0;
			for (JMEmol mol : moleculePartsList) {
				mol.setBondColors(bondAndColorCSV, cumulBondCount);
				cumulBondCount += mol.nBonds();
			}

		} else {
			// select the molecule to color
			JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

			if (molToHighLight == null) {
				return;
			}

			// color its atoms according to the parameters
			molToHighLight.setBondColors(bondAndColorCSV, 0);
		}

		// repaint
		this.redrawMolecularAreaOnly();
	}

	/**
	 * JME accepts a SDF with multiple records. This method returns the list of the
	 * SDF records that were input
	 * 
	 * @return a string array, which could be empty
	 */
	public String[] getMultiSDFstack() {
		return this.sdfStack.getMultiSDFstack();
	}

	/**
	 * Return the selected mol. If the index is not valid, show an error
	 * 
	 * @param molIndex - 1 based
	 * @return JMEmol
	 */
	protected JMEmol selectMolIfValidOrShowError(int molIndex) {
		this.clearInfo(); // clear the info in case an error would occur
		if (molIndex < 1 || molIndex > this.moleculePartsList.size()) {
			this.showError("invalid mol index: " + molIndex);
			return null;
		}

		return this.moleculePartsList.get(molIndex - 1);

	}

	/**
	 * 
	 * @param action
	 * @param moleculePartIndex
	 * @param atomIndex
	 * @param bondIndex
	 */
	protected void recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex,
			int bondIndex) {

		this.recordAfterStructureChangedEvent(action, moleculePartIndex, atomIndex, bondIndex, true);

	}

	/**
	 * 
	 * @param action
	 * @param moleculePartIndex
	 * @param atomIndex
	 * @param bondIndex
	 */
	protected void recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex, int bondIndex,
			boolean willSaveOnUndoStack) {

		if (this.afterStructureChangeEvent != null) {
			this.updateReactionRoles(); // will do nothing if not reaction mode
			this.afterStructureChangeEvent.setAction(action).setAtomAndBondAndMol(moleculePartsList, atomIndex,
					bondIndex, moleculePartIndex);
		}
		// this.notifyStructuralChangeToJS();

		// for the undo/redo manager
		this.willPostSave(willSaveOnUndoStack); // happens after redraw?

	}

	protected void recordMoleculePartEvent(String action, int moleculePartIndex) {
		this.recordAfterStructureChangedEvent(action, moleculePartIndex, 0, 0);

	}

	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * 
	 * @param action
	 */
	public void recordAtomEvent(String action) {
		recordAtomEvent(action, activeMol.touchedAtom);
	}

	public void recordAtomEvent(String action, int atom) {
		recordAfterStructureChangedEvent(action, activeMolIndex(), atom, 0);
	}

	public void recordBondEvent(String action) {
		recordBondEvent(action, activeMol.touchedBond);
	}

	public void recordBondEvent(String action, int bond) {
		recordAfterStructureChangedEvent(action, activeMolIndex(), 0, bond);
	}

	public void recordAfterStructureChangedEvent(String action) {
		recordAfterStructureChangedEvent(action, 0, 0, 0);
	}

	/**
	 * 
	 * @return true if the editor is in depict mode
	 */
	public boolean isDepictMode() {
		return isDepict();
	}

	/**
	 * @return the depict
	 */
	public boolean isDepict() {
		return depict;
	}

	/**
	 * @param depict the depict to set
	 */
	public void setDepict(boolean depict) {
		this.depict = depict;
	}

	public boolean isEmpty() {
		return this.moleculePartsList.isReallyEmpty();
	}

	// ----------- added by Bob Hanson ------------ //

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		String name = evt.getPropertyName();
		try {
			if (name == FileDropper.PROPERTY_FILEDROPPER_FILE) {
				readDroppedTextFile((String) evt.getNewValue());
			} else if (name == FileDropper.PROPERTY_FILEDROPPER_INLINE) {
				readDroppedData(evt.getNewValue());
			}
		} catch (Throwable t) {
			System.err.println("JME couldn't load data for drop " + name);
		}
	}

	protected void readDroppedData(Object newValue) {
		String data = newValue.toString();
		String trimmed = data.trim();
		// BH 2023.1.18 Allowing for copying with a bit of whitespace for SMILES
		try {
			if (trimmed.indexOf("\n") >= 0)
				readMolFile(data);
			else if (trimmed.indexOf(" ") >= 0)
				readMolecule(data);
			else
				readSmiles(trimmed);
			activeMol.center();
		} catch (Exception e) {
			System.err.println("JME error reading data starting with " + data.substring(Math.min(data.length(), 100)));
		}

	}

	protected void readSmiles(String data) {
		try {
			readMolFile(getParser().SMILEStoMOL(data));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	protected void readDroppedTextFile(String fileName) {
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		InputStream fis = null;
		try {
			fis = (fileName.indexOf("://") >= 0 ? new URL(fileName).openStream() : new FileInputStream(fileName));
			byte[] bytes = new byte[0x1000];
			int n;
			while ((n = fis.read(bytes)) > 0) {
				bos.write(bytes, 0, n);
			}
			fis.close();
		} catch (Exception e) {
			System.err.println("JME error reading file " + fileName);
		}
		readDroppedData(new String(bos.toByteArray()));
	}

	public void options(String parameters) {
		options.set(parameters);
		mustRedrawEverything();
		repaint();
	}

	public class Options {

		// unused options

		// boolean writesmi = false;
		// boolean writemi = false;
		// boolean writemol = false;

		// essentially final

		/* final */ public boolean addNewPart = false;
		// when reading a or pasting a mol: add it or replace everything in the canvas
		/* final */ public boolean allowGUIzooming = true;
		/* final */ public boolean allowZooming = true;
		// boolean smilesAromatic = true; // see smilesParams
		// boolean autoez = true; // see smilesParams
		/* final */ public boolean autonumber = false;
		/* final */ public boolean contextMenuEnabledOption = true;
		/* final */ public boolean depictActionEnabled = false;
		// BB allow editing in depict mode
		/* final */ public boolean depictBorder = false;
		/* final */ public boolean exportInchi = true;
		/* final */ public boolean exportInchiAuxInfo = true;
		/* final */ public boolean exportInchiKey = true;
		/* final */ public boolean exportRXNmergeOption = false;
		/* final */ public boolean exportSVG = true;
		/* final */ public boolean fgMenuOption = true;
		/* final */ public boolean fullScreenIconOption = false;
		/* final */ public boolean markerMenu = false;
		// popup menu to select marker color
		/* final */ public boolean markOnly1 = false;
		// only one atom at a time can be marked
		/* final */ public boolean newLook = false;
		/* final */ public boolean paste = true;
		// BB: allow pasting structures, should be disabled in depict mode
		/* final */ public boolean polarnitro = false;
		/* final */ public boolean pseudoMark = false;
		// marking does not happen - used only to trigger event
		/* final */ public boolean rButton = false;
		/* final */ public boolean searchInchiKey = true;
		/* final */ public boolean showAtomMoveJButton = true;
		// BB
		/* final */ public boolean showDragAndDropIconInDepictMode = true;
		// BB
		/* final */ public boolean showFullScreenIconInDepictMode = true;
		// BB
		/* final */ public boolean starAtomOnly = false;
		/* final */ public boolean starBondOnly = false;
		/* final */ public boolean starNothing = false;
		/* final */ public boolean stereo = true;
		/* final */ public boolean toggleDepictEdit = false;
		// BB
		/* final */ public boolean useOclIdCode = false;
		// OpenChemLib option: useOclIDCode
		/* final */ public boolean useOpenChemLib = true; // for SMILES input

		// BH
		/* final */ public boolean boldAtomLabels = true;

		public boolean multipart = true;
		public boolean query = false;
		public boolean reaction = false;
		public boolean xButton = true;

		// Applet-style parameter options

		String jmeString = null;
		String molString = null; // why is this variable declared here? Because it is used in init() and start()
		String genericChemicalInputFromInit = null;
		double atomBGcircleRelativeSize = defaultAtomBGcircleRelativeSize;
		double bondBGrectRelativeSize = defaultBondBGrectRelativeSize;

		public boolean runsmi = false;
		// String depictcgi = null;
		// String depictservlet = null;

		private String options;

		private Boolean parseOption(String option) {
			return parseOption(option, "no");
		}

		/**
		 * Add the JME field to the HTML applet object.
		 * 
		 * @param jme
		 */
		public void registerJS(JME jme) {
			HTML5Applet a = getApplet(false);
			if (a == null)
				return;/**
						 * @j2sNative
						 * 
						 * 			a.JME = jme;
						 */
			{
			}
		}

		public void getAppletOptions(JME jme) {
			try {
				String options = getParameter("options");
				if (options != null)
					set(options);
				String p;
				if ((p = getParameter("jme")) != null)
					jmeString = p;
				if ((p = getParameter("mol")) != null)
					molString = p;
				if ((p = getParameter("chem")) != null)
					genericChemicalInputFromInit = p;
				if ((p = getParameter("smiles")) != null)
					genericChemicalInputFromInit = p;
// BH not referenced
//				if ((p = getParameter("depictcgi")) != null) {
//					depictcgi = p;
//					runsmi = true;
//				}
				if ((p = getParameter("text")) != null)
					molText = p;
				atomBgColors = getParameter("atombg");
				if ((p = getParameter("depictbg")) != null)
					canvasBg = ColorManager.parseHexColor(p);
				if ((p = getParameter("guicolor")) != null)
					setUserInterfaceBackgroundColor(p);
				if ((p = getParameter("guiAtomColor")) != null)
					setLeftMenuAtomColor(p);
				if ((p = getParameter("atombgsize")) != null) {
					double d = Double.valueOf(p);
					atomBGcircleRelativeSize = (d < 0 ? defaultAtomBGcircleRelativeSize : d);
				}
				if ((p = getParameter("bondbgsize")) != null) {
					double d = Double.valueOf(p);
					bondBGrectRelativeSize = (d < 0 ? defaultBondBGrectRelativeSize : d);
				}

				if (showAtomNumbers)
					showAtomNumbers();

				JSFunction f = (JSFunction) (Object) getParameter("notify_structural_change_js_function");
				if (f != null)
					setNotifyStructuralChangeJSfunction(f);
				handleAdditionalParameters();

			} catch (Exception e) {
				System.err.println("JME:  parameters error");
			}
		}

		/**
		 * Get either the JApplet (possibly a JSDummyApplet) linking this to its
		 * JavaScript HTMLApplet counterpart, or that counterpart.
		 * 
		 * @param asJava true to return the JApplet; false to return the DOM object for
		 *               which ._applet is the JApplet.
		 * @return
		 */
		public HTML5Applet getApplet(boolean asJApplet) {
			@SuppressWarnings("unused")
			Object g = Thread.currentThread().getThreadGroup();
			/**
			 * @j2sNative var a = g.getHtmlApplet$(); return (asJApplet ? a._applet : a);
			 * 
			 */
			{
				// Java only
				return null;
			}

		}

		/**
		 * The -c option allows calling any method in sequence with other operations.
		 * 
		 * "this" in the callback will be this JME instance.
		 * 
		 * @param f    generally a function such as function(args) {var x = this;.....}
		 * @param args
		 */
		public void callback(Object f, Object args) {
			@SuppressWarnings("unused")
			JME jme = JME.this;
			/**
			 * @j2sNative
			 * 
			 * 			f.apply(jme, args);
			 */
		}

		public String getParameter(String p) {
			// SwingJS sets the applet in the ThreadGroup
			JApplet applet = (JApplet) getApplet(true);
			return (applet == null ? null : applet.getParameter(p));
		}

		/**
		 * use boundaries for the search
		 * 
		 * @param parameters
		 * @param option
		 * @param negativePrefix
		 * @return null if option not found
		 */
		private Boolean parseOption(String option, String negativePrefix) {
			boolean pos = (options.indexOf(";" + option + ";") >= 0);
			boolean neg = (options.indexOf(";" + negativePrefix + option) >= 0);
			if (pos && neg) {
				log("check option " + option);
				return null;
			}
			return (pos ? Boolean.TRUE : neg ? Boolean.FALSE : null);
		}

		// useful for options with multiple names - for instance star option has been
		// renamed to marker
		private Boolean parseSynonymOptions(String parameters, String... options) {
			for (String eachOption : options) {
				Boolean found = parseOption(eachOption);
				if (found != null) {
					return found;
				}
			}
			return null;
		}

		/**
		 * 
		 * @param parameters
		 * @return true if repaint is needed (always)
		 */
		public void set(String parameters) {

			// boolean repaint = true;

			Boolean o;
			// definition of Regex "word boundary"
			String p0 = parameters;
			parameters = parameters.replaceAll("[^_0-9a-zA-Z]", ";");
			boolean one = (p0.equals(parameters));
			options = ";" + parameters.toLowerCase() + ";";

			// BH note -- if more are added, make sure they are lowercase here

			if ((o = parseOption("depict")) != null) {
				setDepictOption(o.booleanValue());
				if (one)
					return;
			}
			if ((o = parseSynonymOptions(parameters, "star", "marker")) != null) {
				if (params.mark != o) {
					params.number = params.mark = o; // why number?
					// activeMarkerColorIndex = parameters.mark ? 0 : -1; //WIP
					mustRedrawEverything();
					if (!o) // eif star is off, so is star1
						markOnly1 = false;
				}
				if (one)
					return;
			}
			if ((o = parseOption("headless")) != null) { // BH 2023.01.22
				headless = true;
			}

			if ((o = parseOption("boldatomlabels")) != null) {
				boldAtomLabels = o;
			}
			if ((o = parseOption("rbutton")) != null) {
				rButton = o;
				gui.mustReDrawLeftMenu = true;
			}

			// show implicit H
			if ((o = parseOption("hydrogens")) != null) {
				if (params.hydrogenParams.showHs != o) {
					params.hydrogenParams.showHs = o;
					mustReDrawMolecularArea();
				}
			}

			if ((o = parseOption("valencestate")) != null) {

				if (params.computeValenceState != o) {
					params.computeValenceState = o; // April 2019
					mustReDrawMolecularArea();

					// should we update all atom internals e.g. charge, nh, ...?
					// mustReDrawMolecularArea();
					// repaint = true;
				}
			}

			if (parameters.indexOf("keephs") > -1) {
				// keepHydrogens = true;
				// removeOnlyCHydrogens = false;
				params.hydrogenParams.removeHs = false;
			}
			if (parameters.indexOf("removehs") > -1) {
				params.hydrogenParams.removeHs = true;
				params.hydrogenParams.removeOnlyCHs = false;
			}

			if (parameters.indexOf("removehsc") > -1) {
				// keepHydrogens = false;
				// removeOnlyCHydrogens = true;
				setRemoveHsC();

			}

			if ((o = parseOption("query")) != null)
				if (query != o) {
					query = o;
					// repaint = true;
				}

			if ((o = parseOption("reaction")) != null) {
				if (reaction != o) {
					setMustRedrawMolecularArea(true); // reaction arrow change : redrawing needed
					// repaint = true;
				}
				if (!reaction) {
					reactionArrow.hasBeenPlaced = false;
				}
				reaction = o;
			}

			// SMILES and general -- polarnitro and stereo
			if ((o = parseOption("polarnitro")) != null) {
				polarnitro = params.smilesParams.polarnitro = o;
			}
			if ((o = parseOption("stereo")) != null)
				stereo = params.smilesParams.stereo = o;

			// SMILES only
			if ((o = parseOption("autoez")) != null)
				params.smilesParams.autoez = o;
			if ((o = parseOption("smilesaromatic")) != null)
				params.smilesParams.allowaromatic = o;
			if ((o = parseOption("canonize")) != null)
				params.smilesParams.canonize = o;

			if ((o = parseOption("multipart")) != null)
				if (multipart != o) {
					multipart = o;
					// repaint = true;
				}

			// New: handling the negative option
			if (o = parseOption("autonumber") != null) {
				if (autonumber != o) {
					autonumber = o;
					if (autonumber) {
						setNumber(true);
//						return repaint; // BH 2023.01.21 why return???
					}
				}
			}

			if (o = parseOption("number") != null) {
				setNumber(o.booleanValue());
			}

			if (o = parseOption("showatommapnumberwithbackgroundcolor") != null) {
				params.showAtomMapNumberWithBackgroundColor = o;
			}

			if ((o = parseOption("newlook")) != null) {
				newLook = o;
				resetAllGraphics();
			}
			if ((o = parseOption("oldlook")) != null) {
				newLook = !o;
				resetAllGraphics();
			}

			if ((o = parseSynonymOptions(parameters, "star1", "marker1")) != null) {
				if (markOnly1 != o) {
					markOnly1 = o;
					if (o) {
						params.number = params.mark = o; // why
															// number?
					} else {

					}
					mustRedrawEverything();

				}

			}

			if ((o = parseOption("markermenu")) != null) {
				markerMenu = o;
			}

//			if ((optionTest = parseSynonymOptions(parameters, markerMultiColorOptionJLabel )) != null) {
//				if (parameters.markerMultiColor != optionTest) {
//					parameters.markerMultiColor = optionTest;
//					
//					mustRedrawEverything();
			//
//				}
			//
//			}

			// atom marking will not happen, but an event will be triggered
			if ((o = parseOption("pseudomark")) != null) {
				pseudoMark = o;
			}

			if ((o = parseOption("markatomonly")) != null) {
				starAtomOnly = o;
				if (starAtomOnly) {
					starBondOnly = false;
					if (starNothing) {
						// repaint = true;
					}
					starNothing = false;
				}
			}
			if ((o = parseOption("markbondonly")) != null) {
				starBondOnly = o;
				if (starBondOnly) {
					starAtomOnly = false;
					if (starNothing) {
						// repaint = true;
					}
					starNothing = false;
				}
			}

			if ((o = parseOption("marknothing")) != null) {
				if (starNothing != o) {
					// repaint = true;
					starNothing = o;
				}
			}

			if ((o = parseOption("fgmenu")) != null) {
				fgMenuOption = o;
				gui.mustReDrawTopMenu = true;
			}

			if ((o = parseOption("toggle")) != null)
				toggleDepictEdit = o;

			// BB
			if ((o = parseOption("depictaction")) != null) {
				depictActionEnabled = o;
				if (depictActionEnabled) {
					setDepictOption(true);
				}
			}
			if ((o = parseOption("showdraganddropoiconindepictmode")) != null)
				showDragAndDropIconInDepictMode = o;
			// older naming of the same option
			if ((o = parseOption("showdraganddropsymbolindepictmode")) != null)
				showDragAndDropIconInDepictMode = o;
			if ((o = parseOption("addnewpart")) != null)
				addNewPart = o;
			if ((o = parseOption("exportinchi")) != null)
				exportInchi = o;
			if ((o = parseOption("exportinchikey")) != null)
				exportInchiKey = o;
			if ((o = parseOption("exportinchiauxinfo")) != null)
				exportInchiAuxInfo = o;
			if ((o = parseOption("searchinchikey")) != null)
				searchInchiKey = o;
			if ((o = parseOption("exportsvg")) != null)
				exportSVG = o;
			if ((o = parseOption("exportrxnmerge")) != null)
				exportRXNmergeOption = o;
			if ((o = parseOption("contextmenu")) != null)
				contextMenuEnabledOption = o;
			if ((o = parseOption("fullscreenicon")) != null)
				fullScreenIconOption = o;
			if ((o = parseOption("showfullscreeniconindepictmode")) != null)
				showFullScreenIconInDepictMode = o;

			if ((o = parseOption("useoclidcode")) != null)
				useOclIdCode = o;

			if ((o = parseOption("xbutton")) != null) {
				if (xButton != o) {
					xButton = o;
					// repaint = true;
				}

			}
			if ((o = parseOption("paste")) != null)
				if (paste != o) {
					paste = o;
				}

			if ((o = parseOption("border")) != null)
				if (depictBorder != o) {
					depictBorder = o;
					// repaint = true;
					mustRedrawEverything();
				}

			// undocumented options
//			if (parameters.indexOf("writesmi") > -1)
//				writesmi = true;
//			if (parameters.indexOf("writemi") > -1)
//				writemi = true;
//			if (parameters.indexOf("writemol") > -1)
//				writemol = true;
			if (parameters.indexOf("nocenter") > -1)
				nocenter = true;
			if (parameters.indexOf("jmeh") > -1)
				jmeh = true;
			if (parameters.indexOf("showan") > -1)
				showAtomNumbers = true;
			if ((o = parseOption("atommovebutton")) != null)
				showAtomMoveJButton = o;
			if ((o = parseOption("useopenchemlib")) != null)
				useOpenChemLib = o;
			if ((o = parseOption("zoom")) != null)
				allowGUIzooming = allowZooming = o;

			// new Feb 2022
			if ((o = parseOption("zoomgui")) != null)
				allowGUIzooming = o && allowZooming;

			// zladi options - ake dalsie ???
			if (reaction) {
				// BB: if a reaction is read, then the numbering should be autonumber and not
				// number. This should be checked by Peter.
				// With autonumber, one can assign different atom map numbers
				// number = true;
				autonumber = true;
				multipart = true;
			}
			if (!isDepict())
				depictBorder = false;
			handleAdditionalOptions(options);

			resetJPopupMenu(); // the pop menu contains entries and labels that night need to be removed or
								// added or changed

			// if star is disabled , then go back to default action
			if (action == Actions.ACTION_MARK && (params.mark == false || starNothing)) {
				action = Actions.ACTION_BOND_SINGLE;
			}
		}

		private void setDepictOption(boolean tf) {
			boolean depicting = isDepict();
			if (tf != depicting) {
				if (depicting) {
					// BB CHeck if nodepictaction is used
					setDepict(false);
					// molecularAreaScale = 1; // inak kresli mensi font
					resetMolecularAreaScale();

					// october 2019 - depict bug fix

					// musi male molekuly vratit na povodnu velkost
					// for (int i = 1; i <= numberofMoleculeParts; i++) {
					// moleculeParts[i].scaling();
					// moleculeParts[i].center(); // este raz, teraz uz zmensene
					// }

					// JMEmol.centerMolList(this, moleculeParts, numberofMoleculeParts);

					// BB moved above - fixed a bug
					// depictScale = 1; // inak kresli mensi font
					// normal font (ak bola mensia molekula) sa nastavi v
					// drawMolecularArea
					gui.menuCellSize = GUI.standardMenuCellSize;
					paste = true; // BB March 2014 :
					// paste option will be set below
					resetAllGraphics();
				} else {
					setDepict(true);
					gui.menuCellSize = 0;
					molecularAreaImage = null; // pre prechode z depict je ta primala
					// toto len pre norm moleculeParts, nie pre reaction !!!
					// alignMolecules(1, numberofMoleculeParts, 0); //will be done during the
					// repaint
					paste = false; // BB March 2014 : default does not accept paste anymore

					// October 2019
					if (moleculePartsList.size() > 0) {
						// this is done when reading the input file
						molecularAreaScalePixelsPerCoord = scaleAndCenterForDepictMode(graphicalObjectList());
					}
					resetAllGraphics();
				}
			}
		}

		private void setNumber(boolean tf) {
			if (params.number != tf)
				gui.mustReDrawTopMenu = true;
			params.number = tf;
			if (!params.number)
				autonumber = false;
			else {
				if (params.mark)
					mustRedrawEverything(); // if star option is selected later
				params.mark = false;
			}
		}

		public Object getInfo(String param) {
			@SuppressWarnings("unused")
			Object html5applet = getApplet(false);
			/**
			 * @j2sNative
			 * 
			 * 			return html5applet.__Info[param];
			 */
			{
				return null;
			}
		}

	}

	public void handleAdditionalOptions(String options) {
		// for subclasses
	}

	@Override
	public void dragGestureRecognized(DragGestureEvent dge) {
		try {
			MouseEvent e = (MouseEvent) dge.getTriggerEvent();
			if (e.getID() != MouseEvent.MOUSE_PRESSED)
				return;
			int x = e.getX();
			int y = e.getY();
			if (!gui.dragAndDropIcon.contains(x, y))
				return;
			Cursor cursor = null;
			System.out.println(dge.getDragAction());
			if (dge.getDragAction() == DnDConstants.ACTION_COPY) {
				cursor = DragSource.DefaultCopyDrop;
				dge.startDrag(cursor, new Transferable() {

					@Override
					public DataFlavor[] getTransferDataFlavors() {
						// TODO Auto-generated method stub
						return new DataFlavor[] { DataFlavor.stringFlavor };
					}

					@Override
					public boolean isDataFlavorSupported(DataFlavor flavor) {
						// TODO Auto-generated method stub
						return flavor == DataFlavor.stringFlavor;
					}

					@Override
					public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
						if (flavor == DataFlavor.stringFlavor) {
							return molFile();
						}
						return null;
					}

				});

			}
		} catch (Throwable t) {
			System.out.println("hmm");
		}
	}

	public static void main(String args[]) {
		JFrame frame = new JFrame("JME Molecular Editor");
		frame.addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(WindowEvent evt) {
				System.exit(0);
			}
		});
		frame.setBounds(300, 200, 24 * 18, 24 * 16); // urcuje dimensions pre
		JME jme = new JME(frame, false, args);
		SwingUtilities.invokeLater(() -> {
			frame.setVisible(true);
			jme.start(args);
		});
	}

	public boolean doDrawChiralText() {
		return (activeMol != null && moleculePartsList.hasOneMoleculeWithChiralFlag());
	}

	protected boolean structureChangedByAction;

	public void startKeyboardAction() {
		structureChangedByAction = false;
	
	}

	public void endKeyboardAction() {
		postAction(structureChangedByAction);
	}

	

} // End of JME class
