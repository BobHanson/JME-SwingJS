package jme;

// BH 2023.01.20:

// - adds headless creation of PNG images
// - adds JmolD.jar (could use JmolData.jar, ufnless one wants to show the Jmol frame).
// - JME constructor clean-up and expansion
// - centralizes options in Options class
// - adds hooks for subclass JmolJME to write CDXML, MOL, and PNG images using a file dialog

// BH 2023.01.15:
// - moved OCL-dependent methods to OclParser implements Parser
//   -- these are generated by reflection, so a subclass could change that 
// - switched to Swing
//   -- changes java.applet.Applet (deprecated) to JPanel, so JFrame required (but in SwingJS this can be embedded in a div)
//   -- changes Button to JButton, Choice to JComboBox, etc.
//   -- no bypassing simple paints -- just paint everything, since Swing will manage painting itself.
// - corrected missing dimension "2D" in MOL V2000 and V3000 writers.

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Event;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.net.URL;
import java.util.NoSuchElementException;
import java.util.Vector;

import javax.swing.JApplet;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;

import jme.Box.Axis;
import jme.ChemicalFormatDetector.MajorChemicalFormat;
import jme.ColorManager.ColorInfo;
import jme.JMEUtil.GWT;
import jme.JMEUtil.JSME_RunAsyncCallback;
import jme.JMEUtil.RunAsyncCallback;
import jme.JMEUtil.RunWhenDataReadyCallback;
import jme.JMEmol.ReactionRole;
import jme.JMEmolList.MolFileOrRxnParameters;
import jme.MoleculeHandlingParameters.HydrogenHandlingParameters;
import jme.TextTransfer.PasteAction;

// ----------------------------------------------------------------------------
// ****************************************************************************
@SuppressWarnings("serial")
public class JME extends JPanel implements ActionListener, MouseWheelListener, MouseListener, KeyListener,
		MouseMotionListener, PropertyChangeListener {

	public interface HTML5Applet {
		public Object getParameter(String s);
	}

	protected final Options options = new Options();

	// customization
	static final String version = "2014-06-28";
	// static final String startInfoText = "JSME Molecular Editor by Peter Ertl and
	// Bruno Bienfait";
	static final String startInfoText = "Molecular Editor by Peter Ertl and Bruno Bienfait";
	// JSME or JME selected according to the run-time environment
	static final String copyright[] = { "Copyright (c) 2014-2023, Peter Ertl, Bruno Bienfait, and Robert Hanson.",
			"All rights reserved." };
	// Note: the copyright is too long for the info()

	// used for parsing input
	public static final String NumberParsingErrorMsg = "Number parsing";
	public static final String NotEnoughDataMsgError = "Not enough data";

	protected String parserImpl = "jme.OclParser";

	protected static final String OCL_ID_CODE_LABEL = "OCL ID code" /* + " to the clipboard" */;
	protected static final String UN_MARK_ATOM = "unMarkAtom";
	protected static final String MARK_ATOM = "markAtom";
	protected static final String ADD_ATOM_QUERY = "addAtomQuery";
	protected static final String CHARGE_ATOM_MINUS = "chargeAtom-";
	protected static final String CHARGE_ATOM_PLUS = "chargeAtom+";
	protected static final String CHARGE_ATOM0 = "chargeAtom0";
	protected static final String DEL_ATOM2 = "delAtom";
	protected static final String SET_ATOM = "setAtom";
	protected static final String DEL_BOND2 = "delBond";
	protected static final String DEL_ATOM = DEL_ATOM2;
//	protected static final String MARK = "mark";
	protected static final String AUTO_NUMBER = "autonumber";
	protected static final String SD_FSTACK = "SDFstack";
	protected static final String REDO = "redo";
	protected static final String UNDO = "undo";
	protected static final String READ_MOL_FILE = "readMolFile";
	protected static final String READ_RXN_FILE = "readRXNFile";
	protected static final String READ_JME = "readJME";
	protected static final String READ_SMILES = "readSMILES";
	protected static final String READ_SMIRKS = "readSMIRKS";
	protected static final String READ_OCLCODE = "readOCLCode";
	protected static final String READ_MULTI_SDF = "readMultiSDF";

	protected static final String CLEAR = "clear";
	protected static final String RESET = "reset";

	/* for recording events to external program */
	protected static final String ADD_GROUP = "addGroup";
	protected static final String ADD_TEMPLATE = "addTemplate";
	protected static final String ADD_ATOM = "addAtom";
	protected static final String ADD_RING = "addRing";
	protected static final String ADD_BOND = "addBond";
	protected static final String ADD_CHAIN = "addChain";
	protected static final String UN_MARK_BOND = "unMarkBond";
	protected static final String MARK_BOND = "markBond";
	protected static final String SET_QUERY_BOND = "setQueryBond";
	protected static final String ADD_RING_BOND = "addRingBond";
	protected static final String SET_BOND_TRIPLE = "setBondTriple";
	protected static final String SET_BOND_SINGLE = "setBondSingle";
	protected static final String SET_BOND_COORDINATION = "setBondCoordination";
	protected static final String UNSET_BOND_COORDINATION = "unSetBondCoordination";
	protected static final String SET_BOND_DOUBLE = "setBondDouble";
	protected static final String SET_BOND_STEREO = "setBondStereo";
	protected static final String DEL_BOND_GROUP = "delBondGroup";
	protected static final String DEL_BOND = DEL_BOND2;

	protected static final String MOVE_ATOM = "moveAtom";
	protected static final String CHANGE_CHIRAL = "changeChiral";
	protected static final String CHANGE_ATOM_MAP = "changeAtomMap";
	protected static final String CHANGE_MANY_ATOM_MAP = "changeManyAtomMap";
	protected static final String DELETE_HYDROGENS = "deleteHydrogens";
	protected static final String COMPUTE_2D = "compute2D";
	protected static final String DELETE_ATOM_MAPS = "deleteAtomMaps";

	protected static final String SET_ATOM_ADDITIONAL_DATA = "setAtomAdditionalData";
	protected static final String SET_BOND_ADDITIONAL_DATA = "setBondAdditionalData";

	protected static final String CHANGE_REACTION_ROLE = "changeReactionRole";
	protected static final String REACTION_COPY = "reactionCopy";

	protected final static String separator = "\n";

	protected static boolean isStandAloneApplication = false; // by default the program starts as an applet

	protected static final double standardMenuCellSize = 24; // the original value
	protected static final double rightBorderNewLook = 1.0;
	protected static final double rightBorderOldLook = 3; // older look needs more space because of it has a shadow

	final static String helpUrl = "https://jsme-editor.github.io/help.html";
	final static String websiteUrl = "https://jsme-editor.github.io/";
	final static int copyRigthmallTextFontSize = 8; // used in the info box for copyright
	final static Font copyRigthSmallTextFont = new Font(null, 0, copyRigthmallTextFontSize);

	public static enum SupportedFileFormat {
		JME, SMILES, MOL, MOL_V3000, JMOL, INCHI, INCHI_KEY, INCHI_AUXINFO, INCHI_JSON, OCLCODE, SVG, RAW_STRING_GRAPHIC
	}

	// should extend CopyOnClipboard
	// - not possible in Java ??
	// BH -- What's the question here?

	protected static enum CopyPasteAction {
		JME, SMILES, MOL, MOL_V3000, INCHI, INCHI_KEY, INCHI_AUXINFO, INCHI_JSON, OCLCODE, SVG, RAW_STRING_GRAPHIC,
		SEARCH_INCHI_KEY, PASTE;

		public SupportedFileFormat getFormat() {
			return SupportedFileFormat.valueOf(toString());
		}
	}

	// editor state
	int action;

	TouchedMol lastTouchedMol = new TouchedMol();
	TouchedMol newTouchedMol = new TouchedMol();

	int reactionParts[][]; // computed with getReactionParts()
	int active_an;

	protected String infoText = null;
	String customDefaultInfoText = ""; // may be changed by the JS call

	double menuCellSize = standardMenuCellSize; // should be a multiple of 2 and 3, is set 0 in depict mode

	int arrowWidth = 24 * 2;
	ReactionArrow reactionArrow = new ReactionArrow(36 * 2);

	// the IO triangle/arrows
	double ioMargin = 3;
	double ioArrowWidth = ((double) (menuCellSize - 2 * ioMargin) / 1.5);

	// in depict mode, make the DnD and full screen icons smaller
	double smallerIconsForDepictMode = 0.6;

	Color bgColor = Color.lightGray;
	Color brightColor = bgColor.brighter();
	Color leftMenuAtomColor = null;

	// File format for Ctrl C
	protected SupportedFileFormat clipboardFormat = SupportedFileFormat.MOL;

	protected JMEevent afterStructureChangeEvent = new JMEevent();

	// icons
	protected Icon fullScreenIcon;
	protected boolean isFullScreen = false;
	protected boolean fullScreenEnterOrExit = false;

	protected Icon dragAndDropIcon;

	// Fonts
	Font menuCellFont;
	Font menuCellFontBold; // for the atom symbols
	Font menuCellFontSmaller;
	Font atomDrawingAreaFont, dialogFont;
	Font atomMapDrawingAreaFont;
	FontMetrics menuCellFontMet, menuCellFontBoldMet, menuCellFontSmallerMet;
	FontMetrics atomDrawingAreaFontMet;
	FontMetrics atomMapDrawingAreaFontMet;

	int fontSize = 13; // with a value != 12, the stringWidth errors are minimized in JS
	float atomMolecularDrawingAreaFontSize = fontSize; // BB

	String defaultFontFamily = "Helvetica"; // looks good everywhere

	protected boolean appletHasBeenResized = false;
	Rectangle2D.Double previousScaledScreenArea = null;

	protected float molecularAreaLineWidth = (float) 1.0;

	public boolean molecularAreaAntiAlias = true;

	boolean depict = false;

	// tieto parametere sa naplnaju v init (aby sa vynulovali pri starte)
	// boolean bwMode = false;
	
	SmilesCreationParameters smilesPars = new SmilesCreationParameters();
	public MoleculeHandlingParameters params = new MoleculeHandlingParameters();

	boolean pasteFromSDFstack = false;

	boolean jmeh = false; // used in jSME

	Color canvasBg = Color.white;
	// Color starColor = Color.cyan;

	// index in the color manager palette, 0 based index
	public final static int DefaultMarkerColorIndex = 1;
	int activeMarkerColorIndex = DefaultMarkerColorIndex;

	// String atomColors = null; // atom coloring
	String atomBgColors = null; // background coloring
	final static double defaultAtomBGcircleRelativeSize = 0.8;
	final static double defaultBondBGrectRelativeSize = 0.5;


	public final static double defaultMolecularAreaScale = 1.0;

	protected double molecularAreaScalePixelsPerCoord = defaultMolecularAreaScale; // ked scaling viacero moleculeParts,
																					// alebo
	// reaction
	protected final double minmolecularAreaScale = 0.3;
	protected final double maxMolecularAreaScale = 10;

	protected double menuScale = 1.0; // BB scaling the menu
	protected final double minMenuScale = 0.7;
	protected final double maxMenuScale = 4;

	final static boolean scalingIsPerformedByGraphicsEngine = true; // BB, gives nicer looking depiction

	boolean nocenter = false;
	boolean showAtomNumbers = false; // only when starting with a molecule
	// scaling pri depict, nacitanie molekul (jme + mol)

	boolean allowFullScreenToggle = true;

	// files na nacitanie (2002.06)

	// Java applet code but can also be retrieved in JavaScript application

	// pouziva v double bufferingu
	protected Dimension dimension;

	protected PreciseImage molecularAreaImage;
	int molecularAreaPixelWidth;
	int molecularAreaPixelHeight;

	// these images are not used in depict mode
	PreciseImage topMenuImage, leftMenuImage;
	PreciseImage infoAreaImage;
	PreciseImage rightBorderImage;

	// pre repaint()
	// boolean doMenu = true; // ci draw menu pri repaint()
	boolean movePossible; // not to move when dragg in menu

	// BB - avoid unnecessary redraw - speed optimization for slow browsers
	boolean mustReDrawLeftMenu = true;
	boolean mustReDrawTopMenu = true;
	boolean mustReDrawMolecularArea = true;
	boolean mustReDrawInfo = true;
	boolean mustReDrawRightBorderImage = true;

	protected String notifyStructuralChangeJSfunction = null;
	protected String notifyAtomHighLightJSfunction = null;
	protected String prePasteJSfunction = null;

	protected String pasteJLabel = null;

	// boolean atomWasTouched = false;
	// boolean bondWasTouched = false;

	// the ACTION code on which the mouse was during mouse move
	int mouseWasOverAction = 0;

	public ColorManager colorManager = new ColorManager();

	// actions 2 riadky s ACTIONX a atomy s ACTIONA
	static int LEFT_MENU_NUMBER_OF_CELLS = 10; // meni sa podla rxButton
	static final int LEFT_MENU_NUMBER_OF_CELLS_WITHOUT_X_R = 9;
	// cislo action urcuje aj polohu buttonu
	// empty buttons (a ACTION_END v aplete) su vyradene v mousePressed()
	// a kreslenie textov v createSquare (neda sa to v jednom ?)
	static final int ACTION_DELETE = 104;
	static final int ACTION_MARK = 105;
	static final int ACTION_DELGROUP = 106;
	static final int ACTION_SMI = 101;
	static final int ACTION_QRY = 107;
	static final int ACTION_REACP = 109;
	static final int ACTION_UNDO = 110;
	static final int ACTION_REDO = 111;
	static final int ACTION_SPIRO = 112; // BB: was 111
	static final int ACTION_CLEAR = 102;
	static final int ACTION_NEW = 103; // using newMolecule

	static final int ACTION_MOVE_AT = 113; // BB: new

	static final int ACTION_JME = 114; // BB: was 113

	// BB: the number of cells in the top menu - was ACTION_X
	static final int TOP_MENU_NUMBER_OF_CELLS = ACTION_JME - 100; // assume that ACTION_JME is the last menu entry on
																	// the top row

	static final int ACTION_PGUP = 151;
	static final int ACTION_PGDN = 152;
	static final int ACTION_HOME = 153;
	static final int ACTION_END = 154;

	static final int ACTION_ROT90 = 156; // webme
	static final int ACTION_CHARGE_PLUS = 157; // webme
	static final int ACTION_CHARGE_MINUS = 158; // webme

	static final int ACTION_CHARGE = 108;
	static final int ACTION_STEREO = 201;
	static final int ACTION_BOND_SINGLE = 202;
	static final int ACTION_BOND_DOUBLE = 203;
	static final int ACTION_BOND_TRIPLE = 204;
	static final int ACTION_CHAIN = 205;
	static final int ACTION_RING_3 = 206;
	static final int ACTION_RING_4 = 207;
	static final int ACTION_RING_5 = 208;
	public static final int ACTION_RING_PH = 209;
	static final int ACTION_RING_6 = 210;
	static final int ACTION_RING_7 = 211;
	static final int ACTION_RING_8 = 212;

	static final int ACTION_FG = 213; // BB: button for a popup menu with functional groups
	// static final int ACTION_EMPTY_CELL = 214; //BB: defined only to avoid
	// highliting when click on it, to be removed?
	static final int ACTION_IO = 214; // BB replace ACTION_EMPTY_CELL by I/O icon below info icon

	static final int ACTION_RING_FURANE = 221; // nema button
	static final int ACTION_RING_3FURYL = 223; // Alt 0
	static final int ACTION_RING_9 = 229; // nema button
	static final int ACTION_TEMPLATE = 230;

	static final int ACTION_GROUP_MIN = 233; // BB first entry in the substituents (FG)
	static final int ACTION_GROUP_TBU = 233;
	static final int ACTION_GROUP_NITRO = 234;
	static final int ACTION_GROUP_COO = 235;
	static final int ACTION_GROUP_CF3 = 236;
	static final int ACTION_GROUP_CCL3 = 237;
	static final int ACTION_GROUP_CC = 238;
	static final int ACTION_GROUP_SULFO = 239;
	static final int ACTION_GROUP_COOME = 240;
	static final int ACTION_GROUP_OCOME = 241;
	static final int ACTION_GROUP_CYANO = 242;
	static final int ACTION_GROUP_NME2 = 243;
	static final int ACTION_GROUP_NHSO2ME = 244;
	static final int ACTION_GROUP_CCC = 245;
	static final int ACTION_GROUP_C2 = 246;
	static final int ACTION_GROUP_C3 = 247;
	static final int ACTION_GROUP_C4 = 248;
	static final int ACTION_GROUP_COH = 249;
	static final int ACTION_GROUP_dO = 250; // =O
	static final int ACTION_GROUP_PO3H2 = 251;
	static final int ACTION_GROUP_SO2NH2 = 252;
	static final int ACTION_GROUP_TEMPLATE = 253;
	static final int ACTION_GROUP_CF = 254;
	static final int ACTION_GROUP_CL = 255;
	static final int ACTION_GROUP_CB = 256;
	static final int ACTION_GROUP_CI = 257;
	static final int ACTION_GROUP_CN = 258;
	static final int ACTION_GROUP_CO = 259;
	static final int ACTION_GROUP_CON = 260; // BB
	static final int ACTION_GROUP_NCO = 261; // BB
	static final int ACTION_GROUP_MAX = 262; // last+1 len na < test

	static final int ACTION_AN_C = 301;
	static final int ACTION_AN_N = 401;
	static final int ACTION_AN_O = 501;
	static final int ACTION_AN_S = 601;
	static final int ACTION_AN_F = 701;
	static final int ACTION_AN_CL = 801;
	static final int ACTION_AN_BR = 901;
	static final int ACTION_AN_I = 1001;
	static final int ACTION_AN_P = 1101;
	static final int ACTION_AN_X = 1201;

	static final int ACTION_AN_H = 1300; // does not match a square posiiton on left menu
	// added by BB
	// static final int ACTION_AN_STAR = 1301;

	static final int ACTION_AN_R = 1301; // must be 1301 because it corresponds to the left menu square position ???
	static final int ACTION_AN_R1 = 1302;
	static final int ACTION_AN_R2 = 1303;
	static final int ACTION_AN_R3 = 1304;
	// added by BB
	static final int ACTION_AN_R4 = 1305;
	static final int ACTION_AN_R5 = 1306;
	static final int ACTION_AN_R6 = 1307;
	static final int ACTION_AN_R7 = 1308;
	static final int ACTION_AN_R8 = 1309;
	static final int ACTION_AN_R9 = 1310;

	static final int ACTION_AN_R_LAST = 1310;
	// end added by BB

	// JSME custom atomic numbers for use in Atom.na
	// TODO Element table
	static final int AN_H = 1;
	static final int AN_B = 2;
	static final int AN_C = 3;
	static final int AN_N = 4;
	static final int AN_O = 5;
	static final int AN_SI = 6;
	static final int AN_P = 7;
	static final int AN_S = 8;
	static final int AN_F = 9;
	static final int AN_CL = 10;
	static final int AN_BR = 11;
	static final int AN_I = 12;
	static final int AN_SE = 13;

	// BB
	// https://en.wikipedia.org/wiki/List_of_oxidation_states_of_the_elements
	static final int AN_K = 14;
	static final int AN_METAL1_START = AN_K;
	static final int AN_Na = 15;
	static final int AN_Li = 16;
	static final int AN_Rb = 17;
	static final int AN_Cs = 18;
	static final int AN_Fr = 19;
	static final int AN_Ag = 20;
	static final int AN_METAL1_END = AN_Ag;

	static final int AN_Mg = AN_METAL1_END + 1;
	static final int AN_METAL2_START = AN_Mg;
	static final int AN_Ca = AN_Mg + 1;
	static final int AN_Ba = AN_Ca + 1;
	static final int AN_Sr = AN_Ba + 1;;
	static final int AN_Zn = AN_Sr + 1;
	static final int AN_Ni = AN_Zn + 1;
	static final int AN_Cu = AN_Ni + 1;
	static final int AN_Cd = AN_Cu + 1;

	static final int AN_METAL2_END = AN_Cd;

	static final int AN_METAL3_START = AN_METAL2_END + 1;
	static final int AN_Al = AN_METAL3_START;
	static final int AN_Ga = AN_Al + 1;
	static final int AN_Au = AN_Ga + 1;
	static final int AN_METAL3_END = AN_Au;

	static final int AN_X = AN_METAL3_END + 1;

	static final int AN_R = AN_X + 1;
	// static final int AN_R1 = 20;
	// static final int AN_R2 = 21;
	// static final int AN_R3 = 22;
	// added by BB
	static final int AN_R_LAST = AN_R + 9; // keep the 9! 1 value for each R

	static final int actionToAtomNumberArray[] = { ACTION_AN_C, AN_C, ACTION_AN_N, AN_N, ACTION_AN_O, AN_O, ACTION_AN_F,
			AN_F, ACTION_AN_CL, AN_CL, ACTION_AN_BR, AN_BR, ACTION_AN_I, AN_I, ACTION_AN_S, AN_S, ACTION_AN_P, AN_P,
			ACTION_AN_H, AN_H, ACTION_AN_X, AN_X, ACTION_AN_R, AN_R, };

	static final Color color[] = new Color[AN_R_LAST + 1];
	static final String zlabel[] = new String[AN_R_LAST + 1];

	// info about last action & undo
	int lastAction = 0; // trva len po mouse up
	static final int LA_BOND = 1;
	static final int LA_RING = 2;
	static final int LA_GROUP = 3;
	static final int LA_MOVE = 5;
	static final int LA_ROTATE = 7; // BB used for rotation on touch event
	static final int LA_SCALE = 8; // BB used for scaling on touch event
	static final int LA_FAILED = 9; // failed to create bond or ring

	final static protected Dimension nonFullScreenSize = new Dimension();

	final static protected double fullScreenScale = 3;

	public static final int maxFontSize = 100;

	public static Font[] atomDrawingAreaFontCache = new Font[maxFontSize];
	public static FontMetrics[] atomDrawingAreaFontMetCache = new FontMetrics[maxFontSize];

	public static Font[] atomMapDrawingAreaFontCache = new Font[maxFontSize];
	public static FontMetrics[] atomMapDrawingAreaFontMetCache = new FontMetrics[maxFontSize];

	boolean newMolecule = false; // enable to start new molecule
	int xold, yold; // position of mousePressed, updated in mouseDragged
	boolean afterClear = false; // info pre undo
	boolean mouseShift = false; // kvoli numbering

	// boolean isContextMenu = false; //right mouse click

	MultiBox smilesBox = null, atomxBox = null, aboutBox = null;
	QueryBox queryBox;
	boolean spiroAdding = false;
	boolean movingAtom = false; // BB

	String molText = null;
	protected JMEmol activeMol; // BB: the molecule JME is presently working on
	JMEmol uniColorMolecule = null;
	Graphical2DObject activeGraphicalObject;

	// protected int numberofMoleculeParts = 0;
	// int actualMoleculePartIndex = 0;
	int saved = 0; // ktora molekula jindexe saved pri multipart

	InspectorEvent inspectorEvent;

	String template = null; // template as jme string
	JMEmol templateMolecule = null; // template molecule - functional groups?
	static final int maxParts = 99;

	// protected JMEmol moleculeParts[] = new JMEmol[maxParts]; // when multipart,
	// nealokuje !!
	protected JMEmolList moleculePartsList = new JMEmolList(); // when multipart, nealokuje !!
	JMEmol smol; // save

	// BB undo & redo section
	final boolean canMultipleUndo = true; // when false, use Peter's original implementation, otherwise use the
											// changeManager
	ChangeManager<SavedState> molChangeManager;

	// BB : eclipse added the <JMEmol>
	Vector<JMEmol> molStack = new Vector<JMEmol>();

	// BB
	SDFstack sdfStack = new SDFstack();

	int stackPointer = -1;
	boolean doTags = false; // compatibility with JMEPro
	final boolean webme = false; // compatibility with JMEPro
	public int[] apointx, apointy, bpointx, bpointy; // coordinates for webme
	boolean revertStereo = false; // down stereo bond (only 1 action)
	boolean relativeStereo = false;
	// boolean allHs = false;
	// for key marking 2009.04
	boolean resetExtendAtomMark = true;
	int keyboradInputMark = -100;
	boolean markFromKeyboardInput = false;

	// images
	// Image infoImage, clearImage, deleteImage, deleterImage, chargeImage;
	// Image templatesImage, rtemplatesImage, undoImage, endImage, smiImage,
	// smitImage, smartsImage, stereoImage, stereoxImage;

	// BB
	// true if the Java code has been compiled to JavaScript
	final static boolean isJavaScript = System.getProperty("java.vm.name").equals("JavaScript");

	final static double precision;
	final static String programName; // JSME or JME

	protected static final double mouseWheelFactor = 10; // BH 2023 - now this works on my computer.

	static {

		if (isJavaScript) {
			programName = "JSME";
			precision = 30; // 10 looks good with FF at maximum zoom
		} else {
			programName = "JME";
			precision = 1.0;
		}
	}

	// BB: true for touch device iPad, Android
	final static boolean isTouchSupported = System.getProperty("is_touch_supported") != null;

	// BB for copy & paste
	protected TextTransfer clipBoardManager = new TextTransfer();
	JPopupMenu copyPasteJPopupMenuMol;
	JPopupMenu copyPasteJPopupMenuReaction;

	// local popup menu for the touched molecule/atom
	JPopupMenu touchedMolPopuMenu;
	static String setChiralFlagAction = "Set molecule chiral flag";
	static String unSetChiralFlagAction = "Unset molecule chiral flag";
	static String changeAtomChargeAction = "Change atom charge";

	static String changeAtomMapAction = "Change atom map";
	static String changeAtomMarkAction = "Change atom mark value";
	static String autoAtomMapMoleculeAction = "Auto atom map molecule";
	static String deleteAtomMapMoleculeAction = "Delete all atom map molecule";
	final static String deleteHydrogensMoleculeAction = "Delete hydrogens";
	final static String compute2DcoordinatesMoleculeAction = "Compute 2D coordinates";

	final static String bondCoordination = "et coordination bond";
	final static String bondSetCoordinationAction = "S" + bondCoordination;
	final static String bondUnSetCoordinationAction = "Uns" + bondCoordination;

	// functional group selection coming from the HTML example page
	String functionalGroups[] = new String[] { "-C(=O)OH", "-C(=O)OMe", "-OC(=O)Me", "-C(=O)N", "-NC=O", "-CMe3",
			"-CF3", "-CCl3", "-NO2", "-SO2-NH2", "-NH-SO2-Me", "-NMe2", "-C#N", "-C#CH", "-C#C-Me" };

	JPopupMenu functionalGroupPopumemu;
	protected Point functionalGroupJPopupMenuPosition;
	Point markerJPopupMenuPosition;
	protected Point fixedCopyPasteJPopupMenuPosition;
	protected long lastRotation;
	protected boolean bondRubberBanding = false;
	protected PasteAction pasteAction;
	protected boolean mouseDownWasUsed;
	protected boolean saveCurrentState = false; // when true means the current state of the chemical structures must be
												// saved in the undo state manager

	protected String searchInchiKeyMenuJLabel = "Search chemical structure (through InChIKey)";
	protected boolean alignMoleculesHasBeenPerformedByReadingStructure;
	// protected Rectangle2D.Double reactionArrowBoundingBox;
	protected JFrame myFrame;
	protected boolean application;

	protected boolean embedded;

	protected boolean isPostInitialized = false;

	protected boolean headless;

	public JME() {
		this(null, false);
	}

	public JME(JFrame frame) {
		this(frame, false);
	}

	// ----------------------------------------------------------------------------
	/**
	 * Frame entry point; optionally embedded
	 * 
	 * @param frame    optional frame
	 * @param embedded optionally embedded
	 */
	public JME(JFrame frame, boolean embedded) {
		this.embedded = embedded;
		activeMol = new JMEmol(this, params);
		lastTouchedMol.mol = activeMol;
		newTouchedMol.mol = activeMol;
		moleculePartsList.add(activeMol);
		inspectorEvent = new InspectorEvent(this);

		// this.alert("isTouchSupported: " + isTouchSupported);
		// reactionArrowBoundingBox = new Box();
		setFrame(frame);
		initialize();

	}

	public void setFrame(JFrame frame) {
		if (frame == null)
			return;
		myFrame = frame;
		isStandAloneApplication = true;
		frame.setName("JME"); // for embedding in <div id="testApplet-JME-div">
		frame.add("Center", this);
		frame.addKeyListener(this);
		addMouseListener(this);
		addMouseMotionListener(this);
		new FileDropper(this);
		application = true;
	}

	// ----------------------------------------------------------------------------
	public void initialize() {
		options.registerJS(this);
		params.keepSameCoordinatesForOutput = false;
		params.internalBondScalingForInput = true;
		params.showAtomMapNumberWithBackgroundColor = false;

		Container parent = this.getParent();
		if (parent != null) {
			parent.addMouseWheelListener(this); // works
		}
		// Show the copyright stuff at the bottom of the page when the applet starts
		info(programName + " " + startInfoText);

		dimension = getSize(); // will be 0,0 in Java and JavaScript;

		setLayout(null);

		// NS3 ma error vo font metrics (nedava ascent)
		// fontSize = 8;

		if (menuCellFont == null) { // kvoli IE, ktory aj pri Back vola init
			menuCellFont = new Font(defaultFontFamily, Font.PLAIN, fontSize);
			menuCellFontMet = getFontMetrics(menuCellFont);
		}
		if (menuCellFontBold == null) { // kvoli IE, ktory aj pri Back vola init
			menuCellFontBold = new Font(defaultFontFamily, Font.BOLD, fontSize);
			menuCellFontBoldMet = getFontMetrics(menuCellFontBold);
		}

		// int fs = fontSize-1;
		int smallerFontSize = fontSize - 2; // OK for the Java VM

		if (menuCellFontSmaller == null) {
			menuCellFontSmaller = new Font(defaultFontFamily, Font.PLAIN, smallerFontSize);
			menuCellFontSmallerMet = getFontMetrics(menuCellFontSmaller);
		}

		// BB: independent font size for the dialog boxes
		if (this.dialogFont == null) {
			// BB It is not necesssary to specify a font, the default one looks good
			this.dialogFont = null;
			// this.dialogFont = new Font(null, Font.PLAIN, this.dialogFontSize);
		}

		// BB: independant font size for the atoms in the molecular area
		// if(this.atomDrawingAreaFont == null) {

		initatomDrawingAreaFont(this.atomMolecularDrawingAreaFontSize);

		LEFT_MENU_NUMBER_OF_CELLS = this.determineNumberLeftMenuNumberOfCell();
		// showHydrogens = true;

		options.getAppletOptions(this);

		action = ACTION_BOND_SINGLE; // musi to tu but, inak nic

		validate();

		// BB
		if (this.canMultipleUndo) {
			this.molChangeManager = new ChangeManager<SavedState>();
			this.postSave(); // no effects because mol is not part of the array molparts
			// and because it has no atoms
		}

	}

	public void start(String[] args) {
		int pt = 0;
		if (args.length > 0 && !args[1].startsWith("-"))
			options(args[pt++]);

		dimension = getSize();
		// no repaint because the applet viewer will call repaint() after start()
		// this was changed because the molecule is always loaded with a GWT.runasync
		boolean repaint = true;
		if (options.jmeString != null) {
			readMolecule(options.jmeString, repaint);
			// co s colring multipart a reactions ???
			// only 1 coloring scheme (atoms || bg) may be applied
			if (atomBgColors != null && activeMol != null)
				activeMol.setAtomColors(atomBgColors, 0);
			postSave(); // June 2021
		} else if (options.molString != null) {
			readMolFile(options.molString, repaint);
			postSave(); // June 2021
		} else if (options.genericChemicalInputFromInit != null && options.useOpenChemLib) {

			// with a local or global instance of RunAsyncCallback, then code split does not
			// work
			// this.read_MOL_SDF_RXN(smilesString, null); // works also

			// async conversion with open chemlib
			// redraiwng the molecular area will be performed by the async call
			// after the OCL code is loaded and the smiles converted to MOL

			// the function calling this function will call paint in parallel,
			setMustRedrawMolecularArea(false);
			// DOES NOT WORK test_depict_many_smiles_in_table.html
			// this.handleReadGenericInput(genericChemicalInputFromInit, null, repaint,
			// false); // will call paint to redraw the
			// June 2021: last argument set to true to endure undo stack state is added
			//
			// molecular area after the smiles
			handleReadGenericInput(options.genericChemicalInputFromInit, null, repaint, true);
			// will call paint to redraw the has been decoded
		}

		process(args, pt);
	}

	public void process(String[] args, int pt) {
		if (pt < 0 || pt >= args.length)
			return;
		// reads molecule (from 2008.12)
		String fileName = null;
		for (int i = pt; i < args.length; i++) {
			if (args[i].startsWith("-f")) {
				readFile(args[++i]);
			} else if (args[i].startsWith("-o")) {
				options(args[++i]);
			}
		}

	}

	protected Object readFile(String fname) {
		// TODO
		return null;
	}

	public static String makeErrorMessage(Exception e) {
		String errorMsg = null;

		if (e instanceof NumberFormatException) {
			errorMsg = NumberParsingErrorMsg;
		} else if (e instanceof NoSuchElementException) { // if there are no more tokens in this tokenizer's string.)
			errorMsg = NotEnoughDataMsgError;
		}

		if (errorMsg == null) {
			errorMsg = e.toString();
		} else if (e.getMessage() != null) {
			errorMsg += ":" + e.getMessage();
		}

		return errorMsg;

	}

	/**
	 * the menu cell border differs in new and old look
	 * 
	 * @return
	 */
	int menuCellBorder() {
		return options.newLook ? 1 : 0;
	}

	public float getMolecularAreaLineWidth() {
		return molecularAreaLineWidth;
	}

	/**
	 * Line width in pixel
	 * 
	 * @param molecularAreaLineWidth
	 */
	public void setMolecularAreaLineWidth(float molecularAreaLineWidth) {
		this.molecularAreaLineWidth = molecularAreaLineWidth;
		this.drawMolecularAreaRightNow();

	}

	public boolean isMolecularAreaAntiAlias() {
		return molecularAreaAntiAlias;
	}

	/**
	 * Set antialias for the molecular drawing area
	 * 
	 * @param molecularAreaAntiAlias
	 */
	public void setMolecularAreaAntiAlias(boolean molecularAreaAntiAlias) {
		this.molecularAreaAntiAlias = molecularAreaAntiAlias;
		this.drawMolecularAreaRightNow();
	}

	/**
	 * This method is used only in a batch mode test suite in order to have an
	 * instance of JME that has a this.dimension that is not null
	 * 
	 * @param width
	 * @param height
	 */
	public void setDirectSizeForTesting(int width, int height) {
		setDimension(width, height);
		updateMyMolecularAreaSize();
	}

	/**
	 * Used for the test suite
	 * 
	 * @param width
	 * @param height
	 */
	public JME setDimension(int width, int height) {
		if (this.dimension == null) {
			this.dimension = new Dimension();
		}
		this.dimension.setSize(width, height);
		return this;
	}

	public String getPasteJLabel() {
		return pasteJLabel;
	}

	/**
	 * Customization of the paste label
	 * 
	 * @param pasteJLabel
	 */
	public void setPasteJLabel(String pasteJLabel) {
		this.pasteJLabel = pasteJLabel;
		// rebuild the menu each time the pasteJLabel is changed
		copyPasteJPopupMenuMol = createCopyPasteJPopupMenu(false);
	}

	// coud have used a HAshMap, but the code to initialize a hashmap is about the
	// same - JS is much better here for simple dict
	protected int mapActionToAtomNumber(int action, int notFound) {
		int result = notFound;

		if (action >= ACTION_AN_R) {
			int delta = action - ACTION_AN_R;
			result = AN_R + delta;
		} else {
			for (int i = 0; i < actionToAtomNumberArray.length; i += 2) {
				if (actionToAtomNumberArray[i] == action) {
					result = actionToAtomNumberArray[i + 1];
					break;
				}
			}
			// patch related to determineNumberLeftMenuNumberOfCell
			if (result == AN_X) {
				if (!options.xButton && options.rButton) { // X button has been removed and replaced by R button
					result = AN_R;
				}
			}

		}
		return result;
	}

	protected int determineNumberLeftMenuNumberOfCell() {
		int result = LEFT_MENU_NUMBER_OF_CELLS_WITHOUT_X_R;
		if (options.rButton) {
			result++;
		}
		if (options.xButton) {
			result++;
		}
		return result;

	}

	public int numberOfMolecules() {
		return this.moleculePartsList.size();
	}

	// protected int lastTouchedMoleculePart;

	public double getMolecularAreaScale() {
		return molecularAreaScalePixelsPerCoord;
	}

	// used by mouse wheel event in reaction mode
	public void setMolecularAreaScale(double newScale) {
		// should we limit scaling if one molecule becomes invisible?
		if (newScale != this.molecularAreaScalePixelsPerCoord) {
			Rectangle2D.Double dim1 = this.getMolecularAreaBoundingBoxCoordinate00();
			this.molecularAreaScalePixelsPerCoord = newScale;
			Rectangle2D.Double dim2 = this.getMolecularAreaBoundingBoxCoordinate00();
			recenterMoleculesAfterMolecularAreaChange(dim1, dim2);
			this.redrawMolecularAreaOnly();
		}
	}

	public void recenterMoleculesAfterMolecularAreaChange(Rectangle2D.Double before, Rectangle2D.Double after) {
		double moveX = after.getCenterX() - before.getCenterX();
		double moveY = after.getCenterY() - before.getCenterY();

		this.graphicalObjectList().moveXY(moveX, moveY);

	}

	public double getMenuScale() {
		return menuScale;
	}

	public void setMenuScale(double menuScale) {
		if (menuScale != this.menuScale) {
			;
			this.menuScale = menuScale;
			this.resetAllGraphics();
			this.repaint();
		}
	}

	public void setNewJButtonStatus(boolean newStatus) {
		this.newMolecule = newStatus;
		this.mustReDrawTopMenu = true;
		this.repaint();

	}

	public boolean getNewJButtonStatus() {
		return this.newMolecule;
	}

	// -----------------------------------------------------------------------------
	// Shortcuts for molecule

	/**
	 * 
	 * Change atom coordinate
	 * 
	 * @param mol
	 * @param atomIndex
	 * @param x
	 * @param y
	 */
	protected void XY(JMEmol mol, int atomIndex, int x, int y) {
		mol.XY(atomIndex, screenToDrawingX(x), screenToDrawingY(y));
	}

	// NOT USED!!!!
	/**
	 * Move to atom
	 * 
	 * @param mol
	 * @param atomIndex
	 * @param x
	 * @param y
	 */
	protected void moveXY(JMEmol mol, int atomIndex, int x, int y) {
		mol.moveXY(atomIndex, screenToDrawingX(x), screenToDrawingY(y));
	}

	// ----------------------------------------------------------------------------
	protected JPopupMenu createCopyPasteJPopupMenu(boolean isReaction) {

		JPopupMenu popup = new JPopupMenu();

		String smilesOrSmirks = "SMILES";
		String molOrReaction = "MOL";
		String molOrReactionForPasting = "MOL or SDF";
		Boolean hasAtom = !this.isMolecularAreEmpty();

		// String what = "chemical structure(s)";
		if (isReaction) {
			smilesOrSmirks = "SMIRKS";
			molOrReaction = "RXN";
			// what = "reaction";
			molOrReactionForPasting = molOrReaction;
		}

		if (options.useOpenChemLib) {
			molOrReactionForPasting += " or " + smilesOrSmirks;
			if (!isReaction && options.useOclIdCode) {
				molOrReactionForPasting += " or " + OCL_ID_CODE_LABEL;
			}
		}

		// COPY SMILES
		addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + smilesOrSmirks /* + " to the clipboard" */, CopyPasteAction.SMILES);
		// COPY MOL
		addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + molOrReaction /* + " to the clipboard" */, CopyPasteAction.MOL);

		// COPY V3000 MOL
		if (!isReaction) {
			addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + molOrReaction + " V3000" /* + " to the clipboard" */, CopyPasteAction.MOL_V3000);

			// handling Inchi: only available for JSME - use the inchi-js
			if (this.canComputeInchi()) {
				if (options.exportInchi) {
					addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "InChI" /* + " to the clipboard" */, CopyPasteAction.INCHI);
				}

				if (options.exportInchiKey) {
					addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "InChI key" /* + " to the clipboard" */, CopyPasteAction.INCHI_KEY);

				}
				if (options.searchInchiKey) {
					addMenuItem(popup, hasAtom, this.searchInchiKeyMenuJLabel,					CopyPasteAction.SEARCH_INCHI_KEY);
				}
				if (options.exportInchiAuxInfo) {
					addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "InChI auxinfo" /* + " to the clipboard" */, CopyPasteAction.INCHI_AUXINFO);
				}
			}

		}

		// COPY JME
		addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "JME" /* + " to the clipboard" */, CopyPasteAction.JME);
		if (options.useOpenChemLib && options.exportSVG && !isReaction) {
			addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "OCL Scalar Vector Graphics", CopyPasteAction.SVG);

		}

		// on IE7, one would get VML instead of SVG - nobody is using IE7 now
		if (isJavaScript && options.exportSVG) {
			addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + "raw Scalar Vector Graphics", CopyPasteAction.RAW_STRING_GRAPHIC);

		}

		if (options.useOpenChemLib && options.useOclIdCode && !isReaction) {
			addMenuItem(popup, hasAtom, "Copy " /* + what */ + "as " + OCL_ID_CODE_LABEL, CopyPasteAction.OCLCODE);
		}
		
		subclassAddToCopyMenu(popup, hasAtom);
		
		
		// PASTE
		if (options.paste) {
			popup.addSeparator();
			String localPasteJLabel = this.getPasteJLabel();
			if (localPasteJLabel == null) {
				localPasteJLabel = "Paste " + molOrReactionForPasting; // default, no customization
			}
			addMenuItem(popup, true, localPasteJLabel, CopyPasteAction.PASTE);

		}
		this.add(popup); // set the parent the popup

		return popup;

	}

	protected void addMenuItem(JPopupMenu popup, boolean enabled, String text, Object cmd) {
		JMenuItem mi = new JMenuItem(text);
		mi.setActionCommand(cmd.toString());
		mi.addActionListener(this);
		mi.setEnabled(!enabled);
		popup.add(mi);
	}

	protected void subclassAddToCopyMenu(JPopupMenu popup, boolean hasAtom) {
	}

	/**
	 * To be redefined in subclass
	 * 
	 * @return true if this implementation can compute inchi
	 */
	protected boolean canComputeInchi() {
		return true;
	}

	/**
	 * return a based 1 index
	 * 
	 * @return
	 */
	protected int activeMolIndex() {
		return this.moleculePartsList.indexOf(this.activeMol);
	}

	/**
	 * Create a popup menu with additional action for the selected molecule
	 * 
	 * @return
	 */
	protected JPopupMenu createMolJPopupMenu(JMEmol mol, int eventX, int eventY) {
		JPopupMenu popup = new JPopupMenu();

		boolean showAtomMappingToolsInMenu = this.params.number || options.autonumber || options.reaction;
		JMenuItem setUnsetChiralFlagJMenuItem;
		if (mol.getChiralFlag()) {
			setUnsetChiralFlagJMenuItem = new JMenuItem(unSetChiralFlagAction);
		} else {
			setUnsetChiralFlagJMenuItem = new JMenuItem(setChiralFlagAction);
		}

		setUnsetChiralFlagJMenuItem.setEnabled(mol.canBeChiral());

		popup.add(setUnsetChiralFlagJMenuItem);
		setUnsetChiralFlagJMenuItem.addActionListener(this);

		if (mol.touchedAtom > 0) {
			this.inspectorEvent.reset();
			this.inspectorEvent.atomIndex = mol.touchedAtom;
			this.inspectorEvent.mol = mol;
			this.inspectorEvent.x = eventX;
			this.inspectorEvent.y = eventY;
			this.inspectorEvent.molIndex = this.activeMolIndex();

		}
		if (showAtomMappingToolsInMenu && mol.touchedAtom > 0) {
			JMenuItem atomInspectoJMenuItem = new JMenuItem(
					this.params.mark ? changeAtomMarkAction : changeAtomMapAction);
			atomInspectoJMenuItem.addActionListener(this.inspectorEvent);

			popup.add(atomInspectoJMenuItem);
		}

		// charge handling
		if (mol.touchedAtom > 0) {
			// BB July 2022: renable the charge change
			JMenuItem atomInspectoJMenuItem = new JMenuItem(changeAtomChargeAction);
			atomInspectoJMenuItem.addActionListener(this.inspectorEvent);
			popup.add(atomInspectoJMenuItem);
		}

		// add a 2D computation only if Openchemlib is enabled
		if (options.useOpenChemLib) {
			JMenuItem compute2DJMenuItem = new JMenuItem(compute2DcoordinatesMoleculeAction);
			popup.add(compute2DJMenuItem);
			compute2DJMenuItem.addActionListener(this);
		}

		JMenuItem deleteHydrogensJMenuItem = new JMenuItem(deleteHydrogensMoleculeAction);
		deleteHydrogensJMenuItem.setEnabled(mol.hasHydrogen());

		popup.add(deleteHydrogensJMenuItem);
		deleteHydrogensJMenuItem.addActionListener(this);

		if (showAtomMappingToolsInMenu) {
			JMenuItem mapJMenuItem = new JMenuItem(autoAtomMapMoleculeAction);
			mapJMenuItem.addActionListener(this);
			popup.add(mapJMenuItem);

			mapJMenuItem = new JMenuItem(deleteAtomMapMoleculeAction);
			mapJMenuItem.addActionListener(this);
			popup.add(mapJMenuItem);
			mapJMenuItem.setEnabled(mol.geMaxAtomMap() > 0);

		}

		JMenuItem bondInspectoJMenuItem = new JMenuItem();
		String label = bondSetCoordinationAction;
		bondInspectoJMenuItem.setEnabled(false);
		if (mol.touchedBond > 0) {
			Bond bond = mol.bonds[mol.touchedBond];
			if (bond.isSingle() || bond.isCoordination()) {
				label = bond.isCoordination() ? bondUnSetCoordinationAction : bondSetCoordinationAction;
				// bondInspectoJMenuItem.addActionListener(this.inspectorEvent); //not used
				this.inspectorEvent.reset();
				this.inspectorEvent.bondIndex = mol.touchedBond;
				this.inspectorEvent.mol = mol;
				this.inspectorEvent.x = eventX;
				this.inspectorEvent.y = eventY;
				this.inspectorEvent.molIndex = this.activeMolIndex();

				bondInspectoJMenuItem.setEnabled(true);
				bondInspectoJMenuItem.addActionListener(this);

			}
		}
		bondInspectoJMenuItem.setText(label);
		popup.add(bondInspectoJMenuItem);

		return popup;

	}

	@Override
	public void mouseDragged(MouseEvent e) {
		mouseDrag(e, e.getX(), e.getY());
	}

	@Override
	public void mouseMoved(MouseEvent e) {
		mouseMove(e, e.getX(), e.getY());
	}

	@Override
	public void keyTyped(KeyEvent e) {
	}

	@Override
	public void keyPressed(KeyEvent e) {
		keyDown(e, e.getKeyCode());
	}

	@Override
	public void keyReleased(KeyEvent e) {
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}

	@Override
	public void mousePressed(MouseEvent e) {
		mouseDown(e, e.getX(), e.getY());
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		mouseUp(e, e.getX(), e.getY());
	}

	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO

	}

	@Override
	public void mouseExited(MouseEvent e) {
		// TODO

	}

	// BB - this method can be used only by input events methods
	void mustRedrawNothing() {
		mustRedrawImages(false);
	}

	// BB
	public void mustRedrawEverything() {
		mustRedrawImages(true);
	}

	public void mustRedrawImages(boolean yesOrNo) {
		mustReDrawLeftMenu = yesOrNo;
		mustReDrawTopMenu = yesOrNo;
		setMustRedrawMolecularArea(yesOrNo);
		mustReDrawInfo = yesOrNo;
		mustReDrawRightBorderImage = yesOrNo;

	}

	boolean mustRedrawNSomething() {
		return mustReDrawLeftMenu || mustReDrawTopMenu || mustReDrawMolecularArea || mustReDrawInfo
				|| mustReDrawRightBorderImage;

	}

	public void mustReDrawMolecularArea() {
		setMustRedrawMolecularArea(true);
	}

	public void redrawEverything() {
		this.mustRedrawEverything();
		this.repaint();
	}

	// --------------------------------------------------------------------------
	public Color getColor() {
		return bgColor; // it may be used to color other stuff with mi colors
	}

	// --------------------------------------------------------------------------
	public void activateQuery() {
		// v JME menu nastavi na query (ak bolo medzitym ine)
		if (action != ACTION_QRY) {
			action = ACTION_QRY;
			repaint();
		}
	}

	/*
	 * 
	 * For subclassses
	 */
	protected void handleAddiitonalParameters() {

	}

	public void initatomDrawingAreaFont(float realFs) {
		int fs = Math.round(realFs);
		if (fs < maxFontSize) {
			if (atomDrawingAreaFontCache[fs] == null) {
				atomDrawingAreaFontCache[fs] = new Font(defaultFontFamily, Font.PLAIN, fs);
			}
			if (atomDrawingAreaFontMetCache[fs] == null) {
				atomDrawingAreaFontMetCache[fs] = getFontMetrics(atomDrawingAreaFontCache[fs]);
			}

			this.atomDrawingAreaFont = atomDrawingAreaFontCache[fs];
			this.atomDrawingAreaFontMet = atomDrawingAreaFontMetCache[fs];
		} else {
			assert (false);

		}

		int fsAtomMap = (int) Math.round(realFs * 0.8);
		if (fsAtomMap < maxFontSize) {
			if (atomMapDrawingAreaFontCache[fsAtomMap] == null) {
				atomMapDrawingAreaFontCache[fsAtomMap] = new Font(defaultFontFamily, Font.PLAIN, fsAtomMap);
			}
			if (atomMapDrawingAreaFontMetCache[fsAtomMap] == null) {
				atomMapDrawingAreaFontMetCache[fsAtomMap] = getFontMetrics(atomMapDrawingAreaFontCache[fsAtomMap]);
			}

			this.atomMapDrawingAreaFont = atomMapDrawingAreaFontCache[fsAtomMap];
			this.atomMapDrawingAreaFontMet = atomMapDrawingAreaFontMetCache[fsAtomMap];
		} else {
			assert (false);

		}

	}

	public SupportedFileFormat getCopyToClipboardFormat() {
		return this.clipboardFormat;
	}

	public void setCopyToClipboardFormat(SupportedFileFormat format) {
		this.clipboardFormat = format;
	}

	// ----------------------------------------------------------------------------
	protected Color parseHexColor(String hex) {
		return this.colorManager.parseHexColor(hex);
	}

	/**
	 * Perform postinitalization after the editor is completely initialized SMILES
	 * has been read and is ready to be edited
	 *
	 * @return
	 */
	protected void postInitializeIfNeeded() {
		if (!this.isPostInitialized) {
			this.isPostInitialized = true; // aboid infinite loop
			this.postInitialize();
		}
	}

	protected void postInitialize() {

	}

//	@Override
//    public void repaint() {
//        super.repaint();
//        this.postInitializeIfNeeded();
//    }

	// ----------------------------------------------------------------------------
	public void stop() {
		// System.err.println("stop");
		if (smilesBox != null)
			smilesBox.dispose();
		if (atomxBox != null)
			atomxBox.dispose();
		if (aboutBox != null)
			aboutBox.dispose();
		if (queryBox != null)
			queryBox.dispose();
		// moleculeParts = null; // memory leak ?

	}

	// ----------------------------------------------------------------------------
	// --- public functions
	// -------------------------------------------------------
	// ----------------------------------------------------------------------------
	// for JavaScript to establish connection with JME
	public void ping() {
	}

	// ----------------------------------------------------------------------------
	public String smiles() {
		String smiles;
		try {
			smiles = Smiles();
			// this.mustRedrawNothing(); //BB - info will be redrawed if changed
		} catch (Exception e) {
			this.info(e.getMessage());

			return null;
		}

		// mol.touchedAtom = 0;
		// mol.touchedBond = 0;

		// BB why repaint???
		// repaint(); // aby ked je chyba v smilesi (stereo) aby sa objavilo info
		// transaltion form google: so that when the error is in the SMILES (stereo) to
		// appear Info

		return smiles;
	}

	// ----------------------------------------------------------------------------
	/**
	 * Compute and update the reactions roles for each molecule
	 * 
	 * @return the index (0 based) of the first molecule that has a different
	 *         reaction role or -1 if no changes
	 */
	protected int updateReactionRoles() {

		moleculePartsList.isReaction = options.reaction;
		int firstChangedIndex = -1;

		if (options.reaction) {
			for (JMEmol mol : moleculePartsList) {

				int previousRole = mol.getReactionRole();
				int newRole = this.computeReactionRole(mol);

				mol.setReactionRole(newRole);

				if (firstChangedIndex == -1 && newRole != previousRole) {
					firstChangedIndex = moleculePartsList.indexOf(mol);
				}

			}
		}

		return firstChangedIndex;
	}

	/**
	 * Find the reaction roles in the JME canvas based on my relative position to
	 * the reaction arrow
	 * 
	 * @return ReactionRole,
	 */
	protected int computeReactionRole(JMEmol mol) {
		if (mol.nAtoms() == 0) {
			return ReactionRole.NOROLE;
		}
		Box bbox = mol.computeBoundingBoxWithAtomLabels(null);
		// May 2020 improvement for the agent
		Box reactionArrowBox = reactionArrow.updateBoundingBox();
		if (bbox.getCenterX() < reactionArrowBox.x)
			return ReactionRole.REACTANT;
		else if (bbox.getCenterX() > reactionArrowBox.x + reactionArrowBox.width)
			return ReactionRole.PRODUCT;
		else
			return ReactionRole.AGENT;

	}

	// ----------------------------------------------------------------------------
	// ?????

	public String nonisomericSmiles() {
		boolean originalStereo = options.stereo;
		options.stereo = false;
		String smiles = Smiles();
		options.stereo = originalStereo;
		// BB: I commented the line below
		// repaint(); // aby ked je chyba v smilesi, aby sa objavilo info

		return smiles;
	}

	// ----------------------------------------------------------------------------
	String Smiles() {

		this.updateReactionRoles();

		smilesPars.stereo = options.stereo;
		smilesPars.polarnitro = options.polarnitro;
		// System.err.println("smilesPars.canonize: " +smilesPars.canonize);
		// System.err.println("# molecules: " + moleculeParts.size());
		// System.err.println("# atoms: " + moleculeParts.get(0).natoms);
		smilesPars.canonize = options.canonize;

		String smiles = moleculePartsList.generateSmilesOrSmirks(smilesPars);

		return smiles;

	}

	/*
	 * String Smiles() { String s; if (options.reaction) s = partSmiles(1) + ">" +
	 * partSmiles(2) + ">" + partSmiles(3); else { s = partSmiles(0); if (s.length()
	 * > 0) { molStack.addElement(new JMEmol(mol)); // adding molecule to // stack
	 * // skoci na koniec s molsack pointer stackPointer = molStack.size() - 1; } }
	 * return s; }
	 * 
	 * //
	 * ----------------------------------------------------------------------------
	 * String partSmiles(int pp) { // vracia multipart smiles, ak pp != 0
	 * (options.reaction) iba pre tu part // neskor pridat sort jednotlivych
	 * smilesov (alfanumeric) String s = ""; for (int m = 1; m <=
	 * numberofMoleculeParts; m++) { if (pp > 0) { int p =
	 * moleculeParts[m].reactionPart(); if (p != pp) continue; } //String smiles =
	 * moleculeParts[m].createSmilesWithSideEffect();//BB: original SMILES String
	 * smiles = moleculeParts[m].createSmiles(); //BB: make a copy of the mol and do
	 * createSmilesWithSideEffect on it if (smiles.length() > 0) { if (s.length() >
	 * 0) s += "."; s += smiles; // ta molekula moze byt empty } } return s; }
	 */
	// ----------------------------------------------------------------------------
	public void reset(boolean repaint) {
		// volane zvonka - vymaze vsetko
		action = ACTION_BOND_SINGLE;
		newMolecule = false;

		clearMyMolecularContent();
		clearInfo();

		molText = null;
		// BB
		resetMolecularAreaScale();

		this.recordAfterStructureChangedEvent(RESET);
		// notifyStructuralChangeToJS(); //recordAfterStructureChangedEvent performs
		// notifyStructuralChangeToJS
		if (repaint)
			repaint();

	}

	public void repaint() {
		if (!headless)
			super.repaint();
	}

	public void reset() {
		this.reset(true);
	}

	public void resetMolecularAreaScale() {
		if (this.isFullScreen()) {
			molecularAreaScalePixelsPerCoord = fullScreenScale;
		} else {
			molecularAreaScalePixelsPerCoord = 1.; // ??? ked depict viac molekul po sebe
		}
	}

	public void clearMyMolecularContent() {
		// numberofMoleculeParts = 0;
		// JMEmol.maxMark = 0;
		// actualMoleculePartIndex = 0;
		activeMol = new JMEmol(this, this.params); // treba
		activeMol.maxMark = 0;

		moleculePartsList.removeAll();
		moleculePartsList.add(activeMol);

		molText = null;
		mustReDrawMolecularArea();

	}
	// ----------------------------------------------------------------------------

	public void clear() {
		clear(true);
	}

	// delete the active molecule, reselect the active molecule
	public void clear(boolean recordEvent) {
		// zmaze actualMoleculePartIndex, zmensi pocet molekul, actual bude najvyssia

		action = ACTION_BOND_SINGLE;
		newMolecule = false;
		clearInfo();

		if (moleculePartsList.size() == 0)
			return;

		moleculePartsList.remove(activeMol);

		if (moleculePartsList.size() > 0) {
			// Feb 2020: the closes mol to the deleted one becomes the active one
			activeMol = this.findClosestMol(scaleDrawingToScreen(activeMol.centerX()),
					scaleDrawingToScreen(activeMol.centerY()));
		} else {
			activeMol = new JMEmol(this, this.params);
			activeMol.maxMark = 0;
			moleculePartsList.add(activeMol);
		}

		// BB
		setMustRedrawMolecularArea(true);

		afterClear = true;

//		for (int i = actualMoleculePartIndex; i < numberofMoleculeParts; i++) {
//			moleculeParts[i] = moleculeParts[i + 1];
//		}
//		numberofMoleculeParts--;
//		actualMoleculePartIndex = numberofMoleculeParts;
//		if (numberofMoleculeParts > 0)
//			activeMol = moleculeParts[actualMoleculePartIndex]; // kvoli move
//		else {
//			activeMol = new JMEmol(this);
//			activeMol.maxMark = 0;
//		}

		if (recordEvent) {
			this.recordAfterStructureChangedEvent(CLEAR);
			// this.notifyStructuralChangeToJS(); //recordAfterStructureChangedEvent calls
			// notifyStructuralChangeToJS
		}
		// Jan 2016
		// this.postSave();

	}

	// ----------------------------------------------------------------------------
	public String jmeFile() {
		// returns molecule(s) in jme format

		this.updateReactionRoles();

		String result = moleculePartsList.generateJMEstring(false,
				this.computeMoleculeEnsembleCoordinate2DboundingBox());

		return result;
		/*
		 * String s = ""; if (options.reaction) s = partJme(1) + ">" + partJme(2) + ">"
		 * + partJme(3); else s = partJme(0); return s;
		 */
	}

	// ----------------------------------------------------------------------------
//	String partJme(int pp) { // what is pp?
//		// vracia multipart jme, ak pp != 0 (options.reaction) iba pre tu part
//		// neskor pridat sort jednotlivych smilesov (alfanumeric)
//		String s = "";
//		for (JMEmol mol: moleculePartsList) {
//			if (pp > 0) {
//				int p = mol.reactionPart();
//				if (p != pp)
//					continue;
//			}
//			String jme = mol.createJME();
//			if (jme.length() > 0) {
//				if (s.length() > 0)
//					s += "|";
//				s += jme; // ta molekula moze byt empty
//			}
//		}
//		return s;
//	}

	// ----------------------------------------------------------------------------
//	int[][] getReactionParts() {
//		// returns fields of indices for reactants, products and modulators
//		int part[][] = new int[JMEmol.ReactionRole.all.length + 1][numberofMoleculeParts + 1];
//		for (int p : JMEmol.ReactionRole.all) { // role loop
//			int np = 0;
//			int m = 0;
//			for (JMEmol mol: moleculePartsList) {
//				if (mol.reactionPart() == p)
//					part[p][++np] = m;
//				m ++;
//			}
//			part[p][0] = np;
//		}
//		return part;
//	}

	// ----------------------------------------------------------------------------
	// NOT USED OR TESTED TO BE DELETED
//	JMEmol[] getMergedReactionParts() {
//
//		JMEmol results[] = new JMEmol[JMEmol.ReactionRole.maxRole + 1];
//
//		int parts[][] = getReactionParts();
//
//		for (int role : JMEmol.ReactionRole.all) { // role loop
//			JMEmol toMerge[] = new JMEmol[parts[role].length];
//			for (int mol : parts[role]) {
//				toMerge[mol] = moleculeParts[mol];
//			}
//			results[role] = new JMEmol(this, toMerge, toMerge.length);
//		}
//		return results;
//	}

	/**
	 * Compare two reaction parts array and returns the first molecule index that
	 * has changed its reaction role or 0 if no changed. This method is useful to
	 * generate an event when one of the molecules has been moved and consequently
	 * its reaction role has changed
	 * 
	 * @param parts1
	 * @param parts2
	 * @return the molecule index or 0
	 */
//	int findFirstMoleculeIndexWithDifferentReactionRole(int[][] parts1, int[][] parts2) {
//		// the arguments are computed by getReactionParts()
//		// if(Arrays.equals(parts1, parts2)) //does not work: doesn't go deep
//		// return 0;
//		for (int role = 1; role <= 3; role++) {
//			if (Arrays.equals(parts1[role], parts2[role]))
//				continue;
//			int n1 = parts1[role][0];
//			int n2 = parts1[role][0];
//			assert (n1 == n2); // see getReactionParts()
//			for (int i = 1; i <= n1; i++) {
//				if (parts1[role][i] != parts2[role][i]) {
//					if (parts1[role][i] == 0) {
//						return parts2[role][i];
//					} else {
//						return parts1[role][i];
//					}
//				}
//			}
//
//		}
//		return 0;
//	}

	/**
	 * Useful to find the max atom map of e.g. all reactants
	 * 
	 * @param moleculeParts
	 * @param whichMolecules
	 * @return
	 */
	int findMaxAtomMapOfMoleculeParts(JMEmolList moleculeParts, int reactionRole) {

		this.updateReactionRoles();
		return moleculeParts.findMaxAtomMap(reactionRole);

//		int max = 0;
//		int[][] allReactionParts = getReactionParts();
//		int[] reactionPartsWithRole = allReactionParts[reactionRole];
//		for (int i = 1; i <= reactionPartsWithRole[0]; i++) {
//			int m = moleculeParts[reactionPartsWithRole[i]].geMaxAtomMap();
//			if (m > max)
//				max = m;
//
//		}
//
//		return max;
	}

	/**
	 * Read a molecule string in JME format
	 * 
	 * @param molecule
	 * @param repaint
	 */
	public boolean readMolecule(String molecule, boolean repaint) {
		boolean success;
		try {
			if (success = this.handleReadMolecule(molecule, repaint)) {

			} else {
				repaint(); // to show errors
			}
		} catch (Exception e) {
			success = false;
			repaint(); // for showing the error
		}

		return success;
	}

	/**
	 * Read a molecule string in JME format
	 * 
	 * @param molecule
	 */
	public void readMolecule(String molecule) {
		this.readMolecule(molecule, true);
	}

	// Read a molecule or reaction in JME format
	// this code is almost never used and is problably buggy because it was not
	// tested
	// especialy molecule align
	// ----------------------------------------------------------------------------
	// makos
	protected boolean handleReadMolecule(String molecule, boolean repaint) {

		// duplicated code, a pointer to a function would solve the problem?
		JMEmolList inputMolList = new JMEmolList();
		boolean success = inputMolList.readJMEstringInput(molecule, this.params);
		if (success && !inputMolList.isReallyEmpty()) {
			this.processIncomingMolecules(inputMolList, repaint);
		}
		return success;
	}

	
	protected boolean handleReadJmolAdaptorInput(Object[] iterators, boolean repaint) {

		// duplicated code, a pointer to a function would solve the problem?
		JMEmolList inputMolList = new JMEmolList();
		boolean success = inputMolList.readJmolAdaptorInput(iterators, this.params);
		if (success && !inputMolList.isReallyEmpty()) {
			this.processIncomingMolecules(inputMolList, repaint);
		}
		return success;
	}


	public void showError(String errorMessage) {
		this.showInfo("ERROR - " + errorMessage);

	}

	// ----------------------------------------------------------------------------
	// adding template from JavaScript
	// template menu is actually JME string
	public void setTemplate(String t, String name) {
		// clear();
		afterClear = false; // otherwise problems in undo
		MoleculeHandlingParameters pars = new MoleculeHandlingParameters();
		pars.mark = true; // needed otherwise the atom map will be ignored
		// boolean savedStar = this.moleculeHandlingParameters.mark; // BB
		// this.moleculeHandlingParameters.mark = true; // BB to avoid a side effect
		// linked to atom mapping (marked atom)
		try {
			templateMolecule = new JMEmol(this, t, SupportedFileFormat.JME, pars);
			templateMolecule.internalBondLengthScaling(); // June 2020: JMEmol does not do it automatically. SHould be a
															// parameter rom readJMEstringInput?
		} catch (Exception e) {
			// TODO Auto-generated catch block
			// e.printStackTrace();
			info(e.getMessage());
			return;
		} // defined globally
			// this.moleculeHandlingParameters.mark = savedStar; // BB - restore
			// templateMolecule.complete(); //BB: not needed because the call above does
			// call complete()
			// now waiting for atom or free space click
		action = ACTION_GROUP_TEMPLATE;

		// mol.center();
		// numberofMoleculeParts = 1; actualMoleculePartIndex = 1; moleculeParts[1] =
		// mol;

		// TODO
		// check if the the template has a marked atom or atom map, otherwise, show a
		// message

		if (!templateMolecule.hasMappedOrMarkedAtom()) {
			// console warning
			showError("template molecule has no mapped atom");

		} else {
			info(name);
		}
		repaint(); // needed to display status line
	}

	public void setUserInterfaceBackgroundColor(Color bgColor) {
		this.bgColor = bgColor;
		this.brightColor = this.bgColor.brighter();
		this.redrawEverything();
	}

	public void setLeftMenuAtomColor(Color color) {
		this.leftMenuAtomColor = color;
		this.redrawEverything();
	}

	/**
	 * Choose another background color for the GUI frame and the dialog boxes
	 * 
	 * @param bgColor : string like #FFFBBCC
	 */

	public void setUserInterfaceBackgroundColor(String hexColor) {
		this.setUserInterfaceBackgroundColor(this.parseHexColor(hexColor));
	}

	/**
	 * Same color for all atoms of the left menu, e.g. black
	 * 
	 * @param hexColor
	 */
	public void setLeftMenuAtomColor(String hexColor) {
		if (color != null && color.length > 5)
			this.setLeftMenuAtomColor(this.parseHexColor(hexColor));
		else
			this.setLeftMenuAtomColor((Color) null);

	}

	/**
	 * not for reaction
	 * 
	 * @return
	 */
//	double scaleAndCenterForDepictMode(JMEmolList molList) {
	double scaleAndCenterForDepictMode(Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList) {

		// when reading a molfile and creating a JMEmol, the compound is already
		// internally scaled
		// such that its average bond length is equal the RBOND

		double scaleToFit = this.molecularAreaScalePixelsPerCoord;

		double margin = JMEmol.RBOND;

		Rectangle2D.Double cdbb = getChemicalDrawingBoundingBox(graphicalObjecList); // is empty if no molecules
		Rectangle2D.Double mabb = getMolecularAreaBoundingBox();

		if (cdbb.isEmpty() || mabb == null || mabb.getWidth() == 0 || mabb.getHeight() == 0) {
			return scaleToFit; // no change
		}

		double ratioWidth = mabb.getWidth() / (cdbb.getWidth() + margin);
		double ratioHeight = mabb.getHeight() / (cdbb.getHeight() + margin);

		if (ratioWidth == 0 || ratioHeight == 0) {
			return scaleToFit;
		}

		// first case: the molecule is too big
		if (ratioWidth <= 1 || ratioHeight <= 1) {
			scaleToFit = Math.min(ratioWidth, ratioHeight);
			// shrink
		} else {
			scaleToFit = 1.0; // no need to increase the size because of internal bond scaling
		}

		centerAllMoleculesAsAgroup(graphicalObjecList, this.dimension, this.menuScale, scaleToFit);

		return scaleToFit;
	}

	/**
	 * New BB method developed for SMIRKS INPUT molecules internal scaling must have
	 * been performed based on JMEmol.RBOND the reactionRole will determine if the
	 * molecules must be aligned horizontally of vertically Assume that the size of
	 * the drawing canvas is infinite
	 * 
	 * @param m1           0 based
	 * @param m2           0 based
	 * @param reactionRole
	 */
	void alignAndDistributeMolecules(int m1, int m2, int reactionRole) {
		int nm = m2 - m1 + 1;
		if (nm <= 0 || m1 >= moleculePartsList.size() || m2 >= moleculePartsList.size())
			return;

		double spaceBetweenMolecules = JMEmol.RBOND;

		double lastMove = 0;

		for (int i = m1; i <= m2; i++) {
			JMEmol mol = moleculePartsList.get(i);
			Rectangle2D.Double moleculeBox = mol.computeBoundingBoxWithAtomLabels(null);
			double dx = moleculeBox.x * -1;
			double dy = moleculeBox.y * -1;

			if (reactionRole != JMEmol.ReactionRole.AGENT) {
				dx -= moleculeBox.getWidth() / 2;
				dy += lastMove;
				lastMove += moleculeBox.getHeight();

			} else {
				dy -= moleculeBox.getHeight() / 2;
				dx += lastMove;
				lastMove += moleculeBox.getWidth();

			}

			mol.moveXY(dx, dy);

			lastMove += spaceBetweenMolecules;
		}

	}

	/**
	 * 
	 * @param m1           0 based
	 * @param m2           0 based
	 * @param reactionRole ??
	 */
	void alignMolecules(int m1, int m2, int reactionRole) {
		alignMolecules(m1, m2, reactionRole, false);
	}

	// --------------------------------------------------------------------------
	// BB side effects: compute the depictScale correctly for only one time if it is
	// different than 1.0
	// recenter molecule in depict mode
	// m1 and m2 are indices of the molecules in molecularParts: align molecules m1
	// to m2 inclusive
	void alignMolecules(int m1, int m2, int reactionRole, boolean donotAlignJustScale) {

		if (nocenter)
			return; // aj pre depict ???
		int nm = m2 - m1 + 1;
		if (nm <= 0 || m1 >= moleculePartsList.size() || m2 >= moleculePartsList.size())
			return;
		// double previousDepictScale = molecularAreaScale;

		// double center[] = new double[4];

		double RBOND = JMEmol.RBOND;
		double[] share = new double[99]; // share na 1 mol (used pri posune)
		double sumx = 0., sumy = 0., maxy = 0.;
		for (int i = m1; i <= m2; i++) {
			if (moleculePartsList.get(i).nAtoms() == 0)
				continue; // boundingBox() returns null if no atoms
			Box moleculeBox = moleculePartsList.get(i).computeBoundingBoxWithAtomLabels(null); // zisti
																								// dimenzie
			sumx += moleculeBox.getWidth();// center[2]; //width of mol
			sumy += moleculeBox.getHeight(); // ; //height of mol
			maxy = Math.max(maxy, moleculeBox.getHeight());

			share[i] = moleculeBox.getWidth();
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				share[i] = moleculeBox.getHeight();
		}

		// prida medzery (na oboch stranach a medzi), pri !depict to netreba
		if (isDepict()) {
			sumx += RBOND * (nm + 1); // add enough space between molecules
			sumy += RBOND * (nm + 1);
			maxy += RBOND; // malo by byt * 2, ale potom su velke okraje
		}

		double scalex = 1., scaley = 1.;

		// compute the size of the available display box for the molecular area
		Rectangle2D.Double widthAndHeight;
		if (isDepict()) // in depict mode, the scale will be recomputed, therefore we use the original
						// size
			widthAndHeight = this.getMolecularAreaBoundingBox();
		else
			widthAndHeight = this.getMolecularAreaBoundingBoxCoordinate00();

		int xsize = (int) widthAndHeight.width;
		int ysize = (int) widthAndHeight.height;

		if (reactionRole == JMEmol.ReactionRole.REACTANT || reactionRole == JMEmol.ReactionRole.PRODUCT)
			xsize = (xsize - arrowWidth) / 2;
		else if (reactionRole == JMEmol.ReactionRole.AGENT)
			ysize = ysize / 2;

		if (sumx >= xsize)
			scalex = (xsize) / sumx;
		if (maxy >= ysize)
			scaley = (ysize) / maxy;

		double space = 0.;
		if (isDepict()) { // cize == 1.
			molecularAreaScalePixelsPerCoord = Math.min(scalex, scaley); // inak dS = 1.
			space = RBOND * xsize / sumx;
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				space = RBOND * ysize / sumy;

		}

		for (int i = m1; i <= m2; i++) {
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				share[i] = share[i] * ysize / sumy; // share[i] was the y size of the molecule
			else
				share[i] = share[i] * xsize / sumx;// share[i] was the x size of the molecule
		}

		double shiftx = -xsize / 2.;
		double shifty = 0.;
		if (reactionRole == JMEmol.ReactionRole.REACTANT)
			shiftx = -xsize - arrowWidth / 2.;
		else if (reactionRole == JMEmol.ReactionRole.PRODUCT)
			shiftx = arrowWidth / 2.;
		else if (reactionRole == JMEmol.ReactionRole.AGENT) {
			shiftx = 0.;
			shifty = -ysize;
		} // preco nie ..+2*sd ???

		for (int i = m1; i <= m2; i++) {

			// ??? toto sposobuje problemy depictScale = 0 ???
			if (isDepict()) { // pri depicte zmensuje
				// assert(false);
				if (!scalingIsPerformedByGraphicsEngine) {
					moleculePartsList.get(i).scaleXY(molecularAreaScalePixelsPerCoord);
				}
				moleculePartsList.get(i).center(); // Once again, now reduced
			}

			// pri depict urobi aj medzeru
			if (reactionRole == JMEmol.ReactionRole.AGENT)
				shifty += (share[i] / 2. + space);
			else
				// part == JMEmol.ReactionRole.REACTANT, JMEmol.ReactionRole.PRODUCT, or 0
				shiftx += (share[i] / 2. + space);

			// BB correction afterwards, otherwise the shiftx and shifty are too small
//			if(this.scalingIsPerformedByGraphicsEngine) {
//				shiftx /= depictScale;
//				shifty /= depictScale;
//			}

			if (!donotAlignJustScale) { // bad patch to fix a bug
				moleculePartsList.get(i).moveXY(shiftx, shifty);
				// for (int a = 1; a <= moleculeParts[i].natoms; a++) {
				// moleculeParts[i].moveXY(a, shiftx, shifty);
				// moveXY(moleculeParts[i],a, shiftx, shifty);
				// moleculeParts[i].x(a) += shiftx;
				// moleculeParts[i].y(a) += shifty;
				// }
			}

			if (reactionRole == JMEmol.ReactionRole.AGENT)
				shifty += share[i] / 2.;
			else
				shiftx += share[i] / 2.;

		}

		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// BB correction: the depictScale must be absolute
		// molecularAreaScale *= previousDepictScale; //used with iPad scaling
	}

	/**
	 * compute the space needed to display the molecular structures in the molecular
	 * area return null if there is nothing displayed includes the reaction arrow if
	 * present
	 * 
	 * @return
	 */
	public Box getChemicalDrawingBoundingBox(Graphical2DObjectGroup<?> graphicalObjecList) {

		// leave a margin around the molecule
		double margin = (double) JMEmol.RBOND / 2;

		Box boundingBox = graphicalObjecList.newBoundingBox();
		if (boundingBox != null && !boundingBox.isEmpty()) {
			boundingBox.x -= margin;
			boundingBox.y -= margin;
			boundingBox.width += margin * 2;
			boundingBox.height += margin * 2;
		}

		return boundingBox;
	}

	/**
	 * Molecule ensemble bounding box atom label size not taken into account
	 * 
	 * @return
	 */
	public Box computeMoleculeEnsembleCoordinate2DboundingBox() {
		return this.moleculePartsList.computeCoordinate2DboundingBox();
	}

	public Boolean isMolecularAreEmpty() {
		for (JMEmol mol : moleculePartsList) {
			if (mol.natoms > 0)
				return true;
		}

		return false;

	}

	public boolean hasMarkedAtom() {
		return this.moleculePartsList.hasMarkedAtom();
	}

	/**
	 * compute the maximum scale that can be used to fit all objects in the
	 * molecular drawing area
	 * 
	 * return -1 if there is nothing to display
	 */
	public double maximumScaleDisplayArea(Dimension appletDimension, double menuScale) {
		Rectangle2D.Double boundingBox = getChemicalDrawingBoundingBox(this.graphicalObjectList());

		if (boundingBox == null)
			return -1;

		Rectangle2D.Double molecularAreaBox = this.getMolecularAreaBoundingBoxPixel(appletDimension, menuScale);

		double maxScale = Math.min(molecularAreaBox.width / boundingBox.width,
				molecularAreaBox.height / boundingBox.height);

		return maxScale;

	}

	protected Graphical2DObjectGroup<Graphical2DObject> graphicalObjectList(JMEmolList molList) {
		Graphical2DObjectGroup<Graphical2DObject> results = new Graphical2DObjectGroup<Graphical2DObject>();

		for (JMEmol mol : molList) {
			results.add((Graphical2DObject) mol);
		}
		if (options.reaction) {
			results.add((Graphical2DObject) reactionArrow);
		}

		return results;
	}

	protected Graphical2DObjectGroup<Graphical2DObject> graphicalObjectList() {

		return this.graphicalObjectList(this.moleculePartsList);
	}

	// --------------------------------------------------------------------------
	/**
	 * Create a V2000 MOL
	 * 
	 * @return
	 */
	public String molFile() {
		return this.molFile(false);
	}

	public String molFile(boolean isV3000) {
		return this.molFileOrRxn(null, true, isV3000, options.exportRXNmergeOption);
	}

	public String molFile(MolFileOrRxnParameters pars) {

		if (pars.debugDoNotUpdateReactionRole) {
			moleculePartsList.isReaction = true;
			;
		} else {
			this.updateReactionRoles();
		}

		return moleculePartsList.generateMolFileOrRxn(pars);

	}

	public String molFileOrRxn(String header_, boolean stampDate_, boolean isV3000_, boolean mergeReationComponents) {

		MolFileOrRxnParameters pars = new MolFileOrRxnParameters() {
			{
				header = header_; // 1st line of the MOL
				stampDate = stampDate_;
				isV3000 = isV3000_;
				mergeReationComponents = options.exportRXNmergeOption;
			}
		};

		return this.molFile(pars);

//		// creates mol file, multipart sd file or reaction (rxn file)
//
//		if (header == null) {
//			header = smiles(); // now, otherwise for multipart cuts them
//		}
//
//		String s = "";
//		if (options.reaction) {
//			int nReactants;
//			int nProducts;
//			int nAgents;
//			int part[][] = getReactionParts();
//			if (mergeReationComponents) {
//				nReactants = 1;
//				nProducts = 1;
//				nAgents = 1;
//			} else {
//				nReactants = part[JMEmol.ReactionRole.REACTANT][0];
//				nProducts = part[JMEmol.ReactionRole.PRODUCT][0];
//				nAgents = part[JMEmol.ReactionRole.PRODUCT][0];
//
//			}
//
//			s += "$RXN" + separator + separator + separator + "JME Molecular Editor" + separator;
//			s += JMEmol.iformat(nReactants, 3) + JMEmol.iformat(nProducts, 3);
//			if (part[2][0] > 0) { // if agents are present
//				s += JMEmol.iformat(nAgents, 3);
//			}
//			s += separator;
//
//			// reactants products, agents
//			for (int role : new int[] { JMEmol.ReactionRole.REACTANT, JMEmol.ReactionRole.PRODUCT,
//					JMEmol.ReactionRole.AGENT }) {
//				if (mergeReationComponents && part[role][0] > 1) {
//					JMEmol toMerge[] = new JMEmol[part[role][0] + 1];
//					for (int mol : part[role]) {
//						toMerge[mol] = moleculeParts[mol];
//					}
//
//					JMEmol merged = new JMEmol(this, toMerge, toMerge.length);
//					s += "$MOL" + separator + merged.createMolFile(header, stampDate);
//				} else {
//					for (int i = 1; i <= part[role][0]; i++) {
//						s += "$MOL" + separator + moleculeParts[part[role][i]].createMolFile(header, stampDate);
//					}
//				}
//			}
//
//		} else { // viac molekul do 1 mol file
//			if (moleculePartsList.size() > 1)
//				// merge the molecules into one ensemble
//				activeMol = new JMEmol(this, (JMEmol[]) moleculePartsList.toArray(), moleculePartsList.size());
//			if (!isV3000)
//				s = activeMol.createMolFile(header, stampDate);
//			else // BB
//				s = activeMol.createExtendedMolFile(header, stampDate);
//
//			// ???? WHY DOES THIS CHANGE THE IN MEMORY MOL?
//			if (numberofMoleculeParts > 1)
//				activeMol = moleculeParts[actualMoleculePartIndex];
//		}
//		return s;
	}

	// --------------------------------------------------------------------------

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * 
	 * @param molecule string
	 */
	public void readMolFile(String molecule) {
		readMolFile(molecule, true);
	}

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * 
	 * @param molecule string
	 */
	public void readMolFile(String molecule, boolean repaint) {
		try {
			if (this.handleReadMolFileRXN(molecule, repaint)) {

			} else {
				repaint(); // to show errors
			}
		} catch (Exception e) {
			repaint(); // for showing the error
		}
	}

	/**
	 * Read the molfile and repaint the applet when done
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	protected boolean handleReadMolFile(String s) {
		return handleReadMolFileRXN(s, true);
	}

	/**
	 * repaint and record event
	 * 
	 * @param s
	 * @param sucessAndFailureHandler
	 */
	public void handleReadGenericInput(String s, RunAsyncCallback sucessAndFailureHandler) {
		handleReadGenericInput(s, sucessAndFailureHandler, true, true);
	}

	/**
	 * input can be a MOL, RXN, smiles or SMIRKS or OCL
	 * 
	 * @param s
	 */

	public void handleReadGenericInput(String s, RunAsyncCallback sucessAndFailureHandler, boolean repaint,
			boolean recordEvent) {

		if (s == null || s.trim().length() == 0) {
			return;
		}

		ChemicalFormatDetector cfd = new ChemicalFormatDetector(s);
		String error = null;
		boolean runAsync = false;

		this.afterStructureChangeEvent.setOrigin_API();
		// will not overwrite if already set for instance if the call is
		// coming from the GUI

		clearInfo(); // clear previous error message if any
		String afterStructureChangedEvent = null;

		do {

			if (cfd.majorChemicalFormat == ChemicalFormatDetector.MajorChemicalFormat.SVG
					&& cfd.embeddedChemicalFormat != null) {
				// copy the embedded chemical format to cfd
				cfd.init(cfd.embeddedChemicalFormat);
			}
			if (cfd.author == ChemicalFormatDetector.Author.MDL
					&& cfd.minorChemicalFormat != ChemicalFormatDetector.MinorChemicalFormat.V3000) {
				// bug: handling "|" as a line separator

				// TODO : handleReadMolFileRXN is async because of the 2D coordinate computation
				if (!JME.this.handleReadMolFileRXN(cfd.chemicalString, false)) // will do repaint later after event
																				// recording
					error = "Invalid V2000 molfile";
				else {
					afterStructureChangedEvent = cfd.isReaction() ? READ_RXN_FILE : READ_MOL_FILE;
				}
				break;
			}

			if (cfd.author == ChemicalFormatDetector.Author.P_ERTL) {
				if (!readMolecule(cfd.chemicalString, false)) { // will do repaint later after event recording
					error = "Invalid JME string";
				} else {
					afterStructureChangedEvent = READ_JME;
				}
				break;
			}
			if (cfd.author == ChemicalFormatDetector.Author.IUPAC
					|| cfd.majorChemicalFormat == ChemicalFormatDetector.MajorChemicalFormat.CSRML) {
				// GWT: <set-configuration-property name="compiler.enum.obfuscate.names"
				// value="false" /> otherwise the number of the enum is shown instead of its
				// name
				error = "Reading " + cfd.majorChemicalFormat + " is not supported";
				break;
			}

			if (options.useOpenChemLib) {
				runAsync = true;
				// code splitting used to run OpenChemlib code
				JMEUtil.runAsync(new JSME_RunAsyncCallback() {

					@Override
					public void onSuccess() {
						oclSuccess(cfd, sucessAndFailureHandler, recordEvent, repaint);
					}
				});

				break;
			}

		} while (false);

		if (!runAsync) {

			if (error == null && recordEvent && afterStructureChangedEvent != null) {
				JME.this.recordAfterStructureChangedEvent(afterStructureChangedEvent); // the event will be fired after
																						// the repaint() has completed
			}

			// duplicated code with the one inside the runAsync block
			// used for debugging JS code
			setMustRedrawMolecularArea(error == null);
			if (sucessAndFailureHandler != null) {
				if (error == null) {
					sucessAndFailureHandler.onSuccess();
				} else {
					sucessAndFailureHandler.onFailure(new Exception(error));
				}
			} else {
				if (error != null) {
					showError(error);
				}

			}

			if (error == null && repaint) {
				repaint();

			}
		}

	}

	protected void oclSuccess(ChemicalFormatDetector cfd, RunAsyncCallback sucessAndFailureHandler, boolean recordEvent,
			boolean repaint) {
		String error = null;
		String convertedmolFile = null;
		String afterStructureChangedEvent = null;

		if (cfd.author == ChemicalFormatDetector.Author.MDL
				&& cfd.minorChemicalFormat == ChemicalFormatDetector.MinorChemicalFormat.V3000) {
			try {
				convertedmolFile = v3000toV2000MOL(cfd.chemicalString);
				if (convertedmolFile == null) {
					throw new Exception("V3000 read failed.");
				}
				afterStructureChangedEvent = READ_MOL_FILE;
				sdfPastedMessage.innnerString = "V3000 conversion provided by OpenChemLib";
			} catch (Exception e) {
				error = e.getMessage();
			}
		} else {
			if (cfd.author == ChemicalFormatDetector.Author.DAYLIGHT) {
				try {
					convertedmolFile = SMILESorSMIRKStoMolOrRXN(cfd.chemicalString);
					if (cfd.majorChemicalFormat == MajorChemicalFormat.SMIRKS)
						afterStructureChangedEvent = READ_SMIRKS;
					else if (cfd.majorChemicalFormat == MajorChemicalFormat.SMILES)
						afterStructureChangedEvent = READ_SMILES;

					sdfPastedMessage.innnerString = "SMILES conversion provided by OpenChemLib";

				} catch (Exception e) {
					error = "SMILES parsing error:" + e.getMessage();
				}
			} else {
				error = "Invalid or unsupported input";
				if (options.useOclIdCode && cfd.couldBeOclIdCode()) {
					// try to parse OCL if not SMILES
					// ChemicalFormatDetector can not detect OCLcode
					try {
						convertedmolFile = OclCodeToMOL(cfd.chemicalString);
						afterStructureChangedEvent = READ_OCLCODE;
						error = null;
					} catch (Exception e) {

					}
				}
			}
		}

		boolean success = false;
		if (convertedmolFile != null && error == null) {
			try {
				success = handleReadMolFileRXN(convertedmolFile, false);
				if (success && recordEvent) {
					assert (afterStructureChangedEvent != null);
					recordAfterStructureChangedEvent(afterStructureChangedEvent);

				}
			} catch (Exception e) {
				error = "Invalid converted molfile";
			}
		}
		setMustRedrawMolecularArea(success);

		if (sucessAndFailureHandler != null) {
			if (success) {
				sucessAndFailureHandler.onSuccess();
			} else {
				assert (error != null);
				sucessAndFailureHandler.onFailure(new Exception(error));
			}
		} else {
			if (error != null) {
				showError(error);
			}

		}
		if (repaint) {
			repaint();
			// drawMolecularAreaRightNow(); //does not work if called from start(),
			// molecularAreaImage is not initialized
		}

	}

	/**
	 * Returns the graphics representation used in the molecular area, either a SVG
	 * or a VML string This is avalailable only in JavaScript implementation
	 * 
	 * @return a string that can be used in a DOM element innerHTML
	 */

	public String getMolecularAreaGraphicsString() {

		return null;
	}

	/**
	 * Read the input structure (all chemical structure formats supported by JSME)
	 * Update the editor display. An event will be reported if successful.
	 * 
	 * @param s
	 */
	// public JSME interface
	public void readGenericMolecularInput(String s) {
		this.readGenericMolecularInput(s, true);
	}

	/**
	 * Read the input structure (all chemical structure formats supported by JSME)
	 * Update the editor display.
	 * 
	 * @param s
	 * @param recordEvent
	 */
	public void readGenericMolecularInput(String s, boolean recordEvent) {
		this.handleReadGenericInput(s, null, true, recordEvent);
	}

	public String getOclCode() {
		String molFile = this.molFileOrRxn(null, false, true, false);
		return newParser().getOclCode(molFile);
	}

	/**
	 * Generate SVG representation of the molecule Use OpenChem lib SVG generator.
	 * 
	 * @return
	 */
	public String getOclSVG() {
		String molFile = this.molFileOrRxn(null, false, true, false); // use v3000
		return newParser().getOclSVG(molFile);
	}

	/**
	 * Use the openchemlib to convert a OCL code to a molfile string TODO: what
	 * about 2D coordinates?
	 * 
	 * @param oclCode
	 * @return
	 */
	public String OclCodeToMOL(String oclCode) {
		return newParser().OclCodeToMOL(oclCode);
	}

	/**
	 * Use the openchemlib to convert a smiles to a molfile string 2D coordinates
	 * are generated
	 * 
	 * @param smiles
	 * @return
	 * @throws Exception
	 */
	public String SMILEStoMOL(String smiles) throws Exception {
		return newParser().SMILEStoMOL(smiles);
	}

	/**
	 * Use the openchemlib to convert a smirks to a rxn string 2D coordinates are
	 * generated. The individual reaction components are not further split into
	 * molecules (see handleReadMolFileRXN() )
	 * 
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	public String SMIRKStoRXN(String smirks) throws Exception {
		String[] parts = smirks.split(">");
		assert parts.length >= 1 && parts.length <= 3;

		// JS and Java behave differently for string split
		// "bla>>" => 3 parts in JS
		// => 1 part in Java

		// JMEmol newParts[] = mol.splitMultiparts()

		boolean hasProducts = parts.length >= 3 && parts[2].length() > 0;
		boolean hasAgents = parts.length >= 2 && parts[1].length() > 0;

		String reactants = this.SMILEStoMOL(parts[0]);

		String products = hasProducts ? this.SMILEStoMOL(parts[2]) : this.SMILEStoMOL("");
		String agents = hasAgents ? this.SMILEStoMOL(parts[1]) : this.SMILEStoMOL("");

		String s = "";

		s += "$RXN" + separator + separator + separator + "JME Molecular Editor" + separator;
		s += JMEUtil.iformat(1, 3) + JMEUtil.iformat(1, 3);
		if (hasAgents)
			s += JMEUtil.iformat(1, 3);

		s += separator;
		s += "$MOL" + separator + reactants;
		s += "$MOL" + separator + products;
		// not standard
		if (hasAgents)
			s += "$MOL" + separator + agents;

		return s;
	}

	/**
	 * to be completed - used only for the test suite read the modulator as well,
	 * should we (re)use the JME string input code for reaction?
	 * 
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	public boolean readSmirks(String smirks) throws Exception {

		String convertedmolFile = SMILESorSMIRKStoMolOrRXN(smirks);

		this.handleReadMolFileRXN(convertedmolFile, false);

		return true;
	}

	/**
	 * Use the openchemlib to convert a V3000 MOL to a V2000 molfile string
	 * 
	 * @param v3000
	 * @return
	 * @throws Exception
	 */
	public String v3000toV2000MOL(String v3000Mol) throws Exception {
		return newParser().v3000toV2000MOL(v3000Mol);
	}

	protected Parser newParser() {
		return (Parser) getInterface(parserImpl);
	}

	protected Parser getInterface(String name) {
		try {
			Class<?> x = Class.forName(name);
			return (Parser) (x == null ? null : x.newInstance());
		} catch (Exception e) {
			System.out.println("Interface.getInterface Error creating instance for " + parserImpl + ": \n" + e);
			return null;
		}
	}

	/**
	 * Use the openchemlib to convert a smiles or a smirks to a mol or rxn string 2D
	 * coordinates are generated
	 * 
	 * @param smilesOrsmirks
	 * @return
	 * @throws Exception
	 */
	public String SMILESorSMIRKStoMolOrRXN(String smilesOrsmirks) throws Exception {
		if (smilesOrsmirks.contains(">")) {
			return this.SMIRKStoRXN(smilesOrsmirks);
		} else {
			return this.SMILEStoMOL(smilesOrsmirks);
		}

	}

	/**
	 * Used for testing without GUI
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	public boolean readMolFileOrRXN(String s) {
		return this.handleReadMolFileRXN(s, false);
	}

	boolean canBeAddedToExistingMultipartOrReaction() {
		return ((options.reaction || options.multipart) && options.addNewPart) || newMolecule;
		// newMolecule is true if NEW button is pushed
	}

	void processIncomingMolecules(JMEmolList newMolecules, boolean repaint) {

		if (!newMolecules.isReallyEmpty()) {

			if (this.params.internalBondScalingForInput) {
				newMolecules.internalBondLengthScaling();
			}
			activeMol = processIncomingMolecules(newMolecules);
			if (newMolecule) {
				newMolecule = false; // addition performed, cancel NEW option
				mustReDrawTopMenu = true;
			}
			if (repaint && !headless) {
				drawMolecularAreaRightNow();
				if (mustReDrawTopMenu) {
					drawTopMenu(getGraphics());
				}

			}

		}

	}

	/**
	 * For all molecules:
	 * 
	 * 1) assign the JME field
	 * 
	 * 2) recompute aromaticity
	 * 
	 * 3) compute 2D coord if they are missing
	 * 
	 * 4) scale, color, and add it to the list of mols
	 * 
	 * @param newMolecules
	 * @return the new mol
	 */
	 JMEmol processIncomingMolecules(JMEmolList newMolecules) {

		if (newMolecules.isReallyEmpty()) {
			return activeMol;
		}

		// New Jan 2019
		for (int i = 0; i < newMolecules.size(); i++) {
			JMEmol mol = newMolecules.get(i);
			mol.jme = this;

			//// HERE USE OCL LIB !!!!!!
			mol = newMolecules.reComputeBondOrderIfAromaticBondType(mol);

			if (mol != null) {
				newMolecules.set(i, mol);
			}

			//// HERE USE OCL LIB !!!!!!
			// Bug: ensemble does not work correctly
			// Feb 2020
			mol = newMolecules.compute2DcoordinatesIfMissing(mol);
			if (mol != null) {
				newMolecules.set(i, mol);
			}

		}
		// Feb 2020
		newMolecules.scaleInternalBondMolList();

		if (newMolecules.isReaction()) {
			options.reaction = true;
			options.multipart = true;

			double spacing = JMEmol.RBOND;
			Graphical2DObjectGroup<Graphical2DObjectGroup<Graphical2DObject>> groups = new Graphical2DObjectGroup<Graphical2DObjectGroup<Graphical2DObject>>();

			Graphical2DObjectGroup<Graphical2DObject> agentGroup = null;

			for (int role : JMEmol.ReactionRole.all) {
				JMEmolList mols = newMolecules.reactionParts(role);

				Graphical2DObjectGroup<Graphical2DObject> group = new Graphical2DObjectGroup<Graphical2DObject>();
				group.addAll(mols.asGroup());

				if (role != JMEmol.ReactionRole.AGENT) {
					group.distributePositions(Axis.X, spacing, true);
					group.alignCenter(Axis.Y);

				} else {

					// reaction agents on top and below the arrow
					int pos = (int) ((0.5 * group.size()) + 0.5);
					group.add(pos, reactionArrow);
					group.distributePositions(Axis.Y, spacing, false);
					group.alignCenter(Axis.X);// this is centering along Y axis

					agentGroup = group;

				}

				groups.add(group);

			}

			groups.distributePositions(Axis.X, spacing, false);
			groups.alignCenter(Axis.Y); // this is centering along x axis

			// move the agent group such that it is aligned with the center of the two other
			// groups
			assert (agentGroup != null && agentGroup.size() >= 1); // the agent group contains the arrow
			agentGroup.move(Axis.Y, agentGroup.centerY() - reactionArrow.centerY());

			// new June 2017: split the reaction components if needed after the alignment is
			// done
			// such that each molecule can be moved individually
			// the coordinates are not changed
			newMolecules.splitFragments(true);

			// addedToExistingMultipartOrReaction is not implemented
			// would be much more complex
			moleculePartsList.removeAll();
			moleculePartsList.addAll(newMolecules);

			// For reaction, it is better to scale down if this a big reaction
			molecularAreaScalePixelsPerCoord = this.scaleAndCenterForDepictMode(graphicalObjectList(moleculePartsList));

		} else {

			if (isDepict() || pasteFromSDFstack) { // BB let the incoming structure determine the editor mode when in
													// depict mode
				options.reaction = false;
				// multipart = false;
			}
			boolean addedToExistingMultipartOrReaction = canBeAddedToExistingMultipartOrReaction();

			if (!addedToExistingMultipartOrReaction) {
				moleculePartsList.removeAll(); // the new parts will not be appended to the moleculeParts[]
				resetMolecularAreaScale(); // could be an option
			}

			double scale = isDepict() ? 1.0 : molecularAreaScalePixelsPerCoord; // in depict mode, the scale will be
																				// recomputed
			// afterwards
			centerAllMoleculesAsAgroup(graphicalObjectList(newMolecules), dimension, menuScale, scale);

			if (!isDepict()) { // solve the cross fragment issue with atom highlighting based on atom indices
								// (CT3 chemotyper-like display)
				newMolecules.splitFragments(true);
			}

			moleculePartsList.addAll(newMolecules); // newMolecules must be internal scaled and centered as a group
													// before addition

			if (isDepict()) {
				// if the molecules are too big to fit => recompute the scale
				molecularAreaScalePixelsPerCoord = scaleAndCenterForDepictMode(graphicalObjectList(moleculePartsList));
			}

		}

		// coloring tu, inak pri multiupart problemy
		moleculePartsList.setAtomBackGroundColors(atomBgColors);
		assert (moleculePartsList.size() > 0);
		return newMolecules.first();
	}

	/**
	 * generate an afterStructureChangedEvent
	 * 
	 * @param MOL or a RXN
	 * @return true on success
	 */
	boolean handleReadMolFileRXN(String s, boolean repaint) {

		JMEmolList inputMolList = new JMEmolList();
		boolean success = inputMolList.readMDLstringInput(s, this.params);
		if (success && !inputMolList.isReallyEmpty()) {
			this.processIncomingMolecules(inputMolList, repaint);
		}

		return success;
	}

	public int findMaxAtomMapAmongAllMolecules() {

		return moleculePartsList.findMaxAtomMap();

	}

	public void setMaxMapAfterReadingInput() {
		int max = this.findMaxAtomMapAmongAllMolecules();

		// assign the max
		for (JMEmol mol : moleculePartsList) {
			mol.maxMark = max;
		}

	}

	// --------------------------------------------------------------------------
	// called from JavaScript menu, sets Rgroup
	public void setSubstituent(String s) {
		// substituent menu
		int pressed = -1;
		if (s.equals("Select substituent")) {
			pressed = ACTION_BOND_SINGLE;
			s = "";
		} else if (s.equals("-C(=O)OH"))
			pressed = ACTION_GROUP_COO;
		else if (s.equals("-C(=O)OMe"))
			pressed = ACTION_GROUP_COOME;
		else if (s.equals("-C(=O)N"))
			pressed = ACTION_GROUP_CON;
		else if (s.equals("-NC=O"))
			pressed = ACTION_GROUP_NCO;
		else if (s.equals("-OC(=O)Me"))
			pressed = ACTION_GROUP_OCOME;
		else if (s.equals("-CMe3"))
			pressed = ACTION_GROUP_TBU;
		else if (s.equals("-CF3"))
			pressed = ACTION_GROUP_CF3;
		else if (s.equals("-CCl3"))
			pressed = ACTION_GROUP_CCL3;
		else if (s.equals("-NO2"))
			pressed = ACTION_GROUP_NITRO;
		else if (s.equals("-NMe2"))
			pressed = ACTION_GROUP_NME2;
		else if (s.equals("-SO2-NH2"))
			pressed = ACTION_GROUP_SO2NH2;
		else if (s.equals("-NH-SO2-Me"))
			pressed = ACTION_GROUP_NHSO2ME;
		else if (s.equals("-SO3H"))
			pressed = ACTION_GROUP_SULFO;
		else if (s.equals("-PO3H2"))
			pressed = ACTION_GROUP_PO3H2;
		else if (s.equals("-C#N"))
			pressed = ACTION_GROUP_CYANO;
		else if (s.equals("-C#C-Me"))
			pressed = ACTION_GROUP_CCC;
		else if (s.equals("-C#CH"))
			pressed = ACTION_GROUP_CC;

		if (pressed > 0) {
			menuAction(pressed);
		} else
			s = "Not known group!";
		info(s);
		repaint();
	}

	protected String menuXShortcuts = null;

	/**
	 * Specify custom keyboard shortcuts letters for the X menu box. These new
	 * shortcuts will have a higher priority than predefined shortcuts. For
	 * instance, to specify polymers shortcuts ‘e’, ‘d’, ’t’, and
	 * ‘g’, the argument would be "edtg"
	 * 
	 * @param shortcuts
	 */

	public void setMenuXShortcuts(String shortcuts) {
		this.menuXShortcuts = shortcuts;
	}

	/**
	 * Get the custom keyboard shortcuts letters that have been set using the
	 * {@link #setMenuXShortcuts(String)} method
	 * 
	 * @return
	 */

	public String getMenuXShortcuts() {
		return this.menuXShortcuts;
	}

	protected void setRemoveHsC() {
		this.params.hydrogenHandlingParameters.removeHs = true;
		this.params.hydrogenHandlingParameters.removeOnlyCHs = true;
	}

	// TODO: rdefine in JME2
	public void log(String string) {
		System.err.println(string);
	}

	protected void resetAllGraphics() {
		// for subclass
		this.mustRedrawEverything();

		this.molecularAreaImage = null;
		this.topMenuImage = null;
		this.leftMenuImage = null;
		this.infoAreaImage = null;
		this.rightBorderImage = null;

	}

	/**
	 * See also getCopyPasteJPopupMenuMol() and getCopyPasteJPopupMenuReaction()
	 */
	protected void resetJPopupMenu() {
		this.copyPasteJPopupMenuMol = null;
		this.copyPasteJPopupMenuReaction = null;

	}

	/**
	 * Ignore bonds during mouse over
	 * 
	 * @return
	 */
	protected boolean ignoreBonds() {
		return ((options.starNothing || options.starAtomOnly) && action == ACTION_MARK) || action == ACTION_MOVE_AT
				|| action == ACTION_CHAIN || action == ACTION_SPIRO || action == ACTION_CHARGE
				|| (action >= ACTION_GROUP_MIN && action <= ACTION_AN_R_LAST

						|| (action == ACTION_MARK && !params.mark) // case for 123 button - atom
																	// mapping June 2020

				);
	}

	/**
	 * ignore atoms during mouse over
	 * 
	 * @return
	 */
	protected boolean ignoreAtoms() {
		return (/* action == ACTION_STEREO || */
		((options.starNothing || options.starBondOnly) && action == ACTION_MARK));
	}

	// --------------------------------------------------------------------------
	public void setText(String text) {
		molText = text;
		repaint();
	}

	// --------------------------------------------------------------------------
	public void showAtomNumbers() {
		// shows canonical atom numbering
		// numbers only actual molecule !!!
		if (activeMol != null)
			activeMol.numberAtoms();
	}

	// ----------------------------------------------------------------------------
	// --- end of public functions
	// ------------------------------------------------
	// ----------------------------------------------------------------------------
	public void paint(Graphics g) {
		/* The java applet viewer calls this method when the applet window is resized */
		Graphics g2 = g.create();
		update(g);
		// requestFocus(); // kvoli key action
		g2.dispose();
	}

	/**
	 * Should be called after any applet size change
	 * 
	 * @param appletDimension
	 */
	protected void updateMyMolecularAreaSize(Dimension appletDimension, double menuScale) {

		Rectangle2D.Double molecularAreaBoundingBox = getMolecularAreaBoundingBoxPixel(appletDimension, menuScale);

		this.molecularAreaPixelWidth = (int) molecularAreaBoundingBox.width;
		this.molecularAreaPixelHeight = (int) molecularAreaBoundingBox.height;

	}

	/**
	 * Should be called after any applet size change
	 * 
	 * @param d
	 */
	protected void updateMyMolecularAreaSize() {
		if (this.dimension == null) {
			this.dimension = getSize();
		}
		this.updateMyMolecularAreaSize(this.dimension, this.menuScale);

	}

	/**
	 * Return the bounding box of the molecular area (screen pixel)
	 * 
	 */
	Rectangle2D.Double getMolecularAreaBoundingBox() {

		return getMolecularAreaBoundingBoxPixel(this.dimension, this.menuScale);

	}

	protected Box getMolecularAreaBoundingBoxPixel(Dimension appletDimension, double menuScale) {

		double x = isDepict() ? 0 : leftMenuWidth(menuScale);
		double y = isDepict() ? 0 : topMenuHeight(menuScale);
		double width = (double) appletDimension.width - (isDepict() ? 0 : x + rightBorder(menuScale));
		double height = (double) appletDimension.height - (isDepict() ? 0 : y + infoAreaHeight(menuScale));

		return new Box(x, y, width, height);

	}

	protected Box getMolecularAreaBoundingBoxCoordinate(Dimension appletDimension, double menuScale,
			double pixelsPerCoord) {
		Box bbox = getMolecularAreaBoundingBoxPixel(appletDimension, menuScale);

		assert (pixelsPerCoord > 0);

		bbox.x = 0;
		bbox.y = 0;
		bbox.width /= pixelsPerCoord;
		bbox.height /= pixelsPerCoord;

		return bbox;

	}

	/**
	 * Return the width and height of the molecular area with scaling
	 * 
	 */
	protected Box getMolecularAreaBoundingBoxCoordinate00() {
		return getMolecularAreaBoundingBoxCoordinate(this.dimension, this.menuScale,
				this.molecularAreaScalePixelsPerCoord);
	}

	// ----------------------------------------------------------------------------
	public void update(Graphics g2d) {
		// pri fill ma rectangle sirku a vysku presne, pri draw o 1 vacsiu
		// Dimension d = getSize();

		// BB" try to avoid mutilple calls to size() and alignMolecules()

		// Note: Applet has a resize method() that we could override
		boolean initOrResize;
		appletHasBeenResized = false;
		assert (dimension != null); // dimension was initialized by init()()
		if (molecularAreaImage == null) {
			initOrResize = true;
		} else {
			Dimension newDimension = getSize();

			// find out if the size of the applet has changed
			initOrResize = (newDimension.width != dimension.width) || (newDimension.height != dimension.height);

			if (initOrResize) { // if applet has a new size

				dimension = newDimension;
				appletHasBeenResized = true;
			}
		}

		if (initOrResize) {
			mustRedrawEverything();
			updateMyMolecularAreaSize(this.dimension, this.menuScale);
//			log("update(): " + dimension + " " + "initOrResize: " + initOrResize + " " + this.molecularAreaWidth + " "
//					+ this.molecularAreaHeight);

			// compute or resize the graphics
			molecularAreaImage = createOrResizePreciseImage(molecularAreaImage, this.molecularAreaPixelWidth,
					this.molecularAreaPixelHeight);

			if (!isDepict()) {
				// update the menu's and the info area

				topMenuImage = createOrResizePreciseImage(topMenuImage, dimension.width, topMenuHeight());
				double imageh = dimension.height - topMenuHeight();
				if (imageh < 1)
					imageh = 1;
				// leftMenu = createOrResizeImage(leftMenu, menuCellSize, imageh);
				this.leftMenuImage = createOrResizePreciseImage(this.leftMenuImage, this.leftMenuWidth(), imageh);

				infoAreaImage = createOrResizePreciseImage(infoAreaImage, this.molecularAreaPixelWidth + rightBorder(),
						infoAreaHeight());

				rightBorderImage = createOrResizePreciseImage(rightBorderImage, rightBorder(),
						this.molecularAreaPixelHeight);

				// New october 2019
				// JMEmol.centerMolList(this, this.moleculeParts, this.numberofMoleculeParts);

			} else {
				// depict mode
				double oldMolecularAreaScale = this.molecularAreaScalePixelsPerCoord;

				// will recompute the molecular area scale
				this.molecularAreaScalePixelsPerCoord = this.scaleAndCenterForDepictMode(this.graphicalObjectList());

				// October 2019: No molecule alignment : wee keep the layout of the original
				// molecules
				// TODO: for reactions
				// alignMolecules(1, numberofMoleculeParts, 0, isDepict()); //code copied from
				// the depict option initialisation
				// moleculePartsList.scaleInternalBondMolList(); // THIS IS NOT NEEDED!!!!
				// JMEmol.centerMolList(this, this.moleculeParts, this.numberofMoleculeParts);

				log("update() in depict mode: oldMolecularAreaScale = " + oldMolecularAreaScale
						+ " new   molecularAreaScale = " + molecularAreaScalePixelsPerCoord);

				assert topMenuImage == null;
				assert leftMenuImage == null;
				assert infoAreaImage == null;
				assert rightBorderImage == null;
			}
		}

		// draw the parts
		drawMolecularArea(g2d, null);

		// draw the parts
		if (!isDepict()) {
			drawInfo(g2d); // ???
			drawTopMenu(g2d);
			drawLeftMenu(g2d);
			drawRightBorderImage(g2d);
		}

		this.postInitializeIfNeeded();

	}

	/**
	 * Method that is overridden in JSME in order to avoid the creation of multiple
	 * SVG's during a window resize
	 * 
	 * @param img
	 * @param width
	 * @param height
	 * @return a new Image in JME or the same image if the argument img is not null
	 *         in JSME
	 */
	public Image createOrResizeImage(Image img, int width, int height) {
		return createImage(width, height);
	}

	public PreciseImage createOrResizePreciseImage(PreciseImage img, double width, double d) {
		return new PreciseImage(createOrResizeImage(img == null ? null : img.getImage(), (int) (Math.round(width)),
				(int) (Math.round(d))));
	}

	// ----------------------------------------------------------------------------

	// BB
	// metal like LI, K, Na which can be single cation
//	public static int isMetal1(int an) {
//		return an >= AN_METAL1_START && an <= AN_METAL1_END? 1 : 0;
//	}
//	//metal like LI, K, Na which can be single cation
//	public static boolean isMetal2(int an) {
//		return an >= AN_METAL2_START && an <= AN_METAL2_END;
//	}

	public static int chargedMetalType(int an) {
		if (an >= AN_METAL1_START && an <= AN_METAL1_END)
			return 1; // Na+
		if (an >= AN_METAL2_START && an <= AN_METAL2_END)
			return 2; // Ca++
		if (an >= AN_METAL3_START && an <= AN_METAL3_END)
			return 3; // Al+++

		return 0;
	}

	public static void atomicData() {
		for (int i = 1; i <= AN_R_LAST; i++) {
			if (chargedMetalType(i) > 0) {
				color[i] = Color.darkGray;
			} else {
				color[i] = Color.orange;
				zlabel[i] = "X";
			}
		}
		zlabel[AN_H] = "H";
		color[AN_H] = Color.darkGray;
		zlabel[AN_B] = "B";
		color[AN_B] = Color.orange;
		zlabel[AN_C] = "C";
		color[AN_C] = Color.darkGray;
		zlabel[AN_N] = "N";
		color[AN_N] = Color.blue;
		zlabel[AN_O] = "O";
		color[AN_O] = Color.red;
		zlabel[AN_F] = "F";
		color[AN_F] = Color.magenta;
		zlabel[AN_CL] = "Cl";
		color[AN_CL] = Color.magenta;
		zlabel[AN_BR] = "Br";
		color[AN_BR] = Color.magenta;
		zlabel[AN_I] = "I";
		color[AN_I] = Color.magenta;
		zlabel[AN_S] = "S";
		color[AN_S] = Color.yellow.darker();
		zlabel[AN_P] = "P";
		color[AN_P] = Color.orange;
		zlabel[AN_SI] = "Si";
		color[AN_SI] = Color.darkGray;
		zlabel[AN_SE] = "Se";
		color[AN_SE] = Color.darkGray;
		zlabel[AN_X] = "X";
		color[AN_X] = Color.darkGray;

		zlabel[AN_K] = "K";
		zlabel[AN_Li] = "Li";
		zlabel[AN_Na] = "Na";
		zlabel[AN_Rb] = "Rb";
		zlabel[AN_Cs] = "Cs";
		zlabel[AN_Fr] = "Fr";
		zlabel[AN_Ag] = "Ag";

		zlabel[AN_Mg] = "Mg";
		zlabel[AN_Ca] = "Ca";
		zlabel[AN_Sr] = "Sr";
		zlabel[AN_Ba] = "Ba";
		zlabel[AN_Zn] = "Zn";
		zlabel[AN_Ni] = "Ni";
		zlabel[AN_Cu] = "Cu";
		zlabel[AN_Cd] = "Cd";

		zlabel[AN_Al] = "Al";
		zlabel[AN_Ga] = "Ga";
		zlabel[AN_Au] = "Au";

		// BB: replace cases by a loop for the R groups
		for (int i = AN_R; i <= AN_R_LAST; i++) {
			String label = "R";
			if (i > AN_R) {
				label += i - AN_R;
			}
			zlabel[i] = label;
			color[i] = Color.darkGray;
		}
		/*
		 * zlabel[AN_R] = "R"; color[AN_R] = Color.darkGray; zlabel[AN_R1] = "R1";
		 * color[AN_R1] = Color.darkGray; zlabel[AN_R2] = "R2"; color[AN_R2] =
		 * Color.darkGray; zlabel[AN_R3] = "R3"; color[AN_R3] = Color.darkGray;
		 */
	}

	// BB : added atomic atomicData initialization , allows to work also in the test
	// suite
	static {
		atomicData();
	}

	PreciseGraphicsAWT getScaledGraphicsOfPreciseImage(PreciseImage pi, double scale, Rectangle2D.Double screenArea) {
		PreciseGraphicsAWT og;
		if (pi == null)
			System.out.println("??");
		if (scalingIsPerformedByGraphicsEngine) {
			og = pi.getGraphics(scale);
		} else {
			og = pi.getGraphics(1.0); // never used!!?

		}
		og.setDrawOnScreenCoordinates(screenArea);

		return og;
	}

	// direct
	public void drawMolecularAreaRightNow() {
		this.setMustRedrawMolecularArea(true);
		if (molecularAreaImage != null) { // must be initialized
			Graphics g = getGraphics().create();
			drawMolecularArea(g, null);
			g.dispose();
			this.setMustRedrawMolecularArea(false);
		} else {
			this.repaint();
		}

	}

	// ----------------------------------------------------------------------------
	/**
	 * Draw the molecule either to this panel's graphics or to the specified image.
	 * 
	 * When drawing to an image, use the coordOffsets.
	 * 
	 * @param g
	 * @param margin
	 */
	BufferedImage drawMolecularArea(Graphics g, Point margins) {

		// BB
		BufferedImage img = null;
		Point coordOffset = null;
		boolean needRecenter = activeMol.needRecentering;
		if (g == null) {
			jme.Box coordBox = activeMol.computeBoundingBoxWithAtomLabels(null);
			double f = molecularAreaScalePixelsPerCoord;
			img = new BufferedImage((int) (coordBox.getWidth() * f) + margins.x * 2,
					(int) (coordBox.getHeight() * f) + margins.y * 2, BufferedImage.TYPE_INT_ARGB);
			activeMol.needRecentering = false;
			coordOffset = new Point((int) (margins.x / f - coordBox.x), (int) (margins.y / f - coordBox.y));
		} else if (g != null && !this.mustReDrawMolecularArea) {
			return null;
		}

		// new sept 2016
		// FIXme: should not be done here
		if (this.params.computeValenceState) {
			if (this.afterStructureChangeEvent != null && this.afterStructureChangeEvent.action != null) {
				if (this.afterStructureChangeEvent.action != UNDO && this.afterStructureChangeEvent.action != REDO) {
					for (JMEmol mol : moleculePartsList) {
						mol.cleanAfterChanged(options.polarnitro);
					}
				}
			}
		}

		double imgWidth = (img != null ? img.getWidth() : molecularAreaPixelWidth);
		double imgHeight = (img != null ? img.getHeight() : molecularAreaPixelHeight);

		// screen area in pixel
		Rectangle2D.Double molecularScreenArea = new Rectangle2D.Double(leftMenuWidth(), topMenuHeight(), imgWidth,
				imgHeight);

		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(
				(img == null ? molecularAreaImage : new PreciseImage(img)), molecularAreaScalePixelsPerCoord,
				molecularScreenArea);

		og.setColor(canvasBg);

		double coordWidth = imgWidth / this.molecularAreaScalePixelsPerCoord;
		double coordHeight = imgHeight / this.molecularAreaScalePixelsPerCoord;

		og.fillRect(0, 0, coordWidth, coordHeight);

		if (coordOffset != null) {
			og.translate(coordOffset.x, coordOffset.y);
		}

		// BB custom antialias and line width for the molecular drawing area
		Object valueAntiAlias = molecularAreaAntiAlias ? RenderingHints.VALUE_ANTIALIAS_ON
				: RenderingHints.VALUE_ANTIALIAS_OFF;
		og.setRenderingHint(RenderingHints.KEY_ANTIALIASING, valueAntiAlias);

		og.setStroke(new BasicStroke(molecularAreaLineWidth));

		if (img == null && (fullScreenEnterOrExit || (this.appletHasBeenResized && previousScaledScreenArea != null))) {
			Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList = this.graphicalObjectList();
			centerAllMoleculesAsAgroup(graphicalObjecList, this.dimension, menuScale, molecularAreaScalePixelsPerCoord);
			fullScreenEnterOrExit = false;
		}

		for (JMEmol mol : moleculePartsList) {
			mol.draw(og);
		}

		if (img != null) {
			activeMol.needRecentering = needRecenter;
			return img;
		}

		if (previousScaledScreenArea == null)
			previousScaledScreenArea = new Rectangle2D.Double();
		previousScaledScreenArea.width = coordWidth;
		previousScaledScreenArea.height = coordHeight;

		// arrow
		if (options.reaction) {
			// if the reaction arrow is not initialized
			if (!this.reactionArrow.hasBeenPlaced) { // FIXME: to be removed?
				this.reactionArrow.XY(imgWidth / 2, imgHeight / 2);
			}
			this.reactionArrow.draw(og);
		}

		// molText and DnD icon
		if (isDepict()) { // kvoli molText, ale aj depict dalsej molekuly
			// musi robit novy font, lebo v depict moze byt zmeneny
			menuCellFont = new Font(defaultFontFamily, Font.PLAIN, fontSize);
			menuCellFontMet = getFontMetrics(menuCellFont);
			if (molText != null) {
				int w = menuCellFontMet.stringWidth(molText);
				double xstart = (imgWidth - w) / 2.;
				double ystart = imgHeight - fontSize;
				og.setColor(Color.black);
				og.setFont(menuCellFont);
				og.drawString(molText, xstart, ystart);
			}

			// draw the DnD icon
			if (options.showDragAndDropIconInDepictMode)
				// DnD icom is made smaller than the non depict one
				this.drawDragAndDropIcon(og, smallerIconsForDepictMode / this.molecularAreaScalePixelsPerCoord);
			else
				this.dragAndDropIcon = null;

			// FIXME
			// on the left of the DnD icon
			// scaling does not work - because a resize event recomputed the
			// molecularAreaScale
//			if(fullScreenIconOption && showFullScreenIconInDepictMode)
//				this.drawFullScreenIcon(og, imgWidth, imgHeight, smallerIconsForDepictMode /this.molecularAreaScale, this.dragAndDropIcon);
		}

		g.drawImage(molecularAreaImage.getImage(), og.screenX(), og.screenY(), this);
		this.setMustRedrawMolecularArea(false);

		// New September 2016
		// handle the postSave and the event to JS
		if (this.saveCurrentState) {
			this.postSave();
			this.saveCurrentState = false;
		}
		if (this.afterStructureChangeEvent != null && this.afterStructureChangeEvent.action != null) {
			// mol.cleanAfterChanged();
			notifyStructuralChange("draw");
			// this.afterStructureChangeEvent.reset();

			// BB new Feb 2017
			// disable the NEW button after structure change
			if (newMolecule == true) {
				newMolecule = false;
				mustReDrawTopMenu = true;
				repaint();
			}
		}
		return null;
	}

	public void centerAllMoleculesAsAgroup(Graphical2DObjectGroup<Graphical2DObject> graphicalObjecList,
			Dimension appletDimension, double menuScale, double molecularAreaScalePixelsPerCoord) {

		if (appletDimension == null)
			return;
//		if (options.reaction)
//			return; // not implemented yet
		// this.appletHasBeenResized = false;

		Rectangle2D.Double chemicalDrawingBoundingBox = this.getChemicalDrawingBoundingBox(graphicalObjecList);
		if (chemicalDrawingBoundingBox == null)
			return;
		// molecule coordinate
		Rectangle2D.Double appletMolBoundingBox = this.getMolecularAreaBoundingBoxCoordinate(appletDimension, menuScale,
				molecularAreaScalePixelsPerCoord);
		double dx = appletMolBoundingBox.getCenterX() - chemicalDrawingBoundingBox.getCenterX();
		double dy = appletMolBoundingBox.getCenterY() - chemicalDrawingBoundingBox.getCenterY();

		for (Graphical2DObject each : graphicalObjecList.group) {
			each.moveXY(dx, dy);
		}
		// molecules.moveXY(dx, dy);

	}

	void drawRightBorderImage(Graphics g) {
		if (!this.mustReDrawRightBorderImage)
			return;

		Rectangle2D.Double screenArea = new Rectangle2D.Double(dimension.width - rightBorder(), topMenuHeight(),
				rightBorder(), molecularAreaPixelHeight);
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(rightBorderImage, menuScale, screenArea);

		double imgWidth = rightBorder(1);
		// double imgHeight = (double)this.molecularAreaHeight/this.depictScale;
		double imgHeight = screenArea.height / this.menuScale;
		if (options.newLook) {
			og.setColor(Color.darkGray);
			// og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1);//right line
			// og.drawLine(0, 0, 0, imgHeight);//right line
			og.fillRect(0, 0, imgWidth, imgHeight);
			// og.fillRect(0, 0, imgWidth, imgHeight/2);
		} else {
			// vonkajsi okraj na pravej strane
			og.setColor(bgColor.darker());
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight);
			// predel vo farbe backgroundu
			og.setColor(bgColor);
			og.drawLine(imgWidth - 2, 0, imgWidth - 2, imgHeight);
			// svetly okraj dovnutra
			og.setColor(brightColor);
			og.drawLine(imgWidth - 3, 0, imgWidth - 3, imgHeight);
		}

		g.drawImage(rightBorderImage.getImage(), (int) screenArea.x, (int) screenArea.y, this);

	}

	// ----------------------------------------------------------------------------
	void drawTopMenu(Graphics g) {
//Swing will handle this differently
//		if (!this.mustReDrawTopMenu)
//			return;
		
		// BH 2023 topMenuImage can be null even in Java if this is happening on the main thread. 
		if (topMenuImage == null)
			return;
		Rectangle2D.Double screenArea = new Rectangle2D.Double(0, 0, dimension.width, topMenuHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(topMenuImage, menuScale, screenArea);

		double imgWidth = (double) dimension.width / this.menuScale;
		double imgHeight = topMenuHeight(1.0);
		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (options.newLook) {
			// og.setColor(Color.darkGray);
			og.setColor(bgColor.darker());
			double s = (menuCellSize + menuCellBorder()) * TOP_MENU_NUMBER_OF_CELLS;
			// og.drawRect(s,0,imgWidth-s-1,menuCellSize*2 + menuCellBorder()-1);
			og.drawRect(s, 0, imgWidth - s - 1, imgHeight - 1);
		} else {
			og.setColor(bgColor.darker());
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1); // right
			og.drawLine(0, imgHeight - 1, imgWidth - 1, imgHeight - 1); // bottom

			og.setColor(brightColor);
			og.drawLine(0, 0, imgWidth - 1, 0); // top
		}

		// og.drawLine(TOP_MENU_NUMBER_OF_CELLS * menuCellSize, 0,
		// TOP_MENU_NUMBER_OF_CELLS * menuCellSize, imgHeight - 1); // predel

		// BB: redraw the FG menu cell if a substituent had been selected
		int savedAction = action;
		if (ACTION_GROUP_MIN <= action && action <= ACTION_GROUP_MAX) {
			action = ACTION_FG;
		}
		for (int i = 1; i <= TOP_MENU_NUMBER_OF_CELLS; i++) {
			createSquare(og, i, 1); // icon cell
			createSquare(og, i, 2);
		}

		// restore the action value in case it had been changed for redrawing above
		action = savedAction;

		g.drawImage(topMenuImage.getImage(), 0, 0, this);
	}

	// ----------------------------------------------------------------------------
	void drawLeftMenu(Graphics g) {
		// Swing will handle this differently
//		if (!this.mustReDrawLeftMenu)
//			return;

		Rectangle2D.Double screenArea = new Rectangle2D.Double(0, topMenuHeight(), leftMenuWidth(),
				dimension.height - topMenuHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(leftMenuImage, this.menuScale, screenArea);

		double imgWidth = leftMenuWidth(1);

		double imgHeight = (dimension.height - topMenuHeight()) / this.menuScale;

		double yInfoArea = imgHeight - infoAreaHeight(1);

		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (options.newLook) {
			og.setColor(Color.darkGray);

			double y = LEFT_MENU_NUMBER_OF_CELLS * (menuCellSize + menuCellBorder()) + 3;

			if (yInfoArea > y) {
				og.drawLine(0, y, menuCellSize - 1, y); // top horizontal line
				og.drawLine(0, y, 0, imgHeight - 1); // left

				og.drawLine(menuCellSize - 1, y, menuCellSize - 1, yInfoArea); // right down to info area
				og.drawLine(menuCellSize - 1, yInfoArea, imgWidth, yInfoArea); // small horizontal line to info area
			}
			// frame at the bottom
			og.drawLine(0, imgHeight - 1, imgWidth, imgHeight - 1); // bottom

		} else {
			og.setColor(brightColor);
			og.drawLine(0, 0, 0, imgHeight - 1); // left
			og.drawLine(0, LEFT_MENU_NUMBER_OF_CELLS * menuCellSize, imgHeight - 1,
					LEFT_MENU_NUMBER_OF_CELLS * menuCellSize); // predel

			og.setColor(bgColor.darker());
			// og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1 - menuCellSize); //
			// right down to info area
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, yInfoArea + 1); // right down to info area
			og.drawLine(0, imgHeight - 1, imgWidth - 0, imgHeight - 1); // bottom
		}

		// the actions for the left menu matche the squar numbers
		for (int i = 3; i <= LEFT_MENU_NUMBER_OF_CELLS + 2; i++) {
			createSquare(og, 1, i);
		}

		g.drawImage(leftMenuImage.getImage(), (int) screenArea.x, (int) screenArea.y, this);
	}

	// ----------------------------------------------------------------------------
	protected void drawInfo(Graphics g) {
		// BH 2023.01.18 Swing will handle this differently
//		if (!this.mustReDrawInfo)
//			return;
		if (infoText == null) {
			infoText = "";
		}

		int textYPosition = 15;
		// screen position of the info bar at the bottom of the applet
		Rectangle2D.Double screenArea = new Rectangle2D.Double(leftMenuWidth(),
				dimension.height - this.infoAreaHeight(), dimension.width - leftMenuWidth(), infoAreaHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(infoAreaImage, this.menuScale, screenArea);

		double imgWidth = screenArea.width / this.menuScale; // the width is reduced if scale > 1
		double imgHeight = this.infoAreaHeight(1); // unscaled because og is scaled
		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (options.newLook) {
			og.setColor(Color.darkGray);
			og.drawRect(-10, 0, imgWidth - 1 + 10, imgHeight - 1); // -10: used for masking the left border
		} else {
			og.setColor(brightColor);
			// og.setColor(Color.red);
			// og.drawLine(0, 0, imgWidth - 1 - 2, 0); // top
			og.drawLine(0, 0, imgWidth - rightBorder(1) + 1, 0); // top
			og.setColor(bgColor.darker());
			og.drawLine(0, imgHeight - 1, imgWidth - 1, imgHeight - 1); // bottom
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1); // right
		}
		og.setFont(menuCellFontSmaller);
		og.setColor(Color.black);

		if (infoText.toLowerCase().contains("error"))
			og.setColor(Color.red);
		og.drawString(infoText, 10, textYPosition);

		if (!this.isDepict()) { /*
								 * in depict mode, another graphics must be used because the info bar is not
								 * present
								 */
			// TODO: the java implemenrtation does not support drag and drop
			this.drawDragAndDropIcon(og, 1.0);
			if (options.fullScreenIconOption && isFullScreenSupported())
				this.drawFullScreenIcon(og, 1.0, this.dragAndDropIcon);
			else
				this.fullScreenIcon = null;
		}

		if (imgWidth > 100 && this.activeMol != null && this.moleculePartsList.hasOneMoleculeWithChiralFlag()) {
			String chiralText = "Chiral";
			og.setColor(Color.black);
			og.drawString(chiralText, imgWidth - 100, textYPosition);
		}

		g.drawImage(infoAreaImage.getImage(), (int) screenArea.x, (int) screenArea.y, this);

	}

	/*
	 * to be redefined in JSME
	 */
	protected boolean isFullScreenSupported() {
		return true;
	}

	/**
	 * Java applet only. FIXME: recompute bond center?
	 */
	protected void toggleFullScreen() {
		System.out.println("drawFullScreen " + this.isFullScreen);
		this.mustRedrawEverything();
		Dimension newDim;
		if (!isFullScreen) {
			// save current dimension
			nonFullScreenSize.setSize(this.dimension.width, this.dimension.height);
			newDim = Toolkit.getDefaultToolkit().getScreenSize();
			molecularAreaScalePixelsPerCoord = Math.min(molecularAreaScalePixelsPerCoord * fullScreenScale,
					maxMolecularAreaScale);
			menuScale = Math.min(menuScale * fullScreenScale, maxMenuScale);

		} else {
			molecularAreaScalePixelsPerCoord = Math.max(molecularAreaScalePixelsPerCoord / fullScreenScale,
					minmolecularAreaScale);
			menuScale = Math.max(menuScale / fullScreenScale, minMenuScale);
			newDim = nonFullScreenSize;

		}
		isFullScreen = !isFullScreen;
		this.setSize(newDim);

	}

	// ----------------------------------------------------------------------------
	boolean menuAction(int pressed) {
		// calling actions after pressing menu button or menu keys
		// called from mousePressed() or keyTyped()

		// idea: this.atomTypeChangeAction = true; //atom type selected or FG or query
		// box
		// mouseover would only highlight the atoms

		if (pressed == 0)
			return false; // moze to byt ? ano, napr z keyTyped

		// BB
		this.mustRedrawNothing();
		boolean status = true;
		boolean structureChangePerformed = false;

		int actionOld = action;
		action = pressed;
		if (pressed <= 300) { // top menu
			// BB
			this.mustReDrawTopMenu = true;
			this.mustReDrawLeftMenu = true; // deselection possible on the left menu
			clearInfo(); // clear any messages

			switch (pressed) {
			case ACTION_CLEAR:
				clear();
				// idea: double click would do a complete cleaning of the undo and redo stack
				// this.molChangeManager.clear(); //delete all undo's
				// this.sdfStack.clear(); //delete all entries from the SDF stack
				// this.recordAfterStructureChangedEvent(CLEAR); //already performed by
				// clear()n

				// reset the red highlight correctly
				this.handleMouseLeaveActionMenu(ACTION_CLEAR);
				this.handleMouseEnterActionMenu(ACTION_CLEAR);

				structureChangePerformed = true; // sept 2016
				break;
			case ACTION_UNDO:
				// zostavaju rovnake settings ako predtym

				// BB
				setMustRedrawMolecularArea(true); // needed for e.g. undo

				action = actionOld;
				/*
				 * if(!this.canMultipleUndo) { //PE's original undo // undo po new molecule (pri
				 * new smol = null) if (smol == null) { actualMoleculePartIndex =
				 * numberofMoleculeParts; // mohlo sa medzitym zmenit clear(); } else if
				 * (afterClear) { saved = ++numberofMoleculeParts; actualMoleculePartIndex =
				 * numberofMoleculeParts; afterClear = false; } // undo po standard change (aj
				 * po delete s upravenym saved) if (smol == null) break; // no molecule in undo
				 * stack activeMol = smol.deepCopy(); moleculeParts[saved] = activeMol; } else {
				 */ // multiple undo handling
				if (!this.molChangeManager.canUndo()) {
					info("No more undo");

					// actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
					// clear();
				} else if (afterClear) {
					// saved = ++numberofMoleculeParts;
					// actualMoleculePartIndex = numberofMoleculeParts;
					activeMol = moleculePartsList.last();
					afterClear = false;
				}
				if (!this.molChangeManager.canUndo())
					break; // no molecule in undo stack

				this.retoreState(this.molChangeManager.undo());
				this.recordAfterStructureChangedEvent(UNDO);
				this.willPostSave(false);

				setMustRedrawMolecularArea(true);
				// System.out.println("*********** undo " + mol.natoms);

				break;

			case ACTION_REDO:

				if (!this.canMultipleUndo) {
					action = actionOld;
					this.alert("The redo feature is not implemented yet");

				} else {
					action = actionOld;
					// BB this code is copied from the undo part and adapted
					if (!this.molChangeManager.canRedo()) {
						// actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						// clear();
						info("No more redo");
						break;
					} else if (afterClear) {
						// saved = ++numberofMoleculeParts;
						// actualMoleculePartIndex = numberofMoleculeParts;
						activeMol = moleculePartsList.last();

						afterClear = false;
					}
					// undo po standard change (aj po delete s upravenym saved)
					if (!this.molChangeManager.canRedo())
						break; // no molecule in undo stack
					this.retoreState(this.molChangeManager.redo());
					this.recordAfterStructureChangedEvent(REDO);
					this.willPostSave(false);

					setMustRedrawMolecularArea(true);

				}

				break;

			case ACTION_IO: /* open popup menu with IO */
				this.handleCopyPasteJPopupMenu(null, this.fixedCopyPasteJPopupMenuPosition.x,
						this.fixedCopyPasteJPopupMenuPosition.y);
				action = actionOld;
				break;

			case ACTION_PGUP:
			case ACTION_PGDN:
			case ACTION_END:
			case ACTION_HOME:
				String sdf = null;
				action = actionOld;

				switch (pressed) {
				case ACTION_PGDN:
					sdf = this.sdfStack.previous();
					break;
				case ACTION_PGUP:
					sdf = this.sdfStack.next();
					break;
				case ACTION_END:
					sdf = this.sdfStack.last();
					break;
				case ACTION_HOME:
					sdf = this.sdfStack.first();
					break;
				default:
					assert (false);

				}

				if (sdf == null)
					info("No more molecules in SDF buffer");
				else {
					// sdf = sdf.replace("\n", "|");
					this.clearMyMolecularContent(); // to avoid any merging with the current molecule
					pasteFromSDFstack = true;
					// Does not work with V3000!!!!
					// this.readMolFile(sdf, false);//do not copy in undo
					this.handleReadGenericInput(sdf, null, false, false); // do not repaint and record event here

					pasteFromSDFstack = false;

					if (this.infoText.equals("")) { // no error mesage from readMolFile
						info("MOL n. " + this.sdfStack.getCurrentDisplayIndex() + " of " + this.sdfStack.size());
						structureChangePerformed = true;
						this.recordAfterStructureChangedEvent(SD_FSTACK);
						this.willPostSave(false);
					}

				}

				break;

			case ACTION_SMI:

				this.handleSmilesBox();

				action = actionOld;
				break;
			case ACTION_QRY:
				this.handleQueryBox();

				// stay commented
				// action = action_old;
				break;
			case ACTION_JME:
				this.handleAboutBox();
				action = actionOld;
				break;
			case ACTION_NEW:
				// BB
				// setMustRedrawMolecular(true);
				newMolecule = true;
				action = actionOld; // ak nie je bond alebo ring, malo by

				// there is no structure change!!!! this is just a menu click
				// this.recordAfterStructureChangedEvent(CLEAR);

				// resetnut
				break;

			case ACTION_MARK:
				if (options.markerMenu) {
					action = actionOld;
					this.showJPopupMenuRealtiveToScaledMainMenu(this.createFBackgroundColorPopumemu(),
							this.markerJPopupMenuPosition.x, markerJPopupMenuPosition.y);

					break;
				}
				// BB
				// setMustRedrawMolecular(true);
				if (options.autonumber) {
					// autonumber added in 2009.09
					if (mouseShift) { // automark all atoms, zrusi stare mark
						mouseShift = false; // aby pridavalo cisla
						activeMol.numberAtoms();

						// added Oct 2015 - not tested
						setMustRedrawMolecularArea(true);
						this.recordAfterStructureChangedEvent(AUTO_NUMBER);
						structureChangePerformed = true;

						action = actionOld;
					}
				}
				// set na action_mark
				keyboradInputMark = 1; // starts from 1 ????????????????/
				// there is no structure change , only menu selection 123?
				// this.recordAfterStructureChangedEvent(MARK);

				break;

//BB: END button was removed
//			case ACTION_SPIRO:
//				if (isStandAloneApplication) {
//					System.exit(0);
//				}
			// copy a reaction component to the other side of the reaction
			case ACTION_REACP:
				// save ???
				action = actionOld;
				this.updateReactionRoles();
				if (activeMol.getReactionRole() == JMEmol.ReactionRole.AGENT) {
					info("Copying the agent not possible !");
					break;
				}

				// compute the bounding box of the source molecule
				Box cad = activeMol.computeBoundingBoxWithAtomLabels(null);
				if (cad == null)
					break;

				setMustRedrawMolecularArea(true);
				activeMol = new JMEmol(activeMol);
				// mol = mol.createClone(); // ???
				// posunie ju na spravne miesto
				// int dx = (int) ((dimension.width - menuCellSize) / 2 - cad.getCenterX());
				// //center[0]);
				Rectangle.Double molArea = this.getMolecularAreaBoundingBoxCoordinate00();
				double dx = molArea.getCenterX() - cad.getCenterX(); // dx can be negative or positive
//				for (int i = 1; i <= mol.natoms; i++)
//					mol.x[i] += dx * 2;
//					//mol.atoms[i].x += dx * 2;
//					moveXY(mol, i, dx * 2, 0);
				activeMol.moveXY(dx * 2, 0); // move the new created molecule to the other side

				// mol.complete();
				// moleculeParts[++numberofMoleculeParts] = activeMol;
				// actualMoleculePartIndex = numberofMoleculeParts;
				moleculePartsList.add(activeMol);
				this.recordAfterStructureChangedEvent(REACTION_COPY);

				structureChangePerformed = true;
				// added Jan 2016
				// this.postSave();

				// reset the blue highlight correctly
				this.handleMouseLeaveActionMenu(ACTION_REACP);
				this.handleMouseEnterActionMenu(ACTION_REACP);

				break;

			case ACTION_DELETE:
				// FIXME - DUPLICATED CODED with delete using the mouse!!!!!!!!!!!!!!!!!!!!
				// 2011.01 if touchedAtom or bond, deletes it
				// happens with keyboard shortcut not mouse action
				structureChangePerformed = this.actionDeleteTouchedAtomOrBond();
				break;

			case ACTION_FG:
				action = actionOld;
				this.showJPopupMenuRealtiveToScaledMainMenu(this.getFunctionalGroupPopumemu(),
						this.functionalGroupJPopupMenuPosition.x, functionalGroupJPopupMenuPosition.y);
				// this.getFunctionalGroupPopumemu().show(this,
				// (int)(this.functionalGroupJPopupMenuPosition.x * this.menuScale),
				// (int)(functionalGroupJPopupMenuPosition.y * this.menuScale));

				break;

			case ACTION_CHARGE:
				// BB
				if (activeMol.touchedAtom > 0 && activeMol.changeCharge(activeMol.touchedAtom, 0)) {
					this.recordAtomEvent(CHARGE_ATOM0); // same code as in mouseDown event
					structureChangePerformed = true;
				}
				break;

			default: // vsetky co nerobia okamzitu akcion (DEL, templates, +/-,
				// ...)
				break;
			}
		} else { // pressed > 300 (left menu - atoms)
			// BB
			this.mustReDrawLeftMenu = true;
			this.mustReDrawTopMenu = true; // deselection of an item in the top menu
			// if the action is coming from a keyboard structure change, then there is no
			// need to redraw the the menu
			active_an = mapActionToAtomNumber(pressed, -1);

			// BB added August 2017
			clearInfo(); // clear any messages

//			switch (pressed) {
//			case ACTION_AN_C:
//				active_an = AN_C;
//				break;
//			case ACTION_AN_N:
//				active_an = AN_N;
//				break;
//			case ACTION_AN_O:
//				active_an = AN_O;
//				break;
//			case ACTION_AN_F:
//				active_an = AN_F;
//				break;
//			case ACTION_AN_CL:
//				active_an = AN_CL;
//				break;
//			case ACTION_AN_BR:
//				active_an = AN_BR;
//				break;
//			case ACTION_AN_I:
//				active_an = AN_I;
//				break;
//			case ACTION_AN_S:
//				active_an = AN_S;
//				break;
//			case ACTION_AN_P:
//				active_an = AN_P;
//				break;
//			case ACTION_AN_H:
//				active_an = AN_H;
//				break;
//			case ACTION_AN_X:
//				this.handleAtomXbox();
//				active_an = AN_X;
//				
//				break;
			/*
			 * case ACTION_AN_R: active_an = AN_R; break; case ACTION_AN_R1: active_an =
			 * AN_R1; break; case ACTION_AN_R2: active_an = AN_R2; break; case ACTION_AN_R3:
			 * active_an = AN_R3;
			 * 
			 * 
			 * break;
			 */

//			}

			if (active_an == AN_X) {
				this.handleAtomXbox();
			}
			// BB : handling R group
			if (pressed >= ACTION_AN_R && pressed <= ACTION_AN_R_LAST) {
				active_an = AN_R + (pressed - ACTION_AN_R);
			}

			// 2009.09 if touchedAtom, changes it
			if (structureChangePerformed == false && activeMol.touchedAtom > 0) {
				// BB
				if (active_an != activeMol.an(activeMol.touchedAtom) && active_an != AN_X) {
					activeMol.AN(activeMol.touchedAtom, active_an);
					activeMol.Q(activeMol.touchedAtom, 0); // resetne naboj
					// mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
					activeMol.atoms[activeMol.touchedAtom].iso = 0; // BB: reset isotop
					// mol.nh[mol.touchedAtom] = 0;
					activeMol.atoms[activeMol.touchedAtom].nh = 0;

					// this.postSave();
					// this.recordAtomEvent(SET_ATOM + active_an); // active_an is an arbitrary
					// number, should be
					// changed to the string of the atom type
					this.recordAtomEvent(SET_ATOM); // useless since the JSME_Event has the atom number

					// BB Sept 2015: changed the touched atom but do not change the menu
					// action = actionOld;
					structureChangePerformed = true;
				} else if (active_an == AN_X) {
					// MultiBox not atomxBox (this is static and always
					// available,
					// needed for key press)
					// FIXME: this code is never reached
					// code reached when the X keyboard shortcut is used
					// assert false;
					String xx = MultiBox.atomicSymbol.getText();
					activeMol.setAtom(activeMol.touchedAtom, xx);
					// this.postSave();
					// this.recordAtomEvent(SET_ATOM + active_an);// useless since the
					// JSME_Event has the atom number
					this.recordAtomEvent(SET_ATOM);
					structureChangePerformed = true;

				}
				// mol.cleanAfterChanged(); // to add Hs

			}
		}

		// BB Sept 2015: add ring addition
		// extend with other actions:
		// phenyl ring (shortcut is "1"
		// 2 for double bond?, see the help for the shortcucts
		/*
		 * atoms C, N, O, P, S, F, L (for Cl), B (for Br), I, H, R bonds - for single
		 * bond, = for double bond rings 3..8 for 3 to 8 membered rings, 1 for phenyl
		 * and 0 for furyl groups a - COOH, y - NO2, z - SO3H, t - tert. butyl, ft - CF3
		 */
		if (!structureChangePerformed && (activeMol.touchedAtom > 0 || activeMol.touchedBond > 0)) {
			// the addRing function can handle both bond and atom
			// duplicated code
			// this works as well for addition of phenyl (KB shortcut is "1")
			if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {

				// fusing ring to bond
				lastAction = LA_RING; // in addRing may be set to 0
				activeMol.addRing();
				structureChangePerformed = true;
				this.recordBondEvent(ADD_RING_BOND);
			}

			// BB Oct 2015: add bond & change bond without switch to double bond bond tool
			else if (action == ACTION_BOND_SINGLE || action == ACTION_BOND_DOUBLE || action == ACTION_BOND_TRIPLE) {

				if (activeMol.touchedAtom > 0) {
					// lastAction = LA_BOND; // in addBond may be set to 0
					lastAction = 0; // correction - ohterwise mouse drag will move the end of the new added bond
									// instead of moving the molecule
					// mol.preSave();
					activeMol.addBond();
					this.recordBondEvent(ADD_BOND);
					structureChangePerformed = true;
				} else { // mol.touchedBond > 0
					// code cpoied from mouseDown DUPLiCATED !!!! TODO
					int bondType = JMEmol.SINGLE;
					String eventType = SET_BOND_SINGLE;
					boolean changed; // BB
					switch (action) {
					case ACTION_BOND_DOUBLE:
						bondType = JMEmol.DOUBLE;
						eventType = SET_BOND_DOUBLE;
						break;
					case ACTION_BOND_TRIPLE:
						bondType = JMEmol.TRIPLE;
						eventType = SET_BOND_TRIPLE;
					}
					changed = bondType != activeMol.bonds[activeMol.touchedBond].bondType;
					if (changed) {
						activeMol.bonds[activeMol.touchedBond].bondType = bondType;
						this.recordBondEvent(eventType);
						structureChangePerformed = true;
						activeMol.bonds[activeMol.touchedBond].stereo = 0; // zrusi stereo
					} else if (bondType == JMEmol.DOUBLE) {
						// no change but clicked a second time on a double bond with the double bond
						// tool
						// change normal double bond into crossed bond or vice versa
						activeMol.bonds[activeMol.touchedBond].toggleNormalCrossedDoubleBond();
						structureChangePerformed = true;
					}

				}

			}

		}

		if (structureChangePerformed) {
			// this.mustRedrawNothing(); //info might have been generated
			setMustRedrawMolecularArea(true);
//			mocleanAfterChangedte();
//			
//			if(mustBeSaveToUndoStack);
//				this.postSave();

			// updateReactionParts(); // a new bond might have connected two separated
			// molecules

			action = actionOld; // BB avoid menu change during repaint() after a key press that has changed the
								// structure, like pressing 2 , add a double bond but do not switch to db tool
		}

		// repaintuje zbytocne vsetko - zatial nechat
		if (mustReDrawMolecularArea) {
			this.drawMolecularAreaRightNow();

		}

		repaint();

		// BB
		return status;
	}

	/**
	 * This method recods the event and performn the postSave()
	 * 
	 * @return true if the an atom or a bond has been deleted
	 */
	boolean actionDeleteTouchedAtomOrBond() {
		boolean structureChangePerformed = false;

		if (activeMol.touchedAtom > 0 || activeMol.touchedBond > 0) {
			// BB
			structureChangePerformed = true;
			// mol.preSave(); //TODO REMOVE
			if (activeMol.touchedAtom > 0) {
				activeMol.deleteAtom(activeMol.touchedAtom);
				this.recordAtomEvent(DEL_ATOM);
				activeMol.touchedAtom = 0;
			} else {
				activeMol.deleteBond(activeMol.touchedBond);
				this.recordAtomEvent(DEL_BOND);
				activeMol.touchedBond = 0;

			}
			activeMol.cleanAfterChanged(options.polarnitro); // to add Hs

			// if an atom or a bond is deleted, then create new molecule if needed
			moleculePartsList.splitFragments(true); // true: remove any empty molecule
			if (moleculePartsList.isEmpty()) { // can happen when there are no molecule left, e.g, the last one had a
												// single atom that was deleted
				moleculePartsList.add(new JMEmol());
			}
			activeMol = moleculePartsList.get(0);
			/*
			 * JMEmol newParts[] = mol.splitMultiparts(); if(newParts.length > 1) { int
			 * molIndex = moleculeParts.indexOf(mol); moleculeParts.remove(molIndex);
			 * for(int p = 0; p < newParts.length; p++) { if(p==0) {
			 * moleculeParts[actualMoleculePartIndex] = newParts[p]; //replaced by the first
			 * new molecule mol = moleculeParts[actualMoleculePartIndex]; } else {
			 * moleculeParts[++numberofMoleculeParts] =newParts[p]; //Append new parts } } }
			 */
		}

		return structureChangePerformed;
	}

	/**
	 * Create an alert box with an OK button to display a message
	 * 
	 * @param message
	 */
	public void alert(final String message) {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {

				new AlertBox(message, JME.this, JME.this.bgColor).setVisible(true);

			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAboutBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {

				if (aboutBox != null) {
					aboutBox.disposeIfShowing();
				}
				aboutBox = new MultiBox(MultiBox.BOX_ABOUT, JME.this);

			}
		});
	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleQueryBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {

				// if (queryBox != null) {
				// queryBox.disposeIfShowing();
				// }
				// queryBox = new QueryBox(this);

				// BB: it is better that the query box keeps its selection when brought back -
				// dispose() erase everything
				// however, it might be hidden behind another window, thus it has to show in
				// front
				if (queryBox == null) {
					queryBox = new QueryBox(JME.this);
				} else {
					if (queryBox.isShowing()) {
						queryBox.toFront(); // not tested wihthin a browser window, works fine with Eclipse/Linux
						// queryBox.setVisible(false);
						// queryBox.setVisible(true);
					} else {
						queryBox.setVisible(true);
					}
				}

			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleSmilesBox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				if (smilesBox != null) {
					smilesBox.disposeIfShowing();
				}
				smilesBox = new MultiBox(MultiBox.BOX_SMILES, JME.this);
			}
		});

	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAtomXbox() {
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {

				if (!webme) {
					if (atomxBox != null) {
						atomxBox.disposeIfShowing();
						atomxBox = null;
					}
					if (activeMol.touchedAtom == 0)
						atomxBox = new MultiBox(MultiBox.BOX_ATOMX, JME.this);
				}
			}

		});

	}

	// ----------------------------------------------------------------------------
	void createSquare(PreciseGraphicsAWT g, int xpos, int ypos) {
		int square = ypos * 100 + xpos;
		double xstart = (xpos - 1) * (menuCellSize + menuCellBorder());
		double ystart = (ypos - 1) * (menuCellSize + menuCellBorder());
		if (xpos == 1 && ypos > 2)
			ystart -= (2 * menuCellSize); // relative coordinates in leftMenu
		g.setColor(bgColor);
		if (options.newLook) {
			if (square == action) {
				g.setColor(bgColor.darker());
				// System.out.println("xstart=" + xstart + " ystart=" + ypos);
			}

			g.fillRect(xstart, ystart, menuCellSize, menuCellSize);
			g.setColor(Color.darkGray);
			g.drawRect(xstart, ystart, menuCellSize - 1, menuCellSize - 1);
		} else {
			if (square == action)
				g.fill3DRect(xstart + 1, ystart + 1, menuCellSize, menuCellSize, false); // color override does not work
																							// - always grey?
			else
				g.fill3DRect(xstart, ystart, menuCellSize, menuCellSize, true);
		}

		if (!this.isActionEnabled(square)) {
			return;
		}

		// draws icon or text in the square
		double marginFromCellBorder = menuCellSize / 4; // space between cell border and inside icon
		if (ypos < 3) { // top menu squares
			g.setColor(Color.black);
			switch (square) {
			case ACTION_SMI: // smiley face
				if (true) {
					g.setColor(Color.yellow);
					g.fillOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // head
					g.setColor(Color.black);
				}
				g.drawOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // head
				g.drawArc(xstart + 6, ystart + 6, menuCellSize - 12, menuCellSize - 12, -35, -110); // mouth
				// oci
				g.fillRect(xstart + 9, ystart + 9, 2, 4);
				g.fillRect(xstart + menuCellSize - 10, ystart + 9, 2, 4);
				// jazyk
				if (Math.random() < 0.04) {
					g.setColor(Color.red);
					g.fillRect(xstart + 10, ystart + 18, 4, 4);
				}
				// blink
				if (Math.random() > 0.96) {
					g.setColor(Color.yellow);
					g.fillRect(xstart + menuCellSize - 10, ystart + 8, 2, 3);
				}
				break;
			case ACTION_SPIRO:
				// drawing spiro button
				double xFarLeft = xstart + marginFromCellBorder;
				double xFarRight = xstart + menuCellSize - marginFromCellBorder;
				double xMiddle = xstart + menuCellSize / 2;
				// bottom left - black line
				g.drawLine(xFarLeft, ystart + menuCellSize - marginFromCellBorder, xMiddle, ystart + menuCellSize / 2);
				g.drawLine(xstart + menuCellSize / 2, ystart + menuCellSize / 2, xFarRight,
						ystart + menuCellSize - marginFromCellBorder);

				double y = ystart + menuCellSize - marginFromCellBorder;
				double dotLength = ((double) this.menuCellSize) / standardMenuCellSize;
				g.drawLine(xMiddle - dotLength, y, xMiddle - 2 * dotLength, y);
				g.drawLine(xMiddle + dotLength, y, xMiddle + 2 * dotLength, y);

				g.setColor(Color.magenta);
				// top left - magenta line
				g.drawLine(xFarLeft, ystart + marginFromCellBorder, xMiddle, ystart + menuCellSize / 2);
				g.drawLine(xstart + menuCellSize / 2, ystart + menuCellSize / 2, xFarRight,
						ystart + marginFromCellBorder);

				y = ystart + marginFromCellBorder;
				g.drawLine(xMiddle - dotLength, y, xMiddle - 2 * dotLength, y);
				g.drawLine(xMiddle + dotLength, y, xMiddle + 2 * dotLength, y);

				// restore default color
				g.setColor(Color.black);
				break;

			case ACTION_QRY:
				g.setColor(Color.orange);
				g.fillRect(xstart + 4, ystart + 4, menuCellSize - 8, menuCellSize - 8); // head
				g.setColor(Color.black);
				g.drawRect(xstart + 4, ystart + 4, menuCellSize - 8, menuCellSize - 8); // head
				g.drawArc(xstart + 6, ystart + 6, menuCellSize - 11, menuCellSize - 12, -35, -110); // mouth
				g.fillRect(xstart + 9, ystart + 9, 2, 4);
				g.fillRect(xstart + menuCellSize - 10, ystart + 9, 2, 4);
				break;
			case ACTION_CHARGE:
				// squareText(g, xstart, ystart, "+ / ");
				// squareText(g, xstart, ystart, "+ / -");
				// squareTextBold(g, xstart, ystart, Color.black, "+ -");
				// g.drawLine(xstart + 15, ystart + 13, xstart + 19, ystart + 13); // better
				// -
				double padding = (double) menuCellSize / 4;
				// the / line
				g.drawLine(xstart + padding, ystart + menuCellSize - padding, xstart + menuCellSize - padding,
						ystart + padding);

				double symbolSize = (double) menuCellSize / 2 - padding;

				// the minus - bottom right
				double minusY = ystart + menuCellSize * 2 / 3;
				double minusStartX = xstart + menuCellSize / 2;
				double minusEndX = minusStartX + symbolSize;

				g.drawLine(minusStartX, minusY, minusEndX, minusY);

				// the plus horizontal line - top left
				double hY = ystart + menuCellSize * 1 / 3;
				double hEndX = minusStartX;
				double hStartX = minusStartX - symbolSize;
				g.drawLine(hStartX, hY, hEndX, hY);

				// the plus vertical line - top left
				double vX = (hStartX + hEndX) / 2;
				double vStartY = hY - symbolSize / 2;
				double vEndY = vStartY + symbolSize;
				g.drawLine(vX, vStartY, vX, vEndY);

				break;

			case ACTION_MOVE_AT:

				if (options.showAtomMoveJButton) {
					// Draw a blue rectangle centered in the cell
					double reduction = (double) marginFromCellBorder / 2;
					double squareSize = menuCellSize - 2 * marginFromCellBorder - 2 * reduction;
					double brx = xstart + reduction + marginFromCellBorder; // blue rectangle x
					double bry = ystart + (brx - xstart);

					g.setColor(Color.BLUE);
					g.drawRect(brx, bry, squareSize, squareSize);

					g.setColor(Color.BLACK);

					// four triangles symbolising arrows
					double middleX = xstart + menuCellSize / 2;
					double middleY = ystart + menuCellSize / 2;

					double arrowMarginFromCellBorder = reduction; // not enough space for using a complete margin
					double arrowHeight = reduction;
					double arrowWidth = squareSize; // must be the same as squareSize for small cells, if different, the
													// code has to be adapted
					assert arrowHeight > 0;

					// top triangle arrow
					double xLeft = brx;
					double xRight = brx + arrowWidth;
					double yTop = ystart + arrowMarginFromCellBorder;
					// int yBottom = bry - reduction;
					double yBottom = yTop + arrowHeight;

					g.drawLine(xLeft, yBottom, middleX, yTop);
					g.drawLine(middleX, yTop, xRight, yBottom);

					// bottom triangle arrow
					// x coordinates are the same
					yBottom = bry + squareSize + reduction;
					yTop = yBottom + arrowHeight;
					g.drawLine(xLeft, yBottom, middleX, yTop);
					g.drawLine(middleX, yTop, xRight, yBottom);

					// Left triangle
					xLeft = xstart + reduction;
					xRight = xLeft + arrowHeight;
					yTop = bry;
					yBottom = yTop + arrowWidth;

					g.drawLine(xRight, yTop, xLeft, middleY);
					g.drawLine(xLeft, middleY, xRight, yBottom);

					// right triangle
					// y coordinates are the same
					xLeft = brx + squareSize + reduction;
					xRight = xLeft + arrowHeight;

					g.drawLine(xLeft, yTop, xRight, middleY);
					g.drawLine(xRight, middleY, xLeft, yBottom);
				}

				break;

			case ACTION_UNDO:
				// g.drawArc(xstart+6,ystart+6,sd-12,sd-12,270,270); // head
				// g.drawArc(xstart + 6, ystart + 7, menuCellSize - 12, menuCellSize - 14, 270,
				// 270); // head

				this.drawUndoOrRedoArrowMenuCell(g, xstart, ystart, menuCellSize, true);

				// squareText(g,xstart,ystart,"UDO");
				break;

			case ACTION_REDO:
				this.drawUndoOrRedoArrowMenuCell(g, xstart, ystart, menuCellSize, false);
				break;

			case ACTION_IO:
				this.drawInputOutputArrowsMenuCell(g, xstart, ystart, menuCellSize);
				this.fixedCopyPasteJPopupMenuPosition = new Point((int) xstart, (int) ystart);

				break;

			case ACTION_REACP:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder * 3 / 2,
						ystart + menuCellSize / 2 + marginFromCellBorder / 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder * 3 / 2,
						ystart + menuCellSize / 2 - marginFromCellBorder / 2);
				break;
			case ACTION_CLEAR:
				g.setColor(Color.white);
				g.fillRect(xstart + 3, ystart + 5, menuCellSize - 7, menuCellSize - 11);
				g.setColor(Color.black);
				g.drawRect(xstart + 3, ystart + 5, menuCellSize - 7, menuCellSize - 11);
				// squareText(g,xstart,ystart,"CLR");
				break;
			case ACTION_NEW:
				// special handling (aby boli 2 stvorce on)
				g.setColor(bgColor);
				if (newMolecule)
					g.fill3DRect(xstart + 1, ystart + 1, menuCellSize, menuCellSize, false);
				g.setColor(Color.black);
				squareText(g, xstart, ystart, "NEW");
				break;
			case ACTION_DELGROUP:
				// squareText(g,xstart,ystart,"D-R");
				g.setColor(Color.red);
				g.drawLine(xstart + 7, ystart + 7, xstart + menuCellSize - 7, ystart + menuCellSize - 7);
				// g.drawLine(xstart + 8, ystart + 7, xstart + menuCellSize - 6, ystart +
				// menuCellSize
				// - 7);
				g.drawLine(xstart + 7, ystart + menuCellSize - 7, xstart + menuCellSize - 7, ystart + 7);
				// g.drawLine(xstart + 8, ystart + menuCellSize - 7, xstart + menuCellSize - 6,
				// ystart + 7);
				g.setColor(Color.black);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + 12,
						ystart + menuCellSize / 2);
				squareText(g, xstart + 6, ystart, "R");
				break;
			case ACTION_DELETE:
				// squareText(g,xstart,ystart,"DEL");
				g.setColor(Color.red);
				// g.drawLine(xstart+m,ystart+m,xstart+sd-m,ystart+sd-m);
				// g.drawLine(xstart+m+1,ystart+m,xstart+sd-m+1,ystart+sd-m);
				// g.drawLine(xstart+m,ystart+sd -m,xstart+sd-m,ystart+m);
				// g.drawLine(xstart+m+1,ystart+sd-m,xstart+sd-m+1,ystart+m);
				g.drawLine(xstart + 7, ystart + 7, xstart + menuCellSize - 7, ystart + menuCellSize - 7);
				// g.drawLine(xstart + 8, ystart + 7, xstart + menuCellSize - 6, ystart +
				// menuCellSize
				// - 7);
				g.drawLine(xstart + 7, ystart + menuCellSize - 7, xstart + menuCellSize - 7, ystart + 7);
				// g.drawLine(xstart + 8, ystart + menuCellSize - 7, xstart + menuCellSize - 6,
				// ystart + 7);
				g.setColor(Color.black);
				break;
			case ACTION_MARK: // handle both color marking and setting of atom map

				if (!options.starNothing) {
					if (params.mark) {

						// May 2015replaced by a circle

						// 6 is same as for smiley
						double pseudoRadius = 9; // was 6, PE wants it smaller
						Color color = this.colorManager.getColor(activeMarkerColorIndex);
						if (color != null) {
							g.setColor(color);
							g.fillOval(xstart + pseudoRadius / 2, ystart + pseudoRadius / 2,
									menuCellSize - pseudoRadius, menuCellSize - pseudoRadius);
							g.setColor(Color.black);
						} else {
							this.showInfo("invalid color index:" + activeMarkerColorIndex);
							assert (false);
						}

					} else
						squareText(g, xstart, ystart, "123");

					this.markerJPopupMenuPosition = new Point((int) xstart, (int) ystart);
				}
				break;
			case ACTION_JME:
				// squareText(g,xstart,ystart,"JME");
				// g.drawImage(infoImage,xstart+2,ystart+2,this);
				g.setColor(Color.blue);
				double coloredRectSize = menuCellSize - 8;
				double coloredRectSizeX = xstart + (menuCellSize - coloredRectSize) / 2;
				double coloredRectSizeY = ystart + (menuCellSize - coloredRectSize) / 2;
				g.fillRect(coloredRectSizeX, coloredRectSizeY, coloredRectSize, coloredRectSize);
				g.setColor(Color.black);
				// g.drawRect(coloredRectSizeX, coloredRectSizeY, coloredRectSize,
				// coloredRectSize);
				// squareTextBold(g, xstart + 1, ystart - 1, Color.white, "i");
				squareTextBold(g, xstart, ystart, Color.white, "i");
				break;
			case ACTION_STEREO:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 2);
				break;
			case ACTION_BOND_SINGLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2);
				break;
			case ACTION_BOND_DOUBLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 - 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 + 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 2);
				break;
			case ACTION_BOND_TRIPLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 - 3,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 3);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 + 3,
						xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 3);
				break;
			case ACTION_CHAIN:
				g.drawLine(xstart + marginFromCellBorder / 2,
						ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3,
						xstart + marginFromCellBorder / 2 * 3,
						ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3);
				g.drawLine(xstart + marginFromCellBorder / 2 * 3,
						ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3,
						xstart + marginFromCellBorder / 2 * 5,
						ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3);
				g.drawLine(xstart + marginFromCellBorder / 2 * 5,
						ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3,
						xstart + marginFromCellBorder / 2 * 7,
						ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3);
				break;
			case ACTION_RING_3: // klesnute o 2
				drawRingIcon(g, xstart, ystart + 2, 3);
				break;
			case ACTION_RING_4:
				drawRingIcon(g, xstart, ystart, 4);
				break;
			case ACTION_RING_5:
				drawRingIcon(g, xstart, ystart, 5);
				break;
			case ACTION_RING_PH:
				drawRingIcon(g, xstart, ystart, 1);
				break;
			case ACTION_RING_6:
				drawRingIcon(g, xstart, ystart, 6);
				break;
			case ACTION_RING_7:
				drawRingIcon(g, xstart, ystart, 7);
				break;
			case ACTION_RING_8:
				drawRingIcon(g, xstart, ystart, 8);
				break;

			case ACTION_FG:
				if (options.fgMenuOption) {
					squareText(g, xstart, ystart, "FG");
					this.functionalGroupJPopupMenuPosition = new Point((int) xstart, (int) ystart);
				}
				break;

			}
		} else { // ypos >=3 (left menu squares)
			int dan = mapActionToAtomNumber(square, -1);
			if (dan != -1) {
				String label = zlabel[dan];
				Color atomSymbolColor = this.leftMenuAtomColor == null ? color[dan] : this.leftMenuAtomColor;

				squareTextBold(g, xstart, ystart, atomSymbolColor, label);
			}

		}
	}

	// BB
	// To ease debugging this method, the menuCellSize can be set to a higher value
	// , e.g 120
	void drawUndoOrRedoArrowMenuCell(PreciseGraphicsAWT g, double xstart, double ystart, double cellSize,
			boolean undo) {
		double arrowWidth = ((double) cellSize / 4.0); // 6
		double arrowHeight = arrowWidth;
		double margin = 2;
		ystart -= 1; // Nov 2016: better vertical centering

		// X values: we work with relative values because the absolute values will be
		// different for the Undo and Redo arrows
		double xStartArrowLine = margin;
		double xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		double xEndArrowLine = xStartArrowLine + arrowWidth;

		// All Y values are absolute
		double yStartArrowLine = ystart + (10.0 * cellSize / 24.0);
		double yArrowTip = yStartArrowLine + arrowHeight;

		double xEnd = xstart + cellSize;

		double absoluteXArrowTip = 0;
		double absoluteXstartArrowLine = 0;
		double absoluteXEndArrowLine = 0;
		if (undo) {
			absoluteXstartArrowLine = xStartArrowLine + xstart;
			absoluteXArrowTip = xArrowTip + xstart;
			absoluteXEndArrowLine = xEndArrowLine + xstart;
		} else {
			// mirror image
			// Y values stay the same
			absoluteXArrowTip = xEnd - xArrowTip;
			absoluteXstartArrowLine = xEnd - xStartArrowLine;
			absoluteXEndArrowLine = xEnd - xEndArrowLine;
		}

		// draw the two lines of the arrow tip - two sides of the triangle
		g.drawLine(absoluteXstartArrowLine, yStartArrowLine, absoluteXArrowTip, yArrowTip);
		g.drawLine(absoluteXEndArrowLine, yStartArrowLine, absoluteXArrowTip, yArrowTip);

		// draw middle line of the arrow , but not as extended as the triangle lines -
		// it looks nicer so
		double yArrowCenterCorrection = arrowHeight / 3 - 0.5; // without the -0.5 , there is a gap visible when zooming
																// in

		g.drawLine(absoluteXArrowTip, yStartArrowLine + yArrowCenterCorrection, absoluteXArrowTip, yArrowTip);

		// The arc

		// define the coordinates and sizes of the bounding box that will contain the
		// arc
		double xStartArcBoxTopLeft = xArrowTip;
		double yStartArcBoxTopLeft = ystart + xStartArcBoxTopLeft;
		double arcBoxWidth = cellSize - xStartArcBoxTopLeft - 2 * margin;
		double arcBoxHeight = cellSize - 2 * margin;

		// The arc has to be moved slightly up in order to align with the start of the
		// line of the center of the arrow (see above)
		yStartArcBoxTopLeft -= yArrowCenterCorrection;
		arcBoxHeight -= yArrowCenterCorrection;

		arcBoxHeight -= 1; // looks better when the cell size is small

		double arcSpan = 270;
		double startAngle = 0;
		double absoluteXxtartArcBoxTopLeft = 0;
		if (undo) {
			absoluteXxtartArcBoxTopLeft = xstart + xStartArcBoxTopLeft;
			startAngle = 270;
		} else {
			absoluteXxtartArcBoxTopLeft = xEnd - arcBoxWidth - xStartArcBoxTopLeft;
			arcSpan *= -1;
			startAngle = -90;
		}
		// draw an arc inside the box
		g.drawArc(absoluteXxtartArcBoxTopLeft, yStartArcBoxTopLeft, arcBoxWidth, arcBoxHeight, startAngle, arcSpan);
	}

	// To ease debugging this method, the menuCellSize can be set to a higher value
	// , e.g 120
	/**
	 * draw two vertical blue arrows to symbolize output / input, arrows are
	 * simplified as triangles
	 * 
	 * @param g
	 * @param xstart
	 * @param ystart
	 * @param cellSize
	 * @param undo
	 */
	void drawInputOutputArrowsMenuCell(PreciseGraphicsAWT g, double xstart, double ystart, double cellSize) {

		// arrows are simplified as triangle
		double arrowWidth = this.ioArrowWidth;
		double arrowHeight = arrowWidth;
		double margin = this.ioMargin;
		double xStartArrowLine = margin + xstart;
		double xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		double xEndArrowLine = xStartArrowLine + arrowWidth;

		double yStartArrowLine = ystart + margin;
		double yArrowTip = yStartArrowLine + arrowHeight;

		g.setColor(Color.BLUE);

		g.fillPolygon(new double[] { xStartArrowLine, xArrowTip, xEndArrowLine },
				new double[] { yStartArrowLine, yArrowTip, yStartArrowLine }, 3);

		/* 2nd triangle */
		xStartArrowLine = xArrowTip;
		xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		xEndArrowLine = xStartArrowLine + arrowWidth;

		yArrowTip = yStartArrowLine + arrowHeight / 2.0;
		yStartArrowLine = yArrowTip + arrowHeight;

		g.fillPolygon(new double[] { xStartArrowLine, xArrowTip, xEndArrowLine },
				new double[] { yStartArrowLine, yArrowTip, yStartArrowLine }, 3);

	}

	/**
	 * Draw the drag and drop symbol at the bottom right of the JSME container
	 * 
	 * @param g                       : either the infor bar or the molecular area
	 * @param graphicsContainerWidth
	 * @param graphicsContainerHeight
	 */
	void drawDragAndDropIcon(PreciseGraphicsAWT g, double iconScale) {
		// arrows are simplified as triangle

		double graphicsContainerWidth = g.getWidth();
		double graphicsContainerHeight = g.getHeight();

		// Use the same size as I/O arrows

		double margin = this.ioMargin * iconScale;
		double arrowWidth = this.ioArrowWidth * iconScale;
		double arrowHeight = arrowWidth;

		if (dragAndDropIcon == null)
			dragAndDropIcon = new Icon(g);
		else
			dragAndDropIcon.pg = g;

		if (this.isDepict()) {
			margin = 0; // put the arrow at the extreme left and bottom without any margin
		}

		double xStartArrowLine = graphicsContainerWidth - margin - arrowWidth;
		double xArrowTip = xStartArrowLine + arrowWidth;

		double yArrowBottom;

		double yArrowTop;
		double yArrowMiddle;

		if (!this.isDepict()) { // non depict mode: the arrow is Y centered in the middle of the info bar
			yArrowMiddle = graphicsContainerHeight / 2;
			yArrowBottom = yArrowMiddle + arrowHeight / 2;
			yArrowTop = yArrowMiddle - arrowHeight / 2;
		} else { // arrow is placed at the bottom right
			yArrowBottom = graphicsContainerHeight;

			yArrowTop = yArrowBottom - arrowHeight;
			yArrowMiddle = (yArrowTop + yArrowBottom) / 2;
		}

		g.setColor(Color.BLUE);

		g.fillPolygon(new double[] { xStartArrowLine, xArrowTip, xStartArrowLine },
				new double[] { yArrowTop, yArrowMiddle, yArrowBottom }, 3);

		dragAndDropIcon.setRect(xStartArrowLine, yArrowTop, arrowWidth, arrowHeight);

	}

	// isFullScreen() is overiden is JSME
	public boolean isFullScreen() {
		return this.isFullScreen;
	}

	/**
	 * Draw the icon for toggling between normal and fullscreen
	 * 
	 * @param g
	 * @param graphicsContainerWidth
	 * @param graphicsContainerHeight
	 * @param iconScale
	 * @param expand
	 */
	void drawFullScreenIcon(PreciseGraphicsAWT g, double iconScale, Icon rightIcon) {

		boolean expand = !isFullScreen();

		// the icon is needed for event handling
		if (this.fullScreenIcon == null) {
			this.fullScreenIcon = new Icon(g);
		} else {
			this.fullScreenIcon.pg = g;
		}

		double margin = this.ioMargin * iconScale;
		double iconHeight = this.ioArrowWidth * iconScale; // same height as the DnD icon

		// the icon will placed at the bottom right
		double rightX = g.getWidth();
		double graphicsContainerHeight = g.getHeight();
		if (rightIcon != null) {
			rightX = rightIcon.x;// put the icon to left side of the DnD icon if present
			iconHeight = rightIcon.height; // same height as the DnD icon
			// move further to the left of the DnD icon
			rightX -= 2 * margin;
		}

		// icon will look like a monitor display with 16:9 ratio
		double rectangleWidth = iconHeight * 16 / 9;

		double startSize = 1.0;
		double endSize = 0.3;
		double startColor = 0;
		double endColor = 1.0;
		int steps = 20;
		boolean firstLoop = true;

		// create a gradient blue to white (or vice versa) by stacking rectangles of
		// decreasing sizes
		for (double relativeSize = startSize; relativeSize >= endSize; relativeSize -= (startSize - endSize) / steps) {
			float c = (float) ((startSize - relativeSize) * (endColor - startColor) / (startSize - endSize));

			// reverse the icon color scheme when the applet is in full screen mode
			if (!expand) {
				c = (float) endColor - c;
			}
			Color color = new Color(c, c, 1.0f);
			g.setColor(color);

			double h = iconHeight * relativeSize;
			double w = h / iconHeight * rectangleWidth;
			double x = rightX - rectangleWidth + (rectangleWidth - w) / 2;
			double y;
			if (!this.isDepict()) { // non depict mode: the icon is Y centered in the middle of the info bar
				y = graphicsContainerHeight / 2 - h / 2;
			} else {
				y = graphicsContainerHeight - iconHeight / 2 - h / 2;
			}
			g.fillRect(x, y, w, h);

			if (firstLoop) {
				// save the position of the icon on the graphics - will be used for event
				// handling
				firstLoop = false;
				fullScreenIcon.setRect(x, y, w, h); // for event handling
			}

		}

	}

	// --------------------------------------------------------------------------
	void squareText(PreciseGraphicsAWT g, double xstart, double ystart, String text) {

		// Smaller font is needed to display NEW and 123

		// g.setFont(menuCellFontSmaller);
		// int hSmall = menuCellFontSmallerMet.getBoxUppercaseHeight(); // vyska fontu
		// int w = menuCellFontSmallerMet.stringWidth(text);

		FontMetrics fm = menuCellFontMet;
		int w = fm.stringWidth(text);

		// Smaller font is needed to display NEW and 123
		// If the text is too wide for the cell, then use a smaller font
		if (w >= menuCellSize - 1) {
			int size = fm.getFont().getSize();
			// TODO: font cache does not work here
			// decrease font size until the text fits in the cell
			while (w >= menuCellSize - 1 && size > 1) {
				size--;
				Font smallerFont = new Font(fm.getFont().getName(), fm.getFont().getStyle(), size);
				fm = getFontMetrics(smallerFont);
				w = fm.stringWidth(text);
				g.setFont(smallerFont);

			}
		} else {
			g.setFont(menuCellFont);
		}
		double h = JMEUtil.stringHeight(fm); // vyska fontu

		g.drawString(text, xstart + (menuCellSize - w) / 2, ystart + (menuCellSize - h) / 2 + h);

	}

	// --------------------------------------------------------------------------
	void squareTextBold(PreciseGraphicsAWT g, double xstart, double ystart, Color col, String text) {
		// Used for the atom symbols on the left side menu
		double h = JMEUtil.stringHeight(menuCellFontBoldMet); // vyska fontu
		double w = menuCellFontBoldMet.stringWidth(text);
		g.setFont(menuCellFontBold);
		g.setColor(col);
//		if (bwMode)
//			g.setColor(Color.black);
		g.drawString(text, xstart + (menuCellSize - w) / 2, ystart + (menuCellSize - h) / 2 + h);
		// poor man's BOLD
		// g.drawString(text,xstart+(sd-w)/2+1,ystart+(sd-h)/2+h);
	}

	// --------------------------------------------------------------------------
	void drawRingIcon(PreciseGraphicsAWT g, double xstart, double d, int n) {
		double m = menuCellSize / 4; // margin
		boolean ph = false;
		double xp[] = new double[9];
		double yp[] = new double[9]; // polygon coordinates
		double xcenter = xstart + menuCellSize / 2;
		double ycenter = d + menuCellSize / 2;
		double rc = menuCellSize / 2 - m / 2;
		if (n == 1) {
			n = 6;
			ph = true;
		}
		for (int i = 0; i <= n; i++) {
			double uhol = Math.PI * 2. / n * (i - .5);
			xp[i] = xcenter + rc * Math.sin(uhol);
			yp[i] = ycenter + rc * Math.cos(uhol);
		}
		g.drawPolygon(xp, yp, n + 1);
		if (ph) { // double bonds in Ph icon
			for (int i = 0; i <= n; i++) {
				double uhol = Math.PI * 2. / n * (i - .5);
				xp[i] = xcenter + (rc - 3) * Math.sin(uhol);
				yp[i] = ycenter + (rc - 3) * Math.cos(uhol);
			}
			g.drawLine(xp[0], yp[0], xp[1], yp[1]);
			g.drawLine(xp[2], yp[2], xp[3], yp[3]);
			g.drawLine(xp[4], yp[4], xp[5], yp[5]);
		}
	}

	// ----------------------------------------------------------------------------

	void clearInfo() {
		info(customDefaultInfoText);
	}

	protected void info(String text) {
		if (text == null)
			text = customDefaultInfoText;
		mustReDrawInfo = true;
		if (infoText != text && text != "")
			this.log("info: " + text);
		infoText = text;
	}

	// ----------------------------------------------------------------------------
	// Will do an immediate repaint
	public void showInfo(String text) {

		info(text);
		repaint();
	}

	public void setCustomDefaultInfoText(String text) {
		showInfo(text);
		customDefaultInfoText = text;
	}

	/**
	 * select one of the menu action without having to click on the menu
	 * 
	 * @param action
	 */
	public void setAction(int action) {
		this.action = action;
	}

	/**
	 * BB
	 * 
	 * Find out which button-action matches the mouse coordinates
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	public int determineMenuAction(int x, int y, boolean ignoreDisabledActions) {
		int action = 0;

		// convert the x,y event coordinate to the menu scale
		x = (int) Math.round((double) x / this.menuScale);
		y = (int) Math.round((double) y / this.menuScale);

		if (x < leftMenuWidth(1.0) || y < topMenuHeight(1.0)) { // --- inside the menu area

			int xbutton = 0;
			for (int i = 1; i <= TOP_MENU_NUMBER_OF_CELLS; i++)
				if (x < i * (menuCellSize + menuCellBorder())) {
					xbutton = i;
					break;
				}
			int ybutton = 0;
			for (int i = 1; i <= LEFT_MENU_NUMBER_OF_CELLS + 2; i++)
				if (y < i * (menuCellSize + menuCellBorder())) {
					ybutton = i;
					break;
				}
			if (xbutton > 0 && ybutton > 0) {
				action = ybutton * 100 + xbutton;
			}
		}

		// TODO: filter out all actions that are disabled
		if (ignoreDisabledActions) {
			switch (action) {
			case ACTION_REACP:
				if (!options.reaction)
					action = 0;
				break;
			case ACTION_FG:
				if (!options.fgMenuOption)
					action = 0;
				break;

			case ACTION_MARK:
				if (options.starNothing) {
					action = 0;
				}
				break;
			}

		}
		return action;
	}

	@Override
	public void mouseWheelMoved(MouseWheelEvent e) {
		double newScale;

		if (!options.allowZooming)
			return;

		double notches = e.getPreciseWheelRotation() * mouseWheelFactor;
		if (notches == 0)
			return;

//		String message;
//		String newline = "\n";
//		if (notches < 0) {
//			message = "Mouse wheel moved UP " + -notches + " notch(es)" + newline;
//		} else {
//			message = "Mouse wheel moved DOWN " + notches + " notch(es)" + newline;
//		}
//		if (e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL) {
//			message += "    Scroll type: WHEEL_UNIT_SCROLL" + newline;
//			message += "    Scroll amount: " + e.getScrollAmount() + " unit increments per notch" + newline;
//			message += "    Units to scroll: " + e.getUnitsToScroll() + " unit increments" + newline;
//			message += "    Vertical unit increment: " + " pixels" + newline;
//		} else { // scroll type == MouseWheelEvent.WHEEL_BLOCK_SCROLL
//			message += "    Scroll type: WHEEL_BLOCK_SCROLL" + newline;
//			message += "    Vertical block increment: " + " pixels" + newline;
//		}
		// System.out.println(message);

		notches *= -1; // to give the same zoom direction as googlemaps

		int x = e.getX();
		int y = e.getY();
		double sizeChange = (100.0 + 2 * notches) / 100;
		if (isInMolecularArea(x, y)) {
			newScale = this.molecularAreaScalePixelsPerCoord * sizeChange;

			System.out.println("JME wheeling " + notches + " " + this.molecularAreaScalePixelsPerCoord + " " + newScale
					+ " " + sizeChange);

			if ((newScale > this.molecularAreaScalePixelsPerCoord && newScale <= maxMolecularAreaScale) // size
																										// increased,
																										// but not too
					// much
					|| (newScale < this.molecularAreaScalePixelsPerCoord && newScale >= minmolecularAreaScale) // size
																												// decreased,
																												// but
			// not too much
			) {
				lastAction = LA_SCALE;

				if (options.reaction) {
					// do not move around object because the arrow will move out of center
					// and it is difficult to recenter all objects
					setMolecularAreaScale(newScale); // will call repaint()
				} else {
					// previous zoom method
					// center around the atom closes to the x,y position
					setMolecularAreaScale(newScale, x, y);
					repaint();
				}

			}

		} else {
			if (options.allowGUIzooming) {
				newScale = this.menuScale * sizeChange;
				if (newScale >= minMenuScale && newScale <= maxMenuScale) {
					setMenuScale(newScale); // setMenuScale will do a repaint
				}
			}
		}

	}

	public boolean isInMolecularArea(int x, int y) {
		if (isDepict()) {
			return true;
		}

		if (x < leftMenuWidth() || y < topMenuHeight() || y > (this.dimension.height - this.infoAreaHeight())
				|| x > (this.dimension.width - rightBorder())) {
			return false;
		}
		return true;
	}

	/**
	 * rescale around the the nearest molecule to the given position does not call
	 * repaint()!
	 * 
	 * @param scale
	 * @param x     (GUI coordinate)
	 * @param y
	 */
	// used by mouse wheel event in non reaction mode
	public void setMolecularAreaScale(double scale, int x, int y) {
		// should we limit scaling if one molecule becomes invisible?
		// if (!reaction) {
		// mol.center(0.1); //should move progressively to center
		// The center position varies with the scale !!!!!!! FIXME

		Box previousAreaSize = getMolecularAreaBoundingBoxCoordinate00();
		this.molecularAreaScalePixelsPerCoord = scale;
		Box newAreaSize = getMolecularAreaBoundingBoxCoordinate00();

		TouchedMol touchedMol = new TouchedMol();
		// find the closest mol - use a large distance radius
		this.findMolAndAtomOrBondWithinRadius(x, y, Integer.MAX_VALUE, touchedMol);
		// this.findClosestMol(x, y)
		Point.Double shiftXY = this.findTranslationToCenterAfterScaling(touchedMol, previousAreaSize, newAreaSize);

		if (shiftXY != null) {
			this.graphicalObjectList().move(shiftXY);
		}
		// } else {
		// What to do?
		// reaction TODO
		// multipart
		// }
		this.setMustRedrawMolecularArea(true);

	}

	// don't use this in reaction mode because the arrow
//	protected void moveAllMolecules(double x, double y) {
//		moleculePartsList.moveXY(x, y);

//	}

//	protected void moveAllMolecules(Point.Double shiftXY) {
//		moveAllMolecules(shiftXY.x, shiftXY.y);

//	}

	/**
	 * Compute the translation X,Y needed for the molecule to stay centered after
	 * scaling
	 * 
	 * @param atomIndex
	 * @param previousAreaSize
	 * @param newAreaSize
	 * @return
	 */
	public Point.Double findTranslationToCenterAfterScaling(TouchedMol closestTouchedMol, Box previousAreaSize,
			Box newAreaSize) {
		Point.Double result = new Point.Double();

		JMEmol closestMolecule = closestTouchedMol.mol;
		if (closestMolecule == null || closestMolecule.nAtoms() == 0) {
			return result;
		}
		assert previousAreaSize.width > 0;
		assert previousAreaSize.height > 0;

		double x;
		double y;
		if (closestTouchedMol.atomIndex > 0) {
			x = closestMolecule.atoms[closestTouchedMol.atomIndex].x;
			y = closestMolecule.atoms[closestTouchedMol.atomIndex].y;
		} else {
			// closestMolecule.findBondCenters();
			x = closestMolecule.bonds[closestTouchedMol.bondIndex].bondCenterX;
			y = closestMolecule.bonds[closestTouchedMol.bondIndex].bondCenterY;

		}

		double newX = x / previousAreaSize.width * newAreaSize.width;
		double newY = y / previousAreaSize.height * newAreaSize.height;

		double shiftX = newX - x;
		double shiftY = newY - y;

		result.setLocation(shiftX, shiftY);

		return result;

	}

	/**
	 * Invoked when a mouse button has been pressed on a component.
	 */
//	@Override
//	public void mousePressed(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//
//	}

	/**
	 * Invoked when the mouse button has been clicked (pressed and released) on a
	 * component.
	 */
//	@Override
//	public void mouseClicked(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//
//	}

	/**
	 * Invoked when a mouse button has been released on a component.
	 */
//	@Override
//	public void mouseReleased(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	/**
	 * Invoked when the mouse enters a component.
	 */
//	@Override
//	public void mouseEntered(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	/**
	 * Invoked when the mouse exits a component.
	 */
//	@Override
//	public void mouseExited(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	protected boolean canDoAtomOrBondAction(int action) {
		return (!isDepict() || (isDepict() && action == ACTION_MARK));
	}

	// ----------------------------------------------------------------------------
//	@Override
	public boolean mouseDown(MouseEvent e, int x, int y) {
		// 02.06 niektotre return true zmenene na false (aby events aj v mipc)

		// this.mouseDownWasUsed = false;
		this.mouseDownWasUsed = false;
		// BB popup menu for copy&paste
		if (options.contextMenuEnabledOption && this.handleCopyPasteJPopupMenu(e, x, y)) {
			this.mouseDownWasUsed = true;
			// FIXME
			movePossible = false; // to avoid bug is my JSapplet lib with popup menu disabled, the mouseUp event
									// is not registered and a mouseDrag event is generated
			return true; // event has been consumed
		}

//Dec 2016: allow mol to move 
//		if (depict && !(this.canHandleBondClickedCallBack() || this.canHandleBondClickedCallBack() || depictActionEnabled))
//			//return true; //no action is performed in depict mode
//			return false; //no action is performed in depict mode - BB changed March 2013

		// the return value of this method
		// set to true if the event was consumed and does not need to be propagated
		boolean eventNotUsed = false;

		// experiment: to ease switching to the applet for copy paste with the system
		// clipboard
		boolean eventUsed = true;
		// boolean eventUsed = !isSystemClipBoardSupportedByBrowser();
		boolean returnStatus = eventUsed; // 2206

		// BB
		// this.isContextMenu = this.isEventContextMenu(e); //will be used in the
		// addRing() method to decide if a spiro ring should be added

		xold = x;// used later in mouseDrag
		// yold = y - (2 * (int)menuCellSize + menuCellBorder());
		yold = y; // used later in mouseDrag

		// log("mouseDown(): xold=" + xold + " yold=" + yold);

		clearInfo();
		// int x = e.getX(); int y = e.getY();
		this.mouseShift = e.isShiftDown(); // because of numbering

		movePossible = false;

		if (!isDepict() && (x < leftMenuWidth() || y < topMenuHeight())) { // --- menu pressed
			int action = this.determineMenuAction(x, y, true);

			// Code written by PE
			// Should this be moved to menuAction(action)?
			// empty buttons not considered
			if (action == ACTION_SPIRO) {
				spiroAdding = true;
				info("Next ring will be added as spiro");
				repaint();
				this.mouseDownWasUsed = true;
				return eventUsed;
			}

			// Code written by BB
			// Should this be moved to menuAction(action)?
			if (action == ACTION_MOVE_AT) {
				if (options.showAtomMoveJButton) {
					info("Move one atom");
					repaint();
				} else {
					this.mouseDownWasUsed = true;
					return eventUsed;
				}

			}

			// BB: xbutton handling
			if (!options.xButton && action == ACTION_AN_X) {
				return eventNotUsed;
			}

			if (!options.query && action == ACTION_QRY)
				return eventNotUsed;
			if (!options.stereo && action == ACTION_STEREO)
				return eventNotUsed;
			if (!options.multipart && action == ACTION_NEW)
				return eventNotUsed;
			if (!(this.params.number || options.autonumber) && action == ACTION_MARK)
				return eventNotUsed;
			if (!options.reaction && action == ACTION_REACP)
				return eventNotUsed;
			// if(action == ACTION_EMPTY_CELL){
			// return eventNotUsed;
			// }

			returnStatus = menuAction(action); // has its own paint() call
		}

		else if (!isDepict() && (y > dimension.height - infoAreaHeight())) { // --- info area clicked
			return eventNotUsed;
		}

		else { // --- mouse click in the drawing area
				// ---------------------------
			activeGraphicalObject = findClosestGraphicalObject(xold, yold);
//			if(m>0) {
//				actualMoleculePartIndex = m;
//				mol = moleculeParts[m];
//			} else {
//				actualMoleculePartIndex = 0;
//				
//			}
			// OKK

			// March 2016
			// the closest mol becomes the active one - needed for table to move one of the
			// fragments
			// int m = findClosestMol(x,y);
			activeMol = findClosestMol(xold, yold);

			if (activeGraphicalObject == reactionArrow) {
				activeMol.touchedAtom = 0; // probably not needed
				activeMol.touchedBond = 0;

				// movePossible = true;
				// return true;
			}

			// June 2015
			if (this.canHandleAtomClickedCallBack()) {
				if (activeMol.touchedAtom > 0) { // touchedAtom means mouse over?

					this.handleAtomClickedCallBack(activeMolIndex(), activeMol.touchedAtom); // not sure that
																								// actualMoleculePartIndex
																								// is set correctly in
																								// case of a multi
																								// structure
					if (isDepict() && !options.depictActionEnabled) {
						return true;
					}
				}

				if (activeMol.touchedBond > 0) {
					this.handleBondClickedCallBack(activeMolIndex(), activeMol.touchedBond); // not sure that
																								// actualMoleculePartIndex
																								// is set correctly in
																								// case of a multi
																								// structure
					if (isDepict() && !options.depictActionEnabled) {
						return true;
					}

				}
			}

			movePossible = true;
			// x -= menuCellSize; //menuCellSize is 0 in depict mode
			// y -= 2 * menuCellSize + menuCellBorder();
			// y -= topMenuHeight();

			// atom clicked

			if (activeMol.touchedAtom > 0 && canDoAtomOrBondAction(action)) {
				lastTouchedMol.mol = activeMol;
				if (action == ACTION_DELETE) {
					this.actionDeleteTouchedAtomOrBond();
//					mol.preSave();
//					mol.deleteAtom(mol.touchedAtom);
//					this.recordAtomEventAndPostSave(DEL_ATOM2);
//
//					mol.touchedAtom = 0;

				} else if (action == ACTION_DELGROUP) {
					return true; // do nothing
				} else if (action == ACTION_CHARGE) {
					if (activeMol.changeCharge(activeMol.touchedAtom, 0))
						this.recordAtomEvent(CHARGE_ATOM0);
//this is never called from the JME gui since it has only a toggle button
//				} else if (action == ACTION_CHARGE_PLUS) {
//					if(mol.changeCharge(mol.touchedAtom, 1))
//						this.recordAtomEventAndPostSave(CHARGE_ATOM_PLUS);
//				} else if (action == ACTION_CHARGE_MINUS) {
//					if(mol.changeCharge(mol.touchedAtom, -1))
//						this.recordAtomEventAndPostSave(CHARGE_ATOM_MINUS);
				} else if (action == ACTION_BOND_SINGLE || action == ACTION_BOND_DOUBLE || action == ACTION_BOND_TRIPLE
						|| action == ACTION_STEREO || action == ACTION_CHAIN) {
					lastAction = LA_BOND; // in addBond may be set to 0
					activeMol.addBond();
					activeMol.touched_org = activeMol.touchedAtom;

					if (action == ACTION_CHAIN) {
						activeMol.nchain = 1; // pre CHAIN rubberbanding
						activeMol.chain[1] = activeMol.natoms;
						activeMol.chain[0] = activeMol.touchedAtom;
						activeMol.touchedBond = 0; // 2005.02
						// mol.avoidTouch(1);
						// this.recordBondEvent(ADD_BOND); //postpone until finished
						this.willPostSave(false); // for the CHAIN, save the state at mouseUp event

					} else {
						this.recordBondEvent(ADD_BOND);

					}

				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					lastAction = LA_RING; // in addRing may be set to 0
					activeMol.addRing();
					this.recordAtomEvent(ADD_RING);

				} else if (action == ACTION_TEMPLATE) {
					// mol.addTemplate(template);
					lastAction = LA_GROUP;
					this.recordAtomEvent(ADD_TEMPLATE);

				} else if (action >= ACTION_GROUP_MIN && action < ACTION_GROUP_MAX) {

					activeMol.addGroup(false);
					this.recordAtomEvent(ADD_GROUP);

					lastAction = LA_GROUP; // may be set to 0
				} else if (action == ACTION_QRY) { // setting atom as query atom
					if (queryBox.isBondQuery())
						return true;
					activeMol.setAtom(activeMol.touchedAtom, queryBox.getSmarts());
					activeMol.isQuery = true; // 2013.09

					this.recordAtomEvent(ADD_ATOM_QUERY);

				} else if (action == ACTION_MARK) { // either color marking or atom map

					boolean marked;

					if (!options.pseudoMark && !options.starNothing) {

						int newMap = -1;
						if (markFromKeyboardInput) {
							newMap = keyboradInputMark;
							resetExtendAtomMark = true;
							markFromKeyboardInput = false;
							clearInfo(); // reset the info message generated by updateMark()

							if (this.params.mark) {
								this.activateMarkerColor(newMap);
							}
						}

						if (params.mark) {

							marked = activeMol.markAtom(newMap > 0 ? newMap : activeMarkerColorIndex // set the color
																										// index from a
																										// keyboard
																										// shortcut
							);
						} else {
							if (newMap == -1) {
								if (options.reaction) {
									int reactionRole = activeMol.getReactionRole();
									newMap = findMaxAtomMapOfMoleculeParts(moleculePartsList, reactionRole);
								} else {
									newMap = activeMol.geMaxAtomMap();
								}
								// allow same atom map for several atoms of the group is shift is pressed
								if (!this.mouseShift || newMap == 0) // BB june 2020: if shift is on and new mapping:
																		// must be 1
									newMap++;
							}

							marked = activeMol.markAtom(newMap);

						}

					} else {
						marked = true; // equivalent to an atom click event but can be tracked using MARK_ATOM
					}
					if (marked)
						this.recordAtomEvent(MARK_ATOM);
					else
						// happens if newMap == -1
						this.recordAtomEvent(UN_MARK_ATOM);

					if (options.pseudoMark) {
						this.willPostSave(false); // do not put on the undo stack
					}

				} else if (action == ACTION_MOVE_AT) {
					// System.out.println("Move atom started");
				} else if (action > 300) { // atoms
					if (active_an != activeMol.an(activeMol.touchedAtom) || active_an == AN_X) {
						activeMol.AN(activeMol.touchedAtom, active_an);
						activeMol.Q(activeMol.touchedAtom, 0); // resetne naboj
						// mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
						activeMol.atoms[activeMol.touchedAtom].iso = 0; // BB: reset isotop
						// mol.nh[mol.touchedAtom] = 0;
						activeMol.atoms[activeMol.touchedAtom].nh = 0;

						// special processing pre AN_X, osetrene, ze moze byt aj
						// ""
						if (active_an == AN_X) {
							String xx = MultiBox.atomicSymbol.getText();
							if (xx.length() < 1)
								xx = "X";
							activeMol.setAtom(activeMol.touchedAtom, xx);

						}
						// this.recordAtomEvent(SET_ATOM + active_an); // active_an is an arbitrary
						// number, should be
						// changed to the string of the atom type
						this.recordAtomEvent(SET_ATOM);
					}
				} else { // BB: nothing happened to the clicked atom
					returnStatus = eventNotUsed;

				}
				// BB:moved
				// status = false; // 2206

			}

			// bond clicked
			else if (activeMol.touchedBond > 0 && canDoAtomOrBondAction(action)) {
				lastTouchedMol.mol = activeMol;
				if (action == ACTION_DELETE) {
					this.actionDeleteTouchedAtomOrBond(); // record the event as well

				} else if (action == ACTION_DELGROUP) {
					activeMol.deleteAtomGroup();
					activeMol.cleanAfterChanged(options.polarnitro);
					this.recordBondEvent(DEL_BOND_GROUP);
					activeMol.touchedBond = 0;
				} else if (action == ACTION_STEREO) {
					activeMol.stereoBond(activeMol.touchedBond);
					this.recordBondEvent(SET_BOND_STEREO);
				} else if (action == ACTION_BOND_SINGLE || action == ACTION_CHAIN) { // ACTION_CHAIN should be removed?
					if (activeMol.bonds[activeMol.touchedBond].bondType == JMEmol.SINGLE
							&& activeMol.bonds[activeMol.touchedBond].stereo == 0) {// nie pre
						// stereo
						activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.DOUBLE;
						this.recordBondEvent(SET_BOND_DOUBLE);

					} else {
						activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.SINGLE;
						activeMol.bonds[activeMol.touchedBond].stereo = 0; // BB: remove stereo flag - bug fix - was
																			// creating a
						// problem with undo/redo

						this.recordBondEvent(SET_BOND_SINGLE);

					}
					activeMol.bonds[activeMol.touchedBond].stereo = 0; // zrusi stereo
				} else if (action == ACTION_BOND_DOUBLE) {
					boolean differentBondOrder = activeMol.bonds[activeMol.touchedBond].bondType != JMEmol.DOUBLE;

					activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.DOUBLE;

					if (!differentBondOrder) {
						activeMol.bonds[activeMol.touchedBond].toggleNormalCrossedDoubleBond();
					} else {
						activeMol.bonds[activeMol.touchedBond].stereo = 0; // zrusi stereo
					}
					activeMol.cleanAfterChanged(options.polarnitro);

					this.recordBondEvent(SET_BOND_DOUBLE);

				} else if (action == ACTION_BOND_TRIPLE) {
					activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.TRIPLE;
					activeMol.bonds[activeMol.touchedBond].stereo = 0; // zrusi stereo
					activeMol.cleanAfterChanged(options.polarnitro);

					this.recordBondEvent(SET_BOND_TRIPLE);

				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					// fusing ring to bond
					lastAction = LA_RING; // in addRing may be set to 0
					activeMol.addRing();
					this.recordBondEvent(ADD_RING_BOND);
					activeMol.cleanAfterChanged(options.polarnitro); // FIXME: add to addRing

				} else if (action == ACTION_QRY) {
					if (!queryBox.isBondQuery())
						return true;
					String bondQuery = queryBox.getSmarts();
					activeMol.bonds[activeMol.touchedBond].bondType = JMEmol.QUERY;
					// mol.stereob[mol.touchedBond] = JMEmol.QUERY;
					activeMol.bonds[activeMol.touchedBond].btag = bondQuery;
					/*
					 * if ("~".equals(bondQuery)) mol.stereob[mol.touchedBond] = JMEmol.QB_ANY; if
					 * (":".equals(bondQuery)) mol.stereob[mol.touchedBond] = JMEmol.QB_AROMATIC; if
					 * ("@".equals(bondQuery)) mol.stereob[mol.touchedBond] = JMEmol.QB_RING; if
					 * ("!@".equals(bondQuery)) mol.stereob[mol.touchedBond] = JMEmol.QB_NONRING;
					 */

					this.recordBondEvent(SET_QUERY_BOND);

				} else if (action == ACTION_MARK) {
					// info("Only atoms may be marked !");
					// March 2014

					{
						boolean marked;

						// some duplicated code logic with marking of atom
						if (!options.pseudoMark) {
							marked = activeMol.markBond(activeMarkerColorIndex);
						} else {
							marked = true;
						}
						// some duplicated code logic with marking of atom
						if (marked)
							this.recordBondEvent(MARK_BOND);
						else
							this.recordBondEvent(UN_MARK_BOND);

						if (options.pseudoMark) {
							this.willPostSave(false); // do not put on the undo stack
						}

					}

				} else {
					// no bond were changed
					returnStatus = false; // 2206
				}
				// BB removed and replaced by above
				// status = false; // 2206
			}

			// free space clicked - new molecule
			// creating new molecule only on start or when ACTION_NEW is on
			else if ((moleculePartsList.isReallyEmpty() || newMolecule == true) && !isDepict()) {
				if (action <= ACTION_STEREO)
					return eventNotUsed;

				moleculePartsList.removeEmptyMolecules(); // Jan 2019
				// numberofMoleculeParts++;
				// actualMoleculePartIndex = numberofMoleculeParts;
				activeMol = new JMEmol(this, this.params);
				moleculePartsList.add(activeMol);

				lastTouchedMol.mol = activeMol;

//				if(newMolecule == true) {
//					newMolecule = false; //will be done in draw
//					this.mustReDrawTopMenu = true;
//				}

				smol = null; // kvoli undo

				// BB: TODO : lot of duplicated code
				if (action >= ACTION_BOND_SINGLE && action <= ACTION_BOND_TRIPLE || action == ACTION_CHAIN) {
					activeMol.createAtom();
					activeMol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(activeMol, 1, x, y);
					activeMol.touchedAtom = 1;
					activeMol.touched_org = 1; // needed for checkNewBond();
					lastAction = LA_BOND;
					activeMol.addBond();
					// orienting chain
					if (action == ACTION_CHAIN) {
//						mol.x[2] = x + JMEmol.RBOND * .866;
//						mol.y[2] = y - JMEmol.RBOND * .5;
//						XY(mol, 2, x + JMEmol.RBOND * .866, 
//								 y - JMEmol.RBOND * .5);
						activeMol.XY(2, // TODO : JMEMol sould handle this
								screenToDrawingX(x) + JMEmol.RBOND * .866, screenToDrawingY(y) - JMEmol.RBOND * .5);

						activeMol.chain[0] = 1;
						activeMol.chain[1] = 2;
						activeMol.nchain = 1;
						this.recordBondEvent(ADD_CHAIN);

					} else {
						this.recordBondEvent(ADD_BOND);

					}
				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					activeMol.xorg = screenToDrawingX(x);
					activeMol.yorg = screenToDrawingY(y);
					lastAction = LA_RING;
					activeMol.addRing();
					this.recordAfterStructureChangedEvent(ADD_RING);
				} else if (action > 300) { // adding 1st atom
					activeMol.createAtom();
					activeMol.AN(1, active_an);
					activeMol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(activeMol, 1, x, y);
					activeMol.touchedAtom = 1;
					if (active_an == AN_X) {
						String xx = MultiBox.atomicSymbol.getText();
						if (xx.length() < 1)
							xx = "X";
						activeMol.setAtom(1, xx);
					}
					this.recordAtomEvent(ADD_ATOM);

				} else if (action == ACTION_TEMPLATE) {
					readMolecule(template);
					this.recordAfterStructureChangedEvent(ADD_TEMPLATE);

				} else if (action >= ACTION_GROUP_MIN && action < ACTION_GROUP_MAX) {
					// adding first atom (to which group will be connected)
					activeMol.createAtom();
					activeMol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(activeMol, 1, x, y);

					activeMol.touchedAtom = 1;
					// adding group
					activeMol.addGroup(true);
					this.recordAfterStructureChangedEvent(ADD_GROUP);
				} else {
					System.err.println("error -report fall through bug !");
				}
				// BB changed
				// returnStatus = eventNotUsed; // 2206

			} else { // BB nothing happened
				returnStatus = false;
			}

			if (returnStatus != eventNotUsed) {// BB: if nothing has changed - there is no need to repaint
				// BB
				// mol.cleanAfterChanged(); //FIXME: sacveState already called this method

				this.setMustRedrawMolecularArea(true);
				// any showInfo() call will be taken into account
				this.repaint();

//				this.mustReDrawLeftMenu = false;
//				this.mustReDrawTopMenu = false;
//				
//				this.setMustRedrawMolecular(true);
//				//don't touch info - automatic
//				repaint(); // ciastocne zbytocne repaintuje, ale asi nechat tak
			}
		}

		this.mouseDownWasUsed = returnStatus;

		return returnStatus;
	}

	// ----------------------------------------------------------------------------
	public boolean mouseUp(MouseEvent e, int x, int y) {

		boolean eventUsed = false;

		// DUPLICATED CODE WITH BELOW
//		if (depict && !depictActionEnabled) {
//			if(toggleDepictEdit == true) {
//				this.options("nodepict");
//				this.handleAfterAfterDepictEditToggleEvent();
//			}
//			return true;
//			
//		}

		if (this.movingAtom) {
			// end of atom move
			this.movingAtom = false;
			// mol.findBondCenters(); //BB: aton has been moved, thus the bond centers must
			// be updated
			// this.recordAtomEvent(MOVE_ATOM); //this is not a structure change
			this.willPostSave(true);
			eventUsed = true;
		}

		// BB
		this.mustReDrawInfo = false;
		lastRotation = 0; // needed?

		// LA_GROUP netreba, tam nemoze byt atom overlap
		if (lastAction == LA_BOND) {
			if (action == ACTION_CHAIN) {
				activeMol.checkChain();
				this.recordBondEvent(ADD_CHAIN);
				this.willPostSave(true);

			} else {

				// find out if the last touched mol is the same
				// findMolAndAtomOrBondInDrawingAreaFromEventXY(x, y, this.newTouchedMol);
				// System.out.println("@@@mouseUp: newTouchedMol: " + newTouchedMol.molIndex + "
				// " + newTouchedMol.atomIndex + " x:" + x + " y: " + y);
				// System.out.println("@@@mouseUp: numberofMoleculeParts: " +
				// numberofMoleculeParts + " actualMoleculePartIndex: " +
				// actualMoleculePartIndex);
				// System.out.println("@@@mouseUp: lastTouchedMol: " + lastTouchedMol.molIndex +
				// " " + lastTouchedMol.atomIndex + " x:" + x + " y: " + y);

				// lastTouchedMol was set during mouseDrag
				if (lastTouchedMol.mol != null && activeMol != lastTouchedMol.mol) {
					activeMol = mergeMols(lastTouchedMol, activeMol);				
				} else {
					// as before - no merge
					// checkBond create or increase bond order
					activeMol.checkBond(); // standard bond check
				}
			}
			// don in createAndAddNewBond
			// mol.findBondCenters(); // zbytocne vela, ale tu kvoli r.b.

			// BB :
			if (this.bondRubberBanding) {
				// a bond had been added and the state saved
				// to keep only the bond stabilized after the rubberbanding,
				// remove the previous state

				if (action != ACTION_CHAIN) {
					this.molChangeManager.removeLast();
					this.recordBondEvent(ADD_BOND);
				}

				this.bondRubberBanding = false;
			}
			eventUsed = true;
		} else if (lastAction == LA_MOVE) {
			// !!! mal by sem este prist check na touched
			// mol.findBondCenters();

			// BB
			this.willPostSave(true);
			eventUsed = true;

		}
		if (lastAction > 0) {

			// BB - this seems to be a duplcated of doMenu
			// mustRedrawNothing();
			// this.setMustRedrawMolecular(true);

			if (lastAction != LA_MOVE && lastAction != LA_ROTATE) {
				// mol.cleanAfterChanged();
				// nevola sa vzdy ked treba !!!!!
				// mol.cleanPolarBonds(); // nie je to privela action ??? nie az pri
			}
			if (lastAction == LA_MOVE && options.reaction) {
				// check if the reaction roles have changed
				// int parts[][] = getReactionParts();
				// if(reactionParts == null)
				// reactionParts = parts;
				// int changedPart =
				// findFirstMoleculeIndexWithDifferentReactionRole(reactionParts, parts);
				int changedPart = updateReactionRoles();
				changedPart++;
				if (changedPart != 0) {
					// send an update message
					this.recordMoleculePartEvent(CHANGE_REACTION_ROLE, changedPart);
				}
			}
			// canon
			// repaint(); // napr po zdvojeni vazby ju nakresli
			this.redrawMolecularAreaOnly();
			lastAction = 0;
			afterClear = false;
			eventUsed = true;
		}

		// BB: useful for touch devices to avoid showing the marked atom after edition
		if (isTouchSupported && (activeMol.touchedBond != 0 || activeMol.touchedAtom != 0)) {
			activeMol.touchedBond = 0;
			activeMol.touchedAtom = 0;
			this.redrawMolecularAreaOnly();
			eventUsed = true;

		}

		// mouse click on the full screen icon
		if (eventUsed == false && !this.mouseDownWasUsed && this.fullScreenIcon != null) {
			if (fullScreenIcon.contains(x, y)) {
				eventUsed = true;
				// Rectangle dim1 = this.getMolecularAreaSizeWithScalingForDepiction();
				toggleFullScreen();
				// mol.needRecentering = true;
				// Rectangle dim2 = this.getMolecularAreaSizeWithScalingForDepiction();
				// recenterMoleculesAfterMolecularAreaChange(dim1, dim2);
				// this.redrawMoleculartAreaOnly();

			}
		}

		// handle toggle depict/edit
		if (options.toggleDepictEdit && !this.mouseDownWasUsed && !eventUsed) {
			if (this.isDepict()) {
				this.options("nodepict"); // menu is ready and paintedafter this call
				// new Feb 2020
				this.centerAllMoleculesAsAgroup(this.graphicalObjectList(), dimension, menuScale,
						molecularAreaScalePixelsPerCoord);
				this.redrawMolecularAreaOnly();

			} else {
				this.options("depict");
			}
			this.handleAfterAfterDepictEditToggleEvent();
			eventUsed = true;
		}

		return eventUsed;
	}

	protected JMEmol mergeMols(final TouchedMol last, final JMEmol active) {
		// merge the current mol and the other mol

		
		active.deleteAtom(active.natoms);
		// remove the last atom because it will be replaced by the atoms of the new mol
		int atom1 = active.touched_org; // first atom of the new bond to be created
		int atom2 = last.atomIndex + active.natoms;// second atom of the new bond to be created

		assert atom1 != active.natoms + 1;

		JMEmol otherMol = last.mol;
		JMEmol merged = new JMEmol(this, new JMEmol[] { active, otherMol });
		merged.atoms[0] = new Atom(); // needed by rubberbanding()

		// bug: the user selected bond order is not taken into account
		merged.createAndAddNewBond(atom1, atom2);

		moleculePartsList.remove(otherMol);
		moleculePartsList.replace(active, merged);

		//
//		JMEmol[] newMoleculeParts = new JMEmol[moleculeParts.length];
//		for(int p = 0, newP = 0; p < moleculeParts.length; p++) {
//			if(moleculeParts[p] == activeMol) {
//				newMoleculeParts[newP++] = merged; //replace mol with merged
//			} else if (moleculeParts[p] == otherMol ) { //skip
//				continue;
//			} else {
//				newMoleculeParts[newP++] = moleculeParts[p];
//			}
//			
//		}
//		
//		moleculeParts = newMoleculeParts;
//		numberofMoleculeParts --;

		last.reset();
		return merged;
	}

	protected void willPostSave(boolean b) {
		this.saveCurrentState = b;

	}

//	protected void updateReactionParts() {
//		if (options.reaction)
//			reactionParts = getReactionParts();
//	}

//	/**
//	 * screen pixel to molecular drawing area coordinate
//	 * 
//	 * @param coord
//	 * @return
//	 */
//	@Deprecated
//	protected int scaleCoordinate_(int coord) {
//		double newCoord = scaleCoordinate_((double) coord);
//
//		return (int) Math.round(newCoord);
//	}
//
//	/**
//	 * screen coordinate to molecular drawing area coordinate
//	 * 
//	 * @param coord
//	 * @return
//	 */
//	@Deprecated
//	protected double scaleCoordinate_(double coord) {
//		if (this.scalingIsPerformedByGraphicsEngine) {
//			return coord / molecularAreaScalePixelsPerCoord;
//		}
//		return coord;
//	}

	protected double scaleScreenToDrawing(int pos) {
		return (double) pos / molecularAreaScalePixelsPerCoord;
	}

	protected int scaleDrawingToScreen(double coord) {
		return (int) Math.round(coord * molecularAreaScalePixelsPerCoord);
	}

	/**
	 * convert the applet screen position to the coordinate of the drawing area
	 * 
	 * @param pixelPosition
	 * @return
	 */
	// TODO: drawing should not revert the Y axis
	protected double screenToDrawingX(int appletPixelPositionX) {
		int x = appletPixelPositionX - leftMenuWidth();// leftMenuWidth() returns 0 in depict mode

		return scaleScreenToDrawing(x);
	}

	/**
	 * convert the applet screen position to the coordinate of the drawing area
	 * 
	 * @param pixelPosition
	 * @return
	 */
	protected double screenToDrawingY(int appletPixelPositionY) {
		int y = appletPixelPositionY - topMenuHeight(); // topMenuHeight() returns 0 in depict mode

		return scaleScreenToDrawing(y);
	}

	/**
	 * Convert a drawing x coordinate to the pixel coordinate
	 * 
	 * @param xCoord
	 * @return
	 */
	protected int drawingToScreenX(double xCoord) {
		int screenX = scaleDrawingToScreen(xCoord);

		screenX += leftMenuWidth(); // leftMenuWidth() returns 0 in depict mode

		return screenX;
	}

	/**
	 * Convert a drawing y coordinate to the pixel coordinate
	 * 
	 * @param x
	 * @return
	 */
	protected int drawingToScreenY(double yCoord) {
		int screenY = scaleDrawingToScreen(yCoord);

		screenY += topMenuHeight();// topMenuHeight() returns 0 in depict mode

		return screenY;
	}

//	/**
//	 * convert a the applet screen position to the coordinate of the drawing area
//	 * @param pixelPosition
//	 * @return
//	 */
//	protected double screenToDrawing(int appletPixelPositionX) {
//		
//		return (double)appletPixelPositionX*molecularAreaScale;
//	}

	// ----------------------------------------------------------------------------
	public boolean mouseDrag(MouseEvent e, int x, int y) {
		// public void mouseDragged(MouseEvent e) {

		if (!movePossible)
			return true;

		// BB popup menu for copy&paste
		boolean meta = e.isMetaDown(); // true if right mouse click
		if (meta) {
			return true;
		}

		// BB
		this.mustReDrawInfo = false;

		// ??? MS-Win toto volaju aj len pri MouseClick (handled here)
		// int x = e.getX()-sd; int y = e.getY()-sd*2;
		// x -= leftMenuWidth();
		// y -= topMenuHeight();
		double drawingAreaMoveX = scaleScreenToDrawing(x - xold);
		double drawingAreaMoveY = scaleScreenToDrawing(y - yold);
		// info("mouseDrag(): xold=" + xold + " yold=" + yold + " lastAction=" +
		// lastAction);
		// log("mouseDrag(): x=" + x + " y=" + y);

		double drawingAreaX = screenToDrawingX(x);
		double drawingAreaY = screenToDrawingY(y);

		if (lastAction == LA_RING || lastAction == LA_GROUP || lastAction == LA_FAILED) {
			return true;
		} else if (lastAction == LA_BOND) {
			// mol.rubberBanding(drawingAreaX, drawingAreaY);
			// info("mouseDrag(): lasaction = LA_BOND " + lastAction);

			// code copied and adapted from mol.rubberBanding
			// goal: to crerate bond between two different molecule parts
			boolean done = false;
			this.lastTouchedMol.mol.touchedAtom = 0;

			// to be used for adding a bond with another part
			// need to differentiate the temporary moving atom that was created during
			// mousedown
			// from the atom of another fragment because they can overlap
			// the temp atom is the last one
			activeMol.natoms--;
			findMolAndAtomOrBondInDrawingArea(x, y, this.newTouchedMol);
			activeMol.natoms++; // restore

			// System.out.println("@@@ mouseDrag: mol.natoms: " + mol.natoms);
			// System.out.println("@@@ mouseDrag: newTouchedMol: " + newTouchedMol.molIndex
			// + " " + newTouchedMol.atomIndex);

			if (this.newTouchedMol.mol != null && this.newTouchedMol.atomIndex > 0) {
				JMEmol touched_JMEmol = newTouchedMol.mol;
				touched_JMEmol.touchedAtom = this.newTouchedMol.atomIndex;

				if (touched_JMEmol != activeMol || this.newTouchedMol.atomIndex != activeMol.touched_org) { // make bond
																											// towards
					// existing atom
					activeMol.XY(activeMol.natoms, touched_JMEmol.x(newTouchedMol.atomIndex),
							touched_JMEmol.y(newTouchedMol.atomIndex)); // move the new atom to the coordinate of the
																		// closest touched atom "snap"
					// actually it does not move while it still close to the touched atom
					// System.out.println("SNAP otheratom");
					touched_JMEmol.touchedAtom = newTouchedMol.atomIndex;

					done = true;
					// lastTouchedMol will be used by mouseUp() to create the new bnond between the
					// two
					//
					this.lastTouchedMol.initMyselfWith(this.newTouchedMol);
				}
			}
			if (!done) {
				// perform the rubberbanding within the same mol - old code
				activeMol.rubberBanding(drawingAreaX, drawingAreaY);
			}
			this.bondRubberBanding = true; // BB
		}
		// BB
		else if (action == ACTION_MOVE_AT && activeMol.touchedAtom > 0) {
			if (this.movingAtom == false) {
				this.movingAtom = true;
			}
			// mol.atomRubberBanding(drawingAreaX, drawingAreaY);
			activeMol.XY(activeMol.touchedAtom, drawingAreaX, drawingAreaY);

		} else if (e.isShiftDown() || e.isMetaDown()) {
			// else if (e.isShiftDown() || e.isMetaDown()) {
			activeMol.rotate(drawingAreaMoveX);
			lastAction = LA_MOVE; // BB: should it be changed to LA_ROTATE?
			// info("Rotation: " + x ); //BB

		} else if (activeMol.touchedAtom == 0 && activeMol.touchedBond == 0) { // if no atom or bond are touched, then
																				// the touched
			// mol can be moved
			// Start molecue move only if the mousedrag event started within the drawing
			// area

			// avoid unwanted sudden large moves after a rotation on a touch device
			// if(lastAction != LA_MOVE) {
			// drawingAreaMoveX = drawingAreaMoveY=0;
			// }

			// Do not move the molecule if the dragging start is not within the drawing area
			if (!isOutsideDrawingArea(x, y)) {
				Rectangle2D.Double boundingBox = this.getMolecularAreaBoundingBoxCoordinate00();
				// activeMol.move(drawingAreaMoveX, drawingAreaMoveY, boundingBox);
				activeGraphicalObject.move(drawingAreaMoveX, drawingAreaMoveY, boundingBox);

				lastAction = LA_MOVE;
			}
		}

		// BB
		this.redrawMolecularAreaOnly();

		xold = x;
		yold = y;
		return true;
	}

//	protected boolean isMoleculeCompletelyOutsideDrawingArea(JMEmol mol) {
//
//		if (mol.nAtoms() == 0)
//			return false;
//
//		for (Atom atom : mol.atoms) {
//
//			if (!isOutsideDrawingArea(drawingToScreenX(atom.x), drawingToScreenY(atom.y)))
//				return false;
//		}
//
//		return true;
//	}
//
	/**
	 * for mouse actions
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	protected boolean isOutsideDrawingArea(int x, int y) {
		x -= leftMenuWidth();
		y -= topMenuHeight();
		return (x < 0 || y < 0 || y > this.molecularAreaPixelHeight || x > this.molecularAreaPixelWidth);

	}

	/**
	 * Return the molecule index of the molecule that is the closest to the provided
	 * screen position
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	JMEmol findClosestMol(int x, int y) {
		JMEmol found = null;

		if (moleculePartsList.size() == 1)
			return moleculePartsList.first();

		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double min = Double.MAX_VALUE;

		for (JMEmol mol : moleculePartsList) {
			double d = mol.closestDistance(xCoord, yCoord);

			if (d < min) {
				min = d;
				found = mol;
			}

		}
		return found;
	}

	Graphical2DObject findClosestGraphicalObject(int x, int y) {
		Graphical2DObject found = null;
		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double min = Double.MAX_VALUE;

		if (options.reaction) {
			min = this.reactionArrow.closestDistance(xCoord, yCoord);
			found = this.reactionArrow;
		}
		for (JMEmol mol : moleculePartsList) {
			double d = mol.closestDistance(xCoord, yCoord);

			if (d < min) {
				min = d;
				found = mol;
			}
		}
		return found;
	}

	/**
	 * for mouse actions
	 * 
	 * @param x
	 * @param y
	 * @param result
	 */
	void findMolAndAtomOrBondInDrawingArea(int x, int y, TouchedMol result) {

		if (this.isOutsideDrawingArea(x, y)) {
			result.reset();
			// System.out.println("isOutsideDrawingArea x=" + x + " y=" + y);
			return;
		}
		findMolAndAtomOrBondWithinRadius(x, y, getHumanInteractionTouchRadius(), result);
	}

	/**
	 * find the closest touched atom or bond within the given radius. Store the
	 * results in the argumet result
	 * 
	 * @param x
	 * @param y
	 * @param result
	 */
	void findMolAndAtomOrBondWithinRadius(int x, int y, int radius, TouchedMol result) {

		result.reset();

		// x = scaleCoordinate(x);
		// y = scaleCoordinate(y);
		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double minDistance = radius;

		for (JMEmol eachMol : this.moleculePartsList) {
			DoubleWrapper minDistanceFound = new DoubleWrapper(radius);
			int a_or_b = eachMol.testAtomAndBondTouch(xCoord, yCoord, this.ignoreAtoms(), this.ignoreBonds(),
					minDistanceFound);

			if (minDistanceFound.value < minDistance) {
				minDistance = minDistanceFound.value;
				result.reset();
				result.mol = eachMol;
				result.distance = minDistance;
				assert a_or_b != 0;
				;
				if (a_or_b > 0) {
					result.atomIndex = a_or_b;
				} else {
					result.bondIndex = a_or_b * -1;

				}
			}
		}

	}

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	/**
	 * BB Compute the radius for human interaction around an atom or a bond. This
	 * radius should be larger for touch device than for pointer based system.
	 * 
	 * The drawback of a larger radius is that one has to be more precise when
	 * moving the structure.
	 * 
	 * @return a radius
	 */
	static final int TOUCH_LIMIT = 50;

	protected int getHumanInteractionTouchRadius() {
		if (isTouchSupported) {
			return TOUCH_LIMIT + 300; // determined by trial and error on an iPad 4 by BB
		}
		return TOUCH_LIMIT + 120;
	}

	// ----------------------------------------------------------------------------
//	@Override
	public boolean mouseMove(MouseEvent e, int x, int y) {

		// is depictActionEnabled test needed here? if depictActionEnabled is used only
		// for the toggle edit/depict, then no
		if (isDepict() && !(this.canHandleAtomHighLightCallBack() || this.canHandleBondHighLightCallBack()
				|| options.depictActionEnabled)) // notifyAtomHighLightJSfunction: Luc P request to show atom highlight
													// in
			// depict mode
			return true;
		// int x = e.getX()-sd; int y = e.getY()-sd*2;

		// BB popup menu for copy&paste has been opened
		// boolean meta = e.metaDown() ; //true if right mouse click
		if (this.isEventContextMenu(e)) {
			// do nothing to avoid the molecule moving while popup menu is displayed
			return true;
		}

		boolean repaintFlag = false;
		mustRedrawNothing(); // shoInfo() will change that

		int action = this.determineMenuAction(x, y, true);

		if (this.isActionEnabled(action)) {
			if (action != this.mouseWasOverAction) {
				// kind of new event
				repaintFlag |= this.handleMouseLeaveActionMenu(this.mouseWasOverAction);
				repaintFlag |= this.handleMouseEnterActionMenu(action);
				this.mouseWasOverAction = action;
			}
		}

		// BB
		// this.mustReDrawInfo = false; //whenpaste operation fails, a mouse move can
		// still occur, and there will be no error message.

		// System.out.println("X:Y: " + x +" " + y + " " + menuCellSize);

		// BB: bug found by Oli: with structure underneath the menu region: highlight
		// must dissapear

		// boolean outsideDrawingArea = !depict && ( x < menuCellSize || y <
		// topMenuHeight() || y > dimension.height - menuCellSize - 1 || x >=
		// dimension.width-1);

		// x -= leftMenuWidth();
		// y -= topMenuHeight();

		// don't create any new object during a mouse move to
		// avoid stressing the garbage colector
		// BB: bug found by Oli: with structure underneath the menu region: highlight
		// must dissapear
		findMolAndAtomOrBondInDrawingArea(x, y, newTouchedMol);

		// Don't allow bond touching in ACTION_MOVE_AT
		// if(action == ACTION_MOVE_AT && newTouchedMol.bondIndex > 0) {
		// newTouchedMol.bondIndex = 0;
		// }
		// System.out.println(newTouchedMol.molIndex + " " + newTouchedMol.atomIndex + "
		// " + newTouchedMol.bondIndex);

		if (!newTouchedMol.equals(lastTouchedMol) && (newTouchedMol.isTouched() || lastTouchedMol.isTouched())) {

			// necekuje, ci sa nedotyka 2 molekul naraz, ale to by bolo asi zbytocne

			// int m = lastTouchedMol.molIndex;
			JMEmol tm = lastTouchedMol.mol;

			if (tm != null) {
				tm.touchedAtom = 0;
				tm.touchedBond = 0;
			}

			tm = newTouchedMol.mol;
			if (tm != null) {
				tm.touchedAtom = newTouchedMol.atomIndex;
				tm.touchedBond = newTouchedMol.bondIndex;
				// touched mol becomes the mol for edition
				activeMol = tm;
				// this must be changed!!!!!
//				if (m != actualMoleculePartIndex ) {
//					actualMoleculePartIndex = m;
//					activeMol = moleculeParts[actualMoleculePartIndex];
//				}
			}

			repaintFlag = true;
			// June 2018: fire the leave event first
			if (newTouchedMol.atomIndex == 0) {
				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);
				notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
			} else if (newTouchedMol.bondIndex == 0) {
				notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);
			} else {
				// should never happen
				notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);

			}

			// BB changed: notify only if it is an atom highlight

			// Design issue: notifyAtomHighLightJSfunction does not provide the molecule
			// part number
			// presently notifyAtomHighLightJSfunction handle the minimal change reporting
			// if(newTouchedMol.atomIndex != lastTouchedMol.atomIndex || m !=
			// lastTouchedMol.molIndex) {
			// notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);
			// }
			// if(newTouchedMol.bondIndex != lastTouchedMol.bondIndex|| m !=
			// lastTouchedMol.molIndex) {
			// notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
			// }

//			if(newTouchedMol.atomIndex > 0) {
//				if(lastTouchedMol.bondIndex >0) {
//					notifyBondHighLightJSfunction(0);//used to notify that the cursor has moved away from the bond
//				}
//				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex); //used by LP to highlight NMR spectrum part
//								
//			} else if (newTouchedMol.bondIndex>0) { //bond was touched
//				if(lastTouchedMol.atomIndex>0) {
//					notifyAtomHighLightJSfunction(0);//used to notify that the cursor has moved away from the atom
//				}
//				notifyBondHighLightJSfunction(newTouchedMol.bondIndex); //used by LP to highlight NMR spectrum part
//				
//			}

			// System.out.println(actualMoleculePartIndex + " "+ m );

			lastTouchedMol.initMyselfWith(newTouchedMol);
			assert lastTouchedMol.equals(newTouchedMol);

		}
//		else {
//			if(this.atomWasTouched) { //NEW 06 2015!!!!!
//				notifyAtomHighLightJSfunction(0); //used to notify that the cursor has moved away from the atom
//				this.atomWasTouched = false;
//			}
//
//			if(this.bondWasTouched) { //NEW 06 2015!!!!!
//				notifyBondHighLightJSfunction(0); //used to notify that the cursor has moved away from the bond
//				this.bondWasTouched = false;
//			}

//			if (moleculeParts[m].touchedAtom > 0 || moleculeParts[m].touchedBond > 0) {
//				moleculeParts[m].touchedAtom = 0;
//				moleculeParts[m].touchedBond = 0;
//				repaintFlag = true;
//			}
//		}

		if (repaintFlag) {
			// vynuluje pripadny predosly touch
//			for (int m = actualMoleculePartIndex + 1; m <= numberofMoleculeParts; m++) {
//				moleculeParts[m].touchedAtom = 0;
//				moleculeParts[m].touchedBond = 0;
//			}
			// BB
			setMustRedrawMolecularArea(true);
			repaint();

		}
		// added after
		// if (depict && this.notifyStructuralChangeJSfunction == null)
		// above was changed
//		if (depict) {
//			return true;
//		}

		return repaintFlag;
	}

	/*
	 * * to be redefined in JS subclass (JSME)
	 * 
	 */
	public boolean isMacintosh() {
		return false;
	}

//	@Override
	public boolean keyDown(KeyEvent e, int key) {

		// BB
		this.mustReDrawInfo = false;
		// this.log("Key code: " + key);

		// handling numeric keypad
		if (key >= 96 && key <= 105) { // number
			key = key - 96 + 48;
		}

		// public void keyPressed(KeyEvent e) {
		if (isDepict() && !options.depictActionEnabled)
			return false;
		clearInfo();

		boolean shift = e.getModifiers() == Event.SHIFT_MASK;
		boolean alt = e.getModifiers() == Event.ALT_MASK;
		// On Mac: meta is down for system copy
		boolean meta = isMacintosh() ? e.isMetaDown() : e.isControlDown();

		int pressed = 0;

		// custom shortcuts
		if (this.menuXShortcuts != null && this.menuXShortcuts.length() > 0) {
			char shortcut = (char) key;
			if (!shift) {
				shortcut = Character.toLowerCase(shortcut);
			} else {
				shortcut = Character.toUpperCase(shortcut);
			}
			if (this.menuXShortcuts.indexOf(shortcut) >= 0) {
				// duplicated code
				MultiBox.atomicSymbol.setText(Character.toString(shortcut));
				options.xButton = true;
				info(MultiBox.atomicSymbol.getText());
				pressed = ACTION_AN_X;
				active_an = AN_X;
				return menuAction(pressed);
			}
		}

		// key shortcuts
		// treba to disabled, ked input do elementu;
		// if (elementInput) return false;
		// int key = e.getKeyChar();

		// System.err.println("key " + key + " " + alt);
		switch (key) {
		// case 'e': case 'E': JMEmol.TESTDRAW = !JMEmol.TESTDRAW; break;
		case 'c':
		case 'C':

			// NOT USED IN JS !!!!!
			if (meta) { // try a Ctrl C for copy. does not work in Java due to java security policy
				this.copyFileToClipboard();
				break;
			}
			pressed = ACTION_AN_C;

			break;

		// May 2019: shortcut for '*'
		case '*':
		case 106: // keyboard numeric pad
		case 'g':
		case 'G':
			MultiBox.atomicSymbol.setText("*");
			options.xButton = true;

		case 'x':
		case 'X':
			if (meta) { //
				this.cutSelectedMoleculeForSystemClipBoard();
				break;
			}
			if (options.xButton) {
				info(MultiBox.atomicSymbol.getText());
				pressed = ACTION_AN_X;
				active_an = AN_X;
			}
			break;

		case 'v':
		case 'V':

			// paste with Ctrl V
			// does not work in Java in a browser due to java security policy
			if (meta && options.paste) {
				this.pasteMolFileFromClipboard();
				break;
			}
			break;

		case 'n':
		case 'N':
			pressed = ACTION_AN_N;
			break;
		case 'o':
		case 'O':
			pressed = ACTION_AN_O;
			break;
		case 's':
		case 'S':
			pressed = ACTION_AN_S;
			break;
		case 'p':
		case 'P':
			pressed = ACTION_AN_P;
			break;
		case 'f':
		case 'F':
			pressed = ACTION_AN_F;
			break;
		case 'l':
		case 'L':
			pressed = ACTION_AN_CL;
			break;
		case 'b':
		case 'B':
			pressed = ACTION_AN_BR;
			break;
		case 'i':
		case 'I':
			pressed = ACTION_AN_I;
			break;
		case 'h':
		case 'H':
			info("H");
			pressed = ACTION_AN_H;
			break;
		case 'r':
		case 'R':
			info("-R");
			pressed = ACTION_AN_R;
			break; // if (options.rButton) ?
		case 't':
		case 'T':
			if (action == ACTION_AN_F) {
				pressed = ACTION_GROUP_CF3;
				info("-CF3");
			} else if (action == ACTION_AN_CL) {
				pressed = ACTION_GROUP_CCL3;
				info("-CCl3");
			} else {
				pressed = ACTION_GROUP_TBU;
				info("-tBu"); // TODO: consistent naming with the FG's
			}
			break;
		case 'y':
		case 'Y':
			if (meta) { // BB - does not work in Java
				pressed = ACTION_REDO;
			} else {
				pressed = ACTION_GROUP_NITRO;
				info("-NO2");
			}
			break;
		case 'z':
		case 'Z':
			if (meta) { // BB - does not work in Java
				pressed = ACTION_UNDO;
			} else {
				pressed = ACTION_GROUP_SULFO;
				info("-SO3H");
			}

			break;

		case 'a':
		case 'A':
			pressed = ACTION_GROUP_COO;
			info("-COOH");
			break;
		case 'e':
		case 'E':
			pressed = ACTION_GROUP_CC;
			info("-C#CH");
			break;
		case 'u':
		case 'U':
			pressed = ACTION_UNDO;
			break;
		case 'q':
		case 'Q':
			pressed = ACTION_GROUP_CYANO;
			info("-C#N");
			break;
		// case 'g': // used for testing
		// return true;
		case 27: // esc
			pressed = ACTION_BOND_SINGLE;
			break;
		case '-':
			// check here that an was changed and then cancell this -X ???
			if (action == ACTION_AN_F) {
				pressed = ACTION_GROUP_CF;
				info("-F");
			} else if (action == ACTION_AN_CL) {
				pressed = ACTION_GROUP_CL;
				info("-Cl");
			} else if (action == ACTION_AN_BR) {
				pressed = ACTION_GROUP_CB;
				info("-Br");
			} else if (action == ACTION_AN_I) {
				pressed = ACTION_GROUP_CI;
				info("-I");
			} else if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_CO;
				info("-OH");
			} else if (action == ACTION_AN_N) {
				pressed = ACTION_GROUP_CN;
				info("-NH2");
			} else
				pressed = ACTION_BOND_SINGLE;
			break;
		// BB merged '=' and '
		/*
		 * case '=':'
		 * 
		 * if (action == ACTION_AN_O) { pressed = ACTION_GROUP_dO; info("=O"); } else
		 * pressed = ACTION_BOND_DOUBLE; break;
		 */
		// new BB shortcut
		case '+':
		case 107: // numeric keypad
			// toggle charge - same as clicking on the +/- icon
			// note that there is already a shortcut for '-'
			pressed = ACTION_CHARGE;
			break;
		case '#':
			pressed = ACTION_BOND_TRIPLE;
			break;
		case '0':
			if (action == ACTION_MARK)
				updateMark(0);
			else {
				if (!alt) {
					pressed = ACTION_RING_FURANE;
					info("-Furyl");
				} else {
					pressed = ACTION_RING_3FURYL;
					info("-3-Furyl");
				}
			}
			break;
		case '1':
			if (action == ACTION_MARK)
				updateMark(1);
			else
				pressed = ACTION_RING_PH;
			break;
		case '2':
		case '=':
			if (key == '2' && action == ACTION_MARK)
				updateMark(2);
			// BB added October 2015 : create a double bond
			// duplacade code with = TODO:
			else if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_dO;
				info("=O");
			} else
				pressed = ACTION_BOND_DOUBLE;
			break;
		case '3':
			if (action == ACTION_MARK)
				updateMark(3);
			else
				pressed = ACTION_RING_3;
			break;
		case '4':
			if (action == ACTION_MARK)
				updateMark(4);
			else
				pressed = ACTION_RING_4;
			break;
		case '5':
			if (action == ACTION_MARK)
				updateMark(5);
			else
				pressed = ACTION_RING_5;
			break;
		case '6':
			if (action == ACTION_MARK)
				updateMark(6);
			else
				pressed = ACTION_RING_6;
			break;
		case '7':
			if (action == ACTION_MARK)
				updateMark(7);
			else
				pressed = ACTION_RING_7;
			break;
		case '8':
			if (action == ACTION_MARK)
				updateMark(8);
			else
				pressed = ACTION_RING_8;
			break;
		case '9':
			if (action == ACTION_MARK)
				updateMark(9);
			else {
				info("9 ring");
				pressed = ACTION_RING_9;
			}
			break;
		case 'd':
		case 'D':
		case 8:
		case 127:
			pressed = ACTION_DELETE;
			break;
		case 32:
			pressed = ACTION_CHAIN;
			break; // SPACE
		case 'm': // BB
		case 'M': // BB
		case Event.PGUP:
			pressed = ACTION_PGUP;
			break; // PgUp

		case 'w': // BB
		case 'W': // BB
		case Event.PGDN:
			pressed = ACTION_PGDN;
			break; // PgDn
		// default: System.out.println("key "+key); break;

		case Event.HOME:
			pressed = ACTION_HOME;
			break;
		case Event.END:
			pressed = ACTION_END;
			break;

		}

		// handling R #
		int digit_key = key + 1 - '1';
		// if number between 0 and 9 was entered
		if (digit_key >= 0 && digit_key <= 9 && activeMol.touchedAtom > 0) {
			int an = activeMol.an(activeMol.touchedAtom);
			if (an >= AN_R && an <= AN_R_LAST) {
				pressed = ACTION_AN_R + digit_key;
			}
		}
		if (pressed != 0)
			return menuAction(pressed); // will redraw if needed, will change this.action

		return false; // did not use the event: will be forwarded to other apps
	}

	// --------------------------------------------------------------------------
	// called when number key clicked and marking active
	// updates actual mark which will be used for marking
	protected void updateMark(int n) {
		// need to know when new number and when combination of 2 presses i.e.
		// 12
		if (options.autonumber) {
			if (n == 0) {
				keyboradInputMark = 0;
				showInfo("click marked atom to delete map");
				markFromKeyboardInput = true;

				// repaint(); // updates status line

				return; // BB June 2020: moved from level below, otherwise atom mapping can not be used
						// from the keyboard
			}

		}

		// markUsed true: accumulate the mark number, which allows to get number >= 10
		if (resetExtendAtomMark) {
			keyboradInputMark = n;
			resetExtendAtomMark = false;
		} else {
			if (keyboradInputMark > -1 && keyboradInputMark < 100)
				keyboradInputMark = keyboradInputMark * 10 + n;
			else {
				keyboradInputMark = n; // mark cannot be > 999
				resetExtendAtomMark = false;

			}
		}

		String action_type = "map";
		String target = "atom";
		String reset_action = "delete map";

		if (this.params.mark) {
			reset_action = "remove background color";
			action_type = "color index";
			if (options.starAtomOnly) {

			} else if (options.starBondOnly) {
				target = "bond";
			} else {
				target = "atom or bond";
			}
			if (keyboradInputMark <= 0) {
				keyboradInputMark = 1; // reset to default color index
			}
		}

		if (keyboradInputMark == 0) {
			// keyboradInputMark = -1; //BUG? Novenber 2020
			keyboradInputMark = 0;
			showInfo("click marked " + target + " to " + reset_action);
		} else {
			if (this.params.mark) {
				this.activateMarkerColor(keyboradInputMark);
			}
			showInfo("Click " + target + " to set " + action_type + " to " + keyboradInputMark);

		}

		markFromKeyboardInput = true;
	}

	// --------------------------------------------------------------------------
	// BB used for copy paste and setSubtituents
	@Override
	public void actionPerformed(ActionEvent evt) {
		mustRedrawNothing();

		String cmd = evt.getActionCommand();
		
		if (subclassHandleMenuAction(cmd)) {
			return;
		}

		ColorInfo colorInfo = this.colorManager.getColorInfoOfColorHash(cmd);
		if (colorInfo != null) {
			int colorIndex = colorInfo.index;
			this.activateMarkerColor(colorIndex);
			this.showInfo(colorInfo.name);

			return;
		}

		if (cmd.equals(CopyPasteAction.SMILES.toString())) {
			clipBoardManager.setClipboardContents(this.smiles());
		} else if (cmd.equals(CopyPasteAction.MOL.toString())) {
			this.copyMolFileToClipboard(false);
		} else if (cmd.equals(CopyPasteAction.MOL_V3000.toString())) {
			this.copyMolFileToClipboard(true);

		} else if (cmd.equals(CopyPasteAction.JME.toString())) {
			this.copyJmeStringToClipboard();

		} else if (cmd.equals(CopyPasteAction.PASTE.toString())) {
			if (options.paste)
				this.pasteMolFileFromClipboard();
		} else if (cmd.equals(CopyPasteAction.INCHI.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI);
		} else if (cmd.equals(CopyPasteAction.INCHI_KEY.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI_KEY);
		} else if (cmd.equals(CopyPasteAction.INCHI_AUXINFO.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.INCHI_AUXINFO);
		} else if (cmd.equals(CopyPasteAction.OCLCODE.toString())) {
			this.copyOclCodetoClipboard();
		}

		else if (cmd.equals(CopyPasteAction.SEARCH_INCHI_KEY.toString())) {
			this.searchChemicalStructureUsingInchiKey();
		}

		else if (cmd.equals(CopyPasteAction.SVG.toString())) {
			this.copySVGToClipboard();
		}

		else if (isJavaScript && cmd.equals(CopyPasteAction.RAW_STRING_GRAPHIC.toString())) {
			this.copyRawGraphicToClipboard();
		}

		// BB : rotation coming from the touch handling
		else if (cmd.equals("rotation")) { // used by touch devices
			if (lastAction != LA_ROTATE) {
				lastRotation = 0;
			}
			long rotation = evt.getWhen(); // I had to store the rotation somewhere
			rotation *= -1; // feels more natural
			long deltaRotation = rotation - lastRotation;

			if (Math.abs(deltaRotation) < 10) {
				activeMol.rotate((int) deltaRotation);
			}
			// mustRedrawNothing();
			setMustRedrawMolecularArea(true);
			// info("Rotation: " + rotation + " deltaRotation " + deltaRotation);

			// repaint(); //done at the end
			lastAction = LA_ROTATE;
			lastRotation = rotation;

		} else if (cmd == unSetChiralFlagAction || cmd == setChiralFlagAction) {
			boolean changed = this.activeMol.setChiralFlag(cmd == setChiralFlagAction);
			if (changed) {
				int n = this.moleculePartsList.size();
				String additional = "";
				if (n > 1) {
					int index = this.moleculePartsList.indexOf(this.activeMol);
					index++;
					additional = " for molecule " + index;

				}

				if (this.activeMol.chiralFlag) {
					info("Chiral flag is set" + additional);
				} else {
					info("No Chiral flag" + additional);

				}
				// this.postSave(); //idea: recordMoleculePartEvent could be used to perform the
				// postSave, + giving a name to saved state
				// that could be used for displaying in info() when mouse over undo button
				this.recordMoleculePartEvent(CHANGE_CHIRAL, this.activeMolIndex());
				setMustRedrawMolecularArea(true); // not really needed but the event will be written out only when
													// redrawing the molecular area
			}

		} else if (cmd == autoAtomMapMoleculeAction) {

			// find the highest atom map
			int max = this.findMaxAtomMapAmongAllMolecules();
			boolean changed = false;
			for (int at = 1; at <= activeMol.natoms; at++) {
				Atom atom = activeMol.atoms[at];
				if (!atom.hasBeenMapped()) {
					max++;
					atom.setMap(max);
					changed = true;
				}
			}

			if (changed) {
				setMustRedrawMolecularArea(true);
				this.recordMoleculePartEvent(CHANGE_MANY_ATOM_MAP, this.activeMolIndex());
			}
		} else if (cmd == deleteAtomMapMoleculeAction) {
			if ((setMustRedrawMolecularArea(activeMol.resetAtomMaps()))) {
				this.recordMoleculePartEvent(DELETE_ATOM_MAPS, this.activeMolIndex());
			}

		} else if (cmd == bondSetCoordinationAction || cmd == bondUnSetCoordinationAction) {
			setMustRedrawMolecularArea(true);
			int bondIndex = this.inspectorEvent.bondIndex;
			assert (bondIndex > 0);
			Boolean isCoordination = this.inspectorEvent.mol.getBond(bondIndex).toggleCoordination().isCoordination();
			this.recordBondEvent(isCoordination ? SET_BOND_COORDINATION : UNSET_BOND_COORDINATION);
			// TODO: the event name could be the same as the action

		} else if (cmd == deleteHydrogensMoleculeAction) {

			// From the user interaction, thus it is not using the settings from options()
			HydrogenHandlingParameters options = new MoleculeHandlingParameters().hydrogenHandlingParameters;
			options.removeHs = true;
			options.removeOnlyCHs = false;

			setMustRedrawMolecularArea(activeMol.deleteHydrogens(options)); // mustReDrawMolecularArea is flase if there
																			// are no deleted hydrogens

			if (mustReDrawMolecularArea) {
				this.recordMoleculePartEvent(DELETE_HYDROGENS, this.activeMolIndex());
			}
		} else if (cmd == compute2DcoordinatesMoleculeAction) {

			// compute2Dcoordinates needs openchemlib
			JMEUtil.runAsync(new JSME_RunAsyncCallback() {

				@Override
				public void onSuccess() {
					compute2DSuccess();
				}

			});

		} else if (cmd.equals("scale100")) { // used by touch devices
			// BB : rotation coming from the touch handling
			// problem: unwanted interaction with the rotation
			// Chemdoodle rotation & scaling works nice
			if (false && this.moleculePartsList.size() == 1) {
				long scale100 = evt.getWhen(); // I had to store the scale somewhere

				setMustRedrawMolecularArea(true);

				double delta = 0.05;
				if (scale100 != 100) {
					if (scale100 < 100) {
						delta *= -1;
					}
					this.molecularAreaScalePixelsPerCoord = scale100 / 100.0;
					// Todo : compute center of mol
					// activeMol.scaling();
					activeMol.center(); // TODO : translate back to previous center
					// info("Scale " + this.depictScale );
					lastAction = LA_SCALE;

				}
			}
		} else if (cmd.equals("end_gesture")) {
			this.willPostSave(true);
		} else {
			this.setSubstituent(cmd);
		}

		if (mustReDrawMolecularArea || mustReDrawInfo) {
			repaint();
		}

	}

	protected boolean subclassHandleMenuAction(String cmd) {
		return false;
	}

	protected void compute2DSuccess() {
		if (activeMol.nAtoms() > 1) {
			int index = activeMolIndex();

			double centerX = activeMol.centerX();
			double centerY = activeMol.centerY();

			// newActiveMol may or may not be activeMol
			JMEmol newActiveMol = moleculePartsList.compute2Dcoordinates(activeMol);

			if (newActiveMol != null) {
				double dx = centerX - newActiveMol.centerX();
				double dy = centerY - newActiveMol.centerY();
				newActiveMol.moveXY(dx, dy);

				moleculePartsList.set(index, newActiveMol);
				recordMoleculePartEvent(COMPUTE_2D, index);
				setMustRedrawMolecularArea(true);
				info("2D coordinates provided by OpenChemLib");
				repaint();
			} else {
				info("2D coordinates computation failed");
			}
		}
	}

	/**
	 * nEW tbc, SHOULD ENCAPSULATED THE RUN asYn WHEN NEEDED tO BE USED IN ACTIO
	 * MENU AND DIRECT COPY AND DIRECT CUT AND d&d
	 * 
	 * @param format
	 * @param callBack
	 */
	public void exportFile(SupportedFileFormat format, final RunWhenDataReadyCallback callBack) {

		switch (format) {
		case INCHI:
			break;
		case INCHI_AUXINFO:
			break;
		case INCHI_KEY:
			break;
		case JME:
			break;
		case MOL:
			break;
		case MOL_V3000:
			break;
		case OCLCODE:
			break;
		case RAW_STRING_GRAPHIC:
			break;
		case SMILES:
			break;
		case SVG:
			break;
		default:
			break;

		}
	}

	// not used?
	public void copyFileToClipboard() {
		switch (this.clipboardFormat) {
		case MOL:
			this.copyMolFileToClipboard(false);
			break;

		case MOL_V3000:
			this.copyMolFileToClipboard(true);
			break;

		case JME:
			this.copyJmeStringToClipboard();
			break;
		case SVG:
			this.copySVGToClipboard();
			break;
		case RAW_STRING_GRAPHIC:
			this.copyRawGraphicToClipboard();
			break;
		case SMILES:

			clipBoardManager.setClipboardContents(this.smiles());
			break;
		case INCHI:
			this.copyInchiToClipboard(CopyPasteAction.INCHI);
			break;
		case INCHI_AUXINFO:
			this.copyInchiToClipboard(CopyPasteAction.INCHI_AUXINFO);
			break;
		case INCHI_KEY:
			this.copyInchiToClipboard(CopyPasteAction.INCHI_KEY);
			break;
		case OCLCODE:
			this.copyOclCodetoClipboard();
		default:
			clipBoardManager.setClipboardContents("incorrect or unsupported export format");
		}
	}

	/**
	 * Work for all upported file formats, even thos that require loading code
	 * dynamically, hence the callback argument
	 * 
	 * @param format
	 */
	public void generateOuttputFile(final RunWhenDataReadyCallback callBack) {
		this.generateOuttputFile(this.clipboardFormat, callBack);

	}

	/**
	 * Work for all upported file formats, even thos that require loading code
	 * dynamically, hence the callback argument
	 * 
	 * @param format
	 * @param callBack
	 */

	public void generateOuttputFile(SupportedFileFormat format, final RunWhenDataReadyCallback callBack) {

		String output = null;

		switch (format) {
		case MOL:
			output = this.molFile(false);
			break;

		case MOL_V3000:
			output = this.molFile(true);
			break;

		case JME:
			output = this.jmeFile();
			break;

		case SVG:
//			GWT.runAsync(new JSME_RunAsyncCallback() {
//
//				@Override
//				public void onSuccess() {
//					callBack.onSuccess(JME.this.getOclSVG());
//				}
//				
//			});
			break;

		case RAW_STRING_GRAPHIC:
			output = this.getMolecularAreaGraphicsString();
			break;
		case SMILES:
			output = this.smiles();
			break;

		case INCHI:
		case INCHI_AUXINFO:
		case INCHI_KEY:
		case INCHI_JSON:
			this.computeInchi(format, callBack);
			break;

		case OCLCODE:
			JMEUtil.runAsync(new JSME_RunAsyncCallback() {

				@Override
				public void onSuccess() {
					callBack.onSuccess(JME.this.getOclCode());
				}

			});
			break;

		default:
			Throwable error = new Throwable("incorrect or unsupported export format");
			callBack.onFailure(error);
		}

		if (output != null) {
			callBack.onSuccess(output);
		}
	}

	public void computeInchi(final SupportedFileFormat action, final RunWhenDataReadyCallback callBack) {

	}

	// BB
	// should use new gneral methodexportFile
	@Deprecated
	public void copyMolFileToClipboard(boolean isV3000) {
		clipBoardManager.setClipboardContents(this.molFile(isV3000));
	}

	// April 2020
	// should use new gneral methodexportFile

	public void copyJmeStringToClipboard() {
		clipBoardManager.setClipboardContents(this.jmeFile());
	}
	// BB
	// should use new gneral methodexportFile

	public void copyOclCodetoClipboard() {
		// use RunAsyncCallback to trigger a code split to download openchemlib
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				clipBoardManager.setClipboardContents(JME.this.getOclCode());
			}

		});

	}

	// should use new gneral methodexportFile

	public void copySVGToClipboard() {
		// use RunAsyncCallback to trigger a code split to download openchemlib
		JMEUtil.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				clipBoardManager.setClipboardContents(JME.this.getOclSVG());
			}

		});

	}

	// should use new gneral methodexportFile

	public void copyRawGraphicToClipboard() {
		String result = this.getMolecularAreaGraphicsString();
		if (result != null) {
			clipBoardManager.setClipboardContents(result);
		}
	}

	// should use new gneral methodexportFile

	public void copyInchiToClipboard(CopyPasteAction action) {
		// for subclasses
		// clipBoardManager.setClipboardContents(this.computeInchi(isKey));
	}

	public void searchChemicalStructureUsingInchiKey() { // for subclasses

	}

	//
	public void pasteMolFileFromClipboard() {
		// String molecule = clipBoardManager.getClipboardContents();
		// if(molecule != null) {
		// molecule = molecule.replace("\n", "|");
		// this.readMolFile(molecule);
		// }
		this.afterStructureChangeEvent.setOrigin_PASTE();

		// asynchronous action is needed for non IE browsers
		clipBoardManager.getAsyncClipboardContents(this.getPasteAction());

	}

	// used by drag and drop and system clipboard paste
	public void pasteDirect(String molString, boolean originIsDrop) {
		// if pasting is allowed
		if (!options.paste) {
			return;
		}
		if (molString != null && molString.length() > 0) {
			// OK if only DnD uses this function
			if (originIsDrop)
				this.afterStructureChangeEvent.setOrigin_DROP();
			else
				this.afterStructureChangeEvent.setOrigin_PASTE();

			this.getPasteAction().paste(molString);
		} else {
			this.showError("empty or null structure");
		}
	}

	protected PasteAction getPasteAction() {
		return this.createPasteActionInstanceIfNeeded();
	}

	protected PasteAction createPasteActionInstanceIfNeeded() {
		if (this.pasteAction == null) {
			this.pasteAction = new PasteAction() {

				@Override
				public void paste(String clipboardContent) {
					if (clipboardContent != null) {
						handleClipboardPasteAction(clipboardContent);
					}
				}

			};
		}
		return this.pasteAction;
	}

	protected void handleClipboardPasteAction(String clipboardContent) {

		// customized paste
		if (getPrePasteJSfunction() != null) {
			JSObject jsObject = JSObject.getWindow(JME.this);
			jsObject.call(getPrePasteJSfunction(), new String[] { clipboardContent });
			return;
		}

		/// customized paste only for JSME
		if (handleBeforePasteEvent(clipboardContent)) { // if the callback is set
			return;
		}
		pasteGenericInput(clipboardContent, true, new RunAsyncCallback() {

			@Override
			public void onFailure(Throwable reason) {
				// read_MOL_SDF_RXN has already handled the error
			}

			@Override
			public void onSuccess() {
				// callback to client
				JME.this.handleAfterPasteEvent(clipboardContent);

			}

		});
	}

	class StringWrapper {
		public String innnerString;
	};

	// TODO the input error handling has to be redesigned
	// test cases with invalid MOL
	final StringWrapper sdfPastedMessage = new StringWrapper();

	public final static String JME_EVENT_STRUCTURE_MODIFIED = "JME_StructureModifiedEvent";
	public final static String JME_EVENT_PASTE = "JME_PasteEvent";
	private static final String JME_EVENT_DEPICT_EDIT_TOGGLE = "JME_DepictEditToggleEvent";
	private static final String JME_EVENT_ATOM_CLICKED = "JME_AtomClickedEvent";
	private static final String JME_EVENT_BOND_CLICKED = "JME_BondClickedEvent";
	private static final String JME_EVENT_ATOM_HIGHLIGHT = "JME_AtomHighlightEvent";
	private static final String JME_EVENT_BOND_HIGHLIGHT = "JME_BondHighlightEvent";

	public void pasteGenericInput(String chemicalString, boolean recordEvent,
			final RunAsyncCallback sucessAndFailureHandle) {

		sdfPastedMessage.innnerString = "";
		this.afterStructureChangeEvent.setOrigin_API();

		// todo: handle RDF
		int countSDF = sdfStack.addEntries(chemicalString);
		if (countSDF > 0) {
			// sdfPastedMessage = ". " + countSDF + " structures in stack .Use Page Up/Down
			// for SDF access";
			sdfPastedMessage.innnerString = " Use Page Up/Down for SDF access (" + countSDF + ")";

			// emit an event that says that a SDF mutiple structure was added sept 2019
			this.afterStructureChangeEvent.setAction(READ_MULTI_SDF);
			notifyStructuralChange("paste");

		}

		RunAsyncCallback localSucessAndFailureHandle = new RunAsyncCallback() {

			@Override
			public void onFailure(Throwable reason) {
				info("ERROR: " + reason.getMessage()); // the readMolFile() method has already generated a message
				JME.this.alert(JME.this.infoText); // this.infotext has be set on thye line above
				JME.this.reset();
				JME.this.repaint();

			}

			@Override
			public void onSuccess() {
				info("Structure pasted. " + sdfPastedMessage.innnerString);
				// JME.this.postSave(); //add it to the undo/redo manager
				JME.this.setMustRedrawMolecularArea(true);
				JME.this.repaint();

				sucessAndFailureHandle.onSuccess();
			}
		};
		try {
			handleReadGenericInput(chemicalString, localSucessAndFailureHandle, false, recordEvent); // do not
																										// repaint
																										// because
			// localSucessAndFailureHandle
			// does it
		} catch (Exception e) {
			localSucessAndFailureHandle.onFailure(e);
		}
	}
	
	@Deprecated
	public String cutSelectedMoleculeForSystemClipBoard() {
		if (this.activeMol.natoms == 0) {
			return "";
		}

		this.activeMol.forceUniColor(Color.RED); // need a delay for that??
		String s = activeMol.createMolFile("");
		this.redrawMolecularAreaOnly();
		clear();

		this.redrawMolecularAreaOnly();

		return s;
	}

	public void cutSelectedMoleculeForSystemClipBoard(RunWhenDataReadyCallback callBack) {
		if (this.activeMol.natoms == 0) {
			return;
		}

		// this.activeMol.forceUniColor(Color.RED); // need a delay for that?? no
		// visible effect
		this.generateOuttputFile(callBack);
		// this.redrawMolecularAreaOnly();
		clear();

		this.redrawMolecularAreaOnly();
	}

	/**
	 * This code is incompleted it is needed for showing mouse over info (see
	 * handleMouseEnterActionMenu())
	 * 
	 * @param action
	 * @return
	 */
	protected boolean isActionEnabled(int selectedAction) {

		// treba, aby nekreslilo neaktivne buttons
		if (selectedAction == ACTION_AN_R && !options.rButton)
			return false;

		// if (square == ACTION_END && !isStandAloneApplication)
		// return;
		if (selectedAction == ACTION_QRY && !options.query)
			return false;
		if (selectedAction == ACTION_STEREO && !options.stereo)
			return false;
		if (selectedAction == ACTION_NEW && !options.multipart)
			return false;

		// WHEN marker option is set than, number is set but not automumber
		if (selectedAction == ACTION_MARK && !(this.params.number || options.autonumber))
			return false;
		if (selectedAction == ACTION_REACP && !options.reaction)
			return false;

		// new code
		switch (selectedAction) {
		case ACTION_MARK:
			return (!options.starNothing && params.mark) || this.params.number || options.autonumber;
		case ACTION_MOVE_AT:
			return options.showAtomMoveJButton;
		case ACTION_REACP:
			return options.reaction;

		}
		return true;
	}

	/**
	 * mouse cursor move over the button square: special action
	 * 
	 * @param action
	 * @return
	 */
	boolean handleMouseEnterActionMenu(int action) {

		// idea: show info for each button
		// each actoon used here must also be decalred in handleMouseLeaveActionMenu()
		switch (action) {
		case ACTION_NEW:
			this.info("Add new molecule");
			return true;

		case ACTION_MOVE_AT:
			this.info("Move atom");
			return true;
		case ACTION_SPIRO:
			this.info("Activate spiro ring");
			return true;
		case ACTION_STEREO:
			this.info("Stereo bond single or double");
			return true;
		case ACTION_CHAIN:
			this.info("Create alkyl chain");
			return true;
		case ACTION_DELETE:
			this.info("Delete atom or bond");
			return true;

		case ACTION_DELGROUP:
			this.info("Click bond to delete smallest fragment");
			return true;

		case ACTION_SMI:
			this.info("Show SMILES or SMIRKS");
			return true;

		case ACTION_QRY:
			this.info("Open query box for SMARTS");
			return true;

		case ACTION_AN_X:
			this.info("Select other atom type");
			return true;

		case ACTION_AN_R:
			this.info("Select R group");
			return true;

		}
		// if there is no atoms, then there is nothing to highlight
		if (this.activeMol == null || this.activeMol.natoms == 0) {
			return false;
		}

		String note = null;

		switch (action) {
		case ACTION_CLEAR:
			if (this.moleculePartsList.size() > 1) {
				note = "Delete selected molecule (red)";
			} else {
				note = "Clear canvas";
			}
			this.activeMol.forceUniColor(Color.RED);
			this.uniColorMolecule = this.activeMol;
			break;
		case ACTION_REACP:
			note = "Copy selected (blue) molecule to the other side of the reaction";
			this.activeMol.forceUniColor(Color.BLUE);
			this.uniColorMolecule = this.activeMol;

		}

		if (note != null) {
			this.info(note);
			this.setMustRedrawMolecularArea(true); // new oct 2016
			this.mustReDrawTopMenu = true;
		} else {
			this.setMustRedrawMolecularArea(false); // new oct 2016
			this.mustReDrawTopMenu = false;
		}

		return note != null; // || this.mustReDrawMolecularArea || this.mustReDrawTopMenu;
	}

	/**
	 * 
	 * @param action
	 * @return true if repaint needed
	 */
	boolean handleMouseLeaveActionMenu(int action) {

		switch (action) {
		case ACTION_NEW:
		case ACTION_MOVE_AT:
		case ACTION_SPIRO:
		case ACTION_STEREO:
		case ACTION_CHAIN:
		case ACTION_DELGROUP:
		case ACTION_DELETE:
		case ACTION_SMI:
		case ACTION_QRY:
		case ACTION_AN_X:
		case ACTION_AN_R:

			this.clearInfo();
			return true;
		// break;
		}

		if (this.uniColorMolecule != null && (action == ACTION_CLEAR || (options.reaction && action == ACTION_REACP))) {

			this.uniColorMolecule.resetForceUniColor();
			this.uniColorMolecule = null;

			for (JMEmol mol : moleculePartsList) {
				mol.resetForceUniColor();
			}

			this.clearInfo();
			this.setMustRedrawMolecularArea(true);
			this.mustReDrawTopMenu = true;

		} else {
			this.setMustRedrawMolecularArea(false); // new october2016
			this.mustReDrawTopMenu = false;
		}

		// this.mustReDrawTopMenu = true;

		return this.mustReDrawMolecularArea;// || this.mustReDrawTopMenu;

	}

	/*
	 * Save the current molecules to the change manager
	 */
	protected void postSave() {

		if (!this.canMultipleUndo) {
			return;
		}

		SavedState state = this.createState();
		// if(state != null) {
		this.molChangeManager.insertItem(state);
		// }

	}

	/*
	 * Create a state to store the chemical state of the editor. Return null if
	 * there is nothing to save.
	 */
	protected SavedState createState() {

		// state.actualMoleculePartIndex = activeMolIndex1();
		// state.numberofMoleculeParts = this.numberofMoleculeParts();

		// we have two options:
		// return null: do not save an empty state
		// or save the empty save

		if (true) {
			while (moleculePartsList.isReallyEmpty() && moleculePartsList.size() > 1) {
				moleculePartsList.remove(0);
			}
		} else {
			if (moleculePartsList.isReallyEmpty()) {
				return null;
			}
		}

		SavedState state = new SavedState();
		state.moleculePartsList = this.moleculePartsList.deepCopy();
		// FIXME: some code call createState() before cleanup of the valence!!!! e.g.
		// mouseDown
		// most don't so instead of adding mol.cleanAfterChanged() everywhere ...
		// state.moleculeParts.get(i).cleanAfterChanged();

//		for(int i=1; i < JME.maxParts; i++) {
//			JMEmol part = this.moleculeParts.get(i);
//			if(part != null) {
//				if(part.natoms > 0) {
//					mustBeSaved = true;
//				}
//				state.moleculeParts.get(i) = part.deepCopy();
//			} else {
//				break;
//			}
//		}

		state.reaction = options.reaction;
		state.multipart = options.multipart;

		state.depictScale = this.molecularAreaScalePixelsPerCoord;
		state.lastAction = this.lastAction;

//		if(mustBeSaved) {
//			return state;
//		} else {
//			return null;
//		}

		return state;
	}

	protected void retoreState(SavedState state) {
		basicRetoreState(state);

		// Notifify the JavaScript world that my structure has changed
		switch (state.lastAction) {
		case LA_MOVE:
		case LA_ROTATE:
		case LA_FAILED:
			break;
		default:
			this.notifyStructuralChange("restore");
		}

	}

	protected void basicRetoreState(SavedState state) {

		// BUG: this should not happen!!!
		if (state == null) {
			// go back to the first state that is null/empty?
			// TODO: simplify
			do {
				this.clear(false);
			} while (!this.moleculePartsList.isReallyEmpty());

			return;
		}
		// this.actualMoleculePartIndex = state.actualMoleculePartIndex;
		// this.numberofMoleculeParts = state.numberofMoleculeParts;

		moleculePartsList = state.moleculePartsList.deepCopy();

		/*
		 * for(int i=1; i < JME.maxParts; i++) { JMEmol part =
		 * state.moleculeParts.get(i); if(part != null) { this.moleculeParts.get(i) =
		 * part.deepCopy(); } else { this.moleculeParts.get(i) = null; } }
		 */
		// issue: this can create a null mol
		if (state.activeMol != null) {
			this.activeMol = state.activeMol;
		} else {
			this.activeMol = new JMEmol(this, this.params); // avoid a null pointer, for state saved
															// after a clear or reset
		}

		options.reaction = state.reaction;
		options.multipart = state.multipart;

		this.molecularAreaScalePixelsPerCoord = state.depictScale;
	}

	public JPopupMenu getCopyPasteJPopupMenuMol() {
		// if(this.copyPasteJPopupMenuMol == null) {
		this.copyPasteJPopupMenuMol = this.createCopyPasteJPopupMenu(false);
		// }
		return copyPasteJPopupMenuMol;
	}

	public JPopupMenu getCopyPasteJPopupMenuReaction() {
		// if(this.copyPasteJPopupMenuReaction == null) {
		this.copyPasteJPopupMenuReaction = this.createCopyPasteJPopupMenu(true);
		// }
		return copyPasteJPopupMenuReaction;
	}

	// return true if event has been used
	public boolean handleCopyPasteJPopupMenu(MouseEvent e, int x, int y) {

		// detect mol and atom under the cursor: needed for tablet?

		if (e == null || this.isEventContextMenu(e)) {

			// Tablet: needed for touch screen because they cannot detect a mouse move
			// Does not work: the delay for the context menu is too long and is needed
//			if(isTouchSupported) {
//				findMolAndAtomOrBondInDrawingArea(x, y, newTouchedMol);
//				if(newTouchedMol.molIndex > 0) {
//					mol = this.moleculeParts[newTouchedMol.molIndex];
//					mol.touchedAtom = newTouchedMol.atomIndex;
//					mol.touchedBond = newTouchedMol.bondIndex;
//					
//				}
//
//			}
			boolean isTouched = activeMol.touchedAtom > 0 || activeMol.touchedBond > 0;
			if (isTouched && (action == ACTION_DELETE || action == ACTION_DELGROUP)) {
				return true; // true: do not use the context menu to delete atom or bond
			}
//			this.info("isTouched = " + isTouched);
//			repaint();

			if (isTouched && !isDepict()) {
				// set shiral flag to the mol
				if (this.touchedMolPopuMenu != null) {
					this.remove(this.touchedMolPopuMenu);

				}
				touchedMolPopuMenu = this.createMolJPopupMenu(activeMol, x, y);
				this.add(touchedMolPopuMenu); // set the parent the popup
				touchedMolPopuMenu.show(this, x, y);
			} else {

				{
					JPopupMenu pm;
					if (options.reaction) {
						pm = this.getCopyPasteJPopupMenuReaction();
					} else {
						pm = this.getCopyPasteJPopupMenuMol();
					}
					if (this.isEventContextMenu(e)) {
						pm.show(this, x, y);
					} else { // click performed on the menu
						this.showJPopupMenuRealtiveToScaledMainMenu(pm, x, y);
					}

				}

			}

			// the atom or bond highlight must disappear =-to be improved
//			Event ne = new Event(null, 0, 0);
//			this.mouseMove(ne, 1000000, 100000); // large number to be sure that no mouse over menu action would be
//													// detected
			processMouseMotionEvent(new MouseEvent(this, MouseEvent.MOUSE_MOVED, 0, 0, 1000000, 100000, 0, false, 0));

			return true;
		}
		return false;

	}

	/*
	 * Show the JPopupMenu at the given coordinate relative to the GUI menu The GUI
	 * menu might have been scaled up or down, thus the x,y coordinates must be
	 * changed accordingly
	 */
	protected void showJPopupMenuRealtiveToScaledMainMenu(JPopupMenu pm, int x, int y) {
		pm.show(this, (int) (x * this.menuScale + 0.5), (int) (y * this.menuScale + 0.5));

	}

	public boolean isEventContextMenu(MouseEvent e) {
		if (e == null)
			return false;

		boolean meta = e.isMetaDown(); // true if right mouse click
		boolean ctrl = e.isControlDown(); // Safari Mac

		return meta || ctrl;

	}

	public JPopupMenu getFunctionalGroupPopumemu() {
		if (this.functionalGroupPopumemu == null) {
			this.functionalGroupPopumemu = this.createFunctionalGroupPopumemu();
		}
		return this.functionalGroupPopumemu;
	}

	public JPopupMenu createFunctionalGroupPopumemu() {

		JPopupMenu popup = new JPopupMenu();

		for (String eachFG : functionalGroups) {
			JMenuItem mi = new JMenuItem(eachFG);
			popup.add(mi);
			mi.setActionCommand(eachFG);
			mi.addActionListener(this);
		}
		// setSubstituent(r);

		this.add(popup); // set the parent the popup

		return popup;
	}

	public JPopupMenu createFBackgroundColorPopumemu() {

		JPopupMenu popup = new JPopupMenu();

		for (int i = 1; i < this.colorManager.psColor.length; i++) {
			ColorInfo ci = this.colorManager.getColorInfo(i);
			Color color = ci.color;
			String label = ci.name;
			String colorrHash = ci.hash;
			;
			JMenuItem mi = new JMenuItem(label + "\t" + this.colorManager.makeHexColor(color)); // JSapplet awt
																								// JMenuItem will create
																								// SVG with color circle
			popup.add(mi);
			mi.setActionCommand(colorrHash);
			mi.addActionListener(this);

		}
		// setSubstituent(r);

		this.add(popup); // set the parent the popup

		return popup;
	}

	// public int stringHeight(FontMetrics fm, String text) {
	// int h = stringHeight(fm);
	// //Correction for a string that is only lower case - NO working : i is as high
	// as a L
	// if(text.equals(text.toLowerCase()) ) {
	// h = h *2 /3;
	// }
	// return h;
	// }

	/**
	 * 
	 * @return the notifyAtomHighLightJSfunction
	 */
	public String getNotifyAtomHighLightJSfunction() {
		return this.notifyAtomHighLightJSfunction;
	}

	/**
	 * Set the name of the JavaScript function that will be called each time the
	 * mouse move over an atom. To cancel, set to null.
	 * 
	 * @param notifyAtomHighLightJSfunction
	 */
	public void setNotifyAtomHighLightChangeJSfunction(String notifyAtomHighLightJSfunction) {
		this.notifyAtomHighLightJSfunction = notifyAtomHighLightJSfunction;
	}

	/**
	 * Notify the JavaScript envirronement that the mouse over atom has changed
	 * 
	 * @param touchedAtom
	 */
	protected int previousTouchedAtomForHighlight = 0;
	protected int previousTouchedBondForHighlight = 0;
	protected int previousActualMoleculePartIndex = 0;

	/**
	 * return -1 if no action should be taken or the touchedAtomOrBond, which might
	 * have been set to 0 in case the curssor has moved away from the atom or bond
	 * 
	 * @param touchedAtomOrBond
	 * @param previousTouchedAtomOrBondForHighlight
	 * @return
	 */
	public int notifyAtomOrBondHighLightJSfunction(int touchedAtomOrBond, int previousTouchedAtomOrBondForHighlight) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		// send an event only if it is about a new atom
		// otherwise each small mouse move will send an event

		// case 1: cursor moved away from atom previous atom is not defined -> do
		// nothing
		if (touchedAtomOrBond <= 0 && previousTouchedAtomOrBondForHighlight == 0) {
			// System.out.println("case 1");
			return -1;
		}

		// case 2: cursor moved around the same atom -> do nothing
		if (touchedAtomOrBond == previousTouchedAtomOrBondForHighlight
				&& this.activeMolIndex() == previousActualMoleculePartIndex) {
			// System.out.println("case 2");

			return -1;
		}

		// case 3: cursor moved away from the atom that was highlighted - send 0 to the
		// callback function
		// to notify that the atom has been deselected
		if (touchedAtomOrBond <= 0 && previousTouchedAtomOrBondForHighlight > 0) {
			// System.out.println("case 3");
			touchedAtomOrBond = 0;
		}

		this.previousActualMoleculePartIndex = this.activeMolIndex();
		return touchedAtomOrBond;

	}

	// TODO
	// potentila bug? this.previousTouchedAtomForHighlight does not depend on the
	// molecular part????
	public void notifyAtomHighLightJSfunction(int touchedAtom) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		if (this.canHandleAtomHighLightCallBack()) {
			touchedAtom = this.notifyAtomOrBondHighLightJSfunction(touchedAtom, this.previousTouchedAtomForHighlight);
			if (touchedAtom == -1)
				return;

			this.previousTouchedAtomForHighlight = touchedAtom;
			// do the function call - will work in a real Java applet
			if (this.notifyAtomHighLightJSfunction != null) {
				JSObject jsObject = JSObject.getWindow(this);
				jsObject.call(this.notifyAtomHighLightJSfunction,
						new Integer[] { new Integer(this.activeMolIndex()), new Integer(touchedAtom) });
			}
			// this is for the new callback mechanism - June 2015
			handleAtomHighLightCallBack(this.activeMolIndex(), touchedAtom);

		}
	}

	public void notifyBondHighLightJSfunction(int touchedBond) {
		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		if (this.canHandleBondHighLightCallBack()) {
			touchedBond = this.notifyAtomOrBondHighLightJSfunction(touchedBond, this.previousTouchedBondForHighlight);
			if (touchedBond == -1)
				return;
			this.previousTouchedBondForHighlight = touchedBond;

			// this is for the new callback mechanism - June 2015
			handleBondHighLightCallBack(this.activeMolIndex(), touchedBond);

		}
	}

	public Boolean canHandleAtomHighLightCallBack() {
		return true;//this.notifyAtomHighLightJSfunction != null;
	}

	public Boolean canHandleBondHighLightCallBack() {
		return true;
	}

	public Boolean canHandleAtomClickedCallBack() {
		return true;
	}

	public Boolean canHandleBondClickedCallBack() {
		return true;
	}

	/**
	 */
	public void handleAtomClickedCallBack(int actualMoleculePartIndex, int clickedAtom) {
		notifyEvent(JME_EVENT_ATOM_CLICKED, new int[] {actualMoleculePartIndex, clickedAtom});
	}

	public void handleBondClickedCallBack(int actualMoleculePartIndex, int clickedBond) {
		notifyEvent(JME_EVENT_BOND_CLICKED, new int[] {actualMoleculePartIndex, clickedBond});
	}
	

	/*
	 * Same functionality as prePasteJSfunction but only for JSME Advantage: the
	 * argument is a JS function, not a JS function name. The JS fyunction will have
	 * two arguments: my self and the string to process before pasting For JME,
	 * always return false - meaning that there is no callback set
	 */
	protected boolean handleBeforePasteEvent(String molecule) {

		return false;
	}

	/**
	 * Called when pasting has been sucessful. Method intended for a subclass.
	 */
	protected void handleAfterPasteEvent(String pasteContent) {
		notifyEvent(JME_EVENT_PASTE, pasteContent);
	}

	/**
	 * Called after swith to edit / depict mode using the toggle option. Method
	 * intended for a subclass.
	 */
	protected void handleAfterAfterDepictEditToggleEvent() {
		notifyEvent(JME_EVENT_DEPICT_EDIT_TOGGLE, Boolean.valueOf(depict));
	}

	protected void handleAftertructureModifiedEvent(String cause) {
		// subclass do something more
		String a = afterStructureChangeEvent.getAction();
		//System.out.println("Structure modified event: " + a);
		notifyEvent(JME_EVENT_STRUCTURE_MODIFIED, afterStructureChangeEvent);
		updateReactionRoles();
	}

	public void notifyEvent(String name, Object value) {
		firePropertyChange(name, new Object[] {options.getApplet(false)}, value);
	}

	/**
	 * For subclasses
	 * 
	 * @param actualMoleculePartIndex2
	 * @param touchedAtom
	 */
	public void handleAtomHighLightCallBack(int actualMoleculePartIndex, int touchedAtom) {
		notifyEvent(JME_EVENT_ATOM_HIGHLIGHT, new int[] {actualMoleculePartIndex, touchedAtom});
	}

	/**
	 * For subclasses
	 * 
	 * @param actualMoleculePartIndex2
	 * @param touchedBond
	 */
	public void handleBondHighLightCallBack(int actualMoleculePartIndex, int touchedBond) {
		notifyEvent(JME_EVENT_BOND_HIGHLIGHT, new int[] {actualMoleculePartIndex, touchedBond});
	}

	/**
	 * Highlight atom like a mouse over. If the atom index is 0, then remove any
	 * atom highlight. If molIndex is zero, that means that the atom index is an
	 * ensemble index
	 * 
	 * @param molIndex  (first index is 1, not 0)
	 * @param atomIndex (first index is 1, not 0)
	 */
	public void setAtomToHighLight(int molIndex, int atomIndex) {

		// JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

		this.moleculePartsList.resetTouchedAtomAndBond();
//		for (int i = 1; i <= this.numberofMoleculeParts; i++) {
//			this.moleculeParts[i].touchedAtom = 0;
//			this.moleculeParts[i].touchedBond = 0;
//		}

		if (atomIndex != 0) {
			// 0 means reset highlight

			JMEmolList.EnsembleAtom ea = this.getEnsembleAtom(molIndex, atomIndex);

			if (ea == null) {
				this.showError("invalid atom index or molecule index");
				return;
			}
			ea.mol.touchedAtom = ea.atomIndex;
		}
		this.redrawMolecularAreaOnly();

	}

	/**
	 * Highlight bond like a mouse over. If the bond index is 0, then remove any
	 * bond highlight. If molIndex is zero, that means that the bond index is an
	 * ensemble index
	 * 
	 * @param molIndex  (first index is 1, not 0)
	 * @param bondIndex (first index is 1, not 0)
	 */
	public void setBondToHighLight(int molIndex, int bondIndex) {

		// JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

		this.moleculePartsList.resetTouchedAtomAndBond();

		// 0 means reset highlight
		if (bondIndex != 0) {

			JMEmolList.EnsembleBond ea = this.getEnsembleBond(molIndex, bondIndex);

			if (ea == null) {
				this.showError("invalid bond index or molecule index");
				return;
			}
			ea.mol.touchedBond = ea.bondIndex;
		}
		this.redrawMolecularAreaOnly();

	}

	public void changeAtomMap(int molIndex, int atomIndex, int newMap) {
		JMEmol mol = this.selectMolIfValidOrShowError(molIndex);
		changeAtomMap(mol, atomIndex, newMap);

	}

	public void changeAtomMap(JMEmol mol, int atomIndex, int newMap) {
		Atom at = mol.getAtom(atomIndex);
		if (newMap <= 0) {
			at.resetObjectMark();// Nov 2020 bug fix: set atom ap to 0 reset it
		} else {
			at.setMapOrMark(newMap, !this.params.mark); // Nov 2020 bug fix: !
		}
		this.recordAtomEvent(CHANGE_ATOM_MAP, atomIndex);
		// this.setAtomToHighLight(molIndex, atomIndex);
		this.redrawMolecularAreaOnly();

	}

	public void changeAtomCharge(JMEmol mol, int atomIndex, int newCharge) {
		Atom at = mol.getAtom(atomIndex);
		at.Q(newCharge);

		this.recordAtomEvent(CHARGE_ATOM0, atomIndex);
		// this.setAtomToHighLight(molIndex, atomIndex);
		this.redrawMolecularAreaOnly();

	}

	/**
	 * @return the notifyStructuralChangeJSfunction
	 */
	public String getNotifyStructuralChangeJSfunction() {
		return notifyStructuralChangeJSfunction;
	}

	/**
	 * @param notifyStructuralChangeJSfunction the notifyStructuralChangeJSfunction
	 *                                         to set
	 */
	public void setNotifyStructuralChangeJSfunction(String notifyStructuralChangeJSfunction) {
		this.notifyStructuralChangeJSfunction = notifyStructuralChangeJSfunction;
	}

	/**
	 * Notify the JavaScript envirronement that the chemical structure has changed
	 * 
	 * @param cause
	 */
	public void notifyStructuralChange(String cause) {

		if (afterStructureChangeEvent != null && afterStructureChangeEvent.action != null) {
			if (afterStructureChangeEvent.stackLevel > 0) {
				afterStructureChangeEvent.reset();
				return;
			}
			afterStructureChangeEvent.stackLevel++;
			handleAftertructureModifiedEvent(cause);
		}

		// TODO: exception handling with JSException: this function will not work
		// outside a web browser
		if (notifyStructuralChangeJSfunction != null) {
			// BH this does not allow for xx.xx.f
			JSObject jsObject = JSObject.getWindow(this);
			jsObject.call(this.notifyStructuralChangeJSfunction, null);
		}

	}

	public String getPrePasteJSfunction() {
		return prePasteJSfunction;
	}

	/**
	 * Set a JS function that will be called before the paste is performed. THis
	 * function will receive one argument: a string that a represent a molecular
	 * structure. The return value of the fuinction is a string. Purpose: convert a
	 * name or a SMILES or an InchI into a MOL.
	 * 
	 * @param prePasteJSfunction
	 */
	public void setPrePasteJSfunction(String prePasteJSfunction) {
		this.prePasteJSfunction = prePasteJSfunction;
	}

	/**
	 * 
	 * @return the height in pixel of the top menu
	 */
	int topMenuHeight() {
		return (int) Math.round(topMenuHeight(this.menuScale));
	}

	/**
	 * 
	 * @return the height in pixel of the top menu
	 */
	double topMenuHeight(double scale) {
		return this.isDepict() ? 0.0 : (menuCellSize * 2 + menuCellBorder()) * scale;
	}

	/**
	 * 
	 * @return the width in pixel of the top menu
	 */
	int leftMenuWidth() {
		return (int) Math.round(leftMenuWidth(this.menuScale));
	}

	/**
	 * 
	 * @return the scaled width in pixel of the left menu
	 */
	double leftMenuWidth(double scale) {

		return this.isDepict() ? 0.0 : (menuCellSize * 1 + menuCellBorder()) * scale;
	}

	/**
	 * 
	 * @return the height in pixel of the bottom bar (info bar) = 0 in depict mode
	 */
	public int infoAreaHeight() {
		return (int) Math.round(infoAreaHeight(this.menuScale));
	}

	public double infoAreaHeight(double scale) {
		return this.isDepict() ? 0.0 : menuCellSize * scale;
	}

	/**
	 * the right border differs in new and old look
	 * 
	 * @return
	 */
	int rightBorder() {
		return (int) Math.round(rightBorder(this.menuScale)); // the width of the line on the right of the molecular
																// area in edit mode
	}

	double rightBorder(double scale) {
		return this.isDepict() ? 0.0 : (options.newLook ? rightBorderNewLook : rightBorderOldLook) * scale; // the width
																											// of the
		// line on the right
		// of the molecular
		// area in edit mode
	}

	/*
	 * 
	 * @return the height in pixel of the bottom bar (info bar) > 0 also in depict
	 * mode
	 */
	public int getDefaultInfoBarHeight() {
		return (int) standardMenuCellSize;
	}

	public void redrawMolecularAreaOnly() {
		this.mustRedrawNothing();
		this.setMustRedrawMolecularArea(true);
		this.repaint();

	}

	boolean setMustRedrawMolecularArea(boolean b) {
		return true;
//		return (mustReDrawMolecularArea = b);

	}

	public void redrawMolecularAreaOnylForGettingSVG() {
		int savedTouchedAtom = this.activeMol.touchedAtom;
		int savedTouchedBond = this.activeMol.touchedBond;

		// hide the touched atom or bond
		this.activeMol.touchedAtom = 0;
		this.activeMol.touchedBond = 0;
		this.afterStructureChangeEvent.reset(); // oct 2016: avoid an infinite loop when
												// redrawMoleculartAreaOnlForGettingSVG is called within js notification
												// of a structure change

		this.redrawMolecularAreaOnly();

		this.activeMol.touchedAtom = savedTouchedAtom;
		this.activeMol.touchedBond = savedTouchedBond;
	}

	/**
	 * if mol index is 0, than set the colors for all molecules
	 * 
	 * @param molIndex        1 based
	 * @param atomAndColorCSV : at,c,at,c,at,c, ... at: atom index; c: color index
	 */
	public void setAtomColors(int molIndex, String atomAndColorCSV) {

		// TODO Use EnsembleAtom
		// if the mol index has not been specified - then assume that the atom indices
		// are valid for the whole ensemble
		if (molIndex == 0) {

			int cumulAtomCount = 0;
			for (int i = 1; i <= moleculePartsList.size(); i++) {
				JMEmol mol = this.selectMolIfValidOrShowError(i);
				mol.setAtomColors(atomAndColorCSV, cumulAtomCount);
				cumulAtomCount += mol.nAtoms();
			}

		} else {
			// select the molecule to color
			JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

			if (molToHighLight == null) {
				return;
			}

			// color its atoms according to the parameters
			molToHighLight.setAtomColors(atomAndColorCSV, 0);
		}

		// repaint
		this.redrawMolecularAreaOnly();
	}

	/**
	 * Get ensemble information about the atom index. If molIndex is zero. then
	 * atomIndex is an ensemble index
	 * 
	 * @param molIndex  - 0 based
	 * @param atomIndex
	 * @return
	 */
	public JMEmolList.EnsembleAtom getEnsembleAtom(int molIndex, int atomIndex) {

		if (molIndex < 0 || atomIndex < 0) {
			GWT.log("Invalid index for getEnsembleAtom()");
			return null;
		}

		return new JMEmolList.EnsembleAtom(this.moleculePartsList, molIndex, atomIndex);

	}

	/**
	 * 
	 * @param molIndex - 0 based
	 * @return
	 */
	public JMEmol getMolecule(int molIndex) {
		if (molIndex < 0 || molIndex >= this.moleculePartsList.size()) {
			GWT.log("Invalid index for getMolecule()");
			return null;
		}

		return this.moleculePartsList.get(molIndex);

	}

	int lastValidColorIndex = 1; // TODO: use the default color

	/**
	 * Choose the background color to be used for the atom or bond. The marker
	 * symbol will get this color as well. The index is the index of the color of
	 * current color palette.
	 * 
	 * @param colorIndex (first value is 1)
	 */
	public void activateMarkerColor(int colorIndex) {
		// this.moleculeHandlingParameters.mark = true;

		if (colorIndex < 1 || colorIndex > this.colorManager.numberOfBackgroundColors()) {
			this.alert("Invalid color index: " + colorIndex);
			resetExtendAtomMark = true; // June 2020: do not accumulate large numbers with keyboard input (see
										// updateMark() )
			markFromKeyboardInput = false;
			this.activeMarkerColorIndex = lastValidColorIndex;
			this.clearInfo();
			this.repaint();
		} else {
			lastValidColorIndex = this.activeMarkerColorIndex = colorIndex;
			this.setAction(105);
			this.options("marker");

			this.mustReDrawTopMenu = true; // the marker symbol is in the top menu
			this.repaint();
		}
	}

	public void setStarColor(String hexColor) {
		this.alert("methods setStarColor and setMarkerColor have been replaced by activateMarkerColor");

	}

	/**
	 * Get the Atom object using an ensemble based index
	 * 
	 * @param atomE
	 * @return
	 */
	public Atom getAtomE(int atomE) {
		return this.getEnsembleAtom(0, atomE).atom;
	}

	public int totalNumberOfAtoms() {

		return this.moleculePartsList.totalNumberOfAtoms();
//		int cumulAtomCount = 0;
//		for (int i = 1; i <= numberofMoleculeParts; i++) {
//			JMEmol mol = this.selectMolIfValidOrShowError(i);
//			cumulAtomCount += mol.nAtoms();
//		}
//
//		return cumulAtomCount;
	}

	/**
	 * Just replace. Assume that the new Atom is the same with some extra data
	 * field. No further checking
	 * 
	 * @param oldAtom
	 * @param newAtom
	 */
	public void replaceAtom(AtomBondCommon oldAtom, Atom newAtom) {
		for (int i = 1; i <= moleculePartsList.size(); i++) {
			JMEmol mol = this.selectMolIfValidOrShowError(i);
			for (int at = 0; at < mol.atoms.length; at++) {
				if (mol.atoms[at] == oldAtom) {
					mol.atoms[at] = newAtom;
					return;
				}
			}
		}
	}

	/**
	 * Reset background atom colors
	 * 
	 * @param molIndex
	 */
	public void resetAtomColors(int molIndex) {

		if (molIndex == 0) { // new May 2018
			// this.atomColors = "";

			for (int i = 1; i <= moleculePartsList.size(); i++) {
				this.resetAtomColors(i);
			}

			return;
		} else {

			// select the molecule to decolor
			JMEmol selectedMol = this.selectMolIfValidOrShowError(molIndex);

			if (selectedMol == null) {
				return;
			}

			//
			selectedMol.resetChemicalObjectColors(selectedMol.atoms);
		}

		// repaint
		this.redrawMolecularAreaOnly();

		// clear the atom colors from the option

	}

	/**
	 * Reset background atom colors
	 * 
	 * @param molIndex
	 */
	public void resetBondColors(int molIndex) {

		if (molIndex == 0) { // new Sepetmber 2019
			this.atomBgColors = "";

			for (int i = 1; i <= moleculePartsList.size(); i++) {
				this.resetBondColors(i);
			}

			return;
		} else {

			// select the molecule to decolor
			JMEmol selectedMol = this.selectMolIfValidOrShowError(molIndex);

			if (selectedMol == null) {
				return;
			}

			//
			selectedMol.resetChemicalObjectColors(selectedMol.bonds);
		}

		// repaint
		this.redrawMolecularAreaOnly();

		// clear the atom colors from the option

	}

	public int totalNumberOfBonds() {
//		int cumulBOndCount = 0;
//		for (int i = 1; i <= numberofMoleculeParts; i++) {
//			JMEmol mol = this.selectMolIfValidOrShowError(i);
//			cumulBOndCount += mol.nBonds();
//		}
//
//		return cumulBOndCount;

		return this.moleculePartsList.totalNumberOfBonds();
	}

	/**
	 * Get ensemble information about the atom index. If molIndex is zero. then
	 * atomIndex is an ensemble index
	 * 
	 * @param molIndex  - 0 based
	 * @param bondIndex - 1 based
	 * @return
	 */
	public JMEmolList.EnsembleBond getEnsembleBond(int molIndex, int bondIndex) {

		if (molIndex < 0 || bondIndex < 0) {
			GWT.log("Invalid index for getEnsembleBond()");
			return null;
		}

		return new JMEmolList.EnsembleBond(this.moleculePartsList, molIndex, bondIndex);

	}

	/**
	 * Get the Atom object using an ensemble based index
	 * 
	 * @param bondE
	 * @return
	 */
	public Bond getBondE(int bondE) {
		return this.getEnsembleBond(0, bondE).bond;
	}

	/**
	 * Just replace. Assume that the new Bond is the same with some extra data
	 * field. No further checking
	 * 
	 * @param oldBond
	 * @param newBond
	 */
	public void replaceBond(AtomBondCommon oldBond, Bond newBond) {
		for (JMEmol mol : moleculePartsList) {
			for (int b = 0; b < mol.bonds.length; b++) {
				if (mol.bonds[b] == oldBond) {
					mol.bonds[b] = newBond;
					return;
				}
			}
		}
	}

	// molIndex is based 1
	public void setBondColors(int molIndex, String bondAndColorCSV) {

		// if the mol index has not been specified - then assume that the aom indices
		// ave valid for the whole ensemble
		if (molIndex == 0) {

			int cumulBondCount = 0;
			for (JMEmol mol : moleculePartsList) {
				mol.setBondColors(bondAndColorCSV, cumulBondCount);
				cumulBondCount += mol.nBonds();
			}

		} else {
			// select the molecule to color
			JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);

			if (molToHighLight == null) {
				return;
			}

			// color its atoms according to the parameters
			molToHighLight.setBondColors(bondAndColorCSV, 0);
		}

		// repaint
		this.redrawMolecularAreaOnly();
	}

	/**
	 * JME accepts a SDF with multiple records. This method returns the list of the
	 * SDF records that were input
	 * 
	 * @return a string array, which could be empty
	 */
	public String[] getMultiSDFstack() {
		return this.sdfStack.getMultiSDFstack();
	}

	/**
	 * Return the selected mol. If the index is not valid, show an error
	 * 
	 * @param molIndex - 1 based
	 * @return JMEmol
	 */
	protected JMEmol selectMolIfValidOrShowError(int molIndex) {
		this.clearInfo(); // clear the info in case an error would occur
		if (molIndex < 1 || molIndex > this.moleculePartsList.size()) {
			this.showError("invalid mol index: " + molIndex);
			return null;
		}

		return this.moleculePartsList.get(molIndex - 1);

	}

	/**
	 * 
	 * @param action
	 * @param moleculePartIndex
	 * @param atomIndex
	 * @param bondIndex
	 */
	protected void recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex,
			int bondIndex) {

		this.recordAfterStructureChangedEvent(action, moleculePartIndex, atomIndex, bondIndex, true);

	}

	/**
	 * 
	 * @param action
	 * @param moleculePartIndex
	 * @param atomIndex
	 * @param bondIndex
	 */
	protected void recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex, int bondIndex,
			boolean willSaveOnUndoStack) {

		if (this.afterStructureChangeEvent != null) {
			this.updateReactionRoles(); // will do nothing if not reaction mode
			this.afterStructureChangeEvent.setAction(action).setAtomAndBondAndMol(moleculePartsList, atomIndex,
					bondIndex, moleculePartIndex);
		}
		// this.notifyStructuralChangeToJS();

		// for the undo/redo manager
		this.willPostSave(willSaveOnUndoStack); // happens after redraw?

	}

	protected void recordMoleculePartEvent(String action, int moleculePartIndex) {
		this.recordAfterStructureChangedEvent(action, moleculePartIndex, 0, 0);

	}

	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * 
	 * @param action
	 */
	protected void recordAtomEvent(String action) {
		this.recordAtomEvent(action, this.activeMol.touchedAtom);

	}

//	protected void recordAtomEventAndPostSave(String action) {
//		this.recordAtomEvent(action, this.mol.touchedAtom);
//		this.postSave();
//
//	}
	protected void recordAtomEvent(String action, int atom) {
		this.recordAfterStructureChangedEvent(action, this.activeMolIndex(), atom, 0);

	}

	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * 
	 * @param action
	 */
	protected void recordBondEvent(String action) {
		this.recordAfterStructureChangedEvent(action, this.activeMolIndex(), 0, this.activeMol.touchedBond);

	}

	protected void recordAfterStructureChangedEvent(String action) {
		this.recordAfterStructureChangedEvent(action, 0, 0, 0);

	}

	/**
	 * 
	 * @return true if the editor is in depict mode
	 */
	public boolean isDepictMode() {
		// alert("isDepictMode: "+ this.depict);
		return this.isDepict();
	}

	/**
	 * @return the depict
	 */
	public boolean isDepict() {
		return depict;
	}

	/**
	 * @param depict the depict to set
	 */
	public void setDepict(boolean depict) {
		this.depict = depict;
	}

	public boolean isEmpty() {
		return this.moleculePartsList.isReallyEmpty();
	}

	// ----------- added by Bob Hanson ------------ //
	
	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		String name = evt.getPropertyName();
		try {
			if (name == FileDropper.PROPERTY_FILEDROPPER_FILE) {
				readDroppedTextFile((String) evt.getNewValue());
			} else if (name == FileDropper.PROPERTY_FILEDROPPER_INLINE) {
				readDroppedData(evt.getNewValue());
			}
		} catch (Throwable t) {
			System.err.println("JME couldn't load data for drop " + name);
		}
	}

	protected void readDroppedData(Object newValue) {
		String data = newValue.toString();
		String trimmed = data.trim();
		// BH 2023.1.18 Allowing for copying with a bit of whitespace for SMILES
		try {
			if (trimmed.indexOf("\n") >= 0)
				readMolFile(data);
			else if (trimmed.indexOf(" ") >= 0)
				readMolecule(data);
			else
				readSmiles(trimmed);
			activeMol.center();
		} catch (Exception e) {
			System.err.println("JME error reading data starting with " + data.substring(Math.min(data.length(), 100)));
		}

	}

	protected void readSmiles(String data) {
		try {
			readMolFile(newParser().SMILEStoMOL(data));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	protected void readDroppedTextFile(String fileName) {
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		InputStream fis = null;
		try {
			fis = (fileName.indexOf("://") >= 0 ? new URL(fileName).openStream() : new FileInputStream(fileName));
			byte[] bytes = new byte[0x1000];
			int n;
			while ((n = fis.read(bytes)) > 0) {
				bos.write(bytes, 0, n);
			}
			fis.close();
		} catch (Exception e) {
			System.err.println("JME error reading file " + fileName);
		}
		readDroppedData(new String(bos.toByteArray()));
	}

	
	
	
	
	public void options(String parameters) {
		options.set(parameters);
		mustRedrawEverything();
		repaint();
	}

	class Options {

		// unused options

		// boolean writesmi = false;
		// boolean writemi = false;
		// boolean writemol = false;

		// essentially final

		/* final */ boolean addNewPart = false;
		// when reading a or pasting a mol: add it or replace everything in the canvas
		/* final */ boolean allowGUIzooming = true;
		/* final */ boolean allowZooming = true;
		/* final */ boolean autonumber = false;
		/* final */ boolean contextMenuEnabledOption = true;
		/* final */ boolean depictActionEnabled = false;
		// BB allow editing in depict mode
		/* final */ boolean depictBorder = false;
		/* final */ boolean exportInchi = true;
		/* final */ boolean exportInchiAuxInfo = true;
		/* final */ boolean exportInchiKey = true;
		/* final */ boolean exportRXNmergeOption = false;
		/* final */ boolean exportSVG = true;
		/* final */ boolean fgMenuOption = true;
		/* final */ boolean fullScreenIconOption = false;
		/* final */ boolean markerMenu = false;
		// popup menu to select marker color
		/* final */ boolean markOnly1 = false;
		// only one atom at a time can be marked
		/* final */ boolean newLook = false;
		/* final */ boolean paste = true;
		// BB: allow pasting structures, should be disabled in depict mode
		/* final */ boolean polarnitro = false;
		/* final */ boolean pseudoMark = false;
		// marking does not happen - used only to trigger event
		/* final */ boolean rButton = false;
		/* final */ boolean searchInchiKey = true;
		/* final */ boolean showAtomMoveJButton = true;
		// BB
		/* final */ boolean showDragAndDropIconInDepictMode = true;
		// BB
		/* final */ boolean showFullScreenIconInDepictMode = true;
		// BB
		/* final */ boolean starAtomOnly = false;
		/* final */ boolean starBondOnly = false;
		/* final */ boolean starNothing = false;
		/* final */ boolean toggleDepictEdit = false;
		// BB
		/* final */ boolean useOclIdCode = false;
		// OpenChemLib option: useOclIDCode
		/* final */ boolean useOpenChemLib = true; // for SMILES input

		// default only:
		boolean canonize = true;
		boolean multipart = true;
		boolean query = false;
		boolean reaction = false;
		boolean stereo = true;
		boolean xButton = true;

		// Applet-style parameter options
		
		String jmeString = null;
		String molString = null; // why is this variable declared here? Because it is used in init() and start()
		String genericChemicalInputFromInit = null;
		double atomBGcircleRelativeSize = defaultAtomBGcircleRelativeSize;
		double bondBGrectRelativeSize = defaultBondBGrectRelativeSize;

		boolean runsmi = false; 
		//String depictcgi = null;
		//String depictservlet = null;

		private String options;

		private Boolean parseOption(String option) {
			return parseOption(option, "no");
		}

		/**
		 * Add the JME field to the HTML applet object. 
		 * @param jme
		 */
		public void registerJS(JME jme) {
			HTML5Applet a = getApplet(false);
			if (a == null)
				return;
			/**
			 * @j2sNative
			 * 
			 * a.JME = jme;
			 */
			{}			
		}

		public void getAppletOptions(JME jme) {
			try {
				String options = getParameter("options");
				if (options != null)
					set(options);
				String p;
				if ((p = getParameter("jme")) != null)
					jmeString = p;
				if ((p = getParameter("mol")) != null)
					molString = p;
				if ((p = getParameter("chem")) != null)
					genericChemicalInputFromInit = p;
				if ((p = getParameter("smiles")) != null)
					genericChemicalInputFromInit = p;
// BH not referenced
//				if ((p = getParameter("depictcgi")) != null) {
//					depictcgi = p;
//					runsmi = true;
//				}
				if ((p = getParameter("text")) != null)
					molText = p;
				atomBgColors = getParameter("atombg");
				if ((p = getParameter("depictbg")) != null)
					canvasBg = parseHexColor(p);
				if ((p = getParameter("guicolor")) != null)
					setUserInterfaceBackgroundColor(p);
				if ((p = getParameter("guiAtomColor")) != null)
					setLeftMenuAtomColor(p);
				if ((p = getParameter("atombgsize")) != null) {
					double d = Double.valueOf(p);
					atomBGcircleRelativeSize = (d < 0 ? defaultAtomBGcircleRelativeSize : d);
				}
				if ((p = getParameter("bondbgsize")) != null) {
					double d = Double.valueOf(p);
					bondBGrectRelativeSize = (d < 0 ? defaultBondBGrectRelativeSize : d);
				}

				if (showAtomNumbers)
					showAtomNumbers();

				String jsFunction = getParameter("notify_structural_change_js_function");
				setNotifyStructuralChangeJSfunction(jsFunction);

				handleAddiitonalParameters();

			} catch (Exception e) {
				System.err.println("JME:  parameters error");
			}
		}

		/**
		 * Get either the JApplet (possibly a JSDummyApplet) linking this to its
		 * JavaScript HTMLApplet counterpart, or that counterpart.
		 * 
		 * @param asJava true to return the JApplet; false to return the DOM object for
		 *               which ._applet is the JApplet.
		 * @return
		 */
		public HTML5Applet getApplet(boolean asJApplet) {
			@SuppressWarnings("unused")
			Object g = Thread.currentThread().getThreadGroup();
			/**
			 * @j2sNative
			 * 			var a = g.getHtmlApplet$();
			 * 			return (asJApplet ? a._applet : a);
			 * 
			 */
			{
				// Java only
				return null;
			}
			
		}
		public String getParameter(String p) {
			// SwingJS sets the applet in the ThreadGroup
			JApplet applet = (JApplet) getApplet(true);
			return (applet == null ? null : applet.getParameter(p));
		}

		/**
		 * use boundaries for the search
		 * 
		 * @param parameters
		 * @param option
		 * @param negativePrefix
		 * @return null if option not found
		 */
		private Boolean parseOption(String option, String negativePrefix) {
			boolean pos = (options.indexOf(" " + option + " ") >= 0);
			boolean neg = (options.indexOf(" " + negativePrefix + option) >= 0);
			if (pos && neg) {
				log("check option " + option);
				return null;
			}
			return (pos ? Boolean.TRUE : neg ? Boolean.FALSE : null);
		}

		// useful for options with multiple names - for instance star option has been
		// renamed to marker
		private Boolean parseSynonymOptions(String parameters, String... options) {
			for (String eachOption : options) {
				Boolean found = parseOption(eachOption);
				if (found != null) {
					return found;
				}
			}
			return null;
		}

		/**
		 * 
		 * @param parameters
		 * @return true if repaint is needed (always)
		 */
		public void set(String parameters) {

			// boolean repaint = true;

			Boolean o;
			// definition of Regex "word boundary"
			String p0 = parameters;
			parameters = parameters.replaceAll("[^_0-9a-zA-Z]", ";");
			boolean one = (p0.equals(parameters));
			options = ";" + parameters.toLowerCase() + ";";

			// BH note -- if more are added, make sure they are lowercase here

			if ((o = parseOption("depict")) != null) {
				setDepictOption(o.booleanValue());
				if (one)
					return;
			}
			if ((o = parseSynonymOptions(parameters, "star", "marker")) != null) {
				if (params.mark != o) {
					params.number = params.mark = o; // why number?
					// activeMarkerColorIndex = moleculeHandlingParameters.mark ? 0 : -1; //WIP
					mustRedrawEverything();
					if (!o) // eif star is off, so is star1
						markOnly1 = false;
				}
				if (one)
					return;
			}
			if ((o = parseOption("headless")) != null) {
				headless = true;
			}

			if ((o = parseOption("rbutton")) != null) {
				rButton = o;
				mustReDrawLeftMenu = true;
			}

			// show implicit H
			if ((o = parseOption("hydrogens")) != null) {
				if (params.hydrogenHandlingParameters.showHs != o) {
					params.hydrogenHandlingParameters.showHs = o;
					mustReDrawMolecularArea();
				}
			}

			if ((o = parseOption("polarnitro")) != null) {
				polarnitro = o;
			}

			if ((o = parseOption("valencestate")) != null) {

				if (params.computeValenceState != o) {
					params.computeValenceState = o; // April 2019
					mustReDrawMolecularArea();

					// should we update all atom internals e.g. charge, nh, ...?
					// mustReDrawMolecularArea();
					// repaint = true;
				}
			}

			if (parameters.indexOf("keephs") > -1) {
				// keepHydrogens = true;
				// removeOnlyCHydrogens = false;
				params.hydrogenHandlingParameters.removeHs = false;
			}
			if (parameters.indexOf("removehs") > -1) {
				params.hydrogenHandlingParameters.removeHs = true;
				params.hydrogenHandlingParameters.removeOnlyCHs = false;
			}

			if (parameters.indexOf("removehsc") > -1) {
				// keepHydrogens = false;
				// removeOnlyCHydrogens = true;
				setRemoveHsC();

			}

			if ((o = parseOption("query")) != null)
				if (query != o) {
					query = o;
					// repaint = true;
				}

			if ((o = parseOption("reaction")) != null) {
				if (reaction != o) {
					setMustRedrawMolecularArea(true); // reaction arrow change : redrawing needed
					// repaint = true;
				}
				if (!reaction) {
					reactionArrow.hasBeenPlaced = false;
				}
				reaction = o;
			}

			if ((o = parseOption("autoez")) != null) {
				// autoez = optionTest;
				smilesPars.autoez = o;
			}

			if ((o = parseOption("stereo")) != null)
				stereo = o;

			if ((o = parseOption("canonize")) != null)
				canonize = o;

			if ((o = parseOption("multipart")) != null)
				if (multipart != o) {
					multipart = o;
					// repaint = true;
				}

			// New: handling the negative option
			if (o = parseOption("autonumber") != null) {
				if (autonumber != o) {
					autonumber = o;
					if (autonumber) {
						setNumber(true);
//						return repaint; // BH 2023.01.21 why return???
					}
				}
			}

			if (o = parseOption("number") != null) {
				setNumber(o.booleanValue());
			}

			if (o = parseOption("showatommapnumberwithbackgroundcolor") != null) {
				params.showAtomMapNumberWithBackgroundColor = o;
			}

			if ((o = parseOption("newlook")) != null) {
				newLook = o;
				resetAllGraphics();
			}
			if ((o = parseOption("oldlook")) != null) {
				newLook = !o;
				resetAllGraphics();
			}

			if ((o = parseSynonymOptions(parameters, "star1", "marker1")) != null) {
				if (markOnly1 != o) {
					markOnly1 = o;
					if (o) {
						params.number = params.mark = o; // why
																	// number?
					} else {

					}
					mustRedrawEverything();

				}

			}

			if ((o = parseOption("markermenu")) != null) {
				markerMenu = o;
			}

//			if ((optionTest = parseSynonymOptions(parameters, markerMultiColorOptionJLabel )) != null) {
//				if (moleculeHandlingParameters.markerMultiColor != optionTest) {
//					moleculeHandlingParameters.markerMultiColor = optionTest;
//					
//					mustRedrawEverything();
			//
//				}
			//
//			}

			// atom marking will not happen, but an event will be triggered
			if ((o = parseOption("pseudomark")) != null) {
				pseudoMark = o;
			}

			if ((o = parseOption("markatomonly")) != null) {
				starAtomOnly = o;
				if (starAtomOnly) {
					starBondOnly = false;
					if (starNothing) {
						// repaint = true;
					}
					starNothing = false;
				}
			}
			if ((o = parseOption("markbondonly")) != null) {
				starBondOnly = o;
				if (starBondOnly) {
					starAtomOnly = false;
					if (starNothing) {
						// repaint = true;
					}
					starNothing = false;
				}
			}

			if ((o = parseOption("marknothing")) != null) {
				if (starNothing != o) {
					// repaint = true;
					starNothing = o;
				}
			}

			if ((o = parseOption("fgmenu")) != null) {
				fgMenuOption = o;
				mustReDrawTopMenu = true;
			}

			if ((o = parseOption("toggle")) != null)
				toggleDepictEdit = o;

			// BB
			if ((o = parseOption("depictaction")) != null) {
				depictActionEnabled = o;
				if (depictActionEnabled) {
					setDepictOption(true);
				}
			}
			if ((o = parseOption("showdraganddropoiconindepictmode")) != null)
				showDragAndDropIconInDepictMode = o;
			// older naming of the same option
			if ((o = parseOption("showdraganddropsymbolindepictmode")) != null)
				showDragAndDropIconInDepictMode = o;
			if ((o = parseOption("addnewpart")) != null)
				addNewPart = o;

			if ((o = parseOption("exportinchi")) != null)
				exportInchi = o;
			if ((o = parseOption("exportinchikey")) != null)
				exportInchiKey = o;
			if ((o = parseOption("exportinchiauxinfo")) != null)
				exportInchiAuxInfo = o;
			if ((o = parseOption("searchinchikey")) != null)
				searchInchiKey = o;
			if ((o = parseOption("exportsvg")) != null)
				exportSVG = o;

			if ((o = parseOption("exportrxnmerge")) != null)
				exportRXNmergeOption = o;

			if ((o = parseOption("contextmenu")) != null)
				contextMenuEnabledOption = o;
			if ((o = parseOption("fullscreenicon")) != null)
				fullScreenIconOption = o;
			if ((o = parseOption("showfullscreeniconindepictmode")) != null)
				showFullScreenIconInDepictMode = o;

			if ((o = parseOption("useoclidcode")) != null)
				useOclIdCode = o;

			if ((o = parseOption("xbutton")) != null) {
				if (xButton != o) {
					xButton = o;
					// repaint = true;
				}

			}
			if ((o = parseOption("paste")) != null)
				if (paste != o) {
					paste = o;
				}

			if ((o = parseOption("border")) != null)
				if (depictBorder != o) {
					depictBorder = o;
					// repaint = true;
					mustRedrawEverything();
				}

			// undocumented options
//			if (parameters.indexOf("writesmi") > -1)
//				writesmi = true;
//			if (parameters.indexOf("writemi") > -1)
//				writemi = true;
//			if (parameters.indexOf("writemol") > -1)
//				writemol = true;
			if (parameters.indexOf("nocenter") > -1)
				nocenter = true;
			if (parameters.indexOf("jmeh") > -1)
				jmeh = true;
			if (parameters.indexOf("showan") > -1)

				showAtomNumbers = true;
			// System.out.println(rButton+"
			// "+moleculeHandlingParameters.hydrogenHandlingParameters.showHs+" "+query+"
			// "+autoez+"
			// "+stereo+" "+canonize+" "+reaction);

			// BB
			if ((o = parseOption("atommovebutton")) != null)
				showAtomMoveJButton = o;
			if ((o = parseOption("useopenchemlib")) != null)
				useOpenChemLib = o;
			if ((o = parseOption("zoom")) != null)
				allowGUIzooming = allowZooming = o;

			// new Feb 2022
			if ((o = parseOption("zoomgui")) != null)
				allowGUIzooming = o && allowZooming;

			
			
			// zladi options - ake dalsie ???
			if (reaction) {
				// BB: if a reaction is read, then the numbering should be autonumber and not
				// number. This should be checked by Peter.
				// With autonumber, one can assign different atom map numbers
				// number = true;
				autonumber = true;
				multipart = true;
			}
			if (!isDepict())
				depictBorder = false;
			// positions and actions for X and Rx buttons
			// nove X a R action musia byt > 300
//			if (rButton)
//				LEFT_MENU_NUMBER_OF_CELLS++;
			LEFT_MENU_NUMBER_OF_CELLS = determineNumberLeftMenuNumberOfCell();

			
			handleAdditionalOptions(options);
			
			resetJPopupMenu(); // the pop menu contains entries and labels that night need to be removed or
								// added or changed

			// if star is disabled , then go back to default action
			if (action == ACTION_MARK && (params.mark == false || starNothing)) {
				action = ACTION_BOND_SINGLE;
				// repaint = true;
			}

//			return repaint;
		}

		private void setDepictOption(boolean tf) {
			boolean depicting = isDepict();
			if (tf != depicting) {
				if (depicting) {
					// BB CHeck if nodepictaction is used
					setDepict(false);
					// molecularAreaScale = 1; // inak kresli mensi font
					resetMolecularAreaScale();

					// october 2019 - depict bug fix

					// musi male molekuly vratit na povodnu velkost
					// for (int i = 1; i <= numberofMoleculeParts; i++) {
					// moleculeParts[i].scaling();
					// moleculeParts[i].center(); // este raz, teraz uz zmensene
					// }

					// JMEmol.centerMolList(this, moleculeParts, numberofMoleculeParts);

					// BB moved above - fixed a bug
					// depictScale = 1; // inak kresli mensi font
					// normal font (ak bola mensia molekula) sa nastavi v
					// drawMolecularArea
					menuCellSize = standardMenuCellSize;
					if (activeMol != null) {
						// mol.needRecentering = true; // october 2019 bug
					}

					paste = true; // BB March 2014 :
					// paste option will be set below
					resetAllGraphics();
				} else {
					setDepict(true);
					menuCellSize = 0;
					molecularAreaImage = null; // pre prechode z depict je ta primala
					// toto len pre norm moleculeParts, nie pre reaction !!!
					// alignMolecules(1, numberofMoleculeParts, 0); //will be done during the
					// repaint
					paste = false; // BB March 2014 : default does not accept paste anymore

					// October 2019
					if (moleculePartsList.size() > 0) {
						// this is done when reading the input file
						// JMEmol.scaleInternalBondMolList(moleculeParts,
						// numberofMoleculeParts);
						// JMEmol.centerMolList(this, moleculeParts, numberofMoleculeParts);
						molecularAreaScalePixelsPerCoord = scaleAndCenterForDepictMode(graphicalObjectList());
					}
					resetAllGraphics();
				}
			}
		}

		private void setNumber(boolean tf) {
			if (params.number != tf)
				mustReDrawTopMenu = true;
			params.number = tf;
			if (!params.number)
				autonumber = false;
			else {
				if (params.mark)
					mustRedrawEverything(); // if star option is selected later
				params.mark = false;
			}
		}

	}

	public void handleAdditionalOptions(String options) {
		// for subclasses
	}

	public static void main(String args[]) {
		JFrame frame = new JFrame("JME Molecular Editor");
		frame.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent evt) {
				System.exit(0);
			}
		});
		frame.setBounds(300, 200, 24 * 18, 24 * 16); // urcuje dimensions pre
		JME jme = new JME(frame);
		frame.setVisible(true);
		jme.start(args);
	}


} // End of JME class
