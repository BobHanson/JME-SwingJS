/***
 * 
 * 
 * 
 * 
 * 
 */


package jme;

//START JAVA_IMPORT
import java.util.Vector;
import java.util.regex.Pattern;

//
import gwt_compat.GWT;
import gwt_compat.RunAsyncCallback;
//
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;
import java.applet.Applet;
import java.applet.AppletContext;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.io.InputStreamReader;
//
//
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
//
//
import netscape.javascript.JSObject;//To compile JME, you have to link with the NetScape library (plugin.jar) which is available in all JRE distributions, e.g.for linux:  /usr/lib/jvm/java-7-oracle/jre/lib/plugin.jar
import jme.ChemicalFormatDetector.Author;
import jme.ChemicalFormatDetector.MajorChemicalFormat;

//



//END JAVA_IMPORT





//START GWT_IMPORT


//import java.util.Vector;
//import java.util.HashMap;


//import com.actelion.research.chem.MolfileCreator;
//import com.actelion.research.chem.SmilesParser;
//import com.actelion.research.chem.StereoMolecule;
//import com.google.gwt.core.client.GWT;
//import com.google.gwt.user.client.Window;
//import com.google.gwt.core.client.RunAsyncCallback;

//import ejava.awt.Image;
//import ejava.applet.Applet;
//import ejava.awt.BasicStroke;
//import ejava.awt.Component;
//import ejava.awt.BorderLayout;
//import ejava.awt.Button;
//import ejava.awt.Choice;
//import ejava.awt.MenuItem;
//import ejava.awt.Point;
//import ejava.awt.Color;
//import ejava.awt.Dimension;
//import ejava.awt.Event;
//import ejava.awt.FlowLayout;
//import ejava.awt.Dialog;
//import ejava.awt.Font;
//import ejava.awt.FontMetrics;
//import ejava.awt.Frame;
//import ejava.awt.Graphics;
//import ejava.awt.Rectangle;
//import ejava.awt.GridLayout;
//import ejava.awt.Label;
//import ejava.awt.Panel;
//import ejava.awt.PopupMenu;
//import ejava.awt.RenderingHints;
//import ejava.awt.TextField;
//import ejava.awt.Toolkit;
//import ejava.awt.event.ActionEvent;
//import ejava.awt.event.ActionListener;
//import ejava.awt.event.WindowAdapter;
//import ejava.awt.event.WindowEvent;
//import ejava.awt.geom.Rectangle2D;
//import ejava.util.Arrays;
//import ejava.util.StringTokenizer;
//import ejava.util.regex.Pattern;
//import ejava.lang.System;
//import ejava.net.URL;
//import ejava.applet.AppletContext;
//import ejava.net.MalformedURLException;
//import enetscape.javascript.JSObject;


//import ejava.awt.event.MouseWheelEvent;
//import ejava.awt.event.MouseWheelListener;

//import ejava.awt.Container;

//END GWT_IMPORT



//OpenChemLib import
import com.actelion.research.chem.MolfileCreator;
import com.actelion.research.chem.MolfileParser;
import com.actelion.research.chem.SmilesParser;
import com.actelion.research.chem.StereoMolecule;
import com.actelion.research.chem.AbstractDepictor;
import com.actelion.research.chem.IDCodeParser;
import com.actelion.research.chem.SVGDepictor;

import jme.ChemicalFormatDetector.MajorChemicalFormat;
import jme.TextTransfer.PasteAction;



class TouchedMol {
	int molIndex;
	int atomIndex;
	int bondIndex;
	double distance;
	
	
	public boolean equals(TouchedMol other) {
		return this.molIndex == other.molIndex && this.atomIndex == other.atomIndex && this.bondIndex == other.bondIndex;
		
	}
	
	public void reset() {
		molIndex = 0;
		atomIndex = 0;
		bondIndex = 0;
	}
	
	public void initMyselfWith(TouchedMol other) {
		this.molIndex = other.molIndex;
		this.atomIndex = other.atomIndex;
		this.bondIndex = other.bondIndex;
		
	}
	public boolean isTouched() {
		return this.molIndex>0 &&(this.atomIndex >0 || this.bondIndex >0);
	}
}


// ----------------------------------------------------------------------------
// ****************************************************************************
@SuppressWarnings("serial")
public class JME extends Applet implements ActionListener, MouseWheelListener /*, MouseListener*/  {



	protected static final String OCL_ID_CODE_LABEL = "OCL ID code" /* + " to the clipboard" */;
	private static final String UN_MARK_ATOM = "unMarkAtom";
	private static final String MARK_ATOM = "markAtom";
	private static final String ADD_ATOM_QUERY = "addAtomQuery";
	private static final String CHARGE_ATOM_MINUS = "chargeAtom-";
	private static final String CHARGE_ATOM_PLUS = "chargeAtom+";
	private static final String CHARGE_ATOM0 = "chargeAtom0";
	private static final String DEL_ATOM2 = "delAtom";
	private static final String SET_ATOM = "setAtom";
	private static final String DEL_BOND2 = "delBond";
	private static final String DEL_ATOM = JME.DEL_ATOM2;
	private static final String MARK = "mark";
	private static final String AUTO_NUMBER = "autonumber";
	private static final String SD_FSTACK = "SDFstack";
	private static final String REDO = "redo";
	private static final String UNDO = "undo";
	private static final String READ_MOL_FILE = "readMolFile";
	private static final String READ_RXN_FILE = "readRXNFile";
	private static final String READ_JME = "readJME";
	private static final String READ_SMILES = "readSMILES";
	private static final String READ_SMIRKS = "readSMIRKS";
	private static final String READ_OCLCODE = "readOCLCode";
	
	private static final String CLEAR = "clear";
	private static final String RESET = "reset";
	/* for recording events to external program */
	private static final String ADD_GROUP = "addGroup";
	private static final String ADD_TEMPLATE = "addTemplate";
	private static final String ADD_ATOM = "addAtom";
	private static final String ADD_RING = "addRing";
	private static final String ADD_BOND = "addBond";
	private static final String ADD_CHAIN = "addChain";
	private static final String UN_MARK_BOND = "unMarkBond";
	private static final String MARK_BOND = "markBond";
	private static final String SET_QUERY_BOND = "setQueryBond";
	private static final String ADD_RING_BOND = "addRingBond";
	private static final String SET_BOND_TRIPLE = "setBondTriple";
	private static final String SET_BOND_SINGLE = "setBondSingle";
	private static final String SET_BOND_COORDINATION = "setBondCoordination";
	private static final String UNSET_BOND_COORDINATION = "unSetBondCoordination";
	private static final String SET_BOND_DOUBLE = "setBondDouble";
	private static final String SET_BOND_STEREO = "setBondStereo";
	private static final String DEL_BOND_GROUP = "delBondGroup";
	private static final String DEL_BOND = JME.DEL_BOND2;
	
	private static final String MOVE_ATOM = "moveAtom";
	private static final String CHANGE_CHIRAL = "changeChiral";
	static final String CHANGE_ATOM_MAP = "changeAtomMap";
	static final String CHANGE_MANY_ATOM_MAP = "changeManyAtomMap";
	static final String DELETE_HYDROGENS = "deleteHydrogens" ;
	static final String DELETE_ATOM_MAPS = "deleteAtomMaps" ;

	static final String CHANGE_REACTION_ROLE = "changeReactionRole";
	private static final String REACTION_COPY = "reactionCopy";
	
	// editor state
	int action;
	
	TouchedMol lastTouchedMol = new TouchedMol();
	
	TouchedMol newTouchedMol = new TouchedMol();
	
	int reactionParts[][] ; //computed with getReactionParts()
	
	int active_an;
	static boolean isStandAloneApplication = false; //by default the program starts as an applet
	// static String separator =
	// System.getProperties().getProperty("line.separator");
	static String separator = "\n";

	// customization
	static final String version = "2014-06-28";
	//static final String startInfoText = "JSME Molecular Editor by Peter Ertl and Bruno Bienfait";
	static final String startInfoText = "Molecular Editor by Peter Ertl and Bruno Bienfait"; //JSME or JME selected according to the run time environment
	static final String copyright[] = {"Copyright (c) 2014, Novartis Institutes for BioMedical Research Inc. and Bruno Bienfait.",  "All rights reserved."};
	//Note: the copyright is too long for the info()
	int copyRigthmallTextFontSize = 8; //used in the info box for copyright
	Font copyRigthSmallTextFont = new Font(null, 0, copyRigthmallTextFontSize);

	public String helpUrl = "http://peter-ertl.com/jsme/2013_03/help.html";

	String infoText = null;
	String customDefaultInfoText = ""; //may be changed by the JS call

	//BB: renamed sd to a more meaningful name
	//int sd = 24;
	final double standardMenuCellSize = 24; //the original value
	double menuCellSize = standardMenuCellSize; //should be a multiple of 2 and 3, is set 0 in depict mode
	boolean newLook = false;
	

	final double rightBorderNewLook = 1.0;
	final double rightBorderOldLook = 3; //older look needs more space because of it has a shadow

	
	int arrowWidth = 24 * 2;
	
	
	// the IO triangle/arrows
	double ioMargin = 3;
	double ioArrowWidth = ((double)(menuCellSize - 2 * ioMargin) / 1.5);
	
	//in depict mode, make the DnD and full screen icons smaller
	double smallerIconsForDepictMode = 0.6;
	
	static final Color bgColor = Color.lightGray;
	static final Color brightColor = bgColor.brighter();

	protected enum CopyPasteAction {
		COPY_SMILES, COPY_MOL, COPY_MOL_V3000, COPY_INCHI, COPY_INCHI_KEY, COPY_INCHI_AUXINFO,  COPY_OCLCODE, SEARCH_INCHI_KEY, 
		COPY_SVG, PASTE
	}

	protected JMEevent afterStructureChangeEvent =  new JMEevent();

	
	//icons
	protected Icon  fullScreenIcon;
	protected boolean isFullScreen = false;
	protected boolean fullScreenEnterOrExit = false;

	protected Icon dragAndDropIcon;
	
	//Fonts
	Font menuCellFont;
	Font menuCellFontBold; //for the atom symbols
	Font menuCellFontSmaller;
	Font atomDrawingAreaFont,dialogFont;
	FontMetrics menuCellFontMet, menuCellFontBoldMet, menuCellFontSmallerMet;
	FontMetrics atomDrawingAreaFontMet ;

	int fontSize = 13; //with a value != 12, the stringWidth errors are minimized in JS
	float atomMolecularDrawingAreaFontSize = fontSize; //BB
	
	String defaultFontFamily = "Helvetica"; //looks good everywhere
	//BB if null: use the system default font - looks nice also in Java
	//String defaultFontFamily = "sansserif"; //Java: Helvetica is discouraged in Java 1.1 and should be replaced by sansserif
	//String defaultFontFamily = "Sans-Serif"; //CSS

	protected boolean appletHasBeenResized = false;
	Rectangle2D.Double previousScaledScreenArea = null;

	/**
	 * the menu cell border differs in new and old look
	 * @return
	 */
	int menuCellBorder() {
		return newLook? 1: 0;
		// will be changed to 0 when !newLook
	}


	protected float molecularAreaLineWidth = (float) 1.0;
	
	
	public float getMolecularAreaLineWidth() {
		return molecularAreaLineWidth;
	}

	/**
	 * Line width in pixel
	 * @param molecularAreaLineWidth
	 */
	public void setMolecularAreaLineWidth(float molecularAreaLineWidth) {
		this.molecularAreaLineWidth = molecularAreaLineWidth;
		this.drawMolecularAreaRightNow();

	}

	public boolean molecularAreaAntiAlias = true;
	
	
	public boolean isMolecularAreaAntiAlias() {
		return molecularAreaAntiAlias;
	}

	/**
	 * Set antialias for the molecular drawing area
	 * @param molecularAreaAntiAlias
	 */
	public void setMolecularAreaAntiAlias(boolean molecularAreaAntiAlias) {
		this.molecularAreaAntiAlias = molecularAreaAntiAlias;
		this.drawMolecularAreaRightNow();
	}

	/**
	 * Used for the test suite
	 * @param width
	 * @param height
	 */
	public JME setDimension(int width, int height) {
		if(this.dimension == null) {
			this.dimension = new Dimension();
		}
		this.dimension.setSize(width, height);
		return this;
	}


	// tieto parametere sa naplnaju v init (aby sa vynulovali pri starte)
	boolean bwMode = false;
	boolean runsmi = false; // traba to, alebo sa automaticky setne v param smi
	// ??
	String depictcgi = null;
	String depictservlet = null;

	boolean canonize = true;;
	boolean stereo = true;
	boolean multipart = true; // vzdy aj pri reaction
	boolean xButton = true;
	boolean paste = true; //BB: allow pasting structures, should be disabled in depict mode
	boolean rButton = false;
	boolean showHydrogens = true; //on heteroatom labels OH , NH2, ...
	boolean query = false;
	protected boolean reaction = false;
	boolean autoez = true;
	
	//unused options
	//boolean writesmi = false;
	//boolean writemi = false;
	//boolean writemol = false;
	
	boolean jmeh = false; //used in jSME

	
	boolean number = false;
	boolean star = false;
	boolean autonumber = false;
	protected boolean depict = false;
	boolean toggleDepictEdit = false; //BB
	boolean depictActionEnabled = false; //BB allow editing in depict mode
	boolean depictBorder = false;
	public boolean keepHydrogens = true;
	boolean removeOnlyCHydrogens = false;
	
	boolean addNewPart = false; //when reading a or pasting a mol: add it or replace everything in the canvas
	
	boolean pasteFromSDFstack = false;
	
	boolean exportInchi = true;
	boolean exportInchiKey = true;
	boolean searchInchiKey = true;
	boolean exportInchiAuxInfo = false;
	boolean useOclIdCode = false; //OpenChemLib
	boolean exportSVG = true;

	boolean contextMenuEnabledOption = true;
	
	boolean fullScreenIconOption = true;
	protected boolean exportRXNmergeOption = false;

	
	Color canvasBg = Color.white;
	String atomColors = null; // atom coloring
	String atomBgColors = null; // background coloring
	
	
	protected double molecularAreaScale = 1.0; // ked scaling viacero moleculeParts, alebo reaction
	protected final double minmolecularAreaScale = 0.3 ;
	protected final double maxMolecularAreaScale = 10 ;
	


	protected double menuScale = 1.0; //BB scaling the menu
	protected final double minMenuScale = 0.7 ;
	protected final double maxMenuScale = 4 ;
	
	
	//double previousDepictScale = depictScale;
	final boolean scalingIsPerformedByGraphicsEngine = true; //BB, gives nicer looking depiction
	
	boolean nocenter = false;
	boolean polarnitro = false; 
	boolean showAtomNumbers = false; // only when starting with a molecule
	// scaling pri depict, nacitanie molekul (jme + mol)

	boolean showAtomMoveButton = true; //BB
	//boolean mdlV2000ChiralFlag = false; //for v2000 note: v300 has also a chiral flag
	protected boolean useOpenChemLib = true; //for SMILES input
	
	boolean showDragAndDropIconInDepictMode = true ; //BB
	boolean showFullScreenIconInDepictMode = true ; //BB

	boolean allowZooming = true;
	boolean allowFullScreenToggle = true;
	
	// files na nacitanie (2002.06)
	protected String smilesString = null;
	String jmeString = null;
	String molString = null;

	// pouziva v double bufferingu
	protected Dimension dimension;
	
	protected PreciseImage molecularAreaImage;
	int molecularAreaWidth ;
	int molecularAreaHeight ;
	
	//these images are not used in depict mode
	PreciseImage topMenuImage, leftMenuImage;
	PreciseImage infoAreaImage;
	PreciseImage rightBorderImage;
	
	
	// pre repaint()
	//boolean doMenu = true; // ci draw menu pri repaint()
	boolean movePossible; // not to move when dragg in menu

	// BB - avoid unnecessary redraw - speed optimization for slow browsers
	boolean mustReDrawLeftMenu = true;
	boolean mustReDrawTopMenu = true;
	boolean mustReDrawMolecularArea = true;
	boolean mustReDrawInfo = true;
	boolean mustReDrawRightBorderImage = true;


	protected String notifyStructuralChangeJSfunction = null;
	protected String notifyAtomHighLightJSfunction = null;
	protected String prePasteJSfunction = null;

	protected String pasteLabel = null;

	//boolean atomWasTouched = false;
	//boolean bondWasTouched = false;
	
	
	//the ACTION code on which the mouse was during mouse move
	int mouseWasOverAction = 0;
	
	
	public String getPasteLabel() {
		return pasteLabel;
	}

	/**
	 * Customization of the paste label
	 * @param pasteLabel
	 */
	public void setPasteLabel(String pasteLabel) {
		this.pasteLabel = pasteLabel;
		//rebuild the menu each time the pasteLabel is changed
		this.copyPastePopupMenuMol = this.createCopyPastePopupMenu(false);
	}

	
	// actions 2 riadky s ACTIONX a atomy s ACTIONA
	static int LEFT_MENU_NUMBER_OF_CELLS = 10; // meni sa podla rxButton
	static final int LEFT_MENU_NUMBER_OF_CELLS_WITHOUT_X_R = 9;
	// cislo action urcuje aj polohu buttonu
	// empty buttons (a ACTION_END v aplete) su vyradene v mousePressed()
	// a kreslenie textov v createSquare (neda sa to v jednom ?)
	static final int ACTION_DELETE = 104;
	static final int ACTION_MARK = 105;
	static final int ACTION_DELGROUP = 106;
	static final int ACTION_SMI = 101;
	static final int ACTION_QRY = 107;
	static final int ACTION_REACP = 109;
	static final int ACTION_UNDO = 110;
	static final int ACTION_REDO = 111;
	static final int ACTION_SPIRO = 112; //BB: was 111
	static final int ACTION_CLEAR = 102;
	static final int ACTION_NEW = 103; // using newMolecule
	
	static final int ACTION_MOVE_AT = 113; //BB: new
	
	static final int ACTION_JME = 114; //BB: was 113
	
	
	
	
	//BB: the number of cells in the top menu - was ACTION_X
	static final int TOP_MENU_NUMBER_OF_CELLS = ACTION_JME - 100; //assume that ACTION_JME is the last menu entry on the top row

	
	static final int ACTION_PGUP = 151;
	static final int ACTION_PGDN = 152;
	static final int ACTION_HOME = 153;
	static final int ACTION_END = 154;
	
	static final int ACTION_ROT90 = 156; // webme
	static final int ACTION_CHARGE_PLUS = 157; // webme
	static final int ACTION_CHARGE_MINUS = 158; // webme

	static final int ACTION_CHARGE = 108;
	static final int ACTION_STEREO = 201;
	static final int ACTION_BOND_SINGLE = 202;
	static final int ACTION_BOND_DOUBLE = 203;
	static final int ACTION_BOND_TRIPLE = 204;
	static final int ACTION_CHAIN = 205;
	static final int ACTION_RING_3 = 206;
	static final int ACTION_RING_4 = 207;
	static final int ACTION_RING_5 = 208;
	public static final int ACTION_RING_PH = 209;
	static final int ACTION_RING_6 = 210;
	static final int ACTION_RING_7 = 211;
	static final int ACTION_RING_8 = 212;

	static final int ACTION_FG = 213; //BB: button for a popup menu with functional groups
	//static final int ACTION_EMPTY_CELL = 214; //BB: defined only to avoid highliting when click on it, to be removed?
	static final int ACTION_IO = 214; //BB replace ACTION_EMPTY_CELL by I/O icon below info icon


	static final int ACTION_RING_FURANE = 221; // nema button
	static final int ACTION_RING_3FURYL = 223; // Alt 0
	static final int ACTION_RING_9 = 229; // nema button
	static final int ACTION_TEMPLATE = 230;


	static final int ACTION_GROUP_MIN = 233; //BB first entry in the substituents (FG)
	static final int ACTION_GROUP_TBU = 233;
	static final int ACTION_GROUP_NITRO = 234;
	static final int ACTION_GROUP_COO = 235;
	static final int ACTION_GROUP_CF3 = 236;
	static final int ACTION_GROUP_CCL3 = 237;
	static final int ACTION_GROUP_CC = 238;
	static final int ACTION_GROUP_SULFO = 239;
	static final int ACTION_GROUP_COOME = 240;
	static final int ACTION_GROUP_OCOME = 241;
	static final int ACTION_GROUP_CYANO = 242;
	static final int ACTION_GROUP_NME2 = 243;
	static final int ACTION_GROUP_NHSO2ME = 244;
	static final int ACTION_GROUP_CCC = 245;
	static final int ACTION_GROUP_C2 = 246;
	static final int ACTION_GROUP_C3 = 247;
	static final int ACTION_GROUP_C4 = 248;
	static final int ACTION_GROUP_COH = 249;
	static final int ACTION_GROUP_dO = 250; // =O
	static final int ACTION_GROUP_PO3H2 = 251;
	static final int ACTION_GROUP_SO2NH2 = 252;
	static final int ACTION_GROUP_TEMPLATE = 253;
	static final int ACTION_GROUP_CF = 254;
	static final int ACTION_GROUP_CL = 255;
	static final int ACTION_GROUP_CB = 256;
	static final int ACTION_GROUP_CI = 257;
	static final int ACTION_GROUP_CN = 258;
	static final int ACTION_GROUP_CO = 259;
	static final int ACTION_GROUP_CON = 260; //BB
	static final int ACTION_GROUP_NCO = 261; //BB
	static final int ACTION_GROUP_MAX = 262; // last+1 len na < test


	static final int ACTION_AN_C = 301;
	static final int ACTION_AN_N = 401;
	static final int ACTION_AN_O = 501;
	static final int ACTION_AN_S = 601;
	static final int ACTION_AN_F = 701;
	static final int ACTION_AN_CL = 801;
	static final int ACTION_AN_BR = 901;
	static final int ACTION_AN_I = 1001;
	static final int ACTION_AN_P = 1101;
	static final int ACTION_AN_X = 1201;
	static final int ACTION_AN_H = 1300;
	static final int ACTION_AN_R = 1301;
	static final int ACTION_AN_R1 = 1302;
	static final int ACTION_AN_R2 = 1303;
	static final int ACTION_AN_R3 = 1304;
	//added by BB
	static final int ACTION_AN_R4 = 1305;
	static final int ACTION_AN_R5 = 1306;
	static final int ACTION_AN_R6 = 1307;
	static final int ACTION_AN_R7 = 1308;
	static final int ACTION_AN_R8 = 1309;
	static final int ACTION_AN_R9 = 1310;
	static final int ACTION_AN_R_LAST = 1310;
	//end added by BB
	
	
	//JSME custom atomic numbers for use in Atom.na
	//TODO Element table
	static final int AN_H = 1;
	static final int AN_B = 2;
	static final int AN_C = 3;
	static final int AN_N = 4;
	static final int AN_O = 5;
	static final int AN_SI = 6;
	static final int AN_P = 7;
	static final int AN_S = 8;
	static final int AN_F = 9;
	static final int AN_CL = 10;
	static final int AN_BR = 11;
	static final int AN_I = 12;
	static final int AN_SE = 13;
	
	//BB
	//https://en.wikipedia.org/wiki/List_of_oxidation_states_of_the_elements
	static final int AN_K = 14;
	static final int AN_METAL1_START = AN_K;
	static final int AN_Na = 15;
	static final int AN_Li = 16;
	static final int AN_Rb = 17;
	static final int AN_Cs = 18;
	static final int AN_Fr = 19;
	static final int AN_Ag = 20;
	static final int AN_METAL1_END= AN_Ag;

	static final int AN_Mg = AN_METAL1_END+1;
	static final int AN_METAL2_START = AN_Mg;
	static final int AN_Ca= AN_Mg+1;
	static final int AN_Ba= AN_Ca+1;
	static final int AN_Sr= AN_Ba+1;
			;
	static final int AN_Zn= AN_Sr+1;
	static final int AN_Ni= AN_Zn+1;
	static final int AN_Cu= AN_Ni+1;
	static final int AN_Cd= AN_Cu+1;
	
	static final int AN_METAL2_END= AN_Cd;

	static final int AN_METAL3_START = AN_METAL2_END+1;
	static final int AN_Al= AN_METAL3_START;
	static final int AN_Ga= AN_Al + 1;
	static final int AN_Au= AN_Ga + 1;
	static final int AN_METAL3_END= AN_Au;
	
	
	static final int AN_X = AN_METAL3_END+1;
	static final int AN_R = AN_X+1;
	//static final int AN_R1 = 20;
	//static final int AN_R2 = 21;
	//static final int AN_R3 = 22;
	//added by BB
	static final int AN_R_LAST = AN_R + 9; //keep the 9! 1 value for each R

	static final int actionToAtomNumberArray[] = {
			ACTION_AN_C, AN_C,
			ACTION_AN_N, AN_N,
			ACTION_AN_O, AN_O,
			ACTION_AN_F, AN_F,
			ACTION_AN_CL, AN_CL,
			ACTION_AN_BR, AN_BR,
			ACTION_AN_I, AN_I,
			ACTION_AN_S, AN_S,
			ACTION_AN_P, AN_P,
			ACTION_AN_H, AN_H,
			ACTION_AN_X, AN_X,
			ACTION_AN_R, AN_R
	};
	//coud have used a HAshMap, but the code to initialize a hashmap is about the same - JS is much better here for simple dict
	protected int mapActionToAtomNumber(int action, int notFound) {
		int result = notFound;
		for(int i=0;  i< actionToAtomNumberArray.length; i+=2) {
			if(actionToAtomNumberArray[i] == action) {
				result =  actionToAtomNumberArray[i+1];
				break;
			}
		}
		//patch related to determineNumberLeftMenuNumberOfCell
		if(result == AN_X) {
			if(!this.xButton && this.rButton) { //X button has been removed and replaced by R button
				result = AN_R;
			}
		}
		return result;
	}
	protected int determineNumberLeftMenuNumberOfCell() {
		int result = LEFT_MENU_NUMBER_OF_CELLS_WITHOUT_X_R;
		if(this.rButton) {
			result ++;
		}
		if(this.xButton) {
			result ++;
		}
		
		return result;
		
	}

	static final Color color[] = new Color[AN_R_LAST+1];
	static final String zlabel[] = new String[AN_R_LAST+1];

	// info about last action & undo
	int lastAction = 0; // trva len po mouse up
	static final int LA_BOND = 1;
	static final int LA_RING = 2;
	static final int LA_GROUP = 3;
	static final int LA_MOVE = 5;
	static final int LA_ROTATE = 7; //BB used for rotation on touch event
	static final int LA_SCALE = 8; //BB used for scaling on touch event
	static final int LA_FAILED = 9; // failed to create bond or ring
	boolean newMolecule = false; // enable to start new molecule
	int xold, yold; // position of mousePressed, updated in mouseDragged
	boolean afterClear = false; // info pre undo
	boolean mouseShift = false; // kvoli numbering

	//boolean isContextMenu = false; //right mouse click

	MultiBox smilesBox = null, atomxBox = null, aboutBox = null;
	QueryBox queryBox;
	boolean spiroAdding = false;
	boolean movingAtom = false ; //BB
	
	String molText = null;
	// JMEmol mol = new JMEmol(this); // sposobovalo problemy v NS
	JMEmol mol; //BB: the molecule JME is presently working on
	JMEmol uniColorMolecule = null;
	
	int numberofMoleculeParts = 0;
	int actualMoleculePartIndex = 0;
	int saved = 0; // ktora molekula jindexe saved pri multipart
	
	InspectorEvent inspectorEvent;
	
	String template = null; // template as jme string
	JMEmol templateMolecule = null; // template molecule - functional groups?
	static final int maxParts = 99;

	JMEmol moleculeParts[] = new JMEmol[maxParts]; // when multipart, nealokuje !!
	JMEmol smol; // save

	/**
	 * Storage of the state of the chemical structures of restoring for by the undo manager
	 * @author bruno
	 *
	 */
	class SavedState {
		JMEmol moleculeParts[] = new JMEmol[maxParts]; // when multipart, nealokuje !!
		int numberofMoleculeParts = 0;
		int actualMoleculePartIndex = 0;
		boolean reaction;
		boolean multipart;
		double depictScale = 1.0;
		public int lastAction;
	}

	//BB undo & redo section
	final boolean  canMultipleUndo = true; //when false, use Peter's original implementation, otherwise use the changeManager
	ChangeManager<SavedState> molChangeManager;

	static String programName; //JSME or JME


	// static Color[] psColor;
	static Color[] psColor = new Color[7];

	// BB : eclipse added the <JMEmol>
	Vector<JMEmol> molStack = new Vector<JMEmol>();

	//BB
	SDFstack sdfStack = new SDFstack();

	int stackPointer = -1;
	boolean doTags = false; // compatibility with JMEPro
	final boolean webme = false; // compatibility with JMEPro
	public int[] apointx, apointy, bpointx, bpointy; // coordinates for webme
	boolean revertStereo = false; // down stereo bond (only 1 action)
	boolean relativeStereo = false;
	boolean allHs = false;
	// for key marking 2009.04
	boolean resetExtendAtomMark = true;
	int keyboradInputMark = -100;
	boolean markFromKeyboardInput = false;

	// images
	//Image infoImage, clearImage, deleteImage, deleterImage, chargeImage;
	//Image templatesImage, rtemplatesImage, undoImage, endImage, smiImage,
	//smitImage, smartsImage, stereoImage, stereoxImage;

	//BB
	//true if the Java code has been compiled to JavaScript
	final boolean isJavaScript = System.getProperty("java.vm.name" ).equals("JavaScript");

	//BB: true for touch device iPad, Android
	final static boolean isTouchSupported = System.getProperty("is_touch_supported") != null;

	//BB for copy & paste
	protected TextTransfer clipBoardManager = new TextTransfer();
	PopupMenu copyPastePopupMenuMol;
	PopupMenu copyPastePopupMenuReaction;
	
	
	//local popup menu for the touched molecule/atom
	PopupMenu touchedMolPopuMenu;
	static String setChiralFlagAction = "Set molecule Chiral flag";
	static String unSetChiralFlagAction = "Unset molecule chiral flag";

	static String inspectAtomAction = "Change atom map";
	static String autoAtomMapMoleculeAction = "Auto atom map molecule";
	static String deleteAtomMapMoleculeAction = "Delete all atom map molecule";
	final static String deleteHydrogensMoleculeAction = "Delete hydrogens";
	
	final static String bondCoordination = "et coordination bond";
	final static String bondSetCoordinationAction = "S" + bondCoordination;
	final static String bondUnSetCoordinationAction = "Uns"+ bondCoordination;
	
	//functional group selection coming from the HTML example page
	String functionalGroups[] = 
			new String[]{"-C(=O)OH", "-C(=O)OMe", "-OC(=O)Me", "-C(=O)N", "-NC=O", "-CMe3", "-CF3", "-CCl3", "-NO2",
			"-SO2-NH2", "-NH-SO2-Me", "-NMe2", "-C#N", "-C#CH", "-C#C-Me" };

	PopupMenu functionalGroupPopumemu;
	private Point functionalGroupPopupMenuPosition;
	private Point fixedCopyPastePopupMenuPosition;
	private long lastRotation;
	private boolean bondRubberBanding = false;
	protected PasteAction pasteAction;
	private boolean mouseDownWasUsed;
	private boolean saveCurrentState = false; //when true means the current state of the chemical structures must be saved in the undo state manager
	
	protected  String searchInchiKeyMenuLabel ="Search chemical structure (through InChIKey)";
	private boolean alignMoleculesHasBeenPerformedByReadingStructure;
	protected Rectangle2D.Double  reactionArrowBoundingBox;
	
	
	
	//private int lastTouchedMoleculePart;

	public double getMolecularAreaScale() {
		return molecularAreaScale;
	}

	//used by mouse wheel event in reaction mode in reaction mode
	public void setMolecularAreaScale(double newScale) {
		//should we limit scaling if one molecule becomes invisible?
		if(newScale != this.molecularAreaScale) {
			Rectangle2D.Double dim1 = this.getMolecularAreaBoundingBoxCoordinate();
			this.molecularAreaScale =newScale;
			Rectangle2D.Double dim2 = this.getMolecularAreaBoundingBoxCoordinate();
			recenterMoleculesAfterMolecularAreaChange(dim1, dim2);
			this.redrawMoleculartAreaOnly();
		}
	}

	public void recenterMoleculesAfterMolecularAreaChange(Rectangle2D.Double before, Rectangle2D.Double after) {
		double moveX = after.getCenterX() - before.getCenterX();
		double moveY = after.getCenterY() - before.getCenterY();
		
		moveAllMolecules(moveX, moveY);
		
	}
	public double getMenuScale() {
		return menuScale;
	}

	public void setMenuScale(double menuScale) {
		if(menuScale != this.menuScale) {;
			this.menuScale = menuScale;
			this.resetAllGraphics();
			this.repaint();
		}
	}

	// ----------------------------------------------------------------------------
	public JME() {
		mol = new JMEmol(this);
		psColor[0] = Color.gray;
		psColor[1] = new Color(255, 153, 153); // pastel red
		psColor[2] = new Color(255, 204, 102);
		psColor[3] = new Color(255, 255, 153);
		psColor[4] = new Color(102, 255, 255);
		psColor[5] = new Color(51, 204, 255);
		psColor[6] = new Color(255, 153, 255);
		
		lastTouchedMol.molIndex = 1;
		newTouchedMol.molIndex = 1;
		moleculeParts[1] = mol;
		
		inspectorEvent = new InspectorEvent(this);

		//this.alert("isTouchSupported: " + isTouchSupported);
		reactionArrowBoundingBox = new Rectangle2D.Double();

	}

	//-----------------------------------------------------------------------------
	// Shortcuts for molecule
	
	
	/**
	 * 
	 * Change atom coordinate
	 * @param mol
	 * @param atomIndex
	 * @param x
	 * @param y
	 */
	protected void XY(JMEmol mol, int atomIndex, int x, int y) {
		mol.XY(atomIndex, screenToDrawingX(x), screenToDrawingY(y));
	}
	
	//NOT USED!!!!
	/**
	 * Move to atom 
	 * @param mol
	 * @param atomIndex
	 * @param x
	 * @param y
	 */
	protected void moveXY(JMEmol mol, int atomIndex, int x, int y) {
		mol.moveXY(atomIndex, screenToDrawingX(x), screenToDrawingY(y));
	}
	
	// ----------------------------------------------------------------------------
	protected PopupMenu createCopyPastePopupMenu(boolean isReaction) {

		PopupMenu popup = new PopupMenu();

		String smilesOrSmirks = "SMILES";
		String molOrReaction = "MOL";
		String molOrReactionForPasting = "MOL or SDF";
		Boolean hasAtom = !this.isMolecularAreEmpty();

		//String what = "chemical structure(s)";
		if(isReaction) {
			smilesOrSmirks = "SMIRKS";
			molOrReaction = "RXN" ;
			//what = "reaction";
			molOrReactionForPasting = molOrReaction;
		}

		if(useOpenChemLib) {
			molOrReactionForPasting += " or " + smilesOrSmirks;
			if(! isReaction && this.useOclIdCode) {
				molOrReactionForPasting += " or " + JME.OCL_ID_CODE_LABEL;
			}
		}

		//COPY SMILES
		MenuItem mi = new MenuItem("Copy " /*+ what */ + "as "+ smilesOrSmirks /*+ " to the clipboard"*/);
		mi.setActionCommand(CopyPasteAction.COPY_SMILES.toString());
		popup.add(mi);
		mi.setEnabled(!hasAtom);
		mi.addActionListener(this);

		//COPY MOL
		mi = new MenuItem("Copy " /*+ what */+ "as " +  molOrReaction /*+ " to the clipboard"*/);
		mi.setActionCommand(CopyPasteAction.COPY_MOL.toString());
		mi.addActionListener(this);
		popup.add(mi);

		//COPY V3000 MOL
		if(!isReaction) {
			mi = new MenuItem("Copy " /*+ what */+ "as " +  molOrReaction  + " V3000" /*+ " to the clipboard"*/);
			mi.setActionCommand(CopyPasteAction.COPY_MOL_V3000.toString());
			mi.addActionListener(this);
			popup.add(mi);
			
			
			//handling Inchi: only available for JSME - use the inchi-js
			if (this.canComputeInchi()) {
				if (this.exportInchi) {
					mi = new MenuItem("Copy " /* + what */ + "as " + "InChI" /* + " to the clipboard" */);
					mi.setActionCommand(CopyPasteAction.COPY_INCHI.toString());
					mi.addActionListener(this);
					mi.setEnabled(!hasAtom);
					popup.add(mi);

				}

				if (this.exportInchiKey) {
					mi = new MenuItem("Copy " /* + what */ + "as " + "InChI key" /* + " to the clipboard" */);
					mi.setActionCommand(CopyPasteAction.COPY_INCHI_KEY.toString());
					mi.addActionListener(this);
					mi.setEnabled(!hasAtom);
					popup.add(mi);

				}
				if(this.searchInchiKey) {
					mi = new MenuItem(this.searchInchiKeyMenuLabel );
					mi.setActionCommand(CopyPasteAction.SEARCH_INCHI_KEY.toString());
					mi.addActionListener(this);
					mi.setEnabled(!hasAtom);
					popup.add(mi);
					
				}
				if (this.exportInchiAuxInfo) {
					mi = new MenuItem("Copy " /* + what */ + "as " + "InChI auxinfo" /* + " to the clipboard" */);
					mi.setActionCommand(CopyPasteAction.COPY_INCHI_AUXINFO.toString());
					mi.addActionListener(this);
					mi.setEnabled(!hasAtom);
					popup.add(mi);

				}
			}
			
		}
		
		if(this.useOpenChemLib &&  this.exportSVG && !isReaction) {
			mi = new MenuItem("Copy " /* + what */ + "as " + "Scalar Vector Graphics");
			mi.setActionCommand(CopyPasteAction.COPY_SVG.toString());
			mi.addActionListener(this);
			popup.add(mi);
			
		}

		if(this.useOpenChemLib &&  this.useOclIdCode && !isReaction) {
			mi = new MenuItem("Copy " /* + what */ + "as " + JME.OCL_ID_CODE_LABEL);
			mi.setActionCommand(CopyPasteAction.COPY_OCLCODE.toString());
			mi.addActionListener(this);
			mi.setEnabled(!hasAtom);
			popup.add(mi);
			
		}
		//PASTE
		if(this.paste) {
			popup.addSeparator();
			String localPasteLabel = this.getPasteLabel(); 
			if(localPasteLabel == null) {
				localPasteLabel= "Paste " + molOrReactionForPasting; //default, no customization
			}
			mi = new MenuItem(localPasteLabel);
	
			mi.setActionCommand(CopyPasteAction.PASTE.toString());
			mi.addActionListener(this);
			popup.add(mi);
			
		}
		this.add(popup); //set the parent the popup

		return popup;

	}

	/**
	 * To be redefined in subclass
	 * @return true if this implementation can compute inchi
	 */
	protected boolean canComputeInchi() {
		return false;
	}

	/**
	 * 
	 * @return
	 */
	protected PopupMenu createMolPopupMenu(JMEmol mol, int eventX, int eventY) {
		PopupMenu popup = new PopupMenu();
		
		boolean showAtomMappingToolsInMenu = number || autonumber ||reaction;
		MenuItem setUnsetChiralFlagMenuItem;
		if (mol.getChiralFlag()) {
			setUnsetChiralFlagMenuItem = new MenuItem(unSetChiralFlagAction);
		} else {
			setUnsetChiralFlagMenuItem = new MenuItem(setChiralFlagAction);
		}
		
		setUnsetChiralFlagMenuItem.setEnabled(mol.canBeChiral());
		
		
		popup.add(setUnsetChiralFlagMenuItem);
		setUnsetChiralFlagMenuItem.addActionListener(this);
		
		if(showAtomMappingToolsInMenu && mol.touchedAtom > 0) {
			MenuItem atomInspectoMenuItem = new MenuItem(inspectAtomAction);
			atomInspectoMenuItem.addActionListener(this.inspectorEvent);
			this.inspectorEvent.reset();
			this.inspectorEvent.atomIndex = mol.touchedAtom;
			this.inspectorEvent.mol = mol;
			this.inspectorEvent.x = eventX;
			this.inspectorEvent.y = eventY;
			this.inspectorEvent.molIndex = this.actualMoleculePartIndex;
			
			
			
			popup.add(atomInspectoMenuItem);
		}

		
		
		MenuItem deleteHydrogensMenuItem = new MenuItem(deleteHydrogensMoleculeAction);
		deleteHydrogensMenuItem.setEnabled(mol.hasHydrogen());
		
		popup.add(deleteHydrogensMenuItem);
		deleteHydrogensMenuItem.addActionListener(this);
		
		if(showAtomMappingToolsInMenu) {
			MenuItem mapMenuItem =new MenuItem(autoAtomMapMoleculeAction);
			mapMenuItem.addActionListener(this);
			popup.add(mapMenuItem);

			mapMenuItem =new MenuItem(deleteAtomMapMoleculeAction);
			mapMenuItem.addActionListener(this);
			popup.add(mapMenuItem);
			mapMenuItem.setEnabled(mol.geMaxAtomMap()>0);
				
		}
		
		MenuItem bondInspectoMenuItem = new MenuItem();
		String label = bondSetCoordinationAction;
		bondInspectoMenuItem.setEnabled(false);
		if(mol.touchedBond > 0 ) {
			Bond bond = mol.bonds[mol.touchedBond];
			if(bond.isSingle() || bond.isCoordination()) {
				label = bond.isCoordination()?bondUnSetCoordinationAction:bondSetCoordinationAction;
				//bondInspectoMenuItem.addActionListener(this.inspectorEvent); //not used
				this.inspectorEvent.reset();
				this.inspectorEvent.bondIndex = mol.touchedBond;
				this.inspectorEvent.mol = mol;
				this.inspectorEvent.x = eventX;
				this.inspectorEvent.y = eventY;
				this.inspectorEvent.molIndex = this.actualMoleculePartIndex;
			
				bondInspectoMenuItem.setEnabled(true);
				bondInspectoMenuItem.addActionListener(this);

			}
		}
		bondInspectoMenuItem.setLabel(label);
		popup.add(bondInspectoMenuItem);
		

		return popup;

	}

	// ----------------------------------------------------------------------------
	public static void main(String args[]) {
		isStandAloneApplication = true;
		JME jme = new JME();
		Frame frame = new Frame("JME Molecular Editor");
		frame.add("Center", jme);
		// frame.resize(24*18,24*16); // urcuje dimensions pre aplikaciu
		frame.setBounds(300, 200, 24 * 18, 24 * 16); // urcuje dimensions pre
		// aplikaciu
		jme.init();
		if (args.length == 1)
			jme.options(args[0]);
		frame.show();
		// po frame.show, aby boli zname dimension
		jme.start();

		// reads molecule (from 2008.12)
		String fileName = null;
		for (int i = 0; i < args.length; i++) {
			if (args[i].startsWith("-f")) {
				fileName = args[++i];
			} else if (args[i].startsWith("-o")) {
				jme.options(args[++i]);
			}
		}
		/*
		 * if (fileName != null) { jme.dimension = jme.size();
		 * jme.readFile(fileName); }
		 */
		
		//BB
		// Add a window listener JDK 1.1 for closing the window using the X button of the window
		//Note: BB removed the END button
		frame.addWindowListener ( new WindowAdapter() {
			public void windowClosing ( WindowEvent evt ) {
				System.exit(0);
			}
		});
		
		
		//works
		//frame.addMouseWheelListener(jme);

	}

	// BB - this method can be used only by input events methods
	void mustRedrawNothing() {
		mustRedrawImages(false);
	}

	// BB
	public void mustRedrawEverything() {
		mustRedrawImages(true);
	}
	public void mustRedrawImages( boolean yesOrNo) {
		mustReDrawLeftMenu = yesOrNo;
		mustReDrawTopMenu = yesOrNo;
		mustReDrawMolecularArea = yesOrNo;
		mustReDrawInfo = yesOrNo;
		mustReDrawRightBorderImage = yesOrNo;
		
	}
	public void mustReDrawMolecularArea() {
		mustReDrawMolecularArea = true;
	}
	
	public void redrawEverything() {
		this.mustRedrawEverything();
		this.repaint();
	}

	// --------------------------------------------------------------------------
	public Color getColor() {
		return bgColor; // it may be used to color other stuff with mi colors
	}

	// --------------------------------------------------------------------------
	public void activateQuery() {
		// v JME menu nastavi na query (ak bolo medzitym ine)
		if (action != JME.ACTION_QRY) {
			action = ACTION_QRY;
			repaint();
		}
	}

	// ----------------------------------------------------------------------------
	@Override
	public void init() {

		if(this.isJavaScript) {
			programName = "JSME";
		} else {
			programName = "JME" ;
		}

		Container parent = this.getParent();
		parent.addMouseWheelListener(this); //works
		//parent.addMouseListener(this); //has no effects in Java in Applet or Application run mode

		// tu su veci co suvisia s grafikou

		// addMouseListener(this);
		// addMouseMotionListener(this);
		// addKeyListener(this);

		//BB
		//this.copyPastePopupMenuMol = this.createCopyPastePopupMenu(false);
		//this.copyPastePopupMenuReaction = this.createCopyPastePopupMenu(true);

		//Show the copyright stuff at the bottom of the page when the applet starts
		info(programName + " " + startInfoText);




		dimension = size(); // potrebne pre centrovanie nacitanej molekuly //needed for centering loaded molecules
		log("init: " + dimension.width + " " + dimension.height);
		setLayout(null);

		// NS3 ma error vo font metrics (nedava ascent)
		//fontSize = 8;


		if (menuCellFont == null) { // kvoli IE, ktory aj pri Back vola init
			menuCellFont = new Font(defaultFontFamily, Font.PLAIN, fontSize);
			menuCellFontMet = getFontMetrics(menuCellFont);
		}
		if (menuCellFontBold == null) { // kvoli IE, ktory aj pri Back vola init
			menuCellFontBold = new Font(defaultFontFamily, Font.BOLD, fontSize);
			menuCellFontBoldMet = getFontMetrics(menuCellFontBold);
		}

		// int fs = fontSize-1;
		int smallerFontSize = fontSize - 2; //OK for the Java VM

		if (menuCellFontSmaller == null) {
			menuCellFontSmaller = new Font(defaultFontFamily, Font.PLAIN, smallerFontSize);
			menuCellFontSmallerMet = getFontMetrics(menuCellFontSmaller);
		}

		//BB: independent font size for the dialog boxes
		if(this.dialogFont == null) {
			//BB It is not necesssary to specify a font, the default one looks good
			this.dialogFont = null;
			//this.dialogFont = new Font(null, Font.PLAIN, this.dialogFontSize);
		}
		
		
		//BB: independant font size for the atoms in the molecular area
		//if(this.atomDrawingAreaFont == null) {

		initatomDrawingAreaFont(this.atomMolecularDrawingAreaFontSize);
		
		// este aj tu aby sa vzdy iniciovali pre reload
		// ??? urobit to lepsie
		query = false;
		reaction = false;
		autoez = true;
		stereo = true;
		canonize = true;
		xButton = true;
		rButton = false;
		LEFT_MENU_NUMBER_OF_CELLS = this.determineNumberLeftMenuNumberOfCell();
		showHydrogens = true;

		if (!isStandAloneApplication) {
			try { // chytanie exception kvoli startu z ineho appletu
				String options = getParameter("options");
				if (options != null)
					options(options, false);
				String jme = getParameter("jme");
				if (jme != null)
					jmeString = jme;
				String molf = getParameter("mol");
				if (molf != null)
					molString = molf;
				String dc = getParameter("depictcgi");
				if (dc != null) {
					depictcgi = dc;
					runsmi = true;
				} // sets runsmi, pred smi
				// v parametroch depictcgi PRED smiles, upravit ????
				String s = getParameter("smiles");
				if (s != null)
					smilesString = s;
				String mt = getParameter("text");
				if (mt != null) {
					molText = mt;
					repaint();
				}
				atomColors = getParameter("atomcolors"); // only 1 of these 2
				atomBgColors = getParameter("atombg");
				String bc = getParameter("depictbg");
				if (bc != null && depict)
					canvasBg = parseHexColor(bc);

				if (showAtomNumbers)
					showAtomNumbers();

				String jsFunction = getParameter("notify_structural_change_js_function");
				this.setNotifyStructuralChangeJSfunction(jsFunction);

			} catch (Exception e) {
				//System.err.println("JME:no parameters");
			}
		}

		action = ACTION_BOND_SINGLE; // musi to tu but, inak nic

		// get gif icons
		// Toolkit toolkit = Toolkit.getDefaultToolkit();
		// infoImage =
		// toolkit.getImage(getClass().getResource("jmeimages/info.gif"));

		// negraficka inicializacia
		//atomicData();

		// 2002.06
		validate();

		//BB
		if(this.canMultipleUndo) {
			this.molChangeManager = new ChangeManager<SavedState>();
			//this.postSave(); //no effects because mol is not part of the array molparts and because it has no atoms
		}

	}
	
	//the cache is useful for JSME when there are many instance in depict mode for performance reason
	//stringWidht is expensive, the JSAppplet implementation has a cache inside each font metric instance
	public static final int maxFontSize = 100;
	public static Font[] atomDrawingAreaFontCache = new Font[maxFontSize];
	public static FontMetrics[] atomDrawingAreaFontMetCache = new FontMetrics[maxFontSize];
	
	public void initatomDrawingAreaFont(float realFs) {
		int fs = Math.round(realFs);
		if(fs < maxFontSize) {
			if(atomDrawingAreaFontCache[fs] == null) {
				atomDrawingAreaFontCache[fs]= new Font(defaultFontFamily, Font.PLAIN, fs);
			}
			if(atomDrawingAreaFontMetCache[fs] == null) {
				atomDrawingAreaFontMetCache[fs] = getFontMetrics(atomDrawingAreaFontCache[fs]);
			}
		
			this.atomDrawingAreaFont = atomDrawingAreaFontCache[fs];
			this.atomDrawingAreaFontMet =  atomDrawingAreaFontMetCache[fs];
		} else {
			assert(false);
			
		}
		
	}

	public void setAtomDrawingAreaFontSize(float fs) {
		if(this.atomMolecularDrawingAreaFontSize != fs && fs > 0 && fs < maxFontSize) {
			this.atomMolecularDrawingAreaFontSize = fs;
			initatomDrawingAreaFont(fs);
			this.drawMolecularAreaRightNow();
		}
	}
	// ----------------------------------------------------------------------------
	private Color parseHexColor(String hex) {
		Color c = Color.white;
		try {
			if (!hex.startsWith("#"))
				throw new Exception("bad hex encoding");
			int r = Integer.parseInt(hex.substring(1, 3), 16);
			int g = Integer.parseInt(hex.substring(3, 5), 16);
			int b = Integer.parseInt(hex.substring(5, 7), 16);
			c = new Color(r, g, b);
			return c;
		} catch (Exception e) {
			System.err.println("Problems in parsing background color " + hex);
			return c;
		}
	}
	


	// ----------------------------------------------------------------------------
	@Override
	public void start() {
		// System.err.println("start");
		// cita molekuly (uz by malo poznat dimension)
		// addNotify(); // ??? nekompatibilne z mipc
		//dimension = size(); //already done in init()
		//log("start: " + dimension.width + " " + dimension.height);


		if (jmeString != null) {
			readMolecule(jmeString, false); //no repaint because the applet viewer will call repaint() after start()
			// co s coloring multipart a reactions ???
			// only 1 coloring scheme (atoms || bg) may be applied
			if (atomBgColors != null && mol != null)
				mol.setAtomColors(atomBgColors, true);
			if (atomColors != null && mol != null)
				mol.setAtomColors(atomColors, false);
			//this.postSave(); //BB not needed - readMolecule does it

		} else if (molString != null) {
			readMolFile(molString, false); // coloring tam //no repaint because the applet viewer will call repaint() after start()
			//this.postSave(); //BB not needed -readMolFile does it
		}
		// else if (smiles != null) readSmiles(smiles);
		// toto musi byt after vytvotrenie mol, aby bolo dimenzovane
		
		else if (smilesString != null && this.useOpenChemLib) {

			// with a local or global instance of RunAsyncCallback, then code split does not work
//			this.read_MOL_SDF_RXN(smilesString, null); // works also
			
			//async conversion with open chemlib
			//redraiwng the molecular area will be performed by the async call
			//after the OCL code is loaded and the smiles converted to MOL
			this.mustReDrawMolecularArea = false; //the function calling this function will call paint in parallel,  DOES NOT WORK test_depict_many_smiles_in_table.html
			this.handleReadGenericInput(smilesString, null, true); //will call paint to redraw the molecular area after the smiles has been decoded
		}
	}

	// ----------------------------------------------------------------------------
	public void stop() {
		// System.err.println("stop");
		if (smilesBox != null)
			smilesBox.dispose();
		if (atomxBox != null)
			atomxBox.dispose();
		if (aboutBox != null)
			aboutBox.dispose();
		if (queryBox != null)
			queryBox.dispose();
		moleculeParts = null; // memory leak ?
	}

	// ----------------------------------------------------------------------------
	// --- public functions
	// -------------------------------------------------------
	// ----------------------------------------------------------------------------
	// for JavaScript to establish connection with JME
	public void ping() {
	}

	// ----------------------------------------------------------------------------
	public String smiles() {


		String smiles = Smiles();
		//this.mustRedrawNothing(); //BB - info will be redrawed if changed




		//mol.touchedAtom = 0;
		//mol.touchedBond = 0;

		//BB why repaint???
		//repaint(); // aby ked je chyba v smilesi (stereo) aby sa objavilo info
		//transaltion form google: so that when the error is in the SMILES (stereo) to appear Info


		return smiles;
	}

	// ----------------------------------------------------------------------------
	public String nonisomericSmiles() {
		boolean originalStereo = stereo;
		stereo = false;
		String smiles = Smiles();
		stereo = originalStereo;
		//BB: I commented the line below
		//repaint(); // aby ked je chyba v smilesi, aby sa objavilo info
		
		return smiles;
	}

	// ----------------------------------------------------------------------------
	String Smiles() {
		String s;
		if (reaction)
			s = partSmiles(1) + ">" + partSmiles(2) + ">" + partSmiles(3);
		else {
			s = partSmiles(0);
			if (s.length() > 0) {
				molStack.addElement(new JMEmol(mol)); // adding molecule to
				// stack
				// skoci na koniec s molsack pointer
				stackPointer = molStack.size() - 1;
			}
		}
		return s;
	}

	// ----------------------------------------------------------------------------
	String partSmiles(int pp) {
		// vracia multipart smiles, ak pp != 0 (reaction) iba pre tu part
		// neskor pridat sort jednotlivych smilesov (alfanumeric)
		String s = "";
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			if (pp > 0) {
				int p = moleculeParts[m].reactionPart();
				if (p != pp)
					continue;
			}
			//String smiles = moleculeParts[m].createSmilesWithSideEffect();//BB: original SMILES
			String smiles = moleculeParts[m].createSmiles(); //BB: make a copy of the mol and do createSmilesWithSideEffect on it
			if (smiles.length() > 0) {
				if (s.length() > 0)
					s += ".";
				s += smiles; // ta molekula moze byt empty
			}
		}
		return s;
	}

	// ----------------------------------------------------------------------------
	public void reset(boolean repaint) {
		// volane zvonka - vymaze vsetko
		action = ACTION_BOND_SINGLE;
		newMolecule = false;
		
		clearMyMolecularContent();
		clearInfo();

		molText = null;
		// BB
		resetMolecularAreaScale();
		
		this.recordAfterStructureChangedEvent(JME.RESET);
		//notifyStructuralChangeToJS(); //recordAfterStructureChangedEvent performs notifyStructuralChangeToJS
		if(repaint)
			repaint();
		

	}
	public void reset() {
		this.reset(true);
	}
	
	public void resetMolecularAreaScale() {
		if(this.isFullScreen()) {
			molecularAreaScale = fullScreenScale;
		} else {
			molecularAreaScale = 1.; // ??? ked depict viac molekul po sebe
		}
	}
	
	public void clearMyMolecularContent() {
		numberofMoleculeParts = 0;
		// JMEmol.maxMark = 0;
		actualMoleculePartIndex = 0;
		mol = new JMEmol(this); // treba
		mol.maxMark = 0;

		molText = null;
		mustReDrawMolecularArea();

		
	}
	// ----------------------------------------------------------------------------
	
	public void clear() {
		clear(true);
	}
	public void clear(boolean recordEvent) {
		// zmaze actualMoleculePartIndex, zmensi pocet molekul, actual bude najvyssia



		action = ACTION_BOND_SINGLE;
		newMolecule = false;
		clearInfo();

		if (numberofMoleculeParts == 0)
			return;

		// BB
		mustReDrawMolecularArea = true;

		afterClear = true;
		for (int i = actualMoleculePartIndex; i < numberofMoleculeParts; i++)
			moleculeParts[i] = moleculeParts[i + 1];
		numberofMoleculeParts--;
		actualMoleculePartIndex = numberofMoleculeParts;
		if (numberofMoleculeParts > 0)
			mol = moleculeParts[actualMoleculePartIndex]; // kvoli move
		else {
			mol = new JMEmol(this);
			mol.maxMark = 0;
		}
		
		if(recordEvent) {
			this.recordAfterStructureChangedEvent(JME.CLEAR);
			//this.notifyStructuralChangeToJS(); //recordAfterStructureChangedEvent calls notifyStructuralChangeToJS
		}
		//Jan 2016
		//this.postSave();

	}

	// ----------------------------------------------------------------------------
	public String jmeFile() {
		// returns molecule(s) in jme format
		String s = "";
		if (reaction)
			s = partJme(1) + ">" + partJme(2) + ">" + partJme(3);
		else
			s = partJme(0);
		return s;
	}

	// ----------------------------------------------------------------------------
	String partJme(int pp) {
		// vracia multipart jme, ak pp != 0 (reaction) iba pre tu part
		// neskor pridat sort jednotlivych smilesov (alfanumeric)
		String s = "";
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			if (pp > 0) {
				int p = moleculeParts[m].reactionPart();
				if (p != pp)
					continue;
			}
			String jme = moleculeParts[m].createJME();
			if (jme.length() > 0) {
				if (s.length() > 0)
					s += "|";
				s += jme; // ta molekula moze byt empty
			}
		}
		return s;
	}

	// ----------------------------------------------------------------------------
	int[][] getReactionParts() {
		// returns fields of indices for reactants, products and modulators
		int part[][] = new int[ReactionRole.all.length + 1][numberofMoleculeParts + 1];
		for (int p : ReactionRole.all) { //role loop
			int np = 0;
			for (int m = 1; m <= numberofMoleculeParts; m++)
				if (moleculeParts[m].reactionPart() == p)
					part[p][++np] = m;
			part[p][0] = np;
		}
		return part;
	}
	// ----------------------------------------------------------------------------
	//NOT USED OR TESTED TO GE DELETED
	JMEmol[] getMergedReactionParts() {
		

		JMEmol results[] = new JMEmol[ReactionRole.maxRole+1];
		
		int parts[][] = getReactionParts();
		
		for (int role : ReactionRole.all) { //role loop
			JMEmol toMerge[] = new JMEmol[parts[role].length];
			for (int mol: parts[role]) {
				toMerge[mol] = moleculeParts[mol];
			}
			results[role] = new JMEmol(this, toMerge, toMerge.length);
		}
		return results;
	}

	/**
	 * Compare two reaction parts array and returns the first molecule index  that has changed its reaction role or 0 if no changed.
	 * This method is useful to generate an event when one of the molecules has been moved
	 * 
	 * @param parts1
	 * @param parts2
	 * @return the molecule index or 0
	 */
	int findFirstMoleculeIndexWithDifferentReactionRole(int [][] parts1, int[][] parts2) {
		//the arguments are computed by getReactionParts()
		//if(Arrays.equals(parts1, parts2)) //does not work: doesn't go deep
		//	return 0;
		for(int role = 1; role <= 3; role++) {
			if(Arrays.equals(parts1[role], parts2[role]))
				continue;
			int n1 = parts1[role][0];
			int n2 = parts1[role][0];
			assert(n1==n2); //see getReactionParts()
			for(int i=1; i<= n1; i++) {
				if(parts1[role][i] != parts2[role][i]) {
					if(parts1[role][i] == 0) {
						return parts2[role][i];
					} else {
						return parts1[role][i];
					}
				}
			}
			
		}
		return 0;
	}
	/**
	 * Useful to find the max atom map of e.g. all reactants
	 * @param moleculeParts
	 * @param whichMolecules
	 * @return
	 */
	int findMaxAtomMapOfMoleculeParts( JMEmol moleculeParts[], int reactionRole) {
		int max = 0;
		int [][] allReactionParts = getReactionParts();
		int [] reactionPartsWithRole = allReactionParts[reactionRole];
		for(int i=1; i<=reactionPartsWithRole[0]; i++) {
			int m = moleculeParts[reactionPartsWithRole[i]].geMaxAtomMap();
			if(m>max) max = m;
			
		}
		
		return max;
	}
	/**
	 * Read a molecule string in JME format
	 * @param molecule
	 * @param repaint 
	 */
	public boolean readMolecule (String molecule, boolean repaint) {
		boolean success;
		try {
			if(success=this.handleReadMolecule(molecule, repaint)) {
				
			} else {
				repaint(); //to show errors
			}
		} catch(Exception e) {
			success = false;
			repaint() ; //for showing the error
		}
		
		return success;
	}
	/**
	 * Read a molecule string in JME format
	 * @param molecule
	 */
	public void readMolecule (String molecule) {
		this.readMolecule(molecule, true);
	}

	//this code is almost never used and is problably buggy because it was not tested
	//especialy molecule align
	// ----------------------------------------------------------------------------
	// makos
	protected boolean  handleReadMolecule(String molecule, boolean repaint) {
		// spracuva aj multipart a reactions (aj chybu R>P miesto R>>P)
		// input v JME format


		//this.postSave();

		//reset(repaint); //BB : cancel this: it set numberofMoleculeParts to 0
		int lastReactant = 0, firstProduct = 0;

		StringTokenizer st = new StringTokenizer(molecule, "|>", true);
		boolean inputIsReaction = (molecule.indexOf(">") > -1); //false meas it is a molecule
		int rx = 1; // pocita >

		int nt = st.countTokens();
		boolean addedToExistingParts = numberofMoleculeParts > 0;
		if (! canBeAddedToExistingMultipartOrReaction() ||
				inputIsReaction) {//if reaction input: replace evrything
			numberofMoleculeParts = 0;
			addedToExistingParts = false;
		}
		

			
		for (int i = 1; i <= nt; i++) {
			String s = st.nextToken();
			s.trim();
			if (s.equals("|"))
				continue;
			if (s.equals(">")) {
				rx++;
				if (rx == 2)
					lastReactant = numberofMoleculeParts;
				else if (rx == 3)
					firstProduct = numberofMoleculeParts + 1;
				continue;
			}
			mol = new JMEmol(this, s, true);
			if (mol.natoms == 0) {
				this.showError("problems in reading/processing molecule !");
				System.err.println("ERROR while processing\n" + s);
				//continue;
				return false;  //BB
			}
			// vsetko ok - preberie ju do editora
			numberofMoleculeParts++; // moze byt aj multipart
			actualMoleculePartIndex = numberofMoleculeParts;
			moleculeParts[numberofMoleculeParts] = mol;
			// newMolecule = false;
			smol = null; // kvoli undo


		}

		// --- chyba v zadani reakcie (zly pocet >)
		if (rx == 2) {
			firstProduct = lastReactant + 1;
			this.showError("strange reaction - fixing !");
			System.err.println("ERROR - reactant and product should be separated by >>\n");
			return false;
		} else if (rx > 3) {
			this.showError("strange reaction !");
			System.err.println("ERROR - strange reaction !\n");
			return false;
		}

			//FIXME: duplicate code with reading MOL/RXN?
		if (numberofMoleculeParts > 1 && !inputIsReaction)
			options("multipart");
		if (inputIsReaction && !reaction)
			reaction=true;
		//if (!inputIsReaction && reaction && !addedToExistingParts)
		//	reaction=false;; //back to mol editing

		if (!inputIsReaction) {
			//BB: align only if needed to avoid overlap, otherwise keep original coordinates but scale if needed -does not seem to wotk
			if(!reaction) {
				alignMolecules(1, numberofMoleculeParts, 0, !addedToExistingParts);
			}
		} else {
			if(!addedToExistingParts) { //aligh with one extra mol : todo correctly
				alignMolecules(1, lastReactant, 1);
				alignMolecules(lastReactant + 1, firstProduct - 1, 2);
				alignMolecules(firstProduct, numberofMoleculeParts, 3);
			}
		}
		
		//BB
		this.setMaxMapAfterReadingInput();
		this.recordAfterStructureChangedEvent(JME.READ_JME);
		this.afterStructureChangeEvent.setOrigin_API();
		
		this.mustReDrawMolecularArea = true;
		if(repaint) 
			repaint(); 
		//this.recordAfterStructureChangedEvent(JME.READ_JME); //added June 2016 removed Aug 2016 because this will be done by the method calling this one
		
		return true;
	}

	public void showError(String errorMessage) {
		this.showInfo("ERROR - " + errorMessage);

	}

	// ----------------------------------------------------------------------------
	// adding template from JavaScript
	// template menu is actually JME string
	public void setTemplate(String t, String name) {
		// clear();
		afterClear = false; // otherwise problems in undo
		boolean savedStar = this.star; //BB
		star = false; //BB to avoid a side effect linked to atom mapping (marked atom)
		templateMolecule = new JMEmol(this, t, true); // defined globally
		star=savedStar; //BB - restore
		//templateMolecule.complete(); //BB: not needed because the call above does call complete()
		// now waiting for atom or free space click
		action = ACTION_GROUP_TEMPLATE;

		// mol.center();
		// numberofMoleculeParts = 1; actualMoleculePartIndex = 1; moleculeParts[1] = mol;

		info(name);
		repaint(); // needed to display status line
	}

	
	
	/**
	 * 
	 * @param m1 ??
	 * @param m2 ??
	 * @param reactionRole ??
	 */
	void alignMolecules(int m1, int m2, int reactionRole) {
		alignMolecules(m1, m2, reactionRole, false);
	}
	// --------------------------------------------------------------------------
	//BB side effects: compute the depictScale correctly for only one time if it is different than 1.0
	//recenter molecule in depict mode
	//m1 and m2 are indices of the molecules in molecularParts
	void alignMolecules(int m1, int m2, int reactionRole, boolean donotAlignJustScale) {

		if (nocenter)
			return; // aj pre depict ???
		int nm = m2 - m1 + 1;
		if (nm <= 0 || m1 > numberofMoleculeParts || m2 > numberofMoleculeParts)
			return;
		//double previousDepictScale = molecularAreaScale;
		
		//double center[] = new double[4];

		double RBOND = JMEmol.RBOND;
		double[] share = new double[99]; // share na 1 mol (used pri posune)
		double sumx = 0., sumy = 0., maxy = 0.;
		for (int i = m1; i <= m2; i++) {
			if(moleculeParts[i].nAtoms() == 0) continue; //boundingBox() returns null if no atoms
			Rectangle2D.Double moleculeBox = moleculeParts[i].boundingBox(); // zisti dimenzie
			sumx += moleculeBox.getWidth();//center[2]; //width of mol
			sumy += moleculeBox.getHeight(); //; //height of mol
			maxy = Math.max(maxy, moleculeBox.getHeight());

			share[i] = moleculeBox.getWidth();
			if (reactionRole == ReactionRole.AGENT)
				share[i] = moleculeBox.getHeight();
		}

		// prida medzery (na oboch stranach a medzi), pri !depict to netreba
		if (depict) {
			sumx += RBOND * (nm + 1); //add enough space between molecules
			sumy += RBOND * (nm + 1);
			maxy += RBOND; // malo by byt * 2, ale potom su velke okraje
		}

		// niekedy moze byt nulova
//		if (dimension == null || dimension.width == 0 || dimension.height == 0)
//			dimension = size();
//		// ??? od tychto nezavisi, ale musia tu byt (ide toto 2x)
//		if (dimension.width == 0)
//			dimension.width = 400;
//		if (dimension.height == 0)
//			dimension.height = 300;

		double scalex = 1., scaley = 1.;
		
		//compute the  size of the available display box for the molecular area
		Rectangle2D.Double widhtAndHeight;
		if(depict) //in depict mode, the scale will be recomputed, therefore we use the original size 
			widhtAndHeight = this.getMolecularAreaBoundingBox();
		else 
			widhtAndHeight = this.getMolecularAreaBoundingBoxCoordinate();
		
		
		int xsize = (int) widhtAndHeight.width;
		int ysize = (int) widhtAndHeight.height;

		if (reactionRole == ReactionRole.REACTANT || reactionRole == ReactionRole.PRODUCT)
			xsize = (xsize - arrowWidth) / 2;
		else if (reactionRole == ReactionRole.AGENT)
			ysize = ysize / 2;
		
		
		if (sumx >= xsize)
			scalex = (xsize) / sumx;
		if (maxy >= ysize)
			scaley = (ysize) / maxy;

		double medzera = 0.;
		if (depict) { // cize == 1.
			molecularAreaScale = Math.min(scalex, scaley); // inak dS = 1.
			log("alignMolecules Depict: molecularAreaScale=" + molecularAreaScale + " xsize=" + xsize + " ysize=" + ysize + "\n");
			medzera = RBOND * xsize / sumx;
			if (reactionRole == ReactionRole.AGENT)
				medzera = RBOND * ysize / sumy;
			

		}

		for (int i = m1; i <= m2; i++) {
			if (reactionRole == ReactionRole.AGENT)
				share[i] = share[i] * ysize / sumy; //share[i] was the y size of the molecule
			else
				share[i] = share[i] * xsize / sumx;//share[i] was the x size of the molecule
		}

		double shiftx = -xsize / 2.;
		double shifty = 0.;
		if (reactionRole == ReactionRole.REACTANT)
			shiftx = -xsize - arrowWidth / 2.;
		else if (reactionRole == ReactionRole.PRODUCT)
			shiftx = arrowWidth / 2.;
		else if (reactionRole == ReactionRole.AGENT) {
			shiftx = 0.;
			shifty = -ysize;
		} // preco nie ..+2*sd ???

		for (int i = m1; i <= m2; i++) {

			// ??? toto sposobuje problemy depictScale = 0 ???
			if (depict) { // pri depicte zmensuje
				assert(false);
				if (!this.scalingIsPerformedByGraphicsEngine) {
					moleculeParts[i].scaleXY(molecularAreaScale);
				}
				moleculeParts[i].center(); // este raz, teraz uz zmensene
			}

			// pri depict urobi aj medzeru
			if (reactionRole == ReactionRole.AGENT)
				shifty += (share[i] / 2. + medzera);
			else
				// part == ReactionRole.REACTANT, ReactionRole.PRODUCT, or 0
				shiftx += (share[i] / 2. + medzera);

			//BB correction afterwards, otherwise the shiftx and shifty are too small
//			if(this.scalingIsPerformedByGraphicsEngine) {
//				shiftx /= depictScale;
//				shifty /= depictScale;
//			}

			if(! donotAlignJustScale) { //bad patch to fix a bug
				moleculeParts[i].moveXY( shiftx, shifty);
	//			for (int a = 1; a <= moleculeParts[i].natoms; a++) {
	//				moleculeParts[i].moveXY(a, shiftx, shifty);
	//				moveXY(moleculeParts[i],a, shiftx, shifty);
	//				moleculeParts[i].x(a) += shiftx;
	//				moleculeParts[i].y(a) += shifty;
	//			}
			}

			if (reactionRole == ReactionRole.AGENT)
				shifty += share[i] / 2.;
			else
				shiftx += share[i] / 2.;

		}
		
		//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		//BB correction: the depictScale must be absolute
		//molecularAreaScale *= previousDepictScale; //used with iPad scaling
	}

	/**
	 * compute the space needed to display the molecular structures in the molecular area
	 * return null if there is nothing displayed
	 * includes the reaction arrow if present
	 * @return
	 */
	public Rectangle2D.Double getChemicalDrawingBoundingBox() {
		
		Rectangle2D.Double boundingBox = null;
		
		//loop through all molecules, extend the bounding box with each molecule
		for (int i = 1; i <= this.numberofMoleculeParts; i++) {
			
			Rectangle2D.Double moleculeBox = moleculeParts[i].boundingBox(); //create a new instance each time this method is called
			if(moleculeBox == null)
				continue;
			if(boundingBox == null ) {
				boundingBox = moleculeBox;
			} else {
				boundingBox = (Rectangle2D.Double) boundingBox.createUnion(moleculeBox);
			}

		}
		
		
		if(reaction) {
			//add the arrow object
			Rectangle2D.Double  scaledReactionArrowBoundingBox = new Rectangle2D.Double(
					reactionArrowBoundingBox.x,
					reactionArrowBoundingBox.y,
					reactionArrowBoundingBox.width,
					reactionArrowBoundingBox.height
			);
			
			if(boundingBox == null) {
				boundingBox = scaledReactionArrowBoundingBox;
			} else {
				boundingBox.createUnion(scaledReactionArrowBoundingBox);
			}
		}
		//leave a margin around the molecule 
		double margin = (double)JMEmol.RBOND /2;
		boundingBox.x -= margin;
		boundingBox.y -= margin;
		boundingBox.width += margin*2;
		boundingBox.height += margin*2;
		
		return boundingBox;
	}
	
	public Boolean isMolecularAreEmpty() {
		for (int i = 1; i <= this.numberofMoleculeParts; i++) {
			if(moleculeParts[i].natoms > 0)
				return true;
		}
		
		return false;

	}
	
	/**
	 * compute the maximum scale that can be used to fit all objects in the molecular drawing
	 * area
	 * 
	 * return -1 if there is nothing to display
	 */
	public double maximumScaleDisplayArea(Dimension appletDimension, double menuScale) {
		Rectangle2D.Double boundingBox = getChemicalDrawingBoundingBox();
		
		if(boundingBox == null)
			return -1;
		
		Rectangle2D.Double molecularAreaBox = this.getMolecularAreaBoundingBoxPixel(appletDimension, menuScale);
		
		
		double maxScale = Math.min(
				molecularAreaBox.width/ boundingBox.width,
				molecularAreaBox.height/boundingBox.height
				);
		
		return maxScale;
		
	}
	// --------------------------------------------------------------------------
	/**
	 * Create a V2000 MOL
	 * @return
	 */
	public String molFile() {
		return this.molFile(false);
	}
	
	public String molFile(boolean isV3000) {
		return this.molFileOrRxn(null, true, isV3000, exportRXNmergeOption);
	}
	public String molFileOrRxn(String header, boolean stampDate, boolean isV3000, boolean mergeReationComponents) {
		// creates mol file, multipart sd file or reaction (rxn file)
		
		if( header == null) {
			header = smiles(); // now, otherwise for multipart cuts them
		}
		
		String s = "";
		if (reaction) {
			int nReactants;
			int nProducts;
			int nAgents;
			int part[][] = getReactionParts();
			if(mergeReationComponents ) {
				nReactants = 1;
				nProducts = 1;
				nAgents = 1;
			} else {
				nReactants = part[ReactionRole.REACTANT][0];
				nProducts = part[ReactionRole.PRODUCT][0];
				nAgents = part[ReactionRole.PRODUCT][0];
			
			}
			
			
			s += "$RXN" + separator + separator + separator
					+ "JME Molecular Editor" + separator;
			s += JMEmol.iformat(nReactants, 3) + JMEmol.iformat(nProducts, 3);
			if(part[2][0] > 0) { //if agents are present
				s += JMEmol.iformat(nAgents, 3);
			}
			s += separator;
			
			//reactants products, agents
			for(int role : new int[] {ReactionRole.REACTANT, ReactionRole.PRODUCT, ReactionRole.AGENT}){
				if(mergeReationComponents && part[role][0] > 1) {
					JMEmol toMerge[] = new JMEmol[part[role][0]+1];
					for (int mol: part[role]) {
						toMerge[mol] = moleculeParts[mol];
					}

					JMEmol merged =new JMEmol(this, toMerge, toMerge.length);
					s += "$MOL" + separator
							+ merged.createMolFile(header, stampDate);
				} else {
					for (int i = 1; i <= part[role][0]; i++) {
						s += "$MOL" + separator
						+ moleculeParts[part[role][i]].createMolFile(header, stampDate);
					}
				}
			}
				
		} else { // viac molekul do 1 mol file
			if (numberofMoleculeParts > 1)
				//merge the molecules into one ensemble
				mol = new JMEmol(this, moleculeParts, numberofMoleculeParts);
			if(! isV3000) 
				s = mol.createMolFile(header, stampDate);
			else //BB
				s = mol.createExtendedMolFile(header, stampDate);
			
			//???? WHY DOES THIS CHANGE THE IN MEMORY MOL?
			if (numberofMoleculeParts > 1)
				mol = moleculeParts[actualMoleculePartIndex];
		}
		return s;
	}

	
	// --------------------------------------------------------------------------

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * @param molecule string
	 */
	public void readMolFile(String molecule) {
		readMolFile(molecule, true);
	}

	/**
	 * Read a MOL or a RXN and save it to the undo stack on success
	 * @param molecule string
	 */
	public void readMolFile(String molecule, boolean repaint) {
		try {
			if(this.handleReadMolFileRXN(molecule, repaint)) {

			} else {
				repaint(); //to show errors
			}
		} catch(Exception e) {
			repaint() ; //for showing the error
		}
	}

	/**
	 * Read the molfile and repaint the applet when done
	 * @param MOL or a RXN
	 * @return true on success
	 */
	protected boolean handleReadMolFile(String s) {
		return handleReadMolFileRXN(s,true);
	}
	
	public void handleReadGenericInput(final String s, final RunAsyncCallback sucessAndFailureHandler) {
		handleReadGenericInput(s, sucessAndFailureHandler, true);
	}
	
	/**
	 * input can be a MOL, RXN, smiles or SMIRKS or OCL
	 * @param s
	 */
	
	public void handleReadGenericInput(String s, final RunAsyncCallback sucessAndFailureHandler, final boolean repaint) {

		
		final ChemicalFormatDetector cfd = new ChemicalFormatDetector(s);
		String error = null;
		boolean runAsync = false;
		this.afterStructureChangeEvent.setOrigin_API();
		
		clearInfo(); //clear previous error message if any
		do {
			if(cfd.majorChemicalFormat == ChemicalFormatDetector.MajorChemicalFormat.SVG && cfd.embeddedChemicalFormat != null) {
				//copy the embedded chemical format to cfd
				cfd.init(cfd.embeddedChemicalFormat);
			}
			if(cfd.author == ChemicalFormatDetector.Author.MDL && cfd.minorChemicalFormat != ChemicalFormatDetector.MinorChemicalFormat.V3000) {
				//bug: handling "|" as a line separator
	
				if(!JME.this.handleReadMolFileRXN(cfd.chemicalString, repaint))
					error = "Invalid V2000 molfile";
				break;
			}


			
			if(cfd.author == ChemicalFormatDetector.Author.P_ERTL) {
				if(! readMolecule(cfd.chemicalString, repaint)) {
					error = "Invalid JME string";
				}
				break;
			}
			if(cfd.author ==  ChemicalFormatDetector.Author.IUPAC) {
				//GWT: <set-configuration-property name="compiler.enum.obfuscate.names" value="false" /> otherwise the number of the enum is shown instead of its name
				error = "Reading "+ cfd.majorChemicalFormat + " is not supported";
				break;
			}
			if(this.useOpenChemLib) {
				runAsync = true;
				//code splitting used to run OpenChemlib code
				GWT.runAsync(new JSME_RunAsyncCallback() {

					@Override
					public void onSuccess() {
						String error= null;
						String convertedmolFile = null;
						String afterStructureChangedEvent = null;
						
						if(cfd.author == ChemicalFormatDetector.Author.MDL && cfd.minorChemicalFormat == ChemicalFormatDetector.MinorChemicalFormat.V3000) {
							try {
								convertedmolFile =JME.this.v3000toV2000MOL(cfd.chemicalString);
								if(convertedmolFile == null) {
									throw new Exception("V3000 read failed.");
								}
								afterStructureChangedEvent = READ_MOL_FILE;
								JME.this.sdfPastedMessage.innnerString = "V3000 conversion provided by OpenChemLib";
							} catch (Exception e) {
								error = e.getMessage();
							}
						} else {
							if(cfd.author == ChemicalFormatDetector.Author.DAYLIGHT) {
								try {
									convertedmolFile =JME.this.SMILESorSMIRKStoMolOrRXN(cfd.chemicalString);
									if(cfd.majorChemicalFormat == MajorChemicalFormat.SMIRKS)
										afterStructureChangedEvent = READ_SMIRKS;
									else if(cfd.majorChemicalFormat == MajorChemicalFormat.SMILES)
										afterStructureChangedEvent = READ_SMILES;
									
									JME.this.sdfPastedMessage.innnerString = "SMILES conversion provided by OpenChemLib";
									
								} catch (Exception e) {
									error = e.getMessage();
								}
							} else {
								error = "Invalid or unsupported input";
								if(JME.this.useOclIdCode && cfd.couldBeOclIdCode()){
								// try to parse OCL if not SMILES
								//ChemicalFormatDetector can not detect OCLcode
									try {
										convertedmolFile =JME.this.OclCodeToMOL(cfd.chemicalString);
										afterStructureChangedEvent = READ_OCLCODE;
										error = null;
									} catch (Exception e) {
									
									}
								}
							}
						}
						
						boolean success = false;
						if(convertedmolFile != null && error == null) {
							try {
								success = JME.this.handleReadMolFileRXN(convertedmolFile, false);
								if(success) {
									assert( afterStructureChangedEvent != null);
									JME.this.recordAfterStructureChangedEvent(afterStructureChangedEvent);
									
								}
							}
							catch (Exception e) {
								error = "Invalid converted molfile";
							}
						}
						JME.this.mustReDrawMolecularArea = success;
						
						if(sucessAndFailureHandler != null) {
							if (success) {
								sucessAndFailureHandler.onSuccess();
							} else {
								assert(error != null);
								sucessAndFailureHandler.onFailure(new Exception(error));
							}
						} else {
							if(error != null) {
								JME.this.showError(error);
							}
							
						}
						if(repaint) {
							repaint();
							//drawMolecularAreaRightNow(); //does not work if called from start(), molecularAreaImage is not initialized
						}

					}});
				
				
				break;
			}
		
		} while(false);
		

		if(! runAsync) {
			//duplicated code with the one inside the runAsync block
			JME.this.mustReDrawMolecularArea = (error == null);
			if(sucessAndFailureHandler != null) {
				if (error == null) {
					sucessAndFailureHandler.onSuccess();
				} else {
					sucessAndFailureHandler.onFailure(new Exception(error));
				}
			} else {
				if(error != null) {
					JME.this.showError(error);
				}
				
			}
		}
		

	}

	/**
	 * Read the input structure (all chemical structure formats supported by JSME)
	 * Update the editor display.
	 * @param s
	 */
	public void readGenericMolecularInput(String s) {
		this.handleReadGenericInput(s, null, true);
	}
	
	public String getOclCode() {
		String molFile = this.molFileOrRxn(null, false, true, false); 
		
		//TODO : error handling
		String result = null;
		StereoMolecule mol = new StereoMolecule();
		if (new MolfileParser().parse( mol,  molFile) ) {
		

			result = mol.getIDCode();
		} 
		
		return result;
	}

	/**
	 * Generate SVG representation of the molecule
	 * Use OpenChem lib SVG generator.
	 * @return
	 */
	public String getOclSVG() {
		String molFile = this.molFileOrRxn(null, false, true, false);  //use v3000
		double width = 400;
		double height = 300;
		//TODO : error handling
		String result = null;
		StereoMolecule mol = new StereoMolecule();
		if (new MolfileParser().parse( mol,  molFile) ) {
			//recipe found in openchemlib-js
			SVGDepictor svgd = new SVGDepictorWithEmbeddedChemicalStructure(mol, molFile);
			svgd.validateView(null, new Rectangle2D.Double(0, 0, width, height), AbstractDepictor.cModeInflateToHighResAVBL);
			svgd.paint(null);

			result = svgd.toString();
		} 
		
		return result;
	}
	
	/**
	 * Use the openchemlib to convert a OCL code to a molfile string
	 * TODO: what about 2D coordinates?
	 * @param oclCode
	 * @return
	 */
	public String OclCodeToMOL(String oclCode) {
		String result = null;
		StereoMolecule mol = new IDCodeParser().getCompactMolecule(oclCode.trim());

		MolfileCreator mfc = new MolfileCreator(mol);
		result = mfc.getMolfile();
		
		return result;
		
	}
	/**
	 * Use the openchemlib to convert a smiles to a molfile string
	 * 2D coordinates are generated
	 * @param smiles
	 * @return
	 * @throws Exception
	 */
	public String SMILEStoMOL(String smiles) throws Exception {
		String result = null;
		
		//OCLSmilesParser generates an exception if the SMILES is empty
		if(smiles.length() == 0) 
			return  new JMEmol().createMolFile(""); //empty mol
		
		StereoMolecule mol = new StereoMolecule();
		new SmilesParser().parse(mol, smiles.trim());

		MolfileCreator mfc = new MolfileCreator(mol);
		result = mfc.getMolfile();
		
		
		return result;
	}

	/**
	 * Use the openchemlib to convert a smirks to a rxn string
	 * 2D coordinates are generated. The individual reaction components
	 * are not further splitted into molecules (see handleReadMolFileRXN() )
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	public String SMIRKStoRXN(String smirks) throws Exception {
		String[] parts = smirks.split(">");
		assert parts.length == 3;
		
		//JMEmol newParts[] = mol.splitMultiparts()
		String reactants = this.SMILEStoMOL(parts[0]);
		String products = this.SMILEStoMOL(parts[2]);
		String agents = this.SMILEStoMOL(parts[1]);
		
		
		String s = "";
		
		s += "$RXN" + separator + separator + separator
					+ "JME Molecular Editor" + separator;
		s += JMEmol.iformat(1, 3) + JMEmol.iformat(1, 3);
		if(parts[1].length() > 0)
			s += JMEmol.iformat(1, 3);
		
		s += separator;
		s += "$MOL" + separator
				+ reactants;
		s += "$MOL" + separator
				+ products;
		//not standard
		if( parts[1].length() > 0)
			s += "$MOL" + separator
			+ agents;
			
		return s;
	}

	/**
	 * to be completed - used only for the test suite
	 * read the modulator as well, 
	 * should we (re)use the JME string input code for reaction?
	 * @param smirks
	 * @return
	 * @throws Exception
	 */
	public boolean readSmirks(String smirks) throws Exception {

		String convertedmolFile =JME.this.SMILESorSMIRKStoMolOrRXN(smirks);

		this.handleReadMolFileRXN(convertedmolFile, false);
		
		
		return true;
	}
	/**
	 * Use the openchemlib to convert a V3000 MOL to a V2000 molfile string
	 * @param v3000
	 * @return
	 * @throws Exception
	 */
	public String v3000toV2000MOL(String v3000Mol) throws Exception {
		String result = null;
		StereoMolecule mol = new StereoMolecule();
		boolean success = new MolfileParser().parse(mol, v3000Mol);
		//error messages are sent to a TRACE function that cannot be redefined
		if(success) {
			MolfileCreator mfc = new MolfileCreator(mol);
			result = mfc.getMolfile();
		}
		
		
		return result;
	}
	
	/**
	 * Use the openchemlib to convert a smiles or a smirks to a mol or rxn string
	 * 2D coordinates are generated
	 * 
	 * @param smilesOrsmirks
	 * @return
	 * @throws Exception
	 */
	public String SMILESorSMIRKStoMolOrRXN(String smilesOrsmirks) throws Exception {
		if(smilesOrsmirks.contains(">")) {
			return this.SMIRKStoRXN(smilesOrsmirks);
		} else {
			return this.SMILEStoMOL(smilesOrsmirks);
		}

	}
	/**
	 * Used for testing without GUI
	 * @param MOL or a RXN
	 * @return true on success
	 */
	public boolean  readMolFileOrRXN(String s) {
		return this.handleReadMolFileRXN(s, false);
	}

	boolean canBeAddedToExistingMultipartOrReaction() {
		return  ((reaction || multipart) && addNewPart) || newMolecule; //newMolecule is true if NEW button is pushed
	}

	/**
	 * generate an  afterStructureChangedEvent
	 * @param MOL or a RXN
	 * @return true on success
	 */
	boolean handleReadMolFileRXN(String s, boolean repaint) {
		//NumberFormatException : for interpreting   the integers
		// Should not perform a save to the undo/redo manager since an exception could be raised

		//BB: change June 2014: allow at add extra molecule when multipart is True
		//reset(repaint); // set numberofMoleculeParts = 0
		
		String afterStructureChangedEvent = null;
		
		clearInfo();

		
		if (s.startsWith("$RXN")) { // reaction
			
			//molecularAreaScale = 1.; //Sept 2016: reset the zoom
			resetMolecularAreaScale();
			//has to be done before computing new molecules because they will compute their bond centers
			
			numberofMoleculeParts = 0; //overwrite everything for a reaction
			reaction = true;
			multipart = true;
			String separator = JMEmol.findLineSeparator(s);
			StringTokenizer st = new StringTokenizer(s, separator, true);
			String line = "";
			for (int i = 1; i <= 5; i++) {
				line = JMEmol.nextData(st, separator);
			}
			int nr = Integer.valueOf(line.substring(0, 3).trim()).intValue();
			int np = Integer.valueOf(line.substring(3, 6).trim()).intValue();
			
			//support of agents, this is not standard, same convention as in Marvin JS
			int na = 0;
			if(line.length() >=9) {
				na = Integer.valueOf(line.substring(6, 9).trim()).intValue();
			}
			JMEmol.nextData(st, separator); // 1. $MOL
			for (int p = 1; p <= nr + np + na; p++) {
				String m = "";
				while (true) {
					String ns = JMEmol.nextData(st, separator);
					if (ns == null || ns.equals("$MOL"))
						break;
					else
						m += ns + separator;
				}
				// System.err.print("MOLS"+p+separator+m);
				moleculeParts[++numberofMoleculeParts] = new JMEmol(this, m); //TODO: this can fail and raise an exception
			}

			alignMolecules(1, nr, ReactionRole.REACTANT);
			alignMolecules(nr + 1, nr + np, ReactionRole.PRODUCT);
			if(na>0) {
				//new: align agent
				alignMolecules(nr + np + 1, nr + np + na, ReactionRole.AGENT);

			}
			
			//new June 2017: split the reaction components if needed after the alignment is done
			//such that each molecule can be moved individually
			{	JMEmol newMoleculeParts[] = new JMEmol[maxParts];
				int newNumberofMoleculeParts = 0;
				for(int i=1; i <= numberofMoleculeParts; i++) {
					JMEmol each = moleculeParts[i];
					
					int nparts = each.computeMultiPartIndices();
					if(nparts == 1) {
						newMoleculeParts[++newNumberofMoleculeParts] = each;
					} else {
						//DUPLICATED CODE with MOL split below
						for (int p = 1; p <= nparts; p++) {
							//extract each part and append it to the moleculeParts
							newMoleculeParts[++newNumberofMoleculeParts] = new JMEmol(this, each, p); 
						}
						
					}
				}
				
				moleculeParts = newMoleculeParts;
				numberofMoleculeParts = newNumberofMoleculeParts;
				
			}
			
			
			afterStructureChangedEvent = JME.READ_RXN_FILE;
			//this.recordAfterStructureChangedEvent(JME.READ_RXN_FILE); //dec 2014
		} else { // single molecule - ak multipart automaticky urobi multipart
			
			//June 2014: if there a mutipart already (e.g.) a reaction, pasting an additional structure will add
			//it to the existing parts and not replace everything, UNLESS depict mode
			if(true) {
				//reaction = false;
				
				if(depict || pasteFromSDFstack) { //BB let the incoming structure determine the editor mode when in depict mode
					reaction = false;
					//multipart = false;
				}
				mol = new JMEmol(this, s); //TODO: this can fail and raise an exception
				//in depict mode, the line above will compute the display size in order to center the molecule
				// the constructor neve returns a null
				if (mol == null || mol.natoms == 0) { //An empty molfile (0 atoms) is valid input: return true
					// 2008.12
					// info("ERROR - problems in reading/processing molecule !");
					// System.err.println("ERROR while processing\n"+s);
	
					//BB: turn back on the display of the error message
					if(mol == null)
						this.showError("problems in reading/processing MOL input");
					
					return mol != null;
				}
				
				// message will not be visible because "structure pasted will be shown just after
//				if (mol.natoms == 0) { //An empty molfile (0 atoms) is valid input
//					this.showInfo("MOL input with 0 atoms");
//					return true;
//				}
				
				//New June 2014
				//Feb 2016: in depict mode
				
				boolean addedToExistingMultipartOrReaction = canBeAddedToExistingMultipartOrReaction();
				
				// coloring tu, inak pri multiupart problemy
				if (atomBgColors != null && mol != null)
					mol.setAtomColors(atomBgColors, true);
				if (atomColors != null && mol != null)
					mol.setAtomColors(atomColors, false);
				
				if( !addedToExistingMultipartOrReaction) {
					numberofMoleculeParts = 0; //the new parts will not be appended to the moleculeParts[]
					//molecularAreaScale = 1.; //Sept 2016: reset the zoom, this will affect the alignMolecules
					resetMolecularAreaScale();

				}

				// ak multipart, urobi viac molekul
				int nparts = mol.computeMultiPartIndices();
				
				//only one part or depict mode: don't need to set/split the multiparts
				if (nparts <= 1 || depict) {//Feb 2016: in depict mode, nparts=0 if empty molecule
					moleculeParts[++numberofMoleculeParts] = mol;
				} else {
					multipart = true;
					//addedToExistingMultipartOrReaction = false; //replace all parts with the new mols, like reading an existing reaction over a reaction
					for (int p = 1; p <= nparts; p++) {
						//extract each part and append it to the moleculeParts
						moleculeParts[++numberofMoleculeParts] = new JMEmol(this, mol, p); // aj vycentruje
					}
				}
				
				if(addedToExistingMultipartOrReaction ) {
					actualMoleculePartIndex = numberofMoleculeParts; // the last added mol will be the selected one
					
				} else {
					actualMoleculePartIndex = 1;
				}
				
				mol = moleculeParts[actualMoleculePartIndex]; // odstrani povodnu multipart mol
				// newMolecule = false;
				smol = null; // kvoli undo
				
//				if(addedToExistingMultipartOrReaction) { //BB April 2016 Google+ bug report received by Peter
//					// this creates another bug: in depict mode the structures are not scaled crap 
//					alignMolecules(1, nparts, 0);         // I also commented the line center() in public JMEmol(JME jme, JMEmol m, int part)
//				}
				
				//BB April 2016 Google+ bug report received by Peter
				// this creates another bug: in depict mode the structures are not scaled crap 
				if(!depict)
					alignMolecules(1, nparts, 0, !addedToExistingMultipartOrReaction); //DO NOTHING in depict mode if nparts>1
				else
					alignMolecules(1, 1, 0, true);
					
				// I also commented the line center() in public JMEmol(JME jme, JMEmol m, int part)
//				alignMoleculesHasBeenPerformedByReadingStructure = true;
				
				afterStructureChangedEvent = JME.READ_MOL_FILE;
				//this.recordAfterStructureChangedEvent(JME.READ_MOL_FILE);
				
			} else { //older code kept 
				reaction = false;
				mol = new JMEmol(this, s);
	
				if (mol == null || mol.natoms == 0) {
					// 2008.12
					// info("ERROR - problems in reading/processing molecule !");
					// System.err.println("ERROR while processing\n"+s);
	
					//BB: turn back on the display of the error message
					this.showError("problems in reading/processing MOL input");
					return false;
				}
				// coloring tu, inak pri multiupart problemy
				if (atomBgColors != null && mol != null)
					mol.setAtomColors(atomBgColors, true);
				if (atomColors != null && mol != null)
					mol.setAtomColors(atomColors, false);
				// ak multipart, urobi viac molekul
				int nparts = mol.checkMultipart(false);
				if (nparts == 1) {
					moleculeParts[++numberofMoleculeParts] = mol;
				} else {
					multipart = true;
					for (int p = 1; p <= nparts; p++)
						moleculeParts[++numberofMoleculeParts] = new JMEmol(this, mol, p); // aj vycentruje
				}
				actualMoleculePartIndex = 1;
				mol = moleculeParts[actualMoleculePartIndex]; // odstrani povodnu multipart mol
				// newMolecule = false;
				smol = null; // kvoli undo
				alignMolecules(1, nparts, 0);
			}
		}
		
		// BB october 2015 -LP request
		// set the max mark after reading input
		setMaxMapAfterReadingInput();

		// event will be automatically called after repaint() such that the SVG of the drawing reflects the current state
		// also, save in the undo stack
		if( afterStructureChangedEvent != null) {
			this.afterStructureChangeEvent.setOrigin_API();
			this.recordAfterStructureChangedEvent(afterStructureChangedEvent);
		}
		this.mustReDrawMolecularArea();
		if(repaint)
			repaint();
		
		return true; //success
	}

	public int findMaxAtomMapAmongAllMolecules() {
		//first find the max
		int max = -99999;

		
		for(int p = 1; p <= numberofMoleculeParts; p++ ) {
			JMEmol mol = moleculeParts[p];
			int molMaxMap = mol.geMaxAtomMap();
			if(molMaxMap> max) max = molMaxMap;
		}

		return max;
	}
	public void setMaxMapAfterReadingInput() {
		int max = this.findMaxAtomMapAmongAllMolecules();
		
		
		// assign the max
		for(int p = 1; p <= numberofMoleculeParts; p++ ) {
			JMEmol mol = moleculeParts[p];
			mol.maxMark = max;
		}
		
	}
	// --------------------------------------------------------------------------
	// called from JavaScript menu, sets Rgroup
	public void setSubstituent(String s) {
		// substituent menu
		int pressed = -1;
		if (s.equals("Select substituent")) {
			pressed = ACTION_BOND_SINGLE;
			s = "";
		} else if (s.equals("-C(=O)OH"))
			pressed = ACTION_GROUP_COO;
		else if (s.equals("-C(=O)OMe"))
			pressed = ACTION_GROUP_COOME;
		else if (s.equals("-C(=O)N"))
			pressed = ACTION_GROUP_CON;
		else if (s.equals("-NC=O"))
			pressed = ACTION_GROUP_NCO;
		else if (s.equals("-OC(=O)Me"))
			pressed = ACTION_GROUP_OCOME;
		else if (s.equals("-CMe3"))
			pressed = ACTION_GROUP_TBU;
		else if (s.equals("-CF3"))
			pressed = ACTION_GROUP_CF3;
		else if (s.equals("-CCl3"))
			pressed = ACTION_GROUP_CCL3;
		else if (s.equals("-NO2"))
			pressed = ACTION_GROUP_NITRO;
		else if (s.equals("-NMe2"))
			pressed = ACTION_GROUP_NME2;
		else if (s.equals("-SO2-NH2"))
			pressed = ACTION_GROUP_SO2NH2;
		else if (s.equals("-NH-SO2-Me"))
			pressed = ACTION_GROUP_NHSO2ME;
		else if (s.equals("-SO3H"))
			pressed = ACTION_GROUP_SULFO;
		else if (s.equals("-PO3H2"))
			pressed = ACTION_GROUP_PO3H2;
		else if (s.equals("-C#N"))
			pressed = ACTION_GROUP_CYANO;
		else if (s.equals("-C#C-Me"))
			pressed = ACTION_GROUP_CCC;
		else if (s.equals("-C#CH"))
			pressed = ACTION_GROUP_CC;

		if (pressed > 0) {
			menuAction(pressed);
		}
		else
			s = "Not known group!";
		info(s);
		repaint();
	}

	// --------------------------------------------------------------------------
	public void options(String parameters) {
		this.options(parameters, true);
		
	}
	public void options(String parameters, boolean repaint) {
		Boolean optionTest;
		parameters = parameters.toLowerCase();

		if((optionTest = parseOption(parameters,"rbutton")) != null) rButton = optionTest;

		if((optionTest = parseOption(parameters,"hydrogens")) != null) showHydrogens = optionTest;
		
		if (parameters.indexOf("keephs") > -1) {
			keepHydrogens = true;
			removeOnlyCHydrogens = false;
		}
		if (parameters.indexOf("removehs") > -1) {
			keepHydrogens = false;
			removeOnlyCHydrogens = false;
		}

		if (parameters.indexOf("removehsc") > -1) {
			keepHydrogens = false;
			removeOnlyCHydrogens = true;
		}

		if((optionTest = parseOption(parameters,"query")) != null) query = optionTest;

		if((optionTest = parseOption(parameters,"reaction")) != null) reaction = optionTest;

		if((optionTest = parseOption(parameters,"autoez")) != null) autoez = optionTest;

		if((optionTest = parseOption(parameters,"stereo")) != null) stereo = optionTest;

		if((optionTest = parseOption(parameters,"canonize")) != null) canonize = optionTest;

		if((optionTest = parseOption(parameters,"multipart")) != null) multipart = optionTest;


		//New: handling  the negative option
		if( optionTest = parseOption(parameters,"autonumber") != null) {
			autonumber = optionTest;
			if(autonumber) number = true;
		}
		if(optionTest = parseOption(parameters,"number") != null) {
			number = optionTest;
			if(!number)
				autonumber = false;
		}

		if((optionTest = parseOption(parameters,"newlook")) != null) {
			newLook = optionTest;
			resetAllGraphics();
		}
		if((optionTest = parseOption(parameters,"oldlook")) != null) {
			newLook = !optionTest;
			resetAllGraphics();
		}

		
		if((optionTest = parseOption(parameters,"star")) != null) {
			number=star = optionTest;
		}

		if((optionTest = parseOption(parameters,"polarnitro")) != null) polarnitro = optionTest;

		
		if((optionTest = parseOption(parameters,"toggle")) != null) toggleDepictEdit = optionTest;

		//BB
		if((optionTest = parseOption(parameters,"depictaction")) != null) {
			depictActionEnabled = optionTest;
			if(optionTest)
				parameters += " depict";
		}

		optionTest = parseOption(parameters,"depict");
		if(optionTest !=null) {
			if (optionTest && depict == false) {
				depict = true;
				menuCellSize = 0;
				molecularAreaImage = null; // pre prechode z depict je ta primala
				// toto len pre norm moleculeParts, nie pre reaction !!!
				//alignMolecules(1, numberofMoleculeParts, 0); //will be done during the repaint 
				paste = false;  //BB March 2014 : default does not accept paste anymore
				this.resetAllGraphics();
			}
			//BB CHeck if nodepictaction is used
			if (!optionTest && depict == true) {
				depict = false;
				molecularAreaScale = 1; // inak kresli mensi font
				// musi male molekuly vratit na povodnu velkost
				for (int i = 1; i <= numberofMoleculeParts; i++) {
					moleculeParts[i].scaling();
					moleculeParts[i].center(); // este raz, teraz uz zmensene
				}
				//BB moved above - fixed a bug
				//depictScale = 1; // inak kresli mensi font
				// normal font (ak bola mensia molekula) sa nastavi v
				// drawMolecularArea
				menuCellSize = standardMenuCellSize;
				if (mol != null)
					mol.needRecentering = true;
				
				paste = true;  //BB March 2014 : 
				//oaste ooption will be set below
				this.resetAllGraphics();
	
			}
		}
		
		
		if((optionTest = parseOption(parameters,"showDragAndDropIconInDepictMode")) != null) showDragAndDropIconInDepictMode = optionTest;
		//older naming of the same option
		if((optionTest = parseOption(parameters,"showDragAndDropSymbolInDepictMode")) != null) showDragAndDropIconInDepictMode = optionTest;
		
		if((optionTest = parseOption(parameters,"addNewPart")) != null) addNewPart = optionTest;


		if((optionTest = parseOption(parameters,"exportInchi")) != null) exportInchi = optionTest;
		if((optionTest = parseOption(parameters,"exportInchiKey")) != null) exportInchiKey = optionTest;
		if((optionTest = parseOption(parameters,"exportInchiAuxInfo")) != null) exportInchiAuxInfo = optionTest;
		if((optionTest = parseOption(parameters,"searchInchiKey")) != null) searchInchiKey = optionTest;
		if((optionTest = parseOption(parameters,"exportSVG")) != null) exportSVG = optionTest;
		
		
		if((optionTest = parseOption(parameters,"exportRXNmerge")) != null) exportRXNmergeOption = optionTest;
		
		if((optionTest = parseOption(parameters, "contextMenu")) != null) contextMenuEnabledOption = optionTest;
		if((optionTest = parseOption(parameters, "fullScreenIcon")) != null) fullScreenIconOption = optionTest;
		if((optionTest = parseOption(parameters, "showFullScreenIconInDepictMode")) != null) showFullScreenIconInDepictMode = optionTest;
		
		
		if((optionTest = parseOption(parameters,"useOclIDCode")) != null) useOclIdCode = optionTest;
	
		
		if((optionTest = parseOption(parameters,"xbutton")) != null) xButton = optionTest;

		
		if((optionTest = parseOption(parameters,"paste")) != null) paste = optionTest;
		
		
		if((optionTest = parseOption(parameters,"border")) != null) depictBorder = optionTest;

		// undocumented options
//		if (parameters.indexOf("writesmi") > -1)
//			writesmi = true;
//		if (parameters.indexOf("writemi") > -1)
//			writemi = true;
//		if (parameters.indexOf("writemol") > -1)
//			writemol = true;
		if (parameters.indexOf("nocenter") > -1)
			nocenter = true;
		if (parameters.indexOf("jmeh") > -1)
			jmeh = true;
		if (parameters.indexOf("showan") > -1)
			showAtomNumbers = true;
		// System.out.println(rButton+" "+showHydrogens+" "+query+" "+autoez+" "+stereo+" "+canonize+" "+reaction);

		//BB
		if((optionTest = parseOption(parameters,"atommovebutton")) != null) showAtomMoveButton = optionTest;
		if((optionTest = parseOption(parameters,"useopenchemlib")) != null) useOpenChemLib = optionTest;
		if((optionTest = parseOption(parameters,"zoom")) != null) allowZooming = optionTest;
		
		
		
		// zladi options - ake dalsie ???
		if (reaction) {
			//BB: if a reaction is read, then the numbering should be autonumber and not number. This should be checked by Peter.
			//With autonumber, one can assign different atom map numbers
			//number = true;
			autonumber = true;
			multipart = true;
		}
		if (!depict)
			depictBorder = false;
		// positions and actions for X and Rx buttons
		// nove X a R action musia byt > 300
//		if (rButton)
//			LEFT_MENU_NUMBER_OF_CELLS++;
		LEFT_MENU_NUMBER_OF_CELLS = this.determineNumberLeftMenuNumberOfCell();

		this.resetPopupMenu(); //the pop menu contains  entries and labels that night need to be removed or added or changed
		
		if(repaint)
			repaint();
	}
	
	/**
	 * use boundaries for the search
	 * @param parameters
	 * @param option
	 * @param negativePrefix
	 * @return null if option not found
	 */
	protected Boolean parseOption(String parameters, String option, String negativePrefix) {
		boolean pos = Pattern.compile( "\\b" + option + "\\b", Pattern.CASE_INSENSITIVE).matcher(parameters).find();
		boolean neg = Pattern.compile( "\\b" + negativePrefix  +  option + "\\b", Pattern.CASE_INSENSITIVE).matcher(parameters).find();
		
		
		if(pos && neg) {
			this.log("check option " + option);
			return null;
		}

		if(pos) return true;
		if(neg) return false;
		
		return null;
		
	}
	//TODO: rdefine in JME2
	public void log(String string) {
		System.err.println(string);
	}

	protected Boolean parseOption(String parameters, String option) {
		return parseOption(parameters, option, "no");
	}
	protected void resetAllGraphics() {
		// for subclass
		this.mustRedrawEverything();
		
		this.molecularAreaImage = null;
		this.topMenuImage = null;
		this.leftMenuImage=null;
		this.infoAreaImage=null;
		this.rightBorderImage=null;

	}

	
	/**
	 * See also getCopyPastePopupMenuMol() and getCopyPastePopupMenuReaction()
	 */
	protected void resetPopupMenu() {
		this.copyPastePopupMenuMol = null;
		this.copyPastePopupMenuReaction = null;
		
	}

	// --------------------------------------------------------------------------
	public void setText(String text) {
		molText = text;
		repaint();
	}

	// --------------------------------------------------------------------------
	public void showAtomNumbers() {
		// shows canonical atom numbering
		// numbers only actual molecule !!!
		if (mol != null)
			mol.numberAtoms();
	}

	// ----------------------------------------------------------------------------
	public boolean hasPrevious() {
		if (molStack.size() == 0 || stackPointer == 0)
			return false;
		return true;
	}

	// ----------------------------------------------------------------------------
	public void getPreviousMolecule() {
		getFromStack(-1);
	}

	// ----------------------------------------------------------------------------
	void getFromStack(int n) {
		clearInfo();
		clear();
		// musi vytvorit kopiu, nie len brat poiner (lebo je zmeni)
		stackPointer += n;
		mol = (JMEmol) molStack.elementAt(stackPointer).deepCopy();
		mol.center();
		numberofMoleculeParts = 1;
		actualMoleculePartIndex = 1;
		moleculeParts[1] = mol;

		// BB
		mustReDrawMolecularArea = true; //not needed because clear() does it
		repaint();
		smol = null; // kvoli undo
	}

	// ----------------------------------------------------------------------------
	// --- end of public functions
	// ------------------------------------------------
	// ----------------------------------------------------------------------------
	public void paint(Graphics g) {
		/*The java applet viewer calls this method when the applet window is resized */
		
		update(g);
		// requestFocus(); // kvoli key action

	}

	/**
	 * Should be called after any applet size change
	 * @param appletDimension
	 */
	protected void updateMyMolecularAreaSize(Dimension appletDimension, double menuScale) {
		
		Rectangle2D.Double molecularAreaBoundingBox = getMolecularAreaBoundingBoxPixel(appletDimension, menuScale);
		
		this.molecularAreaWidth = (int) molecularAreaBoundingBox.width;
		this.molecularAreaHeight = (int) molecularAreaBoundingBox.height;

		
	}
	/**
	 * Should be called after any applet size change
	 * @param d
	 */
	protected void updateMyMolecularAreaSize() {
		if (this.dimension == null) {
			this.dimension = size();
		}
		this.updateMyMolecularAreaSize(this.dimension, this.menuScale);
		
	}
	/**
	 * Return the bounding box of  the molecular area (screen pixel)
	 * 
	 */
	Rectangle2D.Double getMolecularAreaBoundingBox() {
		
		return getMolecularAreaBoundingBoxPixel(this.dimension, this.menuScale);
		
		/*
		if(molecularAreaWidth <= 0 || molecularAreaHeight <= 0) {
			updateMyMolecularAreaSize();
		}
		Rectangle2D.Double widhtAndHeight = new Rectangle2D.Double();
		widhtAndHeight.width = 	molecularAreaWidth;
		widhtAndHeight.height = molecularAreaHeight;
		
		return widhtAndHeight;
		*/
//		//compute the the size of the available display box for the molecular area
//		int xsize = 0;
//		int ysize = 0;
//		if(dimension != null) {
//			xsize = dimension.width;
//			ysize = dimension.height;
//			if (!depict) { //in non depict modus, space is used for the menu and info bar
//				xsize -= menuCellSize;
//				ysize -= 3 * menuCellSize;
//			} else {
//				ysize -= 16; /*space for DnD icon */
//			}
//		}
//		Rectangle widhtAndHeight = new Rectangle();
//		widhtAndHeight.width = xsize;
//		widhtAndHeight.height = ysize;
//		
//		return widhtAndHeight;
		
	}
	protected Rectangle2D.Double getMolecularAreaBoundingBoxPixel(Dimension appletDimension, double menuScale) {
		
		
		double x = depict? 0:leftMenuWidth(menuScale);
		double y = depict? 0:topMenuHeight(menuScale);
		double width = (double)appletDimension.width - (depict?0:x+rightBorder(menuScale));
		double height = (double)appletDimension.height -(depict?0:y+infoAreaHeight(menuScale));
		
		
		
		return new Rectangle2D.Double(x,y,width,height);

	}
	
	protected Rectangle2D.Double getMolecularAreaBoundingBoxCoordinate(Dimension appletDimension, double menuScale, double molecularAreaScale) {
		Rectangle2D.Double bbox = getMolecularAreaBoundingBoxPixel(appletDimension,  menuScale);
		
		bbox.x = 0;
		bbox.y = 0;
		bbox.width = scaleScreenToDrawing((int)bbox.width);
		bbox.height = scaleScreenToDrawing((int)bbox.height);
		
		
		
		return bbox;

	}
	
	/**
	 * Return the width and height of the molecular area with scaling
	 * 
	 */
	protected Rectangle2D.Double getMolecularAreaBoundingBoxCoordinate() {
		return getMolecularAreaBoundingBoxCoordinate(this.dimension, this.menuScale, this.molecularAreaScale);
	}
	// ----------------------------------------------------------------------------
	public void update(Graphics g) {
		// pri fill ma rectangle sirku a vysku presne, pri draw o 1 vacsiu
		// Dimension d = getSize();
		
		//BB" try to avoid mutilple calls to size() and alignMolecules()
		
		//Note: Applet has a resize method() that we could override
		boolean initOrResize ;
		appletHasBeenResized = false;
		assert(dimension != null); //dimension was initialized by init()()
		if (molecularAreaImage == null) {
			initOrResize = true;
			assert(molecularAreaImage == null);
			
		} else {
			assert(molecularAreaImage != null);
			
			Dimension newDimension = size();

			//find out if the size of the applet has changed
			initOrResize = (newDimension.width != dimension.width) || (newDimension.height != dimension.height);
			
			if(initOrResize) { //if applet has a new size
				
				dimension = newDimension;
				appletHasBeenResized = true;
			}
		}
		
		
		if(initOrResize) { 
			mustRedrawEverything();
			updateMyMolecularAreaSize(this.dimension, this.menuScale);
			log("update(): " + dimension + " " + "initOrResize: " + initOrResize + " " + this.molecularAreaWidth + " " +  this.molecularAreaHeight);
			
			//compute or resize  the graphics
			molecularAreaImage = createOrResizePreciseImage(molecularAreaImage, this.molecularAreaWidth, this.molecularAreaHeight);
			
			if(!depict) {
				//update the menu's and the info area

				topMenuImage = createOrResizePreciseImage(topMenuImage, dimension.width, topMenuHeight());
				double imageh = dimension.height - topMenuHeight();
				if (imageh < 1)
					imageh = 1;
				//leftMenu = createOrResizeImage(leftMenu, menuCellSize, imageh);
				this.leftMenuImage = createOrResizePreciseImage(this.leftMenuImage, this.leftMenuWidth(), imageh);

				
				infoAreaImage = createOrResizePreciseImage(infoAreaImage, this.molecularAreaWidth+rightBorder(), infoAreaHeight());
				
				rightBorderImage = createOrResizePreciseImage(rightBorderImage, rightBorder(), this.molecularAreaHeight);
				
			} else {
				
				double oldMolecularAreaScale = this.molecularAreaScale;
				//will recompute the molecular area scale
				alignMolecules(1, numberofMoleculeParts, 0, depict); //code copied from the depict option initialisation
				log("update() in depict mode: oldMolecularAreaScale = " + oldMolecularAreaScale + " new   molecularAreaScale = " + molecularAreaScale);

				
				assert topMenuImage == null;
				assert leftMenuImage == null;
				assert infoAreaImage == null;
				assert rightBorderImage == null;
			}
		}
		
		//draw the parts
		drawMolecularArea(g);
		if (! depict) {
			drawInfo(g); // ???
			drawTopMenu(g);
			drawLeftMenu(g);
			drawRightBorderImage(g);
		
		}
		
	}
		
	public void update_OLD(Graphics g) {
		
		Dimension d = size();
		if (dimension == null || (d.width != dimension.width)
				|| (d.height != dimension.height) || molecularAreaImage == null
				|| (molecularAreaImage == null)) {
			
			//BB
			boolean reDimension = false;
			if(dimension != null) {
				reDimension = (d.width != dimension.width) || (d.height != dimension.height);
			}
			// infoArea v if kvoli problemom s appletviewer
			dimension = d;
			// fix for bob hanson when starting JME very small
//			double imagew = d.width - menuCellSize;
//			double imageh = d.height - menuCellSize * 3 - menuCellBorder();
//			if (imagew < 1)
//				imagew = 1;
//			if (imageh < 1)
//				imageh = 1;
			
//			this.molecularAreaWidth = (int) imagew;
//			this.molecularAreaHeight = (int) imageh;

			if(reDimension) {
				this.updateMyMolecularAreaSize(d, this.menuScale); //set this.molecularAreaWidth
				
				//BB the applet window size has changed
				if(depict) {
					alignMolecules(1, numberofMoleculeParts, 0); //code copied from the depict option initialisation
					//side effect: recompute the molecular area  scale to fit the chemical strcture completely in the molecularea frame
				}

			}
			if(reDimension || molecularAreaImage == null) {
				molecularAreaImage = createOrResizePreciseImage(molecularAreaImage, this.molecularAreaWidth, this.molecularAreaHeight);
			}
			drawMolecularArea(g);
			
			if (depict) {
				assert topMenuImage == null;
				assert leftMenuImage == null;
				assert infoAreaImage == null;
				assert rightBorderImage == null;
				return;
				
			}

			topMenuImage = createOrResizePreciseImage(topMenuImage, d.width, topMenuHeight());
			drawTopMenu(g);
			double imageh = d.height - topMenuHeight();
			if (imageh < 1)
				imageh = 1;
			//leftMenu = createOrResizeImage(leftMenu, menuCellSize, imageh);
			this.leftMenuImage = createOrResizePreciseImage(this.leftMenuImage, this.leftMenuWidth(), imageh);

			drawLeftMenu(g);
			
			infoAreaImage = createOrResizePreciseImage(infoAreaImage, this.molecularAreaWidth+rightBorder(), infoAreaHeight());
			drawInfo(g);
			
			rightBorderImage = createOrResizePreciseImage(rightBorderImage, rightBorder(), this.molecularAreaHeight);
			drawRightBorderImage(g);
			
		} else { // robi len cast obrazku
			drawMolecularArea(g);
			if (depict)
				return;
			drawInfo(g); // ???
			drawTopMenu(g);
			drawLeftMenu(g);
			drawRightBorderImage(g);
			
		}
	}

	/**
	 * Method that is overidden in JSME in order to avoid the creation of multiple SVG's during a window resize
	 * @param img
	 * @param width
	 * @param height
	 * @return a new Image in JME or the same image if the argument img is not null in JSME
	 */
	public Image createOrResizeImage(Image img, int width, int height) {
		return createImage(width, height);
	}

	public PreciseImage createOrResizePreciseImage(PreciseImage img, double width, double d) {
		return new PreciseImage(createOrResizeImage(img == null?null:img.getImage(), (int)(Math.round(width)), (int)(Math.round(d))));
	}

	/**
	 * This methos is used only in a batch mode test suite in order to
	 *  have an instance of JME that has a this.dimension that is not null
	 * @param width
	 * @param height
	 */
	public void setDirectSizeForTesting(int width, int height) {
		if (this.dimension == null) {
			this.dimension = new Dimension();
		}
		this.dimension.width = width;
		this.dimension.height = height;
		
		this.updateMyMolecularAreaSize();
		
	}
	// ----------------------------------------------------------------------------
	
	//BB
	//metal like LI, K, Na which can be single cation
//	public static int isMetal1(int an) {
//		return an >= AN_METAL1_START && an <= AN_METAL1_END? 1 : 0;
//	}
//	//metal like LI, K, Na which can be single cation
//	public static boolean isMetal2(int an) {
//		return an >= AN_METAL2_START && an <= AN_METAL2_END;
//	}
	
	public static int chargedMetalType(int an) {
		if(an >= AN_METAL1_START && an <= AN_METAL1_END) return 1; //Na+
		if(an >= AN_METAL2_START && an <= AN_METAL2_END) return 2; //Ca++
		if(an >= AN_METAL3_START && an <= AN_METAL3_END) return 3; //Al+++
		
		return 0;
	}

	
	public static void atomicData() {
		for (int i = 1; i <= AN_R_LAST; i++) {
			if(chargedMetalType(i) >0) {
				color[i] = Color.darkGray;				
			} else {
				color[i] = Color.orange;
				zlabel[i] = "X";
			}
		}
		zlabel[AN_H] = "H";
		color[AN_H] = Color.darkGray;
		zlabel[AN_B] = "B";
		color[AN_B] = Color.orange;
		zlabel[AN_C] = "C";
		color[AN_C] = Color.darkGray;
		zlabel[AN_N] = "N";
		color[AN_N] = Color.blue;
		zlabel[AN_O] = "O";
		color[AN_O] = Color.red;
		zlabel[AN_F] = "F";
		color[AN_F] = Color.magenta;
		zlabel[AN_CL] = "Cl";
		color[AN_CL] = Color.magenta;
		zlabel[AN_BR] = "Br";
		color[AN_BR] = Color.magenta;
		zlabel[AN_I] = "I";
		color[AN_I] = Color.magenta;
		zlabel[AN_S] = "S";
		color[AN_S] = Color.yellow.darker();
		zlabel[AN_P] = "P";
		color[AN_P] = Color.orange;
		zlabel[AN_SI] = "Si";
		color[AN_SI] = Color.darkGray;
		zlabel[AN_SE] = "Se";
		color[AN_SE] = Color.darkGray;
		zlabel[AN_X] = "X";
		color[AN_X] = Color.darkGray;
		
		zlabel[AN_K] = "K";
		zlabel[AN_Li] = "Li";
		zlabel[AN_Na] = "Na";
		zlabel[AN_Rb] = "Rb";
		zlabel[AN_Cs] = "Cs";
		zlabel[AN_Fr] = "Fr";
		zlabel[AN_Ag] = "Ag";
		
		zlabel[AN_Mg] = "Mg";
		zlabel[AN_Ca] = "Ca";
		zlabel[AN_Sr] = "Sr";
		zlabel[AN_Ba] = "Ba";
		zlabel[AN_Zn] = "Zn";
		zlabel[AN_Ni] = "Ni";
		zlabel[AN_Cu] = "Cu";
		zlabel[AN_Cd] = "Cd";

		zlabel[AN_Al] = "Al";
		zlabel[AN_Ga] = "Ga";
		zlabel[AN_Au] = "Au";
		
		//BB: replace cases by a loop for the R groups
		for(int i = AN_R; i <= AN_R_LAST; i++) {
			String label = "R";
			if(i > AN_R) {
				label += i-AN_R;
			}
			zlabel[i] = label;
			color[i] = Color.darkGray;
		}
		/*
		zlabel[AN_R] = "R";
		color[AN_R] = Color.darkGray;
		zlabel[AN_R1] = "R1";
		color[AN_R1] = Color.darkGray;
		zlabel[AN_R2] = "R2";
		color[AN_R2] = Color.darkGray;
		zlabel[AN_R3] = "R3";
		color[AN_R3] = Color.darkGray;
		*/
	}

	//BB : added atomic atomicData initialization , allows to work also in the test suite
	static {
		atomicData();
	}

	PreciseGraphicsAWT getScaledGraphicsOfPreciseImage(PreciseImage pi, double scale, Rectangle2D.Double screenArea) {
		PreciseGraphicsAWT og;
		if(this.scalingIsPerformedByGraphicsEngine) {
			og = pi.getGraphics(scale);
		} else {
			og = pi.getGraphics(1.0); //never used!!?

		}
		og.setDrawOnScreenCoordinates(screenArea);
		
		return og;
	}
	
	//direct
	void drawMolecularAreaRightNow() {
		this.mustReDrawMolecularArea =true;
		if(molecularAreaImage != null) { //must be initialized
			drawMolecularArea(getGraphics());
			this.mustReDrawMolecularArea = false;
		} else {
			this.repaint();
		}

	}
	// ----------------------------------------------------------------------------
	void drawMolecularArea(Graphics g) {

		log("drawMolecularArea  mustReDrawMolecularArea=" + mustReDrawMolecularArea + "\n"); 
		//BB
		if (!this.mustReDrawMolecularArea) {
			return;
		}

		//new sept 2016
		//FIXme: should not be done here
		if(this.afterStructureChangeEvent  != null && this.afterStructureChangeEvent.action != null) {
			if(this.afterStructureChangeEvent.action != JME.UNDO && this.afterStructureChangeEvent.action != JME.REDO) {
				for(int i = 1; i <= this.numberofMoleculeParts; i++) {
					this.moleculeParts[i].cleanAfterChanged();
				}
			}
		}
		
		//screen area in pixel
		Rectangle2D.Double molecularScreenArea = new Rectangle2D.Double(leftMenuWidth(), topMenuHeight(), this.molecularAreaWidth, this.molecularAreaHeight);
		
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(molecularAreaImage, molecularAreaScale, molecularScreenArea);
		
		double imgWidth = this.molecularAreaWidth ;
		double imgHeight = this.molecularAreaHeight;
		log("drawMolecularArea  " + imgWidth + " : " +imgHeight +  " scale: " +  this.molecularAreaScale + "\n"); 
		og.setColor(canvasBg);
		
		imgWidth /= this.molecularAreaScale;
		imgHeight /= this.molecularAreaScale;
		
		og.fillRect(0, 0, imgWidth, imgHeight);

		//BB custom antialias and line width for the molecular drawing area
		Object valueAntiAlias = molecularAreaAntiAlias?RenderingHints.VALUE_ANTIALIAS_ON:RenderingHints.VALUE_ANTIALIAS_OFF;
		og.setRenderingHint(RenderingHints.KEY_ANTIALIASING,valueAntiAlias);

		og.setStroke(new BasicStroke(molecularAreaLineWidth));

		
		if(false ){
			double x= 20;
			double y = 20;
			double w = 40;
			double h = 30;
			
			og.setColor(Color.magenta);
			og.drawRect(x, y, w, h);
			og.setColor(Color.black);
			og.drawLine(x,y, x+10, y);
			
			og.drawLine(x+w,y, x+w, y+10);
			og.drawLine(x+w,y+h, x+w+20, y+h);
			
			og.setColor(Color.magenta);
			og.fillOval(x *4, y*4, menuCellSize, menuCellSize); // same as for the smiley
			og.setColor(Color.black);
			og.drawRect(x*4, y*4, w, h);
			
			x+=100;
			y+=100;
			og.setColor(Color.magenta);
			og.drawRect(x, y, w, h);
			og.setColor(Color.black);
			og.drawLine(x,y, x+w, y+h);

			
			
		}
		
		if (fullScreenEnterOrExit && ! reaction) {
			centerAllMoleculesAsAgroup(this.dimension, menuScale, molecularAreaScale);
			fullScreenEnterOrExit =false;
		} else if (this.appletHasBeenResized && previousScaledScreenArea != null) {

			if(this.depict && ! reaction) {
				centerAllMoleculesAsAgroup(this.dimension, menuScale, molecularAreaScale); //does nothing in reaction mode yet
			} else {
			// this.getMolecularAreaSizeWithScalingForDepiction();
				for (int m = 1; m <= numberofMoleculeParts; m++) {
					// reaction: keep the position of the reaction components around
					// the reaction arrow
					// because the code below always draw the arrow at the center -
					// and we cannot move it yet
					if (/* this.reaction && */this.appletHasBeenResized && previousScaledScreenArea != null) {
						double dx = (imgWidth - previousScaledScreenArea.width) / 2;
						double dy = (imgHeight - previousScaledScreenArea.height) / 2;
						moleculeParts[m].moveXY(dx, dy);
	
					}
				
			}}
		}
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			moleculeParts[m].draw(og);
		}
		if(previousScaledScreenArea==null)
			previousScaledScreenArea = new Rectangle2D.Double();
		previousScaledScreenArea.width=imgWidth;
		previousScaledScreenArea.height=imgHeight;
		

		// arrow
		if (reaction) {
			double pWidth = arrowWidth;
			double pStart = (imgWidth - pWidth) / 2;
			double m = arrowWidth / 8; // hrot sipky
			double y = imgHeight / 2;
			og.setColor(Color.magenta);
			og.drawLine(pStart, y, pStart + pWidth, y);
			og.drawLine(pStart + pWidth, y, pStart + pWidth - m,
					y + m);
			og.drawLine(pStart + pWidth, y, pStart + pWidth - m,
					y - m);
			//record the bonding box of the arrow
			reactionArrowBoundingBox.setRect(pStart, y, pWidth, m*2);
		}

		// molText
		if (depict) { // kvoli molText, ale aj depict dalsej molekuly
			// musi robit novy font, lebo v depict moze byt zmeneny
			menuCellFont = new Font(defaultFontFamily, Font.PLAIN, fontSize);
			menuCellFontMet = getFontMetrics(menuCellFont);
			if (molText != null) {
				int w = menuCellFontMet.stringWidth(molText);
				double xstart = (imgWidth - w) / 2.;
				double ystart = imgHeight - fontSize;
				og.setColor(Color.black);
				og.setFont(menuCellFont);
				og.drawString(molText, xstart, ystart);
			}
		}
		
		//draw the DnD icon
		if(depict) {
			if(showDragAndDropIconInDepictMode)
				//DnD icom is made smaller than the non depict one
				this.drawDragAndDropIcon(og, smallerIconsForDepictMode /this.molecularAreaScale);
			else
				this.dragAndDropIcon = null;
			
			//FIXME
			//on the left of the DnD icon
			//scaling does not work - because a resize event recomputed the molecularAreaScale
//			if(fullScreenIconOption && showFullScreenIconInDepictMode)
//				this.drawFullScreenIcon(og, imgWidth, imgHeight, smallerIconsForDepictMode /this.molecularAreaScale, this.dragAndDropIcon);
		}
		
		//right border of the frame
		//BB Feb 2016: - this should not be part of the molecular drawing area
		if(false) {
			
			if (!depict) {
				//avoid linewidth change because of scaling
				og.setStroke(new BasicStroke((float) (1.0 /this.molecularAreaScale)));
				og.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
				if (newLook) {
					og.setColor(Color.darkGray);
					og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1);//right line
				}
				else {
					// vonkajsi okraj na pravej strane
					og.setColor(bgColor.darker());
					og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1);
					// predel vo farbe backgroundu
					og.setColor(bgColor);
					og.drawLine(imgWidth - 2, 0, imgWidth - 2, imgHeight - 1);
					// svetly okraj dovnutra
					og.setColor(brightColor);
					og.drawLine(imgWidth - 3, 0, imgWidth - 3, imgHeight - 1);
				}
			}
			//og.setStroke(new BasicStroke(molecularAreaLineWidth));
		}

		g.drawImage(molecularAreaImage.getImage(), og.screenX(), og.screenY(), this);
		this.mustReDrawMolecularArea = false;
		
		//New September 2016
		//handle the postSave and the event to JS
		if( this.saveCurrentState) {
			this.postSave();
			this.saveCurrentState = false;
		}
		if(this.afterStructureChangeEvent  != null && this.afterStructureChangeEvent.action != null) {
			//mol.cleanAfterChanged();
			notifyStructuralChangeToJS();
			this.afterStructureChangeEvent.reset();
			
			//BB new Feb 2017
			//disable the NEW button after structure change
			if(newMolecule == true) {
				newMolecule = false;
				mustReDrawTopMenu = true;
				repaint();
			}
		}

	}
	public void centerAllMoleculesAsAgroup(Dimension appletDimension, double menuScale, double molecularAreaScale) {
		
		if(reaction) return; //not implemented yet
		//this.appletHasBeenResized = false;
		
		Rectangle2D.Double chemicalDrawingBoundingBox = this.getChemicalDrawingBoundingBox(); //molecule coordinate
		Rectangle2D.Double appletMolBoundingBox = this.getMolecularAreaBoundingBoxCoordinate(appletDimension, menuScale, molecularAreaScale);
		double dx = appletMolBoundingBox.getCenterX() - chemicalDrawingBoundingBox.getCenterX();
		double dy = appletMolBoundingBox.getCenterY() - chemicalDrawingBoundingBox.getCenterY();
		Point.Double moveXY = new Point.Double(dx, dy);
	
		this.moveAllMolecules(moveXY);
	}

	
	void drawRightBorderImage(Graphics g) {
		if (!this.mustReDrawRightBorderImage)
			return;
		
		Rectangle2D.Double screenArea = new Rectangle2D.Double(dimension.width - rightBorder(), topMenuHeight(), rightBorder(), molecularAreaHeight);
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(rightBorderImage, menuScale, screenArea);
		
		double imgWidth = rightBorder(1);
		//double imgHeight = (double)this.molecularAreaHeight/this.depictScale;
		double imgHeight = screenArea.height/this.menuScale;
		//System.out.print("@@@@ drawRightBorderImage dimensionHeight="+dimension.height + " imgHeight=" + imgHeight + "\n");
		if (newLook) {
			og.setColor(Color.darkGray);
			//og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1);//right line
			//og.drawLine(0, 0, 0, imgHeight);//right line
			og.fillRect(0, 0, imgWidth, imgHeight);
			//og.fillRect(0, 0, imgWidth, imgHeight/2);
		}
		else {
			// vonkajsi okraj na pravej strane
			og.setColor(bgColor.darker());
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight );
			// predel vo farbe backgroundu
			og.setColor(bgColor);
			og.drawLine(imgWidth - 2, 0, imgWidth - 2, imgHeight );
			// svetly okraj dovnutra
			og.setColor(brightColor);
			og.drawLine(imgWidth - 3, 0, imgWidth - 3, imgHeight );
		}
		
		g.drawImage(rightBorderImage.getImage(), 
				(int) screenArea.x,
				(int) screenArea.y,
				this);

		
	}
	// ----------------------------------------------------------------------------
	void drawTopMenu(Graphics g) {
		if (!this.mustReDrawTopMenu)
			return;
		
		//System.out.print("@@@@ drawTopMenu");
		
		//PreciseGraphicsAWT og = topMenuImage.getGraphics();
		
		Rectangle2D.Double screenArea = new Rectangle2D.Double(0, 0, dimension.width, topMenuHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(topMenuImage, menuScale, screenArea);


		double imgWidth = (double)dimension.width /this.menuScale;
		double imgHeight = topMenuHeight(1.0);
		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (newLook) {
			og.setColor(Color.darkGray);
			double s = (menuCellSize+menuCellBorder()) * TOP_MENU_NUMBER_OF_CELLS;
			//og.drawRect(s,0,imgWidth-s-1,menuCellSize*2 + menuCellBorder()-1);
			og.drawRect(s,0,  imgWidth-s-1, imgHeight-1);
		}
		else {
			og.setColor(bgColor.darker());
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1); // right
			og.drawLine(0, imgHeight - 1, imgWidth - 1, imgHeight - 1); // bottom

			og.setColor(brightColor);
			og.drawLine(0, 0, imgWidth - 1, 0); // top
		}

		//og.drawLine(TOP_MENU_NUMBER_OF_CELLS * menuCellSize, 0, TOP_MENU_NUMBER_OF_CELLS * menuCellSize, imgHeight - 1); // predel

		//BB: redraw the FG menu cell if a substituent had been selected
		int savedAction = action;
		if(ACTION_GROUP_MIN <=  action && action <= ACTION_GROUP_MAX) {
			action = ACTION_FG;
		}
		for (int i = 1; i <= TOP_MENU_NUMBER_OF_CELLS; i++) {
			createSquare(og, i, 1); //icon cell 
			createSquare(og, i, 2);
		}

		//restore the action value in case it had been changed for redrawing above
		action = savedAction ; 

		g.drawImage(topMenuImage.getImage(), 0, 0, this);
	}

	// ----------------------------------------------------------------------------
	void drawLeftMenu(Graphics g) {
		if (!this.mustReDrawLeftMenu)
			return;

		
		Rectangle2D.Double screenArea = new Rectangle2D.Double(0, topMenuHeight(), leftMenuWidth(), dimension.height - topMenuHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(leftMenuImage, this.menuScale, screenArea);

		
		double imgWidth = leftMenuWidth(1);
		
		
		double imgHeight = (dimension.height - topMenuHeight()) /  this.menuScale;
		
		double yInfoArea =  imgHeight-infoAreaHeight(1);

		
		og.setColor(bgColor);
		og.fillRect(0, 0, imgWidth, imgHeight);

		if (newLook) {
			og.setColor(Color.darkGray);
			
			
			double y = LEFT_MENU_NUMBER_OF_CELLS * (menuCellSize + menuCellBorder()) + 3;
			
			if(yInfoArea>y) {
				og.drawLine(0,y,menuCellSize-1,y); // top horizontal line
				og.drawLine(0,y,0,imgHeight-1); // left
				
				og.drawLine(menuCellSize-1,y,menuCellSize-1,  yInfoArea); // right down to info area	
				og.drawLine(menuCellSize-1, yInfoArea,imgWidth, yInfoArea); // small horizontal line to info area 
			}
			// frame at the bottom			
			og.drawLine(0,imgHeight-1,imgWidth,imgHeight-1); // bottom 

		
		
		}
		else {
			og.setColor(brightColor);
			og.drawLine(0, 0, 0, imgHeight - 1); // left
			og.drawLine(0, LEFT_MENU_NUMBER_OF_CELLS * menuCellSize, imgHeight - 1, LEFT_MENU_NUMBER_OF_CELLS * menuCellSize); // predel
			
			og.setColor(bgColor.darker());
			//og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1 - menuCellSize); // right down to info area
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, yInfoArea+1); // right down to info area
			og.drawLine(0, imgHeight - 1, imgWidth - 0, imgHeight - 1); // bottom
		}
		for (int i = 3; i <= LEFT_MENU_NUMBER_OF_CELLS + 2; i++) {
			createSquare(og, 1, i);
		}
		
		g.drawImage(leftMenuImage.getImage(), (int)screenArea.x, (int)screenArea.y, this);
	}

	// ----------------------------------------------------------------------------
	void drawInfo(Graphics g) {
		log("drawInfo: " + this.mustReDrawInfo + "  : " + infoText);
		if (!this.mustReDrawInfo)
			return;
		if (infoText == null){
			infoText = "";
		}
		
		//screen position of the info bar at the bottom of the applet
		Rectangle2D.Double screenArea = new Rectangle2D.Double(leftMenuWidth(), dimension.height - this.infoAreaHeight(), dimension.width - leftMenuWidth(), infoAreaHeight());
		PreciseGraphicsAWT og = this.getScaledGraphicsOfPreciseImage(infoAreaImage, this.menuScale, screenArea);

		
		double imgWidth = screenArea.width/this.menuScale; //the width is reduced if scale > 1
		double imgHeight = this.infoAreaHeight(1); //unscaled because og is scaled
		og.setColor(bgColor);
		og.fillRect(0,0,imgWidth,imgHeight);

		if (newLook) {
			og.setColor(Color.darkGray);
			og.drawRect(-10,0,imgWidth-1+10,imgHeight-1); //-10: used for masking the left border
		}
		else {
			og.setColor(brightColor);
			//og.setColor(Color.red);
			//og.drawLine(0, 0, imgWidth - 1 - 2, 0); // top
			og.drawLine(0, 0, imgWidth - rightBorder(1)+1, 0); // top
			og.setColor(bgColor.darker());
			og.drawLine(0, imgHeight - 1, imgWidth - 1, imgHeight - 1); // bottom
			og.drawLine(imgWidth - 1, 0, imgWidth - 1, imgHeight - 1); // right
		}
		og.setFont(menuCellFontSmaller);
		og.setColor(Color.black);
		
		if (infoText.toLowerCase().contains("error"))
			og.setColor(Color.red);
		og.drawString(infoText, 10, 15);
		
		
		

		if (! this.depict) { /*in depict mode, another graphics must be used because the info bar is not present */
			//TODO: the java implemenrtation does not support drag and drop
			this.drawDragAndDropIcon(og, 1.0);
			if(fullScreenIconOption && isFullScreenSupported())
				this.drawFullScreenIcon(og, 1.0, this.dragAndDropIcon);
			else
				this.fullScreenIcon = null;
		}
		
		

		
		g.drawImage(infoAreaImage.getImage(), (int)screenArea.x,  (int)screenArea.y, this);
		

	}
	
	protected Dimension nonFullScreenSize = new Dimension();
	final protected double fullScreenScale = 3;
	
	/*
	 * to be redefined in JSME
	 */
	protected boolean isFullScreenSupported() {
		return true;
	}
	/**
	 * Java applet only. 
	 * FIXME: recompute bond center?
	 */
	protected void toggleFullScreen() {
		System.out.println("drawFullScreen " + this.isFullScreen);
		this.mustRedrawEverything();
		Dimension newDim;
		if(!isFullScreen) {
			//save current dimension
			nonFullScreenSize.setSize(this.dimension.width, this.dimension.height);
			newDim = Toolkit.getDefaultToolkit().getScreenSize();
			molecularAreaScale = Math.min(molecularAreaScale * fullScreenScale, maxMolecularAreaScale);
			menuScale = Math.min(menuScale * fullScreenScale, maxMenuScale);
		
		} else {
			molecularAreaScale = Math.max(molecularAreaScale / fullScreenScale, minmolecularAreaScale);
			menuScale = Math.max(menuScale / fullScreenScale, minMenuScale);
			newDim = nonFullScreenSize;
		
		}
		isFullScreen = !isFullScreen;
		this.setSize(newDim);

	}
	// ----------------------------------------------------------------------------
	boolean menuAction(int pressed) {
		// calling actions after pressing menu button or menu keys
		// called from mousePressed() or keyTyped()

		//idea: this.atomTypeChangeAction = true; //atom type selected or FG or query box
		// mouseover would only highlight the atoms

		if (pressed == 0)
			return false; // moze to byt ? ano, napr z keyTyped

		//BB
		this.mustRedrawNothing();
		boolean status = true;
		boolean structureChangePerformed = false;

		int actionOld = action;
		action = pressed;
		if (pressed <= 300) { // top menu
			//BB
			this.mustReDrawTopMenu = true;
			this.mustReDrawLeftMenu = true; //deselection possible on the left menu
			clearInfo(); //clear any messages
			
			switch (pressed) {
			case ACTION_CLEAR:
				clear();
				//idea: double click would do a complete cleaning of the undo and redo stack
				//this.molChangeManager.clear(); //delete all undo's
				//this.sdfStack.clear(); //delete all entries from the SDF stack
				//this.recordAfterStructureChangedEvent(JME.CLEAR); //already performed by clear()n
				
				//reset the red highlight correctly
				this.handleMouseLeaveActionMenu(ACTION_CLEAR);
				this.handleMouseEnterActionMenu(ACTION_CLEAR);

				structureChangePerformed = true; //sept 2016
				break;
			case ACTION_UNDO:
				// zostavaju rovnake settings ako predtym

				// BB
				mustReDrawMolecularArea = true; // needed for e.g. undo
				
				action = actionOld;
				if(!this.canMultipleUndo) { //PE's original undo
					// undo po new molecule (pri new smol = null)
					if (smol == null) {
						actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						clear();
					} else if (afterClear) {
						saved = ++numberofMoleculeParts;
						actualMoleculePartIndex = numberofMoleculeParts;
						afterClear = false;
					}
					// undo po standard change (aj po delete s upravenym saved)
					if (smol == null)
						break; // no molecule in undo stack
					mol = smol.deepCopy();
					moleculeParts[saved] = mol;
				} else {
					//multiple undo handling
					if (!this.molChangeManager.canUndo()) {
						info("No more undo");

						//actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						//clear();
					} else if (afterClear) {
						saved = ++numberofMoleculeParts;
						actualMoleculePartIndex = numberofMoleculeParts;
						afterClear = false;
					}
					if (!this.molChangeManager.canUndo())
						break; // no molecule in undo stack

					this.retoreState(this.molChangeManager.undo());
					this.recordAfterStructureChangedEvent(JME.UNDO);
					this.willPostSave(false);

					mustReDrawMolecularArea = true; 
					//System.out.println("*********** undo " + mol.natoms);

				}
				break;

			case ACTION_REDO:

				if(!this.canMultipleUndo) {
					action = actionOld;
					this.alert("The redo feature is not implemented yet");

				} else {
					action = actionOld;
					//BB this code is copied from the undo part and adapted
					if (!this.molChangeManager.canRedo()) {
						//actualMoleculePartIndex = numberofMoleculeParts; // mohlo sa medzitym zmenit
						//clear();
						info("No more redo");
						break;
					} else if (afterClear) {
						saved = ++numberofMoleculeParts;
						actualMoleculePartIndex = numberofMoleculeParts;
						afterClear = false;
					}
					// undo po standard change (aj po delete s upravenym saved)
					if (!this.molChangeManager.canRedo())
						break; // no molecule in undo stack
					this.retoreState(this.molChangeManager.redo());
					this.recordAfterStructureChangedEvent(JME.REDO);
					this.willPostSave(false);

					mustReDrawMolecularArea = true; 

				}


				break;
				
			case ACTION_IO: /*open popup menu with IO */
				this.handleCopyPastePopupMenu(null, this.fixedCopyPastePopupMenuPosition.x, this.fixedCopyPastePopupMenuPosition.y);
				action = actionOld;
				break;
				
			case ACTION_PGUP:
			case ACTION_PGDN:
			case ACTION_END:
			case ACTION_HOME:
				String sdf = null;
				action = actionOld;
				
				switch(pressed) {
					case ACTION_PGDN:
						sdf = this.sdfStack.previous();
						break;
					case ACTION_PGUP:
						sdf = this.sdfStack.next();
						break;
					case ACTION_END:
						sdf = this.sdfStack.last();
						break;
					case ACTION_HOME:
						sdf = this.sdfStack.first();
						break;
					default:
						assert(false);
			
				}
				

				if (sdf == null)
					info("No more molecules in SDF buffer");
				else {
					//sdf = sdf.replace("\n", "|");
					this.clearMyMolecularContent(); //to avoid any merging with the current molecule
					pasteFromSDFstack = true;
					this.readMolFile(sdf, false);//do not copy in undo
					pasteFromSDFstack = false;
					
					if(this.infoText.equals("")) { //no error mesage from readMolFile
						info("MOL n. " + this.sdfStack.getCurrentDisplayIndex() + " of " + this.sdfStack.size());
						structureChangePerformed = true;
						this.recordAfterStructureChangedEvent(JME.SD_FSTACK);
						this.willPostSave(false);
					}

				}

				break;


			case ACTION_SMI:

				this.handleSmilesBox();
				
				action = actionOld;
				break;
			case ACTION_QRY:
				this.handleQueryBox();
				
				// stay commented
				// action = action_old;
				break;
			case ACTION_JME:
				this.handleAboutBox();
				action = actionOld;
				break;
			case ACTION_NEW:
				// BB
				//mustReDrawMolecularArea = true;
				newMolecule = true;
				action = actionOld; // ak nie je bond alebo ring, malo by
				
				//there is no structure  change!!!! this is just a menu click
				//this.recordAfterStructureChangedEvent(JME.CLEAR);

				// resetnut
				break;
			case ACTION_MARK:
				// BB
				//mustReDrawMolecularArea = true;
				if (autonumber) {
					// autonumber added in 2009.09
					if (mouseShift) { // automark all atoms, zrusi stare mark
						mouseShift = false; // aby pridavalo cisla
						mol.numberAtoms();
						
						//added Oct 2015 - not tested
						mustReDrawMolecularArea = true;
						this.recordAfterStructureChangedEvent(JME.AUTO_NUMBER);
						structureChangePerformed = true;
						
						action = actionOld;
					}
				}
				// set na action_mark
				keyboradInputMark = 1; // starts from 1 ????????????????/
				//there is no structure change , only menu selection 123?
				//this.recordAfterStructureChangedEvent(JME.MARK);

				break;
				
//BB: END button was removed
//			case ACTION_SPIRO:
//				if (isStandAloneApplication) {
//					System.exit(0);
//				}
			//copy a reaction component to the other side of the reaction
			case ACTION_REACP:
				// save ???
				action = actionOld;
				int part = mol.reactionPart();
				if (part == ReactionRole.AGENT) {
					info("Copying the agent not possible !");
					break;
				}
				
				//compute the bounding box of the source molecule
				Rectangle2D.Double cad = mol.boundingBox();
				if(cad == null)
					break;

				mustReDrawMolecularArea = true;
				mol = new JMEmol(mol);
				// mol = mol.createClone(); // ???
				// posunie ju na spravne miesto
				//int dx = (int) ((dimension.width - menuCellSize) / 2 - cad.getCenterX()); //center[0]);
				Rectangle.Double molArea = this.getMolecularAreaBoundingBoxCoordinate();
				double dx = molArea.getCenterX() - cad.getCenterX(); //dx can be negative or positive
//				for (int i = 1; i <= mol.natoms; i++)
//					mol.x[i] += dx * 2;
//					//mol.atoms[i].x += dx * 2;
//					moveXY(mol, i, dx * 2, 0);
				mol.moveXY(dx*2, 0); //move the new created molecule to the other side
				
				
					
				//mol.complete();
				moleculeParts[++numberofMoleculeParts] = mol;
				actualMoleculePartIndex = numberofMoleculeParts;
				this.recordAfterStructureChangedEvent(JME.REACTION_COPY);
				
				structureChangePerformed = true;
				//added Jan 2016
				//this.postSave();
				
				//reset the blue highlight correctly
				this.handleMouseLeaveActionMenu(ACTION_REACP);
				this.handleMouseEnterActionMenu(ACTION_REACP);

				break;
			case ACTION_DELETE:
				//FIXME - DUPLICATED CODED with delete using the mouse!!!!!!!!!!!!!!!!!!!!
				// 2011.01 if touchedAtom or bond, deletes it
				//happens with keyboard shortcut not mouse action
				structureChangePerformed = this.actionDeleteTouchedAtomOrBond();
				break;

			case ACTION_FG:
				action = actionOld;
				this.showPopUpMenuRealtiveToScaledMainMenu(this.getFunctionalGroupPopumemu(), this.functionalGroupPopupMenuPosition.x, functionalGroupPopupMenuPosition.y);
				//this.getFunctionalGroupPopumemu().show(this, (int)(this.functionalGroupPopupMenuPosition.x * this.menuScale), 
				//		(int)(functionalGroupPopupMenuPosition.y * this.menuScale));
				break;

			case ACTION_CHARGE :
				//BB
				if(mol.touchedAtom > 0 && mol.changeCharge(mol.touchedAtom, 0)) {
					this.recordAtomEvent(JME.CHARGE_ATOM0); //same code as in mouseDown event
					structureChangePerformed = true;
				}
				break;

			default: // vsetky co nerobia okamzitu akcion (DEL, templates, +/-,
				// ...)
				break;
			}
		} else { // pressed > 300 (left menu - atoms)
			// BB
			this.mustReDrawLeftMenu = true;
			this.mustReDrawTopMenu = true; //deselection of an item in the top menu
			// if the action is coming from a keyboard structure change, then there is no need to redraw the the menu
			active_an = mapActionToAtomNumber(pressed, -1);
			
			//BB added August 2017
			clearInfo(); //clear any messages
			
			
//			switch (pressed) {
//			case ACTION_AN_C:
//				active_an = AN_C;
//				break;
//			case ACTION_AN_N:
//				active_an = AN_N;
//				break;
//			case ACTION_AN_O:
//				active_an = AN_O;
//				break;
//			case ACTION_AN_F:
//				active_an = AN_F;
//				break;
//			case ACTION_AN_CL:
//				active_an = AN_CL;
//				break;
//			case ACTION_AN_BR:
//				active_an = AN_BR;
//				break;
//			case ACTION_AN_I:
//				active_an = AN_I;
//				break;
//			case ACTION_AN_S:
//				active_an = AN_S;
//				break;
//			case ACTION_AN_P:
//				active_an = AN_P;
//				break;
//			case ACTION_AN_H:
//				active_an = AN_H;
//				break;
//			case ACTION_AN_X:
//				this.handleAtomXbox();
//				active_an = AN_X;
//				
//				break;
			/*
			case ACTION_AN_R:
				active_an = AN_R;
				break;
			case ACTION_AN_R1:
				active_an = AN_R1;
				break;
			case ACTION_AN_R2:
				active_an = AN_R2;
				break;
			case ACTION_AN_R3:
				active_an = AN_R3;
				
				
				break;
			*/

//			}
			
			if(active_an == AN_X) {
				this.handleAtomXbox();
			}
			//BB : handling R group
			if(pressed >=  ACTION_AN_R && pressed <= ACTION_AN_R_LAST) {
				active_an = AN_R + (pressed-ACTION_AN_R);
			}
			
			

			// 2009.09 if touchedAtom, changes it
			if (structureChangePerformed == false && mol.touchedAtom > 0) {
				// BB
				if (active_an != mol.an(mol.touchedAtom) && active_an != AN_X) {
					mol.AN(mol.touchedAtom, active_an);
					mol.Q(mol.touchedAtom, 0); // resetne naboj
					//mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
					mol.atoms[mol.touchedAtom].iso = 0; //BB: reset isotop
					//mol.nh[mol.touchedAtom] = 0;
					mol.atoms[mol.touchedAtom].nh = 0;

					//this.postSave();
					this.recordAtomEvent(JME.SET_ATOM + active_an); //active_an is an arbitrary number, should be changed to the string of the atom type
					
					//BB Sept 2015: changed the touched atom but do not change the menu
					//action = actionOld;
					structureChangePerformed = true;
				}
				else if (active_an == AN_X) {
					// MultiBox not atomxBox (this is static and always
					// available,
					// needed for key press)
					//FIXME: this code is never reached
					//code reached when the X keyboard shortcut is used
					//assert false;
					String xx = MultiBox.atomicSymbol.getText();
					mol.setAtom(mol.touchedAtom, xx);
					//this.postSave();
					this.recordAtomEvent(JME.SET_ATOM + active_an);
					structureChangePerformed = true;

				}
				//mol.cleanAfterChanged(); // to add Hs
			
			} 
		}

		//BB Sept 2015: add ring addition
		//extend with other actions:
		// phenyl ring (shortcut is "1"
		//2 for double bond?, see the help for the shortcucts
		/*
		 * atoms C, N, O, P, S, F, L (for Cl), B (for Br), I, H, R
bonds - for single bond, = for double bond
rings 3..8 for 3 to 8 membered rings, 1 for phenyl and 0 for furyl
groups a - COOH, y - NO2, z - SO3H, t - tert. butyl, ft - CF3
		 */
		if(!structureChangePerformed && (mol.touchedAtom > 0 || mol.touchedBond > 0)) {
			// the addRing function can handle both bond and atom
			//duplicated code
			//this works as well for addition of phenyl (KB shortcut is "1")
			if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {

				

				// fusing ring to bond
				lastAction = LA_RING; // in addRing may be set to 0
				mol.addRing();
				structureChangePerformed = true;
				this.recordBondEvent(JME.ADD_RING_BOND);
			}

			//BB Oct 2015: add bond & change bond without switch to double bond bond tool
			else if(action == ACTION_BOND_SINGLE ||  action == ACTION_BOND_DOUBLE || action == ACTION_BOND_TRIPLE) {

				if(mol.touchedAtom > 0) {
					//lastAction = LA_BOND; // in addBond may be set to 0
					lastAction = 0; // correction - ohterwise mouse drag will move the end of the new added bond instead of moving the molecule
					//mol.preSave();
					mol.addBond();
					this.recordBondEvent(JME.ADD_BOND);
					structureChangePerformed = true;
				} else { //mol.touchedBond > 0
					//code cpoied from mouseDown DUPLiCATED !!!! TODO
					int bondType =JMEmol.SINGLE ;
					String eventType = JME.SET_BOND_SINGLE;
					boolean changed; //BB
					switch(action) {
						case ACTION_BOND_DOUBLE:
							bondType = JMEmol.DOUBLE;
							eventType =JME.SET_BOND_DOUBLE;
							break;
						case ACTION_BOND_TRIPLE:
							bondType = JMEmol.TRIPLE;
							eventType = JME.SET_BOND_TRIPLE;
					}
					changed = bondType !=mol.bonds[mol.touchedBond].bondType;
					if(changed) {
						mol.bonds[mol.touchedBond].bondType = bondType;
						this.recordBondEvent(eventType);
						structureChangePerformed = true;
						mol.bonds[mol.touchedBond].stereo = 0; // zrusi stereo
					} else if(bondType == JMEmol.DOUBLE) { 
						//no change but clicked a second time on a double bond with the double bond tool
						//change normal double bond into crossed bond or vice versa
						mol.bonds[mol.touchedBond].toggleNormalCrossedDoubleBond();
						structureChangePerformed = true;
					}
					
				}

			}
			

		}

		if(structureChangePerformed) {
			//this.mustRedrawNothing(); //info might have been generated
			mustReDrawMolecularArea = true;
//			mocleanAfterChangedte();
//			
//			if(mustBeSaveToUndoStack);
//				this.postSave();

			updateReactionParts(); //a new bond might have connected two separated molecules
			
			action = actionOld; //BB avoid menu change  during repaint() after a key press that has changed the structure, like pressing 2 , add a double bond but do not switch to db tool
		}
		
		
		
		
		// repaintuje zbytocne vsetko - zatial nechat
		repaint();

		//BB
		return status;
	}

	/**
	 * This method recods the event and performn the postSave()
	 * @return true if the an atom or a bond has been deleted
	 */
	boolean actionDeleteTouchedAtomOrBond() {
		boolean structureChangePerformed = false;
		
		if (mol.touchedAtom > 0 || mol.touchedBond > 0) {
			// BB
			structureChangePerformed = true;
			//mol.preSave(); //TODO REMOVE
			if(mol.touchedAtom > 0 ) {
				mol.deleteAtom(mol.touchedAtom);
				this.recordAtomEvent(JME.DEL_ATOM);
				mol.touchedAtom = 0;
			} else {
				mol.deleteBond(mol.touchedBond);
				this.recordAtomEvent(JME.DEL_BOND);
				mol.touchedBond = 0;
				
			}
			mol.cleanAfterChanged(); // to add Hs

			//if an atom or a bond is deleted, then create new moleculeParts if needed
			JMEmol newParts[] = mol.splitMultiparts();
			if(newParts.length > 1) {
				for(int p = 0; p < newParts.length; p++) {
					if(p==0) {
						moleculeParts[actualMoleculePartIndex] = newParts[p]; //replaced by the first new molecule
						mol = moleculeParts[actualMoleculePartIndex];
					} else {
						moleculeParts[++numberofMoleculeParts] =newParts[p]; //Append new parts
					}
				}
			}
		}

		
		return structureChangePerformed;
	}
	/**
	 * Create an alert box with an OK button to display a message
	 * @param message
	 */
	public void alert(final String message) {
		GWT.runAsync(new JSME_RunAsyncCallback() {
			
		@Override
		public void onSuccess() {
			
			
			
		new AlertBox(message, JME.this, JME.bgColor).show();

		
		}
		});
		
		
		
	}


	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAboutBox() {
		GWT.runAsync(new JSME_RunAsyncCallback() {
			
		@Override
		public void onSuccess() {
			
			
		if (aboutBox != null ) {
			aboutBox.disposeIfShowing();
		}
		aboutBox = new MultiBox(0, JME.this);
		
		
		
		}
		});
	}
	
	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleQueryBox() {
		GWT.runAsync(new JSME_RunAsyncCallback() {
		
		@Override
		public void onSuccess() {
			
			
			
			
			//				if (queryBox != null) {
			//					queryBox.disposeIfShowing();
			//				}
			//				queryBox = new QueryBox(this);

			//BB: it is better that the query box keeps its selection when brought back - dispose() erase everything
			//however, it might be hidden behind another window, thus it has to show in front
			if (queryBox == null) {
				queryBox = new QueryBox(JME.this);
			} else {
				if(queryBox.isShowing()) {
					queryBox.toFront(); //not tested wihthin a browser window, works fine with Eclipse/Linux
					//queryBox.hide();
					//queryBox.show();
				} else {
					queryBox.show();
				}
			}

			
			
			
		}		
	});


	}
	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleSmilesBox() {
		GWT.runAsync(new JSME_RunAsyncCallback() {
			
		@Override
		public void onSuccess() {
		if (smilesBox != null) {
			smilesBox.disposeIfShowing();
		}
		smilesBox = new MultiBox(1, JME.this);
	
		
		
		}		
	});
		
	}

	/**
	 * Will be overidden in JSME for code splitting
	 */
	protected void handleAtomXbox() {
		GWT.runAsync(new JSME_RunAsyncCallback() {
			
		@Override
		public void onSuccess() {
			
			
			
			
		if (!webme) {
			if (atomxBox != null) {
				atomxBox.disposeIfShowing();
				atomxBox = null;
			}
			if (mol.touchedAtom == 0)
				atomxBox = new MultiBox(2, JME.this);
		}
		}
		
		
	});
		
	}
	// ----------------------------------------------------------------------------
	void createSquare(PreciseGraphicsAWT g, int xpos, int ypos) {
		int square = ypos * 100 + xpos;
		double xstart = (xpos - 1) * (menuCellSize + menuCellBorder());
		double ystart = (ypos - 1) * (menuCellSize + menuCellBorder());
		if (xpos == 1 && ypos > 2)
			ystart -= (2 * menuCellSize); // relative coordinates in leftMenu
		g.setColor(bgColor);
		if (newLook) {
			if (square == action) {
				g.setColor(bgColor.darker());
				//System.out.println("xstart=" + xstart + " ystart=" + ypos);
			} 

			g.fillRect(xstart, ystart, menuCellSize, menuCellSize);
			g.setColor(Color.darkGray);
			g.drawRect(xstart, ystart, menuCellSize-1, menuCellSize-1);
		}
		else {
			if (square == action)
				g.fill3DRect(xstart + 1, ystart + 1, menuCellSize, menuCellSize, false);
			else
				g.fill3DRect(xstart, ystart, menuCellSize, menuCellSize, true);
		}

		// treba, aby nekreslilo neaktivne buttons
		if (square == ACTION_AN_R && !rButton)
			return;

		//if (square == ACTION_END && !isStandAloneApplication)
		//	return;
		if (square == ACTION_QRY && !query)
			return;
		if (square == ACTION_STEREO && !stereo)
			return;
		if (square == ACTION_NEW && !multipart)
			return;
		if (square == ACTION_MARK && !(number || autonumber))
			return;
		if (square == ACTION_REACP && !reaction)
			return;

		// draws icon or text in the square
		double marginFromCellBorder = menuCellSize / 4; // space between cell border and inside icon
		if (ypos < 3) { // top menu squares
			g.setColor(Color.black);
			switch (square) {
			case ACTION_SMI: // smiley face
				if (!bwMode) {
					g.setColor(Color.yellow);
					g.fillOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // head
					g.setColor(Color.black);
				}
				g.drawOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // head
				g.drawArc(xstart + 6, ystart + 6, menuCellSize - 12, menuCellSize - 12, -35, -110); // mouth
				// oci
				g.fillRect(xstart + 9, ystart + 9, 2, 4);
				g.fillRect(xstart + menuCellSize - 10, ystart + 9, 2, 4);
				// jazyk
				if (Math.random() < 0.04) {
					g.setColor(Color.red);
					g.fillRect(xstart + 10, ystart + 18, 4, 4);
				}
				// blink
				if (Math.random() > 0.96) {
					g.setColor(Color.yellow);
					g.fillRect(xstart + menuCellSize - 10, ystart + 8, 2, 3);
				}
				break;
			case ACTION_SPIRO:
				// drawing spiro button
				double xFarLeft = xstart + marginFromCellBorder;
				double xFarRight = xstart + menuCellSize - marginFromCellBorder;
				double xMiddle =xstart + menuCellSize/2;
				//bottom left - black line
				g.drawLine(xFarLeft, ystart + menuCellSize -marginFromCellBorder ,xMiddle , ystart + menuCellSize/2);
				g.drawLine(xstart + menuCellSize/2, ystart + menuCellSize/2, xFarRight, ystart + menuCellSize -marginFromCellBorder);
				
				double y = ystart + menuCellSize -marginFromCellBorder ;
				double dotLength = ((double)this.menuCellSize)/this.standardMenuCellSize;
				g.drawLine(xMiddle - dotLength, y , xMiddle - 2 * dotLength, y);
				g.drawLine(xMiddle + dotLength, y , xMiddle + 2 * dotLength, y);
				

				g.setColor(Color.magenta);
				//top left - magenta line
				g.drawLine(xFarLeft, ystart + marginFromCellBorder , xMiddle, ystart + menuCellSize/2);
				g.drawLine(xstart + menuCellSize/2, ystart + menuCellSize/2, xFarRight, ystart + marginFromCellBorder);

				y = ystart + marginFromCellBorder ;
				g.drawLine(xMiddle - dotLength, y , xMiddle - 2 * dotLength, y);
				g.drawLine(xMiddle + dotLength, y , xMiddle + 2 * dotLength, y);

				
				//restore default color
				g.setColor(Color.black);
				break;
				
			case ACTION_QRY:
				g.setColor(Color.orange);
				g.fillRect(xstart + 4, ystart + 4, menuCellSize - 8, menuCellSize - 8); // head
				g.setColor(Color.black);
				g.drawRect(xstart + 4, ystart + 4, menuCellSize - 8, menuCellSize - 8); // head
				g.drawArc(xstart + 6, ystart + 6, menuCellSize - 11, menuCellSize - 12, -35, -110); // mouth
				g.fillRect(xstart + 9, ystart + 9, 2, 4);
				g.fillRect(xstart + menuCellSize - 10, ystart + 9, 2, 4);
				break;
			case ACTION_CHARGE:
				//squareText(g, xstart, ystart, "+ /  ");
				//squareText(g, xstart, ystart, "+ / -");
				//squareTextBold(g, xstart, ystart, Color.black, "+ -");
				//g.drawLine(xstart + 15, ystart + 13, xstart + 19, ystart + 13); // better
				// -
				double padding = (double)menuCellSize / 4 ;
				//the / line
				g.drawLine(xstart + padding, ystart + menuCellSize - padding, 
						xstart + menuCellSize - padding, ystart + padding);

				double symbolSize = (double)menuCellSize / 2 - padding;

				// the minus - bottom right
				double minusY = ystart + menuCellSize * 2 / 3;
				double minusStartX = xstart + menuCellSize / 2;
				double minusEndX = minusStartX + symbolSize;

				g.drawLine(minusStartX, minusY, minusEndX, minusY);

				// the plus horizontal line - top left
				double hY = ystart + menuCellSize * 1 / 3;
				double hEndX = minusStartX;
				double hStartX = minusStartX - symbolSize;
				g.drawLine(hStartX, hY, hEndX, hY);

				// the plus vertical line - top left
				double vX = (hStartX + hEndX) / 2;
				double vStartY = hY - symbolSize / 2;
				double vEndY = vStartY + symbolSize;
				g.drawLine(vX, vStartY, vX, vEndY);

				break;

			case ACTION_MOVE_AT:
				
				if(this.showAtomMoveButton) {
					//Draw a blue rectangle centered in the cell
					double reduction = (double)marginFromCellBorder/2;
					double squareSize = menuCellSize - 2 * marginFromCellBorder - 2*reduction;
					double brx = xstart + reduction + marginFromCellBorder; //blue rectangle x
					double bry = ystart + (brx - xstart);
					
					g.setColor(Color.BLUE);
					g.drawRect(brx, bry, squareSize, squareSize);
	
					g.setColor(Color.BLACK);
	
					//four triangles symbolising arrows
					double middleX = xstart + menuCellSize / 2;
					double middleY = ystart + menuCellSize / 2;
					
					double arrowMarginFromCellBorder = reduction; //not enough space for using a complete margin
					double arrowHeight = reduction ;
					double arrowWidth = squareSize ; //must be the same as squareSize for small cells, if different, the code has to be adapted
					assert arrowHeight > 0;
					
					
					//top triangle arrow
					double xLeft = brx;
					double xRight = brx + arrowWidth;
					double yTop = ystart + arrowMarginFromCellBorder;
					//int yBottom = bry - reduction;
					double yBottom = yTop + arrowHeight;
	
					g.drawLine(xLeft, yBottom , middleX , yTop);
					g.drawLine(middleX , yTop, xRight, yBottom);
					
					
					//bottom triangle arrow
					//x coordinates are the same
					yBottom = bry + squareSize + reduction;
					yTop = yBottom + arrowHeight;
					g.drawLine(xLeft, yBottom , middleX , yTop);
					g.drawLine(middleX , yTop, xRight, yBottom);
	
					
					
					//Left triangle
					xLeft =xstart + reduction;
					xRight = xLeft + arrowHeight;
					yTop = bry;
					yBottom = yTop + arrowWidth;
					
					g.drawLine(xRight, yTop , xLeft , middleY);
					g.drawLine(xLeft , middleY , xRight , yBottom);
	
					//right triangle
					//y coordinates are the same
					xLeft = brx + squareSize + reduction;
					xRight = xLeft + arrowHeight;
					
					g.drawLine(xLeft, yTop , xRight , middleY);
					g.drawLine(xRight , middleY , xLeft , yBottom);
				}
				
				break;
				
				
				
			case ACTION_UNDO:
				// g.drawArc(xstart+6,ystart+6,sd-12,sd-12,270,270); // head
				//g.drawArc(xstart + 6, ystart + 7, menuCellSize - 12, menuCellSize - 14, 270, 270); // head

				this.drawUndoOrRedoArrowMenuCell(g, xstart, ystart, menuCellSize, true);


				// squareText(g,xstart,ystart,"UDO");
				break;

			case ACTION_REDO:
				this.drawUndoOrRedoArrowMenuCell(g, xstart, ystart, menuCellSize, false);
				break;

			case ACTION_IO :
				this.drawInputOutputArrowsMenuCell(g, xstart, ystart, menuCellSize);
				this.fixedCopyPastePopupMenuPosition = new Point((int)xstart, (int)ystart);

				break;
				
			case ACTION_REACP:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart
						+ menuCellSize / 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder
						* 3 / 2, ystart + menuCellSize / 2 + marginFromCellBorder / 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder
						* 3 / 2, ystart + menuCellSize / 2 - marginFromCellBorder / 2);
				break;
			case ACTION_CLEAR:
				g.setColor(Color.white);
				g.fillRect(xstart + 3, ystart + 5, menuCellSize - 7, menuCellSize - 11);
				g.setColor(Color.black);
				g.drawRect(xstart + 3, ystart + 5, menuCellSize - 7, menuCellSize - 11);
				// squareText(g,xstart,ystart,"CLR");
				break;
			case ACTION_NEW:
				// special handling (aby boli 2 stvorce on)
				g.setColor(bgColor);
				if (newMolecule)
					g.fill3DRect(xstart + 1, ystart + 1, menuCellSize, menuCellSize, false);
				g.setColor(Color.black);
				squareText(g, xstart, ystart, "NEW");
				break;
			case ACTION_DELGROUP:
				// squareText(g,xstart,ystart,"D-R");
				g.setColor(Color.red);
				g.drawLine(xstart + 7, ystart + 7, xstart + menuCellSize - 7, ystart + menuCellSize
						- 7);
				//g.drawLine(xstart + 8, ystart + 7, xstart + menuCellSize - 6, ystart + menuCellSize
				//		- 7);
				g.drawLine(xstart + 7, ystart + menuCellSize - 7, xstart + menuCellSize - 7,
						ystart + 7);
				//g.drawLine(xstart + 8, ystart + menuCellSize - 7, xstart + menuCellSize - 6,
				//		ystart + 7);
				g.setColor(Color.black);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + 12, ystart
						+ menuCellSize / 2);
				squareText(g, xstart + 6, ystart, "R");
				break;
			case ACTION_DELETE:
				// squareText(g,xstart,ystart,"DEL");
				g.setColor(Color.red);
				// g.drawLine(xstart+m,ystart+m,xstart+sd-m,ystart+sd-m);
				// g.drawLine(xstart+m+1,ystart+m,xstart+sd-m+1,ystart+sd-m);
				// g.drawLine(xstart+m,ystart+sd -m,xstart+sd-m,ystart+m);
				// g.drawLine(xstart+m+1,ystart+sd-m,xstart+sd-m+1,ystart+m);
				g.drawLine(xstart + 7, ystart + 7, xstart + menuCellSize - 7, ystart + menuCellSize
						- 7);
				//g.drawLine(xstart + 8, ystart + 7, xstart + menuCellSize - 6, ystart + menuCellSize
				//		- 7);
				g.drawLine(xstart + 7, ystart + menuCellSize - 7, xstart + menuCellSize - 7,
						ystart + 7);
				//g.drawLine(xstart + 8, ystart + menuCellSize - 7, xstart + menuCellSize - 6,
				//		ystart + 7);
				g.setColor(Color.black);
				break;
			case ACTION_MARK:
				if (star) {
					if(false) {
					// star (not filled yet)
					g.setColor(Color.cyan);
					g.drawLine(xstart + 11, ystart + 5, xstart + 9, ystart + 9);
					g.drawLine(xstart + 9, ystart + 9, xstart + 4, ystart + 9);
					g.drawLine(xstart + 4, ystart + 9, xstart + 8, ystart + 12);
					g.drawLine(xstart + 8, ystart + 12, xstart + 6, ystart + 18);
					g.drawLine(xstart + 6, ystart + 18, xstart + 11,
							ystart + 15);

					g.drawLine(xstart + 12, ystart + 5, xstart + 14, ystart + 9);
					g.drawLine(xstart + 14, ystart + 9, xstart + 19, ystart + 9);
					g.drawLine(xstart + 19, ystart + 9, xstart + 15,
							ystart + 12);
					g.drawLine(xstart + 15, ystart + 12, xstart + 17,
							ystart + 18);
					g.drawLine(xstart + 17, ystart + 18, xstart + 12,
							ystart + 15);
					g.setColor(Color.black);
					} else {
						//May 2015replaced by a circle
						g.setColor(Color.cyan);
						g.fillOval(xstart + 3, ystart + 3, menuCellSize - 6, menuCellSize - 6); // same as for the smiley
						g.setColor(Color.black);

					}
				} else
					squareText(g, xstart, ystart, "123");
				break;
			case ACTION_JME:
				// squareText(g,xstart,ystart,"JME");
				// g.drawImage(infoImage,xstart+2,ystart+2,this);
				g.setColor(Color.blue);
				double coloredRectSize = menuCellSize - 8;
				double coloredRectSizeX = xstart + (menuCellSize - coloredRectSize) /2 ;
				double coloredRectSizeY = ystart + (menuCellSize - coloredRectSize) /2 ;
				g.fillRect(coloredRectSizeX, coloredRectSizeY, coloredRectSize, coloredRectSize);
				g.setColor(Color.black);
				//g.drawRect(coloredRectSizeX, coloredRectSizeY, coloredRectSize, coloredRectSize);
				//squareTextBold(g, xstart + 1, ystart - 1, Color.white, "i");
				squareTextBold(g, xstart, ystart, Color.white, "i");
				break;
			case ACTION_STEREO:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart
						+ menuCellSize / 2 + 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart
						+ menuCellSize / 2 - 2);
				g.drawLine(xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 2, xstart + menuCellSize
						- marginFromCellBorder, ystart + menuCellSize / 2 - 2);
				break;
			case ACTION_BOND_SINGLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart
						+ menuCellSize / 2);
				break;
			case ACTION_BOND_DOUBLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 - 2, xstart + menuCellSize - marginFromCellBorder,
						ystart + menuCellSize / 2 - 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 + 2, xstart + menuCellSize - marginFromCellBorder,
						ystart + menuCellSize / 2 + 2);
				break;
			case ACTION_BOND_TRIPLE:
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2, xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 - 3, xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 - 3);
				g.drawLine(xstart + marginFromCellBorder, ystart + menuCellSize / 2 + 3, xstart + menuCellSize - marginFromCellBorder, ystart + menuCellSize / 2 + 3);
				break;
			case ACTION_CHAIN:
				g.drawLine(xstart + marginFromCellBorder / 2, ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3, xstart + marginFromCellBorder
						/ 2 * 3, ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3);
				g.drawLine(xstart + marginFromCellBorder / 2 * 3, ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3, xstart
						+ marginFromCellBorder / 2 * 5, ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3);
				g.drawLine(xstart + marginFromCellBorder / 2 * 5, ystart + marginFromCellBorder * 2 + marginFromCellBorder / 3, xstart
						+ marginFromCellBorder / 2 * 7, ystart + marginFromCellBorder * 2 - marginFromCellBorder / 3);
				break;
			case ACTION_RING_3: // klesnute o 2
				drawRingIcon(g, xstart, ystart + 2, 3);
				break;
			case ACTION_RING_4:
				drawRingIcon(g, xstart, ystart, 4);
				break;
			case ACTION_RING_5:
				drawRingIcon(g, xstart, ystart, 5);
				break;
			case ACTION_RING_PH:
				drawRingIcon(g, xstart, ystart, 1);
				break;
			case ACTION_RING_6:
				drawRingIcon(g, xstart, ystart, 6);
				break;
			case ACTION_RING_7:
				drawRingIcon(g, xstart, ystart, 7);
				break;
			case ACTION_RING_8:
				drawRingIcon(g, xstart, ystart, 8);
				break;

			case ACTION_FG:
				squareText(g, xstart, ystart, "FG");
				this.functionalGroupPopupMenuPosition = new Point((int)xstart, (int)ystart);
				break;

			}
		} else { // ypos >=3 (left menu squares)
			
			int dan =  mapActionToAtomNumber(square, -1);
			squareTextBold(g, xstart, ystart, color[dan], zlabel[dan]);
			
		}
	}

	//BB
	//To ease debugging this method, the menuCellSize can be set to a higher value , e.g 120
	void drawUndoOrRedoArrowMenuCell(PreciseGraphicsAWT g, double xstart, double ystart, double cellSize, boolean undo) {
		double arrowWidth = ((double)cellSize / 4.0); //6
		double arrowHeight = arrowWidth ;
		double margin = 2;
		ystart -= 1; //Nov 2016: better vertical centering
		
		//X values: we work with relative values because the absolute values will be different for the Undo and Redo arrows
		double xStartArrowLine = margin;
		double xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		double xEndArrowLine = xStartArrowLine + arrowWidth ;


		//All Y values are absolute
		double yStartArrowLine = ystart + (10.0 * cellSize / 24.0) ;
		double yArrowTip  = yStartArrowLine + arrowHeight;

		double xEnd = xstart + cellSize;

		double absoluteXArrowTip = 0;
		double absoluteXstartArrowLine = 0;
		double absoluteXEndArrowLine = 0;
		if(undo) {
			absoluteXstartArrowLine = xStartArrowLine + xstart;
			absoluteXArrowTip = xArrowTip + xstart ;
			absoluteXEndArrowLine = xEndArrowLine + xstart;
		} else {
			//mirror image
			// Y values stay the same
			absoluteXArrowTip = xEnd - xArrowTip;
			absoluteXstartArrowLine = xEnd - xStartArrowLine;
			absoluteXEndArrowLine =  xEnd - xEndArrowLine ;
		}


		//draw the two lines of the arrow tip - two sides of the triangle
		g.drawLine(absoluteXstartArrowLine , yStartArrowLine, absoluteXArrowTip, yArrowTip);
		g.drawLine(absoluteXEndArrowLine , yStartArrowLine, absoluteXArrowTip , yArrowTip);


		//draw middle line of the arrow , but not as extended as the triangle lines - it looks nicer so
		double yArrowCenterCorrection = arrowHeight / 3 - 0.5; //without the  -0.5 , there is a gap visible when zooming in

		g.drawLine(absoluteXArrowTip , yStartArrowLine + yArrowCenterCorrection, absoluteXArrowTip, yArrowTip);


		//The arc


		//define the coordinates and sizes of the bounding box that will contain the arc 
		double xStartArcBoxTopLeft = xArrowTip;
		double yStartArcBoxTopLeft = ystart + xStartArcBoxTopLeft;
		double arcBoxWidth = cellSize -  xStartArcBoxTopLeft - 2 * margin;
		double arcBoxHeight = cellSize - 2 * margin;

		//The arc has to be moved slightly up in order to align with the start of the line of the center of the arrow (see above)
		yStartArcBoxTopLeft -= yArrowCenterCorrection;
		arcBoxHeight -= yArrowCenterCorrection ;

		arcBoxHeight -= 1; //looks better when the cell size is small

		double arcSpan = 270;
		double startAngle = 0;
		double absoluteXxtartArcBoxTopLeft = 0;
		if(undo) {
			absoluteXxtartArcBoxTopLeft = xstart + xStartArcBoxTopLeft;
			startAngle = 270;
		} else {
			absoluteXxtartArcBoxTopLeft = xEnd - arcBoxWidth - xStartArcBoxTopLeft;
			arcSpan *= -1;
			startAngle = -90;
		}
		//draw an arc inside the box
		g.drawArc(absoluteXxtartArcBoxTopLeft, yStartArcBoxTopLeft, arcBoxWidth , arcBoxHeight, startAngle, arcSpan);
	}
	
	//To ease debugging this method, the menuCellSize can be set to a higher value , e.g 120
	/**
	 * draw two vertical blue arrows to symbolize output / input, arrows are simplified as triangles
	 * @param g
	 * @param xstart
	 * @param ystart
	 * @param cellSize
	 * @param undo
	 */
	void drawInputOutputArrowsMenuCell(PreciseGraphicsAWT g, double xstart, double ystart, double cellSize) {
		
		// arrows are simplified as triangle
		double arrowWidth = this.ioArrowWidth;
		double arrowHeight = arrowWidth ;
		double margin = this.ioMargin;
		double xStartArrowLine = margin + xstart;
		double xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		double xEndArrowLine = xStartArrowLine + arrowWidth ;


		double yStartArrowLine = ystart + margin ;
		double yArrowTip  = yStartArrowLine + arrowHeight;


		g.setColor(Color.BLUE);
		
		g.fillPolygon(new double[] {xStartArrowLine,xArrowTip, xEndArrowLine},
				new double[] {yStartArrowLine, yArrowTip, yStartArrowLine}, 3);

		/*2nd triangle */
		xStartArrowLine = xArrowTip;
		xArrowTip = xStartArrowLine + arrowWidth / 2.0;
		xEndArrowLine = xStartArrowLine + arrowWidth ;
		
		yArrowTip  = yStartArrowLine + arrowHeight / 2.0;
		yStartArrowLine = yArrowTip + arrowHeight;
		
		g.fillPolygon(new double[] {xStartArrowLine,xArrowTip, xEndArrowLine},
				new double[] {yStartArrowLine, yArrowTip, yStartArrowLine}, 3);

	}

	/**
	 * Draw the drag and drop symbol at the bottom right of the JSME container
	 * @param g : either the infor bar or the molecular area
	 * @param graphicsContainerWidth
	 * @param graphicsContainerHeight
	 */
	void drawDragAndDropIcon(PreciseGraphicsAWT g, double iconScale) {
		// arrows are simplified as triangle


		
		double graphicsContainerWidth = g.getWidth();
		double graphicsContainerHeight = g.getHeight();

		//Use the same size as I/O arrows

		double margin = this.ioMargin * iconScale;
		double arrowWidth = this.ioArrowWidth * iconScale;
		double arrowHeight = arrowWidth;
		
		if(dragAndDropIcon == null)
			dragAndDropIcon = new Icon(g);
		else
			dragAndDropIcon.pg = g;
		
		if(this.depict) {
			margin = 0; //put the arrow at the extreme left and bottom without any margin
		}
		
		double xStartArrowLine = graphicsContainerWidth - margin - arrowWidth;
		double xArrowTip = xStartArrowLine + arrowWidth ;

		
		double yArrowBottom;

		double yArrowTop ;
		double yArrowMiddle ;

		if(! this.depict) { //non depict mode: the arrow is Y centered in the middle of the info bar
			yArrowMiddle = graphicsContainerHeight / 2;
			yArrowBottom = yArrowMiddle + arrowHeight/2;
			yArrowTop = yArrowMiddle - arrowHeight/2;
		} else { // arrow is placed at the bottom right
			 yArrowBottom  = graphicsContainerHeight;
	
			 yArrowTop = yArrowBottom  - arrowHeight;
			 yArrowMiddle  = (yArrowTop + yArrowBottom) / 2;
		}

		g.setColor(Color.BLUE);
		
		g.fillPolygon(new double[] {xStartArrowLine,xArrowTip, xStartArrowLine},
				new double[] {yArrowTop, yArrowMiddle, yArrowBottom}, 3);
		
		dragAndDropIcon.setRect(xStartArrowLine, yArrowTop, arrowWidth, arrowHeight);

	}
	
	//isFullScreen() is overiden is JSME
	public boolean isFullScreen() {
		return this.isFullScreen;
	}
	/**
	 * Draw the icon for toggling between normal and fullscreen
	 * @param g
	 * @param graphicsContainerWidth
	 * @param graphicsContainerHeight
	 * @param iconScale
	 * @param expand
	 */
	void  drawFullScreenIcon(PreciseGraphicsAWT g, double iconScale, Icon rightIcon) {
		

		boolean expand = !isFullScreen(); 
		
		//the icon is needed for event handling
		if(this.fullScreenIcon == null) {
			this.fullScreenIcon = new Icon(g);
		} else {
			this.fullScreenIcon.pg = g;
		}
		
		double margin = this.ioMargin * iconScale;
		double iconHeight = this.ioArrowWidth * iconScale; //same height as the DnD icon
		
		//the icon will placed at the bottom right
		double rightX = g.getWidth();
		double graphicsContainerHeight = g.getHeight();
		if(rightIcon != null) {
			rightX = rightIcon.x;//put the icon to left side of the DnD icon if present
			iconHeight = rightIcon.height; //same height as the DnD icon
			//move further to the left of the DnD icon
			rightX -= 2*margin;
		}
		

		
		//icon will look like a monitor display with 16:9 ratio
		double rectangleWidth = iconHeight *16/9;

		double startSize = 1.0;
		double endSize = 0.3;
		double startColor = 0;
		double endColor = 1.0;
		int steps = 20;
		boolean firstLoop = true;
		
		
		//create a gradient blue to white (or vice versa) by stacking rectangles of
		//decreasing sizes
		for(double relativeSize = startSize; relativeSize>=endSize; relativeSize-= (startSize-endSize)/steps)
		{
			float c= (float)((startSize-relativeSize)*(endColor-startColor)/(startSize-endSize));

			//reverse the icon color scheme when the applet is in full screen mode
			if(!expand) {
				c = (float)endColor - c;
			}
			Color color = new Color(c, c, 1.0f);
			g.setColor(color);

			double h = iconHeight * relativeSize;
			double w = h / iconHeight * rectangleWidth;
			double x = rightX - rectangleWidth +(rectangleWidth-w)/2;
			double y;
			if(! this.depict) { //non depict mode: the icon is Y centered in the middle of the info bar
				y = graphicsContainerHeight / 2 - h/2;
			} else {
				y = graphicsContainerHeight-iconHeight/2 -h/2;
			}
			g.fillRect(x, y, w, h);
			
			if(firstLoop) {
				//save the position of the icon on the graphics - will be used for event handling
				firstLoop = false;
				fullScreenIcon.setRect(x, y, w, h); //for event handling
			}
		
		}


		
	}
	
	// --------------------------------------------------------------------------
	void squareText(PreciseGraphicsAWT g, double xstart, double ystart, String text) {

		//Smaller font is needed to display NEW and 123

		//		g.setFont(menuCellFontSmaller);
		//		int hSmall = menuCellFontSmallerMet.getBoxUppercaseHeight(); // vyska fontu
		//		int w = menuCellFontSmallerMet.stringWidth(text);

		FontMetrics fm =  menuCellFontMet;
		int w = fm.stringWidth(text);

		//Smaller font is needed to display NEW and 123
		//If the text is too wide for the cell, then use a smaller font
		if(w >=  menuCellSize -1) {
			int size = fm.getFont().getSize();
			//TODO: font cache does not work here
			//decrease font size until the text fits in the cell
			while(w >=  menuCellSize - 1 && size > 1) {
				size --;
				Font smallerFont = new Font(fm.getFont().getName(), fm.getFont().getStyle(), size);
				fm = getFontMetrics(smallerFont);
				w = fm.stringWidth(text);
				g.setFont(smallerFont);

			}
		} else {
			g.setFont(menuCellFont);
		}
		int h = this.stringHeight(fm); // vyska fontu

		g.drawString(text, xstart + (menuCellSize - w) / 2, ystart + (menuCellSize - h) / 2 + h);


	}



	// --------------------------------------------------------------------------
	void squareTextBold(PreciseGraphicsAWT g, double xstart, double ystart, Color col,
			String text) {
		//Used for the atom symbols on the left side menu
		double h = this.stringHeight(menuCellFontBoldMet); // vyska fontu
		double w = menuCellFontBoldMet.stringWidth(text);
		g.setFont(menuCellFontBold);
		g.setColor(col);
		if (bwMode)
			g.setColor(Color.black);
		g.drawString(text, xstart + (menuCellSize - w) / 2, ystart + (menuCellSize - h) / 2 + h);
		// poor man's BOLD
		// g.drawString(text,xstart+(sd-w)/2+1,ystart+(sd-h)/2+h);
	}


	// --------------------------------------------------------------------------
	void drawRingIcon(PreciseGraphicsAWT g, double xstart, double d, int n) {
		double m = menuCellSize / 4; // margin
		boolean ph = false;
		double xp[] = new double[9];
		double yp[] = new double[9]; // polygon coordinates
		double xcenter = xstart + menuCellSize / 2;
		double ycenter = d + menuCellSize / 2;
		double rc = menuCellSize / 2 - m / 2;
		if (n == 1) {
			n = 6;
			ph = true;
		}
		for (int i = 0; i <= n; i++) {
			double uhol = Math.PI * 2. / n * (i - .5);
			xp[i] = xcenter + rc * Math.sin(uhol);
			yp[i] = ycenter + rc * Math.cos(uhol);
		}
		g.drawPolygon(xp, yp, n + 1);
		if (ph) { // double bonds in Ph icon
			for (int i = 0; i <= n; i++) {
				double uhol = Math.PI * 2. / n * (i - .5);
				xp[i] = xcenter + (rc - 3) * Math.sin(uhol);
				yp[i] = ycenter + (rc - 3) * Math.cos(uhol);
			}
			g.drawLine(xp[0], yp[0], xp[1], yp[1]);
			g.drawLine(xp[2], yp[2], xp[3], yp[3]);
			g.drawLine(xp[4], yp[4], xp[5], yp[5]);
		}
	}

	// ----------------------------------------------------------------------------
	
	void clearInfo() {
		info(customDefaultInfoText);
	}
	void info(String text) {
		if(text == null)
			text = customDefaultInfoText;
		mustReDrawInfo = true;
		infoText = text;
		this.log("info: " + text);
			
		// co s doMenu a repaintom
	}

	// ----------------------------------------------------------------------------
	// Will do an immediate repaint
	public void showInfo(String text) {

		info(text);
		repaint();
	}

	public void setCustomDefaultInfoText(String text) {
		showInfo(text);
		customDefaultInfoText = text;
	}
	
	/**
	 * select one of the menu action without having to click on the menu
	 * @param action
	 */
	public void setAction(int action) {
		this.action = action;
	}
	
	/**
	 * BB
	 * 
	 * Find out which button-action matches the mouse coordinates
	 * @param x
	 * @param y
	 * @return
	 */
	public int determineMenuAction(int x, int y, boolean ignoreDisabledActions) {
		int action = 0;
		
		//convert the x,y event coordinate to the menu scale
		x = (int) Math.round((double)x / this.menuScale);
		y = (int) Math.round((double)y / this.menuScale);
		
		if ( x < leftMenuWidth(1.0) || y < topMenuHeight(1.0)) { // --- inside the menu area

			int xbutton = 0;
			for (int i = 1; i <= TOP_MENU_NUMBER_OF_CELLS; i++)
				if (x < i * (menuCellSize+menuCellBorder())) {
					xbutton = i;
					break;
				}
			int ybutton = 0;
			for (int i = 1; i <= LEFT_MENU_NUMBER_OF_CELLS + 2; i++)
				if (y < i * (menuCellSize+menuCellBorder())) {
					ybutton = i;
					break;
				}
			if (xbutton > 0 && ybutton > 0) {
				action = ybutton * 100 + xbutton;
			}
		}
		
		// TODO: filter out all actions  that are disabled
		if(ignoreDisabledActions) {
			switch(action) {
			case ACTION_REACP:
				if(!this.reaction) action = 0;
				break;
			}
			
		}
		return action;
	}
	

	
	@Override
	public void mouseWheelMoved(MouseWheelEvent e) {
		double newScale;
		
		if(!allowZooming) 
			return;

		double notches = e.getWheelRotation();
		
		String message;
		String newline = "\n";
		if (notches < 0) {
			message = "Mouse wheel moved UP " + -notches + " notch(es)" + newline;
		} else {
			message = "Mouse wheel moved DOWN " + notches + " notch(es)" + newline;
		}
		if (e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL) {
			message += "    Scroll type: WHEEL_UNIT_SCROLL" + newline;
			message += "    Scroll amount: " + e.getScrollAmount() + " unit increments per notch"
					+ newline;
			message += "    Units to scroll: " + e.getUnitsToScroll() + " unit increments" + newline;
			message += "    Vertical unit increment: "
					+ " pixels" + newline;
		} else { // scroll type == MouseWheelEvent.WHEEL_BLOCK_SCROLL
			message += "    Scroll type: WHEEL_BLOCK_SCROLL" + newline;
			message += "    Vertical block increment: "
					+ " pixels" + newline;
		}
		System.out.println(message);

		notches *= -1 ; //to give the same zoom direction as googlemaps
		
		
		int x = e.getX();
		int y = e.getY();
		double sizeChange = (100.0+2*notches)/100;
		if(isInMolecularArea(x,y)) {
			newScale = this.molecularAreaScale * sizeChange;
			if(
					(newScale > this.molecularAreaScale && newScale <= maxMolecularAreaScale) // size increased, but not too much
														||
					(newScale < this.molecularAreaScale && newScale >= minmolecularAreaScale)  //size decreased, but not too much
			) {
				lastAction = LA_SCALE;

				if(reaction) {
					//global scale with centering
					setMolecularAreaScale(newScale); //will call repaint()
				} else {
					//previous zoom method
					//center around the atom closes to the x,y position 
			
					setMolecularAreaScale(newScale, x, y);	
					repaint();
				}
			}

		} else {
			newScale = this.menuScale * sizeChange;
			if(newScale >= minMenuScale && newScale <= maxMenuScale) {
				setMenuScale(newScale); //setMenuScale will do a repaint
			}
		}

	}
	public boolean isInMolecularArea(int x, int y) {
		if(this.depict) {
			return true;
		}
		
		if(x<leftMenuWidth() || y < topMenuHeight() || y > (this.dimension.height - this.infoAreaHeight()) || x > (this.dimension.width-rightBorder())) {
			return false;
		}
		return true;
	}
	/**
	 * rescale around the the nearest molecule to the given position
	 * does not call repaint()!
	 * @param scale
	 * @param x (GUI coordinate)
	 * @param y
	 */
	//used by mouse wheel event in non reaction mode
	public void setMolecularAreaScale(double scale, int x, int y) {
		//should we limit scaling if one molecule becomes invisible?
		if( !reaction) {
			//mol.center(0.1); //should move progressively to center
			//The center position varies with the scale !!!!!!! FIXME
			
			Rectangle2D.Double previousAreaSize  = getMolecularAreaBoundingBoxCoordinate();
			this.molecularAreaScale= scale;
			Rectangle2D.Double newAreaSize  = getMolecularAreaBoundingBoxCoordinate();
			

			TouchedMol touchedMol = new TouchedMol();
			//find the closest mol - use a large distance radius
			this.findMolAndAtomOrBondWithinRadius(x, y, Integer.MAX_VALUE, touchedMol);
			//this.findClosestMol(x, y)
			Point.Double shiftXY = this.findTranslationToCenterAfterScaling(touchedMol, previousAreaSize, newAreaSize);

			if(shiftXY != null) {
				moveAllMolecules(shiftXY);
			}
		} else {
			//What to do?
			//reaction TODO
			//multipart 
		}
		this.mustReDrawMolecularArea = true;
		
	}
	//don't use this in reaction mode because the arrow
	protected void moveAllMolecules(double x, double y) {
		for(int i=1; i<=numberofMoleculeParts; i++) {
			moleculeParts[i].moveXY(x, y);
		}
		
	}
	protected void moveAllMolecules(Point.Double shiftXY) {
		moveAllMolecules(shiftXY.x, shiftXY.y);
		
	}
	/**
	 * Compute the translation X,Y needed for the molecule to stay centered after scaling
	 * @param atomIndex
	 * @param previousAreaSize
	 * @param newAreaSize
	 * @return
	 */
	public Point.Double findTranslationToCenterAfterScaling(TouchedMol closestMol,  Rectangle2D.Double previousAreaSize, Rectangle2D.Double newAreaSize) {
		Point.Double result = new Point.Double();

		if(closestMol.molIndex == 0) {
			return result;
		}
		JMEmol closestMolecule = moleculeParts[closestMol.molIndex];
		if(closestMolecule.natoms == 0) {
			return result;
		}
		assert previousAreaSize.width > 0;
		assert previousAreaSize.height > 0;
		
		double x;
		double y;
		if( closestMol.atomIndex > 0) {
			x= closestMolecule.atoms[closestMol.atomIndex].x;
			y= closestMolecule.atoms[closestMol.atomIndex].y;
		} else {
			//closestMolecule.findBondCenters();
			x = closestMolecule.bonds[closestMol.bondIndex].bondCenterX;
			y = closestMolecule.bonds[closestMol.bondIndex].bondCenterY;
			
		}
		
		
		double newX = x /previousAreaSize.width * newAreaSize.width;
		double newY = y /previousAreaSize.height * newAreaSize.height;
		
		double shiftX = newX - x;
		double shiftY = newY - y;
	
		
		result.setLocation(shiftX, shiftY);
		
		
		return result;

	}

	/**
     * Invoked when a mouse button has been pressed on a component.
     */
//	@Override
//	public void mousePressed(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//
//	}

    /**
     * Invoked when the mouse button has been clicked (pressed
     * and released) on a component.
     */
//	@Override
//	public void mouseClicked(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//
//	}

	/**
	 * Invoked when a mouse button has been released on a component.
	 */
//	@Override
//	public void mouseReleased(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	/**
	 * Invoked when the mouse enters a component.
	 */
//	@Override
//	public void mouseEntered(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	/**
	 * Invoked when the mouse exits a component.
	 */
//	@Override
//	public void mouseExited(MouseEvent e) {
//		int numberOfClicks = e.getClickCount();
//		System.out.println(""+numberOfClicks);
//	}

	// ----------------------------------------------------------------------------
	@Override
	public boolean mouseDown(Event e, int x, int y) {
		// 02.06 niektotre return true zmenene na false (aby events aj v mipc)

		//this.mouseDownWasUsed = false;
		this.mouseDownWasUsed = false;
		//BB popup menu for copy&paste
		if(contextMenuEnabledOption && this.handleCopyPastePopupMenu(e, x, y) ) {
			this.mouseDownWasUsed = true;
			//FIXME
			movePossible = false; //to avoid bug is my JSapplet lib with popup menu disabled, the mouseUp event is not registered and a mouseDrag event is generated
			return true; //event has been consumed
		}

//Dec 2016: allow mol to move 
//		if (depict && !(this.canHandleBondClickedCallBack() || this.canHandleBondClickedCallBack() || depictActionEnabled))
//			//return true; //no action is performed in depict mode
//			return false; //no action is performed in depict mode - BB changed March 2013

		//the return value of this method
		//set to true if the event was consumed and does not need to be propagated
		boolean eventNotUsed = false;
		
		//experiment: to ease switching to the applet for copy paste with the system clipboard
		boolean eventUsed = true;
		//boolean eventUsed = !isSystemClipBoardSupportedByBrowser();
		boolean returnStatus = eventUsed; // 2206

		//BB
		//this.isContextMenu = this.isEventContextMenu(e); //will be used in the addRing() method to decide if a spiro ring should be added


		xold = x;//used later in mouseDrag
		//yold = y - (2 * (int)menuCellSize + menuCellBorder());
		yold = y; //used later in mouseDrag
		
		//log("mouseDown(): xold=" + xold + " yold=" + yold);
		
		clearInfo();
		// int x = e.getX(); int y = e.getY();
		this.mouseShift = e.shiftDown(); // because of numbering
		
		movePossible = false;

		if ( !depict && (x < leftMenuWidth() || y < topMenuHeight())) { // --- menu pressed
			int action = this.determineMenuAction(x, y, true);


			//Code written by PE
			//Should this be moved to menuAction(action)?
			// empty buttons not considered
			if (action == ACTION_SPIRO) { 
				spiroAdding = true;
				info("Next ring will be added as spiro");
				repaint();
				this.mouseDownWasUsed = true;
				return eventUsed;
			}
			
			//Code written by BB
			//Should this be moved to menuAction(action)?
			if(action == ACTION_MOVE_AT) {
				if(this.showAtomMoveButton) {
					info("Move one atom");
					repaint();
				} else {
					this.mouseDownWasUsed = true;
					return eventUsed;
				}
				
			}
			
			//BB: xbutton handling
			if(!xButton && action == ACTION_AN_X) {
				return eventNotUsed;
			}

			if (!query && action == ACTION_QRY)
				return eventNotUsed;
			if (!stereo && action == ACTION_STEREO)
				return eventNotUsed;
			if (!multipart && action == ACTION_NEW)
				return eventNotUsed;
			if (!(number || autonumber) && action == ACTION_MARK)
				return eventNotUsed;
			if (!reaction && action == ACTION_REACP)
				return eventNotUsed;
			//if(action == ACTION_EMPTY_CELL){
			//	return eventNotUsed;
			//}

			returnStatus = menuAction(action); //has its own paint() call
		}

		else if ( !depict && (y > dimension.height - infoAreaHeight())) { // --- info area clicked
			return eventNotUsed;
		}

		else  { // --- mouse click in the drawing area
			// ---------------------------
			//March 2016
			// the closest mol becomes the active one - needed for table to move one of the fragments
			//int m = findClosestMol(x,y);
			int m = findClosestMol(xold,yold);
			if(m>0) {
				actualMoleculePartIndex = m;
				mol = moleculeParts[m];
			} else {
				actualMoleculePartIndex = 0;
				
			}
			//OKK

			//June 2015
			if ( mol.touchedAtom > 0 && this.canHandleAtomClickedCallBack()) {
				
				this.handleAtomClickedCallBack(actualMoleculePartIndex, mol.touchedAtom); //not sure that actualMoleculePartIndex is set correctly in case of a multi structure
				if(depict && ! depictActionEnabled) {
					return true;
				}
			}

			if(mol.touchedBond > 0 && this.canHandleBondClickedCallBack()) {
				this.handleBondClickedCallBack(actualMoleculePartIndex, mol.touchedBond); //not sure that actualMoleculePartIndex is set correctly in case of a multi structure
				if(depict && ! depictActionEnabled) {
					return true;
				}
				
			}

			
			
			
			
			movePossible = true;
			//x -= menuCellSize; //menuCellSize is 0 in depict mode
			//y -= 2 * menuCellSize + menuCellBorder();
			//y -= topMenuHeight();

			// atom clicked
			
			if( mol.touchedAtom > 0 ) {
				lastTouchedMol.molIndex = actualMoleculePartIndex;
				if (action == ACTION_DELETE) {
					this.actionDeleteTouchedAtomOrBond();
//					mol.preSave();
//					mol.deleteAtom(mol.touchedAtom);
//					this.recordAtomEventAndPostSave(JME.DEL_ATOM2);
//
//					mol.touchedAtom = 0;

				} else if (action == ACTION_DELGROUP) {
					return true; // do nothing
				} else if (action == ACTION_CHARGE) {
					if(mol.changeCharge(mol.touchedAtom, 0))
						this.recordAtomEvent(JME.CHARGE_ATOM0);
//this is never called from the JME gui since it has only a toggle button
//				} else if (action == ACTION_CHARGE_PLUS) {
//					if(mol.changeCharge(mol.touchedAtom, 1))
//						this.recordAtomEventAndPostSave(JME.CHARGE_ATOM_PLUS);
//				} else if (action == ACTION_CHARGE_MINUS) {
//					if(mol.changeCharge(mol.touchedAtom, -1))
//						this.recordAtomEventAndPostSave(JME.CHARGE_ATOM_MINUS);
				} else if (action == ACTION_BOND_SINGLE
						|| action == ACTION_BOND_DOUBLE
						|| action == ACTION_BOND_TRIPLE
						|| action == ACTION_STEREO || action == ACTION_CHAIN) {
					lastAction = LA_BOND; // in addBond may be set to 0
					mol.addBond();
					mol.touched_org = mol.touchedAtom;
					
					if (action == ACTION_CHAIN) {
						mol.nchain = 1; // pre CHAIN rubberbanding
						mol.chain[1] = mol.natoms;
						mol.chain[0] = mol.touchedAtom;
						mol.touchedBond = 0; // 2005.02
						// mol.avoidTouch(1);
						this.recordBondEvent(JME.ADD_BOND);
						this.willPostSave(false); //for the CHAIN, save the state at mouseUp event
						
					} else {
						this.recordBondEvent(JME.ADD_BOND);
						
					}

				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					lastAction = LA_RING; // in addRing may be set to 0
					mol.addRing();
					this.recordAtomEvent(JME.ADD_RING);

				} else if (action == ACTION_TEMPLATE) {
					// mol.addTemplate(template);
					lastAction = LA_GROUP;
					this.recordAtomEvent(JME.ADD_TEMPLATE);

				} else if (action >= ACTION_GROUP_MIN
						&& action < ACTION_GROUP_MAX) {

					mol.addGroup(false);
					this.recordAtomEvent(JME.ADD_GROUP);

					lastAction = LA_GROUP; // may be set to 0
				} else if (action == ACTION_QRY) { // setting atom as query atom
					if (queryBox.isBondQuery())
						return true;
					mol.setAtom(mol.touchedAtom, queryBox.getSmarts());
					mol.isQuery = true; //2013.09
					
					this.recordAtomEvent(JME.ADD_ATOM_QUERY);

				} else if (action == ACTION_MARK) {
					boolean marked ;
					int newMap ;
					if(markFromKeyboardInput) {
						newMap = keyboradInputMark;
						resetExtendAtomMark = true;
						markFromKeyboardInput = false;
						clearInfo(); //reset the info message generated by updateMark()
					} else {
						if(reaction) {
							int reactionRole = mol.reactionPart();
							newMap = findMaxAtomMapOfMoleculeParts(moleculeParts, reactionRole);
						} else {
							newMap = mol.geMaxAtomMap();
						}
						//allow same atom map for several atoms of the group is shift is pressed
						if(!this.mouseShift)
							newMap++;

					}
					marked = mol.mark(newMap);
					if (marked)
						this.recordAtomEvent(JME.MARK_ATOM);
					else
						//happens if newMap == -1
						this.recordAtomEvent(JME.UN_MARK_ATOM);
						
				} else if (action == ACTION_MOVE_AT) {
					//System.out.println("Move atom started");
				} else if (action > 300) { // atoms
					if (active_an != mol.an(mol.touchedAtom)
							|| active_an == AN_X) {
						mol.AN(mol.touchedAtom, active_an);
						mol.Q(mol.touchedAtom, 0); // resetne naboj
						//mol.iso[mol.touchedAtom] = 0; //BB: reset isotop
						mol.atoms[mol.touchedAtom].iso = 0; //BB: reset isotop
						//mol.nh[mol.touchedAtom] = 0;
						mol.atoms[mol.touchedAtom].nh = 0;

						// special processing pre AN_X, osetrene, ze moze byt aj
						// ""
						if (active_an == AN_X) {
							String xx = MultiBox.atomicSymbol.getText();
							if (xx.length() < 1)
								xx = "X";
							mol.setAtom(mol.touchedAtom, xx);

						} 
						this.recordAtomEvent(JME.SET_ATOM + active_an); //active_an is an arbitrary number, should be changed to the string of the atom type


					}
				} else { //BB: nothing happened to the clicked atom
					returnStatus = eventNotUsed; 

				}
				//BB:moved
				//status = false; // 2206




			} 

			// bond clicked
			else if ( mol.touchedBond > 0) {
				lastTouchedMol.molIndex = actualMoleculePartIndex;
				if (action == ACTION_DELETE) {
					this.actionDeleteTouchedAtomOrBond(); //record the event as well
					
				} else if (action == ACTION_DELGROUP) {
					mol.deleteAtomGroup();
					mol.cleanAfterChanged();
					this.recordBondEvent(JME.DEL_BOND_GROUP);
					mol.touchedBond = 0;
				} else if (action == ACTION_STEREO) {
					mol.stereoBond(mol.touchedBond);
					this.recordBondEvent(JME.SET_BOND_STEREO);
				}
				else if (action == ACTION_BOND_SINGLE || action == ACTION_CHAIN) {
					if (mol.bonds[mol.touchedBond].bondType == JMEmol.SINGLE
							&& mol.bonds[mol.touchedBond].stereo == 0) {// nie pre
						// stereo
						mol.bonds[mol.touchedBond].bondType = JMEmol.DOUBLE;
						this.recordBondEvent(JME.SET_BOND_DOUBLE);

					}
					else {
						mol.bonds[mol.touchedBond].bondType = JMEmol.SINGLE;
						mol.bonds[mol.touchedBond].stereo = 0; //BB: remove stereo flag - bug fix - was creating a problem with undo/redo
						this.recordBondEvent(JME.SET_BOND_SINGLE);

					}
					mol.bonds[mol.touchedBond].stereo = 0; // zrusi stereo
				} else if (action == ACTION_BOND_DOUBLE) {
					boolean differentBondOrder=mol.bonds[mol.touchedBond].bondType != JMEmol.DOUBLE;

					mol.bonds[mol.touchedBond].bondType = JMEmol.DOUBLE;
					
					if(!differentBondOrder) {
						mol.bonds[mol.touchedBond].toggleNormalCrossedDoubleBond();
					} else {
						mol.bonds[mol.touchedBond].stereo = 0; // zrusi stereo
					}
					mol.cleanAfterChanged();
					
					this.recordBondEvent(JME.SET_BOND_DOUBLE);

				} else if (action == ACTION_BOND_TRIPLE) {
					mol.bonds[mol.touchedBond].bondType = JMEmol.TRIPLE;
					mol.bonds[mol.touchedBond].stereo = 0; // zrusi stereo
					mol.cleanAfterChanged();
					
					this.recordBondEvent(JME.SET_BOND_TRIPLE);

				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					// fusing ring to bond
					lastAction = LA_RING; // in addRing may be set to 0
					mol.addRing();
					this.recordBondEvent(JME.ADD_RING_BOND);
					mol.cleanAfterChanged(); //FIXME: add to addRing
					
				} else if (action == ACTION_QRY) {
					if (!queryBox.isBondQuery())
						return true;
					String bondQuery = queryBox.getSmarts();
					mol.bonds[mol.touchedBond].bondType = JMEmol.QUERY;
					// mol.stereob[mol.touchedBond] = JMEmol.QUERY;
					mol.bonds[mol.touchedBond].btag= bondQuery;
					/*
					 * if ("~".equals(bondQuery)) mol.stereob[mol.touchedBond] =
					 * JMEmol.QB_ANY; if (":".equals(bondQuery))
					 * mol.stereob[mol.touchedBond] = JMEmol.QB_AROMATIC; if
					 * ("@".equals(bondQuery)) mol.stereob[mol.touchedBond] =
					 * JMEmol.QB_RING; if ("!@".equals(bondQuery))
					 * mol.stereob[mol.touchedBond] = JMEmol.QB_NONRING;
					 */
					
					this.recordBondEvent(JME.SET_QUERY_BOND);

				} else if (action == ACTION_MARK) {
					//info("Only atoms may be marked !");
					//March 2014
					
					{
						boolean marked = mol.starMarkBond(mol.touchedBond);
						if(marked)
							this.recordBondEvent(JME.MARK_BOND);
						else
							this.recordBondEvent(JME.UN_MARK_BOND);

					}

					
					
				} else {
					//no bond were changed
					returnStatus = false; // 2206
				}
				//BB removed and replaced by above
				//status = false; // 2206
			}

			// free space clicked - new molecule
			// creating new molecule only on start or when ACTION_NEW is on
			else if ((numberofMoleculeParts == 0 || newMolecule == true) && ! depict) {
				if (action <= ACTION_STEREO)
					return eventNotUsed;


				numberofMoleculeParts++;
				actualMoleculePartIndex = numberofMoleculeParts;
				moleculeParts[numberofMoleculeParts] = new JMEmol(this);
				mol = moleculeParts[numberofMoleculeParts];
				lastTouchedMol.molIndex = actualMoleculePartIndex;
				
				
				
//				if(newMolecule == true) {
//					newMolecule = false; //will be done in draw
//					this.mustReDrawTopMenu = true;
//				}
				
				smol = null; // kvoli undo

				//BB: TODO : lot of duplicated code
				if (action >= ACTION_BOND_SINGLE
						&& action <= ACTION_BOND_TRIPLE
						|| action == ACTION_CHAIN) {
					mol.createAtom();
					mol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(mol, 1, x,y);
					mol.touchedAtom = 1;
					mol.touched_org = 1; // needed for checkNewBond();
					lastAction = LA_BOND;
					mol.addBond();
					// orienting chain
					if (action == ACTION_CHAIN) {
//						mol.x[2] = x + JMEmol.RBOND * .866;
//						mol.y[2] = y - JMEmol.RBOND * .5;
//						XY(mol, 2, x + JMEmol.RBOND * .866, 
//								 y - JMEmol.RBOND * .5);
						mol.XY(2, //TODO : JMEMol sould handle this
								screenToDrawingX(x) + JMEmol.RBOND * .866,
								screenToDrawingY(y) - JMEmol.RBOND * .5
								);
						
						mol.chain[0] = 1;
						mol.chain[1] = 2;
						mol.nchain = 1;
						this.recordBondEvent(JME.ADD_CHAIN);

					} else {
						this.recordBondEvent(JME.ADD_BOND);

					}
				} else if (action >= ACTION_RING_3 && action <= ACTION_RING_9) {
					mol.xorg = screenToDrawingX(x);
					mol.yorg = screenToDrawingY(y);
					lastAction = LA_RING;
					mol.addRing();
					this.recordAfterStructureChangedEvent(JME.ADD_RING);
				} else if (action > 300) { // adding 1st atom
					mol.createAtom();
					mol.AN(1, active_an);
					mol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(mol, 1, x, y);
					mol.touchedAtom = 1;
					if (active_an == AN_X) {
						String xx = MultiBox.atomicSymbol.getText();
						if (xx.length() < 1)
							xx = "X";
						mol.setAtom(1, xx);
					}
					this.recordAtomEvent(JME.ADD_ATOM);

				} else if (action == ACTION_TEMPLATE) {
					readMolecule(template);
					this.recordAfterStructureChangedEvent(JME.ADD_TEMPLATE);

				} else if (action >= ACTION_GROUP_MIN
						&& action < ACTION_GROUP_MAX) {
					// adding first atom (to which group will be connected)
					mol.createAtom();
					mol.nbonds = 0;
//					mol.nv[1] = 0;
//					mol.x[1] = x;
//					mol.y[1] = y;
					XY(mol, 1, x, y);

					mol.touchedAtom = 1;
					// adding group
					mol.addGroup(true);
					this.recordAfterStructureChangedEvent(JME.ADD_GROUP);
				} else {
					System.err.println("error -report fall through bug !");
				}
				//BB changed
				//returnStatus = eventNotUsed; // 2206

			} else { //BB nothing happened
				returnStatus = false;
			}



			if(returnStatus != eventNotUsed) {//BB: if nothing has changed - there is no need to repaint
				// BB
				//mol.cleanAfterChanged(); //FIXME: sacveState already called this method
				this.redrawMoleculartAreaOnly();
//				this.mustReDrawLeftMenu = false;
//				this.mustReDrawTopMenu = false;
//				
//				this.mustReDrawMolecularArea = true;
//				//don't touch info - automatic
//				repaint(); // ciastocne zbytocne repaintuje, ale asi nechat tak
			}
		}
		
		this.mouseDownWasUsed = returnStatus;
		
		return returnStatus;
	}

	// ----------------------------------------------------------------------------
	public boolean mouseUp(Event e, int x, int y) {

		
			
		boolean eventUsed = false;

		//DUPLICATED CODE WITH BELOW
//		if (depict && !depictActionEnabled) {
//			if(toggleDepictEdit == true) {
//				this.options("nodepict");
//				this.handleAfterAfterDepictEditToggleEvent();
//			}
//			return true;
//			
//		}

		if(this.movingAtom) {
			//end of atom move
			this.movingAtom = false;
			//mol.findBondCenters(); //BB: aton has been moved, thus the bond centers must be updated
			//this.recordAtomEvent(MOVE_ATOM); //this is not a structure change
			this.willPostSave(true);
			eventUsed = true;
		}

		//BB
		this.mustReDrawInfo = false;
		lastRotation = 0; //needed?

		// LA_GROUP netreba, tam nemoze byt atom overlap
		if (lastAction == LA_BOND) {
			if (action == ACTION_CHAIN) {
				mol.checkChain();
				this.willPostSave(true);

			} else {

				//find out if the last touched mol is the same
				//findMolAndAtomOrBondInDrawingAreaFromEventXY(x, y, this.newTouchedMol);
				//System.out.println("@@@mouseUp: newTouchedMol: " + newTouchedMol.molIndex + " " + newTouchedMol.atomIndex + " x:" + x + " y: " + y);
				//System.out.println("@@@mouseUp: numberofMoleculeParts: " + numberofMoleculeParts + " actualMoleculePartIndex: " + actualMoleculePartIndex);
				//System.out.println("@@@mouseUp: lastTouchedMol: " + lastTouchedMol.molIndex + " " + lastTouchedMol.atomIndex + " x:" + x + " y: " + y);

				//lastTouchedMol was set during mouseDrag
				if(lastTouchedMol.molIndex != 0 && actualMoleculePartIndex != lastTouchedMol.molIndex) {
					// merge the current mol and the other mol
					mol.deleteAtom(mol.natoms);; //remove the last atom because it will be replaced by the atoms of the new mol
					int atom1 = mol.touched_org; //first atom of the new bond to be created
					int atom2 = lastTouchedMol.atomIndex + mol.natoms;//second atom of the new bond to be created
					
					assert atom1 != mol.natoms +1;

					JMEmol otherMol = moleculeParts[lastTouchedMol.molIndex];
					JMEmol merged = new JMEmol(this, new JMEmol[] {null, mol, otherMol}, 2);
					merged.atoms[0] = new Atom(); //needed by rubberbanding()
					
					//bug: the user selected bond order is not taken into account
					merged.createAndAddNewBond(atom1, atom2);
					
					//
					JMEmol[] newMoleculeParts = new JMEmol[moleculeParts.length];
					for(int p = 0, newP = 0; p < moleculeParts.length; p++) {
						if(moleculeParts[p] == mol) {
							newMoleculeParts[newP++] = merged; //replace mol with merged
						} else if (moleculeParts[p] == otherMol ) { //skip
							continue;
						} else {
							newMoleculeParts[newP++] = moleculeParts[p];
						}
						
					}
					
					moleculeParts = newMoleculeParts;
					numberofMoleculeParts --;
					mol = merged;//replace mol with merged
					lastTouchedMol.reset();
					
					
				} else {
					//as before - no merge
					//checkBond create or increase bond order
					mol.checkBond(); // standard bond check
				}
			}
			//don in createAndAddNewBond
			//mol.findBondCenters(); // zbytocne vela, ale tu kvoli r.b.

			//BB :
			if(this.bondRubberBanding ) {
				//a bond had been added and the state saved
				//to keep only the bond stabilized after the rubberbanding,
				//remove the previous state
				this.molChangeManager.removeLast();

				this.recordBondEvent(ADD_BOND);

				this.bondRubberBanding = false;
			}
			eventUsed = true;
		} else if (lastAction == LA_MOVE) {
			// !!! mal by sem este prist check na touched
			//mol.findBondCenters();

			//BB
			this.willPostSave(true);
			eventUsed = true;

		}
		if (lastAction > 0) {

			// BB - this seems to be a duplcated of doMenu
			//mustRedrawNothing();
			//this.mustReDrawMolecularArea = true;

			if(  lastAction != LA_MOVE && lastAction != LA_ROTATE) {
				//mol.cleanAfterChanged();
				// nevola sa vzdy ked treba !!!!!
				//mol.cleanPolarBonds(); // nie je to privela action ??? nie az pri
			}
			if(  lastAction == LA_MOVE && this.reaction) {
				//check if the reaction roles have changed
				int parts[][] = getReactionParts();
				if(reactionParts == null)
					reactionParts = parts;
				int changedPart = findFirstMoleculeIndexWithDifferentReactionRole(reactionParts, parts);
				if(changedPart != 0) {
					// will be performed by updateReactionParts();
					//reactionParts = parts;
					
					//send an update message
					this.recordMoleculePartEvent(CHANGE_REACTION_ROLE, changedPart);
				}
			}
			// canon
			//repaint(); // napr po zdvojeni vazby ju nakresli
			this.redrawMoleculartAreaOnly();
			lastAction = 0;
			afterClear = false;
			eventUsed = true;
		}

		//BB: useful for touch devices to avoid showing the marked atom after edition
		if(isTouchSupported && (mol.touchedBond != 0 || mol.touchedAtom != 0) ) {
			mol.touchedBond = 0;
			mol.touchedAtom = 0;
			this.redrawMoleculartAreaOnly();
			eventUsed = true;

		}


		
		//mouse click on the full screen icon
		if(eventUsed == false && !this.mouseDownWasUsed && this.fullScreenIcon !=null) {
			if(fullScreenIcon.contains(x, y)) {
				eventUsed = true;
				//Rectangle dim1 = this.getMolecularAreaSizeWithScalingForDepiction();
				toggleFullScreen();
				//mol.needRecentering = true;
				//Rectangle dim2 = this.getMolecularAreaSizeWithScalingForDepiction();
				//recenterMoleculesAfterMolecularAreaChange(dim1, dim2);
				//this.redrawMoleculartAreaOnly();
				

			}
		}
		
		//handle toggle depict/edit
		if(this.toggleDepictEdit && !this.mouseDownWasUsed &&!eventUsed) {
			if ( this.depict) {
				this.options("nodepict");
			} else {
				this.options("depict");
			}
			this.handleAfterAfterDepictEditToggleEvent();
			eventUsed = true;
		}

		return eventUsed;
	}
	
	protected void willPostSave(boolean b) {
		this.saveCurrentState = b;
		
	}

	protected void updateReactionParts() {
		if(reaction)
			reactionParts = getReactionParts();
	}
	
	/**
	 * screen pixel to molecular drawing area coordinate
	 * @param coord
	 * @return
	 */
	@Deprecated
	protected int scaleCoordinate_(int coord) {
		double newCoord = scaleCoordinate_((double) coord);
			
		return (int)Math.round(newCoord);
	}
	/**
	 * screen coordinate to molecular drawing area coordinate
	 * @param coord
	 * @return
	 */
	@Deprecated
	protected double scaleCoordinate_(double coord) {
		if(this.scalingIsPerformedByGraphicsEngine) {
			return coord / molecularAreaScale;
		}
		return coord;
	}
	
	protected double scaleScreenToDrawing(int pos) {
		return (double)pos / molecularAreaScale;
	}
	protected int scaleDrawingToScreen(double coord) {
		return (int) Math.round(coord * molecularAreaScale);
	}
	/**
	 * convert the applet screen position to the coordinate of the drawing area
	 * @param pixelPosition
	 * @return
	 */
	//TODO: drawing should not revert the Y axis
	protected double screenToDrawingX(int appletPixelPositionX) {
		int x = appletPixelPositionX -leftMenuWidth();//leftMenuWidth() returns 0 in depict mode
		
		return scaleScreenToDrawing(x);
	}
	/**
	 * convert the applet screen position to the coordinate of the drawing area
	 * @param pixelPosition
	 * @return
	 */
	protected double screenToDrawingY(int appletPixelPositionY) {
		int y = appletPixelPositionY - topMenuHeight(); //topMenuHeight() returns 0 in depict mode
		
		return scaleScreenToDrawing(y);
	}
	
	/**
	 * Convert a drawing x coordinate to the pixel coordinate
	 * @param xCoord
	 * @return
	 */
	protected int drawingToScreenX(double xCoord) {
		int  screenX = scaleDrawingToScreen(xCoord);
		
		screenX += leftMenuWidth(); //leftMenuWidth() returns 0 in depict mode
		
		return screenX;
	}
	
	/**
	 * Convert a drawing y coordinate to the pixel coordinate
	 * @param x
	 * @return
	 */
	protected int drawingToScreenY(double yCoord) {
		int  screenY = scaleDrawingToScreen(yCoord);
		
		screenY += topMenuHeight();//topMenuHeight() returns 0 in depict mode
		
		return screenY;
	}
	
	
//	/**
//	 * convert a the applet screen position to the coordinate of the drawing area
//	 * @param pixelPosition
//	 * @return
//	 */
//	protected double screenToDrawing(int appletPixelPositionX) {
//		
//		return (double)appletPixelPositionX*molecularAreaScale;
//	}
	
	
	
	// ----------------------------------------------------------------------------
	public boolean mouseDrag(Event e, int x, int y) {
		// public void mouseDragged(MouseEvent e) {

//		System.out.println("@@@@ mouseDrag");
		//Commented because if zooming is allopwed in depict mode, then moving should as well
//		if (depict && ! depictActionEnabled)
//			return true;
		// 2Banding possible only after succesfull addition of the bond
		if (!movePossible)
			return true;

		//BB popup menu for copy&paste
		boolean meta = e.metaDown() ; //true if right mouse click
		if(meta) {
			return true;
		}

		//BB
		this.mustReDrawInfo = false;

		// ??? MS-Win toto volaju aj len pri MouseClick (handled here)
		// int x = e.getX()-sd; int y = e.getY()-sd*2;
		//x -= leftMenuWidth();
		//y -= topMenuHeight();
		double drawingAreaMoveX = scaleScreenToDrawing(x - xold);
		double drawingAreaMoveY = scaleScreenToDrawing(y - yold);
		//log("mouseDrag(): xold=" + xold + " yold=" + yold);
		//log("mouseDrag(): x=" + x + " y=" + y);

		
		double drawingAreaX = screenToDrawingX(x);
		double drawingAreaY = screenToDrawingY(y);

		if (lastAction == LA_RING || lastAction == LA_GROUP
				|| lastAction == LA_FAILED) {
			return true;
		}
		else if (lastAction == LA_BOND) {
			//mol.rubberBanding(drawingAreaX, drawingAreaY);
			
			//code copied and adapted from mol.rubberBanding
			//goal: to crerate bond between two different molecule parts
			boolean done = false;
			moleculeParts[this.lastTouchedMol.molIndex].touchedAtom = 0;
			
			
			//to be used for adding a bond with another part
			//need to differentiate the temporary moving atom that was created during mousedown
			//from the atom of another fragment because they can overlap
			//the temp atom is the last one
			mol.natoms--;
			findMolAndAtomOrBondInDrawingArea(x, y, this.newTouchedMol);
			mol.natoms++; //restore
			
			//System.out.println("@@@ mouseDrag: mol.natoms: " + mol.natoms);
			//System.out.println("@@@ mouseDrag: newTouchedMol: " + newTouchedMol.molIndex + " " + newTouchedMol.atomIndex);

			if(this.newTouchedMol.molIndex > 0 && this.newTouchedMol.atomIndex > 0) {
				JMEmol touched_JMEmol = this.moleculeParts[newTouchedMol.molIndex];
				touched_JMEmol.touchedAtom=this.newTouchedMol.atomIndex;

				if (touched_JMEmol != mol || this.newTouchedMol.atomIndex != mol.touched_org) { // make bond towards existing  atom
					mol.XY(mol.natoms,  touched_JMEmol.x(newTouchedMol.atomIndex),  touched_JMEmol.y(newTouchedMol.atomIndex)); //move the new atom to the coordinate of the closest touched atom "snap"
					// actually it does not move while it still close to the touched atom
					//System.out.println("SNAP otheratom");
					touched_JMEmol.touchedAtom = newTouchedMol.atomIndex;
					
					done = true;
					//lastTouchedMol will be used by mouseUp() to create the new bnond between the two
					//
					this.lastTouchedMol.initMyselfWith(this.newTouchedMol);
				}
//				else { // this was standard position of the bond
//					mol.XY(mol.natoms, mol.xorg, mol.yorg);//move the new atom to the coordinate of the origin atom "snap"
//				}
//				this.lastTouchedMol.init(this.newTouchedMol);
//				System.out.println("@@@ mouseDrag: lastTouchedMol: " + lastTouchedMol.molIndex + " " + lastTouchedMol.atomIndex);
//
//			} else {
//				// bond width normal length follows mouse pointer
//				double dx=drawingAreaX-mol.x(mol.touched_org); 
//				double dy=drawingAreaY-mol.y(mol.touched_org);
//				double rx=Math.sqrt(dx*dx+dy*dy); if (rx < 1.0) rx=1.0;
//				double sina=dy/rx; double cosa=dx/rx;
//				
//				mol.XY(mol.natoms, 
//						mol.x(mol.touched_org)+JMEmol.RBOND*cosa, 
//						mol.y(mol.touched_org)+JMEmol.RBOND*sina
//					);
				
			}
			if(!done) { 
				//perform the rubberbanding within the same mol - old code
				mol.rubberBanding(drawingAreaX, drawingAreaY);
			}
			this.bondRubberBanding = true; //BB
		}
		//BB
		else if (action == ACTION_MOVE_AT && mol.touchedAtom > 0) { 
			if(this.movingAtom == false) {
				this.movingAtom = true;
			}
			//mol.atomRubberBanding(drawingAreaX, drawingAreaY);
			mol.XY(mol.touchedAtom, drawingAreaX, drawingAreaY);
				
		} else if (e.shiftDown() || e.metaDown()) {
			// else if (e.isShiftDown() || e.isMetaDown()) {
			mol.rotate(drawingAreaMoveX);
			lastAction = LA_MOVE; //BB: should it be changed to LA_ROTATE?
			//info("Rotation: " + x ); //BB


		} else if (mol.touchedAtom == 0 && mol.touchedBond == 0 ) { //if no atom or bond  are touched, then the touched mol can be moved
			//Start molecue move only if the mousedrag event started within the drawing area

			//avoid unwanted sudden large moves after a rotation on a touch device
			//if(lastAction != LA_MOVE) {
				//drawingAreaMoveX = drawingAreaMoveY=0;
			//}
			
			//Do not move the molecule if the dragging start is not within the drawing area
			if( !(isOutsideDrawingArea(x, y) && lastAction != LA_MOVE)) {
				Rectangle2D.Double boundingBox = this.getMolecularAreaBoundingBoxCoordinate();
				mol.move(drawingAreaMoveX, drawingAreaMoveY, boundingBox);
				//info("Move: " + x  + " " + y); //BB
	
				lastAction = LA_MOVE;
			}
		}



		// BB
		this.redrawMoleculartAreaOnly();

		xold = x;
		yold = y;
		return true;
	}
	
	
	protected boolean isMoleculeCompletelyOutsideDrawingArea(JMEmol mol) {
		
		if(mol.nAtoms() == 0)
			return false;

		for(Atom atom : mol.atoms) {

			if(!isOutsideDrawingArea(drawingToScreenX(atom.x), drawingToScreenY(atom.y)))
				return false;
		}
		
		return true;
	}
	
	protected boolean isOutsideDrawingArea(int x, int y) {
		return ( x < leftMenuWidth() || y < topMenuHeight() || y > this.molecularAreaHeight || x > this.molecularAreaWidth); 

	}
	

	/**
	 * Return the molecule index of the molecule that is the closest to the provided screen position
	 * @param x
	 * @param y
	 * @return
	 */
	int findClosestMol(int x, int y) {
	
		int molIndex = 0;
		if (isOutsideDrawingArea(x,y))
			return molIndex;
		
		if(numberofMoleculeParts == 1) {
			return actualMoleculePartIndex;
		}
		//x = scaleCoordinate(x);
		//y = scaleCoordinate(y);
		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double min  = Double.MAX_VALUE;

		for (int m = 1; m <= numberofMoleculeParts; m++) {
			double d = moleculeParts[m].closestAtomDistance(xCoord, yCoord);
			if(d < min) {
				min = d;
				molIndex = m;
			}
		}
		
		return molIndex;
	}
	/**
	 * find the touched atom or bond
	 * @param x
	 * @param y
	 * @param result
	 */
//	void  findMolAndAtomOrBondWithinRadius(int x, int y, double radius,  TouchedMol result) {
//
//		x = scaleCoordinate(x);
//		y = scaleCoordinate(y);
//		for (int m = 1; m <= numberofMoleculeParts; m++) {
//			//a_or_b > 0 if atom , < 0 if bond and 0 if neither
//			int a_or_b = moleculeParts[m].testAtomAndBondTouch(x, y, new DoubleWrapper(radius));
//			//a_or_b = moleculeParts[m].testAtomAndBondTouch(x, y);
//			//info("" + x + " " + y + " " +a_or_b);				
//			if(a_or_b != 0 ) {
//				
//				result.molIndex = m;
//				if(a_or_b > 0) {
//					result.atomIndex = a_or_b;
//				} else {
//					result.bondIndex = a_or_b * -1;
//					
//				}
//				break;
//				
//			}
//		}
		
		
//	}
//	@Deprecated
//	void findMolAndAtomOrBondInDrawingAreaFromEventXY(int event_x, int event_y,TouchedMol result ) {
//		int x =  event_x - (int)menuCellSize;
//		//int y = event_y - (2 * (int)menuCellSize + menuCellBorder());
//		int y = event_y - topMenuHeight();
//		findMolAndAtomOrBondInDrawingArea(x, y, result);
//
//	}
	void findMolAndAtomOrBondInDrawingArea(int x, int y,  TouchedMol result) {
		
		if(this.isOutsideDrawingArea(x, y)) {
			result.reset();
			return;
		}
		findMolAndAtomOrBondWithinRadius(x, y, getHumanInteractionTouchRadius(), result);
	}

	
	/**
	 * find the closest touched atom or bond within the given radius. Store the results in the argumet result
	 * @param x
	 * @param y
	 * @param result
	 */
	void  findMolAndAtomOrBondWithinRadius(int x, int y, int radius,  TouchedMol result) {
		
		result.reset();

		//x = scaleCoordinate(x);
		//y = scaleCoordinate(y);
		double xCoord = screenToDrawingX(x);
		double yCoord = screenToDrawingY(y);
		double minDistance = radius;
		for (int m = 1; m <= numberofMoleculeParts; m++) {
			DoubleWrapper minDistanceFound = new DoubleWrapper(radius);
			int a_or_b = moleculeParts[m].testAtomAndBondTouch(xCoord, yCoord, minDistanceFound);

			if(minDistanceFound.value <  minDistance) {
				minDistance = minDistanceFound.value;
				result.reset();
				result.molIndex = m;
				result.distance = minDistance;
				assert a_or_b != 0;;
				if(a_or_b > 0) {
					result.atomIndex = a_or_b;
				} else {
					result.bondIndex = a_or_b * -1;
					
				}
			}
		}
		
		
	}
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	/**BB
	 * Compute the radius for human interaction around an atom or a bond.
	 * This radius should be larger for touch device than for pointer based system.
	 * 
	 * The drawback of a larger radius is that one has to be more precise when moving the structure.
	 * @return a radius 
	 */
	static final int TOUCH_LIMIT = 50;

	protected int getHumanInteractionTouchRadius() {
		if(JME.isTouchSupported) {
			return TOUCH_LIMIT + 300; //determined by trial and error on an iPad 4 by BB
		}
		return TOUCH_LIMIT + 120;
	}


	// ----------------------------------------------------------------------------
	@Override
	public boolean mouseMove(Event e, int x, int y) {
		// public void mouseMoved(MouseEvent e) {
		//System.out.println("@@@@ mouseMove");
		//is depictActionEnabled test needed here? if depictActionEnabled is used only for the toggle edit/depict, then no
		if (depict && !(this.canHandleAtomHighLightCallBack()  || this.canHandleBondHighLightCallBack() || depictActionEnabled)) //notifyAtomHighLightJSfunction: Luc P request to show atom highlight in depict mode
			return true;
		// int x = e.getX()-sd; int y = e.getY()-sd*2;

		boolean repaintFlag = false;

		int action = this.determineMenuAction(x, y, true);
		
		if( action != this.mouseWasOverAction) {
			// kind of new event
			repaintFlag |= this.handleMouseLeaveActionMenu(this.mouseWasOverAction);
			repaintFlag |= this.handleMouseEnterActionMenu(action);
			this.mouseWasOverAction = action;
		}
		
		//BB popup menu for copy&paste has been opened
		//boolean meta = e.metaDown() ; //true if right mouse click
		if(this.isEventContextMenu(e)) {
			//do nothing to avoid the molecule moving while popup menu is displayed
			return true;
		}

		//BB
		//this.mustReDrawInfo = false; //whenpaste operation fails, a mouse move can still occur, and there will be no error message.

		//System.out.println("X:Y: " + x +" " + y + " " + menuCellSize);
		
		//BB: bug found by Oli: with structure underneath the menu region: highlight must dissapear
		
		//boolean outsideDrawingArea = !depict  && ( x < menuCellSize || y < topMenuHeight() || y > dimension.height - menuCellSize - 1 || x >= dimension.width-1); 
		
		//x -= leftMenuWidth();
		//y -= topMenuHeight();

		//don't create any new object during a mouse move to 
		//avoid stressing the garbage colector
		//BB: bug found by Oli: with structure underneath the menu region: highlight must dissapear
		findMolAndAtomOrBondInDrawingArea(x, y,  newTouchedMol);
		
		//Don't allow bond touching in ACTION_MOVE_AT
		if(action == ACTION_MOVE_AT && newTouchedMol.bondIndex > 0) { 
			newTouchedMol.bondIndex = 0;
		}
		//System.out.println(newTouchedMol.molIndex + " " + newTouchedMol.atomIndex + " " +  newTouchedMol.bondIndex);

		if( ! newTouchedMol.equals(lastTouchedMol) && (newTouchedMol.isTouched() || lastTouchedMol.isTouched())) {
			
		
		// necekuje, ci sa nedotyka 2 molekul naraz, ale to by bolo asi zbytocne
			
			int m  = lastTouchedMol.molIndex;
			
			if( m > 0) {
				moleculeParts[m].touchedAtom = 0;
				moleculeParts[m].touchedBond = 0;
			}
			m  = newTouchedMol.molIndex;
			if( m > 0) {
				moleculeParts[m].touchedAtom = newTouchedMol.atomIndex;
				moleculeParts[m].touchedBond = newTouchedMol.bondIndex;
				//touched mol becomes the mol for edition
				// this must be changed!!!!!
				if (m != actualMoleculePartIndex ) {
					actualMoleculePartIndex = m;
					mol = moleculeParts[actualMoleculePartIndex];
				}
			}

			repaintFlag = true;
			//BB changed: notify only if it is an atom highlight
			
			//Design issue: notifyAtomHighLightJSfunction does not provide the molecule part number
			//presently notifyAtomHighLightJSfunction handle the minimal change reporting
			//if(newTouchedMol.atomIndex != lastTouchedMol.atomIndex || m != lastTouchedMol.molIndex) {
				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex);
			//}
			//if(newTouchedMol.bondIndex != lastTouchedMol.bondIndex|| m != lastTouchedMol.molIndex) {
				notifyBondHighLightJSfunction(newTouchedMol.bondIndex);
			//}
			
//			if(newTouchedMol.atomIndex > 0) {
//				if(lastTouchedMol.bondIndex >0) {
//					notifyBondHighLightJSfunction(0);//used to notify that the cursor has moved away from the bond
//				}
//				notifyAtomHighLightJSfunction(newTouchedMol.atomIndex); //used by LP to highlight NMR spectrum part
//								
//			} else if (newTouchedMol.bondIndex>0) { //bond was touched
//				if(lastTouchedMol.atomIndex>0) {
//					notifyAtomHighLightJSfunction(0);//used to notify that the cursor has moved away from the atom
//				}
//				notifyBondHighLightJSfunction(newTouchedMol.bondIndex); //used by LP to highlight NMR spectrum part
//				
//			}
				
			//System.out.println(actualMoleculePartIndex + " "+ m  );
			
			lastTouchedMol.initMyselfWith(newTouchedMol);
			assert lastTouchedMol.equals(newTouchedMol);
			

		} 
//		else {
//			if(this.atomWasTouched) { //NEW 06 2015!!!!!
//				notifyAtomHighLightJSfunction(0); //used to notify that the cursor has moved away from the atom
//				this.atomWasTouched = false;
//			}
//
//			if(this.bondWasTouched) { //NEW 06 2015!!!!!
//				notifyBondHighLightJSfunction(0); //used to notify that the cursor has moved away from the bond
//				this.bondWasTouched = false;
//			}

//			if (moleculeParts[m].touchedAtom > 0 || moleculeParts[m].touchedBond > 0) {
//				moleculeParts[m].touchedAtom = 0;
//				moleculeParts[m].touchedBond = 0;
//				repaintFlag = true;
//			}
//		}
		
		
		if (repaintFlag) {
			// vynuluje pripadny predosly touch
//			for (int m = actualMoleculePartIndex + 1; m <= numberofMoleculeParts; m++) {
//				moleculeParts[m].touchedAtom = 0;
//				moleculeParts[m].touchedBond = 0;
//			}
			// BB
			mustRedrawNothing();
			mustReDrawMolecularArea = true;
			repaint();

		} 
		//added after 
		//    if (depict && this.notifyStructuralChangeJSfunction == null) 
		//above was changed
//		if (depict) {
//			return true;
//		}
		
		

		return repaintFlag;
	}
/*
 * 	 * to be redefined in JS subclass (JSME)
	
 */
	public boolean isMacintosh() {
		return false;
	}
	// ----------------------------------------------------------------------------
	@Override
	public boolean keyDown(Event e, int key) {

		//BB
		this.mustReDrawInfo = false;
		//this.log("Key code: " + key);
		System.out.println("@@@@ keyDown: " + key);


		// public void keyPressed(KeyEvent e) {
		if (depict  && ! depictActionEnabled)
			return false;
		clearInfo();
		// key shortcuts
		// treba to disabled, ked input do elementu;
		// if (elementInput) return false;
		// int key = e.getKeyChar();
		int pressed = 0;
		boolean alt = e.modifiers == Event.ALT_MASK;
		//On Mac: meta is down for system copy
		boolean meta = isMacintosh()? e.metaDown():e.controlDown(); 
		
		// System.err.println("key " + key + " " + alt);
		switch (key) {
		// case 'e': case 'E': JMEmol.TESTDRAW = !JMEmol.TESTDRAW; break;
		case 'c':
		case 'C':
			if(meta) { //try a Ctrl C for copy. does not work in Java due to java security policy
				this.copyMolFileToClipboard(false);
				break;
			}
			pressed = ACTION_AN_C;
			

			break;

		case 'x':
		case 'X':
			if(meta) { //
				this.cutSelectedMoleculeForSystemClipBoard();
				break;
			}
			if(this.xButton) {
				info(MultiBox.atomicSymbol.getText());
				pressed = ACTION_AN_X;
				active_an = AN_X;
			}
			break;

			
		case 'v':
		case 'V':
			
			//paste with Ctrl V
			//does not work in Java in a browser due to java security policy
			if(meta && this.paste){
				this.pasteMolFileFromClipboard();
				break;
			}
			break;

		case 'n':
		case 'N':
			pressed = ACTION_AN_N;
			break;
		case 'o':
		case 'O':
			pressed = ACTION_AN_O;
			break;
		case 's':
		case 'S':
			pressed = ACTION_AN_S;
			break;
		case 'p':
		case 'P':
			pressed = ACTION_AN_P;
			break;
		case 'f':
		case 'F':
			pressed = ACTION_AN_F;
			break;
		case 'l':
		case 'L':
			pressed = ACTION_AN_CL;
			break;
		case 'b':
		case 'B':
			pressed = ACTION_AN_BR;
			break;
		case 'i':
		case 'I':
			pressed = ACTION_AN_I;
			break;
		case 'h':
		case 'H':
			info("H");
			pressed = ACTION_AN_H;
			break;
		case 'r':
		case 'R':
			info("-R");
			pressed = ACTION_AN_R;
			break; // if (rButton) ?
		case 't':
		case 'T':
			if (action == ACTION_AN_F) {
				pressed = ACTION_GROUP_CF3;
				info("-CF3");
			} else if (action == ACTION_AN_CL) {
				pressed = ACTION_GROUP_CCL3;
				info("-CCl3");
			} else {
				pressed = ACTION_GROUP_TBU;
				info("-tBu"); //TODO: consistent naming with the FG's
			}
			break;
		case 'y':
		case 'Y':
			if(meta) { //BB - does not work in Java
				pressed = ACTION_REDO;
			}
			else {
				pressed = ACTION_GROUP_NITRO;
				info("-NO2");
			}
			break;
		case 'z':
		case 'Z':
			if(meta) { //BB - does not work in Java
				pressed = ACTION_UNDO;
			}
			else {
				pressed = ACTION_GROUP_SULFO;
				info("-SO3H");
			}

			break;


		case 'a':
		case 'A':
			pressed = ACTION_GROUP_COO;
			info("-COOH");
			break;
		case 'e':
		case 'E':
			pressed = ACTION_GROUP_CC;
			info("-C#CH");
			break;
		case 'u':
		case 'U':
			pressed = ACTION_UNDO;
			break;
		case 'q':
		case 'Q':
			pressed = ACTION_GROUP_CYANO;
			info("-C#N");
			break;
		case 'g': // used for testing
			return true;
		case 27: //esc
			pressed = ACTION_BOND_SINGLE;
			break;
		case '-':
			// check here that an was changed and then cancell this -X ???
			if (action == ACTION_AN_F) {
				pressed = ACTION_GROUP_CF;
				info("-F");
			} else if (action == ACTION_AN_CL) {
				pressed = ACTION_GROUP_CL;
				info("-Cl");
			} else if (action == ACTION_AN_BR) {
				pressed = ACTION_GROUP_CB;
				info("-Br");
			} else if (action == ACTION_AN_I) {
				pressed = ACTION_GROUP_CI;
				info("-I");
			} else if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_CO;
				info("-OH");
			} else if (action == ACTION_AN_N) {
				pressed = ACTION_GROUP_CN;
				info("-NH2");
			} else
				pressed = ACTION_BOND_SINGLE;
			break;
//BB merged '=' and '
/*		case '=':'
			
			if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_dO;
				info("=O");
			} else
				pressed = ACTION_BOND_DOUBLE;
			break;
*/
		//new BB shortcut
		case '+':
			//toggle charge - same as clicking on the +/- icon
			//note that there is already a shortcut for '-'
			pressed = ACTION_CHARGE;
			break;
		case '#':
			pressed = ACTION_BOND_TRIPLE;
			break;
		case '0':
			if (action == ACTION_MARK)
				updateMark(0);
			else {
				if (!alt) {
					pressed = ACTION_RING_FURANE;
					info("-Furyl");
				} else {
					pressed = ACTION_RING_3FURYL;
					info("-3-Furyl");
				}
			}
			break;
		case '1':
			if (action == ACTION_MARK)
				updateMark(1);
			else
				pressed = ACTION_RING_PH;
			break;
		case '2' :
		case '=':
			if (key == '2' && action == ACTION_MARK)
				updateMark(2);
			//BB added October 2015 : create a double bond
			// duplacade code with  =      TODO:
			else if (action == ACTION_AN_O) {
				pressed = ACTION_GROUP_dO;
				info("=O");
			} else
				pressed = ACTION_BOND_DOUBLE;
			break;
		case '3':
			if (action == ACTION_MARK)
				updateMark(3);
			else
				pressed = ACTION_RING_3;
			break;
		case '4':
			if (action == ACTION_MARK)
				updateMark(4);
			else
				pressed = ACTION_RING_4;
			break;
		case '5':
			if (action == ACTION_MARK)
				updateMark(5);
			else
				pressed = ACTION_RING_5;
			break;
		case '6':
			if (action == ACTION_MARK)
				updateMark(6);
			else
				pressed = ACTION_RING_6;
			break;
		case '7':
			if (action == ACTION_MARK)
				updateMark(7);
			else
				pressed = ACTION_RING_7;
			break;
		case '8':
			if (action == ACTION_MARK)
				updateMark(8);
			else
				pressed = ACTION_RING_8;
			break;
		case '9':
			if (action == ACTION_MARK)
				updateMark(9);
			else {
				info("9 ring");
				pressed = ACTION_RING_9;
			}
			break;
		case 'd':
		case 'D':
		case 8:
		case 127:
			pressed = ACTION_DELETE;
			break;
		case 32:
			pressed = ACTION_CHAIN;
			break; // SPACE
		case 'm': //BB
		case 'M': //BB
		case Event.PGUP:
			pressed = ACTION_PGUP;
			break; // PgUp


		case 'w': //BB
		case 'W': //BB
		case Event.PGDN:
			pressed = ACTION_PGDN;
			break; // PgDn
			// default: System.out.println("key "+key); break;
		
		case Event.HOME:
			pressed = ACTION_HOME;
			break;
		case Event.END:
			pressed =ACTION_END;
			break;
		
			
		}

		//handling R #
		int digit_key = key +1 -'1' ;
		//if number between 0 and 9 was entered
		if(digit_key >=0 && digit_key <= 9 && mol.touchedAtom > 0) {
			
			int an = mol.an(mol.touchedAtom);
			if(an >= AN_R && an <= AN_R_LAST) {
				pressed = ACTION_AN_R + digit_key;
			}
		}
		if(pressed != 0)
			return menuAction(pressed); //will redraw if needed, will change this.action
		

		return false; //did not use the event: will be forwarded to other apps
	}


	// --------------------------------------------------------------------------
	// called when number key clicked and marking active
	// updates actual mark which will be used for marking
	private void updateMark(int n) {
		// need to know when new number and when combination of 2 presses i.e.
		// 12
		if (autonumber) {
			if (n == 0) {
				keyboradInputMark = -1;
				showInfo("click marked atom to delete map");
				markFromKeyboardInput = true;

				//repaint(); // updates status line
			}
			return;
		}

		//markUsed true: accumulate the mark number, which allows to get number >= 10
		if (resetExtendAtomMark) {
			keyboradInputMark = n;
			resetExtendAtomMark = false;
		} else {
			if (keyboradInputMark > -1 && keyboradInputMark < 100)
				keyboradInputMark = keyboradInputMark * 10 + n;
			else {
				keyboradInputMark = n; // mark cannot be > 999
				resetExtendAtomMark = false;

			}
		}

		if (keyboradInputMark == 0) {
			keyboradInputMark = -1;
			showInfo("click marked atom to delete map");
		} else
			showInfo("Click atom to set map to " + keyboradInputMark);
		
		markFromKeyboardInput = true;
	}
	// --------------------------------------------------------------------------
	//BB used for copy paste and setSubtituents
	@Override
	public void actionPerformed(ActionEvent evt) {
		mustRedrawNothing();

		String cmd = evt.getActionCommand();

		if (cmd.equals(CopyPasteAction.COPY_SMILES.toString())) {
			clipBoardManager.setClipboardContents(this.smiles());
		} 
		else if (cmd.equals(CopyPasteAction.COPY_MOL.toString())) {
			this.copyMolFileToClipboard(false);
		}
		else if (cmd.equals(CopyPasteAction.COPY_MOL_V3000.toString())) {
			this.copyMolFileToClipboard(true);
		}
		else if (cmd.equals(CopyPasteAction.PASTE.toString())) {
			if(this.paste)
				this.pasteMolFileFromClipboard();
		}
		else if (cmd.equals(CopyPasteAction.COPY_INCHI.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.COPY_INCHI);
		}
		else if (cmd.equals(CopyPasteAction.COPY_INCHI_KEY.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.COPY_INCHI_KEY);
		}
		else if (cmd.equals(CopyPasteAction.COPY_INCHI_AUXINFO.toString())) {
			this.copyInchiToClipboard(CopyPasteAction.COPY_INCHI_AUXINFO);
		}
		else if (cmd.equals(CopyPasteAction.COPY_OCLCODE.toString())) {
			this.copyOclCodetoClipboard();
		}
		
		else if (cmd.equals(CopyPasteAction.SEARCH_INCHI_KEY.toString())) {
			this.searchChemicalStructureUsingInchiKey();;
		}
		
		else if (cmd.equals(CopyPasteAction.COPY_SVG.toString())) {
			this.copySVGToClipboard();;
		}
		//BB : rotation coming from the touch handling
		else if(cmd.equals("rotation")) { //used by touch devices
			if(lastAction != LA_ROTATE) {
				lastRotation = 0;
			}
			long rotation = evt.getWhen(); //I had to store the rotation somewhere 
			rotation *= -1; //feels more natural
			long deltaRotation = rotation - lastRotation ;

			if(Math.abs(deltaRotation) < 10) {
				mol.rotate((int) deltaRotation);
			}
			//mustRedrawNothing();
			mustReDrawMolecularArea =true;
			//info("Rotation: " + rotation + " deltaRotation " +  deltaRotation);

			//repaint(); //done at the end
			lastAction = LA_ROTATE;
			lastRotation = rotation;


		} else if(cmd == unSetChiralFlagAction || cmd==setChiralFlagAction) {
			boolean changed = this.mol.setChiralFlag(cmd == setChiralFlagAction);
			if(changed) {
				if(this.mol.chiralFlag) {
					info("Chiral flag is set");
				} else {
					info("No Chiral flag");
					
				}
				//this.postSave(); //idea: recordMoleculePartEvent could be used to perform the postSave, + giving a name to saved state
				//that could be used for displaying in info() when mouse over undo button
				this.recordMoleculePartEvent(CHANGE_CHIRAL, this.actualMoleculePartIndex);
				mustReDrawMolecularArea =true; //not really needed but the event will be written out only when redrawing the molecular area
			}

		}	else if (cmd == autoAtomMapMoleculeAction) {
			
			//find the highest atom map
			int max = this.findMaxAtomMapAmongAllMolecules();
			boolean changed = false;
			for(int at = 1; at<= mol.natoms; at++) {
				Atom atom = mol.atoms[at];
				if( !atom.hasBeenMapped()) {
					max ++;
					atom.setMap(max);
					changed = true;
				}
			}
			
			if(changed) {
				mustReDrawMolecularArea = true;
				this.recordMoleculePartEvent(CHANGE_MANY_ATOM_MAP, this.actualMoleculePartIndex);
			}
		} else if( cmd == deleteAtomMapMoleculeAction) {
			if((mustReDrawMolecularArea = mol.resetAtomMaps())) {
				this.recordMoleculePartEvent(DELETE_ATOM_MAPS, this.actualMoleculePartIndex);
			}

		} else if( cmd == bondSetCoordinationAction || cmd == bondUnSetCoordinationAction) {
			mustReDrawMolecularArea = true;
			int bondIndex = this.inspectorEvent.bondIndex;
			assert(bondIndex > 0);
			Boolean isCoordination = this.inspectorEvent.mol.getBond(bondIndex).toggleCoordination().isCoordination();
			this.recordBondEvent(isCoordination?SET_BOND_COORDINATION:UNSET_BOND_COORDINATION);
			//TODO: the event name could be the same as the action
		
		}else if (cmd == deleteHydrogensMoleculeAction) {
			
			mustReDrawMolecularArea = mol.deleteHydrogens();
			
			if(mustReDrawMolecularArea) {
				this.recordMoleculePartEvent(DELETE_HYDROGENS, this.actualMoleculePartIndex);
			}
		}
		
		//BB : rotation coming from the touch handling
		//problem: unwanted interaction with the rotation
		//Chemdoodle rotation & scaling works nice
		else if(cmd.equals("scale100") ) { //used by touch devices
			if(false && this.numberofMoleculeParts == 1) {
				long scale100 = evt.getWhen(); //I had to store the scale somewhere 

				mustReDrawMolecularArea =true;

				double delta = 0.05;
				if(scale100 != 100) {
					if(scale100 < 100){
						delta *= -1;
					}
					this.molecularAreaScale = scale100 / 100.0;
					//Todo : compute center of mol
					mol.scaling();
					mol.center(); //TODO : translate back to previous center
					//info("Scale " + this.depictScale );
					lastAction = LA_SCALE; 


				}
			}
		}
		else if(cmd.equals("end_gesture") ) { 
			this.willPostSave(true);
		}
		else  {
			this.setSubstituent(cmd);
		}

		if(mustReDrawMolecularArea || mustReDrawInfo) {
			repaint();
		}

	}

	//BB
	public void copyMolFileToClipboard(boolean isV3000) {
		clipBoardManager.setClipboardContents(this.molFile(isV3000));
	}

	//BB
	public void copyOclCodetoClipboard() {
		//use RunAsyncCallback to trigger a code split to download openchemlib
		GWT.runAsync(new RunAsyncCallback() {
			
			@Override
			public void onSuccess() {
				clipBoardManager.setClipboardContents(JME.this.getOclCode());
			}
			
			@Override
			public void onFailure(Throwable reason) {
				// TODO Auto-generated method stub
				
			}
		});
		
	}
	
	public void copySVGToClipboard() {
		//use RunAsyncCallback to trigger a code split to download openchemlib
		GWT.runAsync(new RunAsyncCallback() {
			
			@Override
			public void onSuccess() {
				clipBoardManager.setClipboardContents(JME.this.getOclSVG());
			}
			
			@Override
			public void onFailure(Throwable reason) {
				// TODO Auto-generated method stub
				
			}
		});
		
	}
	
	
	
	public void copyInchiToClipboard(CopyPasteAction action) {
		//for subclasses
		//clipBoardManager.setClipboardContents(this.computeInchi(isKey));
	}
	
	public void searchChemicalStructureUsingInchiKey()
	{		//for subclasses
	
	}
	
	//
	public void pasteMolFileFromClipboard() {
		//		String molecule = clipBoardManager.getClipboardContents();
		//		if(molecule != null) {
		//			molecule = molecule.replace("\n", "|");
		//			this.readMolFile(molecule);
		//		}
		this.afterStructureChangeEvent.setOrigin_PASTE();

		//asynchronous action is needed for non IE browsers
		clipBoardManager.getAsyncClipboardContents(this.getPasteAction());


	}
	//used by drag and drop and system clipboard paste
	public void pasteDirect(String molString, boolean originIsDrop) {
		//if pasting is allowed
		if(!this.paste) {
			return;
		}
		if(molString != null && molString.length() > 0) {
			//OK if only DnD uses this function
			if(originIsDrop)
				this.afterStructureChangeEvent.setOrigin_DROP();
			else
				this.afterStructureChangeEvent.setOrigin_PASTE();
				
			
			this.getPasteAction().paste(molString);
		} else {
			this.showError("empty or null structure");
		}
	}
	
	protected PasteAction getPasteAction() {
		return this.createPasteActionInstanceIfNeeded();
	}
	protected  PasteAction createPasteActionInstanceIfNeeded() {
		if(this.pasteAction == null) {
			this.pasteAction = new PasteAction() {

			@Override
			public void paste(final String clipboardContent) {
				//final String molecule = clipboardContent;

				if(clipboardContent != null) {
					
					//customized paste 
					if(JME.this.getPrePasteJSfunction() != null) {
						JSObject jsObject =  JSObject.getWindow(JME.this);
						jsObject.call(JME.this.getPrePasteJSfunction(), new String[]{clipboardContent});
						return;
					}
					
					///customized paste only for JSME
					if(JME.this.handleBeforePasteEvent(clipboardContent)) { //if the callback is set
						return;
					}
					//name is not correct because it accepts more format TODO
					JME.this.read_MOL_SDF_RXN(clipboardContent, new RunAsyncCallback() {

						@Override
						public void onFailure(Throwable reason) {
							//read_MOL_SDF_RXN has already handled the error
						}

						@Override
						public void onSuccess() {
							//record an event
							JME.this.handleAfterPasteEvent(clipboardContent);
							
						}
						
					});
				}

			}

		};
		}
		return this.pasteAction;
	}
	
	class StringWrapper {
		public String innnerString ;
	};
	
	//TODO the input error handling has to be redesigned
	// test cases with invalid MOL
	final StringWrapper sdfPastedMessage = new StringWrapper();
	public void read_MOL_SDF_RXN(String SDF_MOL_RXN, final RunAsyncCallback sucessAndFailureHandle) {
		
		sdfPastedMessage.innnerString = "";
		this.afterStructureChangeEvent.setOrigin_API();

		
		//todo: handle RDF
		int countSDF = JME.this.sdfStack.addEntries(SDF_MOL_RXN);
		if( countSDF > 0) {
			//sdfPastedMessage = ". " + countSDF + " structures in stack .Use Page Up/Down for SDF access";
			sdfPastedMessage.innnerString = " Use Page Up/Down for SDF access (" +countSDF + ")";
		}
		
		RunAsyncCallback localSucessAndFailureHandle  = new RunAsyncCallback() {

			@Override
			public void onFailure(Throwable reason) {
				info("ERROR: " + reason.getMessage()); //the readMolFile() method has already generated a message
				JME.this.alert(JME.this.infoText); //this.infotext has be set on thye line above
				JME.this.reset();
				JME.this.repaint();
				
			}

			@Override
			public void onSuccess() {
				info("Structure pasted. " + sdfPastedMessage.innnerString);
				//JME.this.postSave(); //add it to the undo/redo manager
				JME.this.mustReDrawMolecularArea = true;
				JME.this.repaint();
				
				
				
				sucessAndFailureHandle.onSuccess();
			}};
		try {
			JME.this.handleReadGenericInput(SDF_MOL_RXN, localSucessAndFailureHandle, false); //do not repaint because localSucessAndFailureHandle does it
		} catch(Exception e) {
			localSucessAndFailureHandle.onFailure(e);
		}
	}
	
	
	/*Same functionality as prePasteJSfunction but only for JSME
	 *Advantage: the argument is a JS function, not a JS function name. The JS fyunction will have two arguments: my self and the string to process before pasting
	 *For JME, always return false - meaning that there is no callback set
	 */
	protected boolean handleBeforePasteEvent(String molecule) {
		
		return false;
	}

	/**
	 * Called when pasting has been sucessful.
	 * Method intended for a subclass.
	 */
	protected void handleAfterPasteEvent(String pasteContent) {
		// Do nothing
		
	}

	/**
	 * Called after swith to edit / depict mode using the toggle option.
	 * Method intended for a subclass.
	 */
	protected void handleAfterAfterDepictEditToggleEvent() {
		//do nothing
	}

	
	public String cutSelectedMoleculeForSystemClipBoard() {
		if(this.mol.natoms == 0) {
			return "";
		}
		
		this.mol.forceUniColor(Color.RED); //need a delay for that??
		String s = mol.createMolFile("");
		this.redrawMoleculartAreaOnly();
		clear();

		this.redrawMoleculartAreaOnly();
		
		return s;
	}
	/**
	 * 
	 * @param action
	 * @return
	 */
	boolean handleMouseEnterActionMenu(int action) {
		
		//if there is no atoms, then there is nothing to highlight
		if(this.mol.natoms == 0) {
			return false;
		}
		
		String note = null;

		switch(action) {
			case ACTION_CLEAR:
				if(this.numberofMoleculeParts > 1) {
					note = "Delete selected molecule (red)";
				} else {
					note = "Clear canvas";
				}
				this.mol.forceUniColor(Color.RED);
				this.uniColorMolecule = this.mol;
				break;
			case ACTION_REACP:
				note = "Copy selected (blue) molecule to the other side of the reaction";
				this.mol.forceUniColor(Color.BLUE);
				this.uniColorMolecule = this.mol;
		
		}
		
		if(note!=null) {
			this.info(note);
			this.mustReDrawMolecularArea = true; //new oct 2016
			this.mustReDrawTopMenu = true;
		} else {
			this.mustReDrawMolecularArea = false; //new oct 2016
			this.mustReDrawTopMenu = false;
		}
		
		
		return note != null ; //|| this.mustReDrawMolecularArea || this.mustReDrawTopMenu;
	}
	/**
	 * 
	 * @param action
	 * @return
	 */
	boolean handleMouseLeaveActionMenu(int action) {
		if(this.uniColorMolecule != null && (action == ACTION_CLEAR || (this.reaction && action == ACTION_REACP))) {

			this.uniColorMolecule.resetForceUniColor();
			this.uniColorMolecule = null;
			for(int i = 1; i <= this.numberofMoleculeParts; i++) {
				this.moleculeParts[i].resetForceUniColor();
			}
			this.clearInfo();
			this.mustReDrawMolecularArea = true;
			this.mustReDrawTopMenu = true;

		} else {
			this.mustReDrawMolecularArea = false; //new october2016
			this.mustReDrawTopMenu = false;
		}
		

		//this.mustReDrawTopMenu = true;

		return this.mustReDrawMolecularArea ;//|| this.mustReDrawTopMenu;
		
	}
	
	
	/*
	 * Save the current molecules to the change manager
	 */
	protected void postSave() {

		if(!this.canMultipleUndo) {
			return;
		}
		
		System.out.println("@@@@ save state");
		SavedState state = this.createState();
		//if(state != null) {
			this.molChangeManager.insertItem(state);
		//}

	}

	/*
	 * Create a state to store the chemical state of the editor.
	 * Return null if there is nothing to save.
	 */
	protected SavedState createState() {
		SavedState state = new SavedState();

		state.actualMoleculePartIndex = actualMoleculePartIndex;
		state.numberofMoleculeParts = this.numberofMoleculeParts;
		boolean mustBeSaved = false;

		for(int i=1; i < JME.maxParts; i++) {
			JMEmol part = this.moleculeParts[i];
			if(part != null) {
				if(part.natoms > 0) {
					mustBeSaved = true;
				}
				state.moleculeParts[i] = part.deepCopy();
				//FIXME: some code call createState() before cleanup of the valence!!!! e.g. mouseDown
				//most don't so instead of adding mol.cleanAfterChanged() verywhere ...
				//state.moleculeParts[i].cleanAfterChanged();
			} else {
				break;
			}
		}

		state.reaction = this.reaction;
		state.multipart = this.multipart;

		state.depictScale = this.molecularAreaScale;
		state.lastAction = this.lastAction;

		
		
		if(mustBeSaved) {
			return state;
		} else {
			return null;
		}
	}

	protected void retoreState(SavedState state) {
		basicRetoreState(state);



		//Notifify the JavaScript world that my structure has changed
		switch(state.lastAction) {
		case LA_MOVE:
		case LA_ROTATE :
		case LA_FAILED :
			break;
		default:
			this.notifyStructuralChangeToJS();
		}

	}

	protected void basicRetoreState(SavedState state) {
		if(state == null) {
			while(this.numberofMoleculeParts > 0) {
				this.clear(false);
			}
			return;
		}
		this.actualMoleculePartIndex = state.actualMoleculePartIndex;
		this.numberofMoleculeParts = state.numberofMoleculeParts;

		for(int i=1; i < JME.maxParts; i++) {
			JMEmol part = state.moleculeParts[i];
			if(part != null) {
				this.moleculeParts[i] = part.deepCopy();
			} else {
				this.moleculeParts[i] = null;
			}
		}
		//issue: this can create a null mol
		if (state.actualMoleculePartIndex > 0) {
			this.mol = this.moleculeParts[actualMoleculePartIndex];
		} else {
			this.mol = new JMEmol(this); //avoid a null pointer, for state saved after a clear or reset
		}

		this.reaction = state.reaction;
		this.multipart = state.multipart;

		this.molecularAreaScale = state.depictScale;




	}

	public PopupMenu getCopyPastePopupMenuMol() {
		//if(this.copyPastePopupMenuMol == null) {
			this.copyPastePopupMenuMol = this.createCopyPastePopupMenu(false);
		//}
		return copyPastePopupMenuMol;
	}
	public PopupMenu getCopyPastePopupMenuReaction() {
		//if(this.copyPastePopupMenuReaction == null) {
			this.copyPastePopupMenuReaction = this.createCopyPastePopupMenu(true);
		//}
		return copyPastePopupMenuReaction;
	}

	//return true if event has been used
	public boolean handleCopyPastePopupMenu(Event e, int x, int y) {

		//detect mol and atom under the cursor: needed for tablet?

		
		if(e == null || this.isEventContextMenu(e)) {
			
			//Tablet: needed for touch screen because they cannot detect a mouse move
			//Does not work: the delay for the context menu is too long and is needed
//			if(isTouchSupported) {
//				findMolAndAtomOrBondInDrawingArea(x, y, newTouchedMol);
//				if(newTouchedMol.molIndex > 0) {
//					mol = this.moleculeParts[newTouchedMol.molIndex];
//					mol.touchedAtom = newTouchedMol.atomIndex;
//					mol.touchedBond = newTouchedMol.bondIndex;
//					
//				}
//
//			}
			boolean isTouched = mol.touchedAtom >0 || mol.touchedBond > 0;
			if(isTouched  && (action == ACTION_DELETE || action == ACTION_DELGROUP)) {
				return true; //true: do not use the context menu to delete atom or bond
			}
//			this.info("isTouched = " + isTouched);
//			repaint();
			
			if(isTouched && !depict) {
				//set shiral flag to the mol
				if(this.touchedMolPopuMenu != null) {
					this.remove(this.touchedMolPopuMenu);

				}
				touchedMolPopuMenu = this.createMolPopupMenu(mol, x, y);
				this.add(touchedMolPopuMenu); //set the parent the popup
				touchedMolPopuMenu.show(this,  x,  y);
			} else {
			
			
			
				{
					PopupMenu pm;
					if(reaction) {
						pm = this.getCopyPastePopupMenuReaction();
					} else {
						pm = this.getCopyPastePopupMenuMol();
					}
					if(this.isEventContextMenu(e)) {
						pm.show(this, x, y);
					} else { //click performed on the menu
						this.showPopUpMenuRealtiveToScaledMainMenu(pm, x, y);
					}
				
				}
			
			
			}

			//the atom or bond highlight must disappear =-to be improved
			Event ne = new Event(null, 0, 0);
			this.mouseMove(ne, 0,0);
			
			return true;
		}
		return false;

	}

	/*
	 * Show the popupmenu at the given coordinate relative to the GUI menu
	 * The GUI menu might have been scaled up or down, thus the x,y coordinates must be changed accordingly
	 */
	protected void showPopUpMenuRealtiveToScaledMainMenu(PopupMenu pm, int x, int y) {
		pm.show(this, (int)(x*this.menuScale + 0.5), (int)(y*this.menuScale +0.5));
		
	}

	public boolean isEventContextMenu(Event e) {
		if(e == null) return false;
		
		boolean meta = e.metaDown(); //true if right mouse click
		boolean ctrl = e.controlDown() ; //Safari Mac

		return meta || ctrl ;

	}
	public PopupMenu getFunctionalGroupPopumemu() {
		if(this.functionalGroupPopumemu == null) {
			this.functionalGroupPopumemu = this.createFunctionalGroupPopumemu();
		}
		return this.functionalGroupPopumemu;
	}
	public PopupMenu createFunctionalGroupPopumemu() {

		PopupMenu popup = new PopupMenu();

		for(String eachFG: functionalGroups) {
			MenuItem mi = new MenuItem(eachFG);
			popup.add(mi);
			mi.setActionCommand(eachFG);
			mi.addActionListener(this);
		}
		//setSubstituent(r);


		this.add(popup); //set the parent the popup

		return popup;
	}

	/*
	 * Provide the ideal height of a string consisting of usual upper case characters.
	 * Purpose: centering of String in the center of a box.
	 * Does not work for $ , y ;  and others
	 */
	public int stringHeight(FontMetrics fm) {
		return fm.getAscent() - fm.getDescent();
		//return fm.getAscent();
	}

	//	public int stringHeight(FontMetrics fm, String text) {
	//		int h = stringHeight(fm);
	//		//Correction for a string that is only lower case - NO working : i is as high as a L
	//		if(text.equals(text.toLowerCase()) ) {
	//			h = h *2 /3;
	//		}
	//		return h;
	//	}



	/**
	 * 
	 * @return the notifyAtomHighLightJSfunction
	 */
	public String getNotifyAtomHighLightJSfunction() {
		return this.notifyAtomHighLightJSfunction;
	}
	/**
	 * Set the name of the JavaScript function that will be called each time the mouse move over an atom.
	 * To cancel, set to null.
	 * @param notifyAtomHighLightJSfunction
	 */
	public void setNotifyAtomHighLightChangeJSfunction(String notifyAtomHighLightJSfunction) {
		this.notifyAtomHighLightJSfunction = notifyAtomHighLightJSfunction;
	}

	/**
	 * Notify the JavaScript envirronement that the mouse over atom has changed
	 * @param touchedAtom 
	 */
	protected int previousTouchedAtomForHighlight = 0;
	protected int previousTouchedBondForHighlight = 0;
	protected int previousActualMoleculePartIndex = 0;
	
	
	/**
	 * return -1 if no action should be taken or the touchedAtomOrBond, which might have been set to 0
	 * in case the curssor has moved away from the atom or bond
	 * @param touchedAtomOrBond
	 * @param previousTouchedAtomOrBondForHighlight
	 * @return
	 */
	public int notifyAtomOrBondHighLightJSfunction(int touchedAtomOrBond, int previousTouchedAtomOrBondForHighlight) {
		//TODO: exception handling with JSException: this function will not work outside a web browser
			//send an event only if it is about a new atom
			//otherwise each small mouse move will send an event
			
			//case 1: cursor moved away from atom previous atom is not defined -> do nothing
			if(touchedAtomOrBond <=0 && previousTouchedAtomOrBondForHighlight == 0) {
				//System.out.println("case 1");
				return -1;
			}

			//case 2: cursor moved around the same atom -> do nothing
			if(touchedAtomOrBond == previousTouchedAtomOrBondForHighlight && this.actualMoleculePartIndex == previousActualMoleculePartIndex) {
				//System.out.println("case 2");

				return -1;
			}

			//case 3: cursor moved away from the atom that was highlighted - send 0 to the callback function
			// to notify that the atom has been deselected
			if(touchedAtomOrBond <=0 && previousTouchedAtomOrBondForHighlight > 0) {
				//System.out.println("case 3");
				touchedAtomOrBond = 0;
			}

			this.previousActualMoleculePartIndex = this.actualMoleculePartIndex;
			return touchedAtomOrBond;


	}
	public void notifyAtomHighLightJSfunction(int touchedAtom) {
		//TODO: exception handling with JSException: this function will not work outside a web browser
		if(this.canHandleAtomHighLightCallBack()) {
			touchedAtom = this.notifyAtomOrBondHighLightJSfunction(touchedAtom, this.previousTouchedAtomForHighlight);
			if(touchedAtom == -1) return;
			
			this.previousTouchedAtomForHighlight = touchedAtom;
			//do the function call - will work in a real Java applet
			if(this.notifyAtomHighLightJSfunction != null) {
				JSObject jsObject =  JSObject.getWindow(this);
				jsObject.call(this.notifyAtomHighLightJSfunction,
						new Integer[]{new Integer(this.actualMoleculePartIndex), new Integer(touchedAtom)});
			}
			//this is for the new callback mechanism - June 2015
			handleAtomHighLightCallBack(this.actualMoleculePartIndex, touchedAtom);

		}
	}
	
	public void notifyBondHighLightJSfunction(int touchedBond) {
		//TODO: exception handling with JSException: this function will not work outside a web browser
		if(this.canHandleBondHighLightCallBack()) {
			touchedBond = this.notifyAtomOrBondHighLightJSfunction(touchedBond, this.previousTouchedBondForHighlight);
			if(touchedBond == -1) return;
			this.previousTouchedBondForHighlight = touchedBond;

			//this is for the new callback mechanism - June 2015
			handleBondHighLightCallBack(this.actualMoleculePartIndex,  touchedBond);

		}
	}
	
	
	public Boolean canHandleAtomHighLightCallBack() {
		return this.notifyAtomHighLightJSfunction != null;
	}
	public Boolean canHandleBondHighLightCallBack() {
		return false;
	}

	
	public Boolean canHandleAtomClickedCallBack() {
		return false;
	}
	public Boolean canHandleBondClickedCallBack() {
		return false;
	}

	/**
	 */
	public void handleAtomClickedCallBack(int actualMoleculePartIndex, int clickedAtom)
	{
		/*do nothing */
	
	}
	public void handleBondClickedCallBack(int actualMoleculePartIndex, int clickedBond)
	{
		/*do nothing */
	
	}
	

	
	/**
	 * For subclasses
	 * @param actualMoleculePartIndex2
	 * @param touchedAtom
	 */
	public void handleAtomHighLightCallBack(int actualMoleculePartIndex, int touchedAtom)
	{
		/*do nothing */
	
	}
	/**
	 * For subclasses
	 * @param actualMoleculePartIndex2
	 * @param touchedBond
	 */
	public void handleBondHighLightCallBack(int actualMoleculePartIndex, int touchedBond)
	{
		/*do nothing */
	
	}

	
	/**
	 * 
	 * @param molIndex
	 * @param atomIndex
	 */
	public void setAtomToHighLight(int molIndex, int atomIndex) {
		JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);
		
		if(atomIndex < 1 || atomIndex> molToHighLight.natoms) {
			this.showError("invalid atom index: " + atomIndex);
			return;
		}
		molToHighLight.touchedAtom = atomIndex;
		this.redrawMoleculartAreaOnly();
		
		
	}
	
	public void changeAtomMap(int molIndex, int atomIndex, int newMap) {
		JMEmol mol = this.selectMolIfValidOrShowError(molIndex);
		mol.getAtom(atomIndex).setMap(newMap);
		this.recordAtomEvent(JME.CHANGE_ATOM_MAP,atomIndex);
		//this.setAtomToHighLight(molIndex, atomIndex);
		this.redrawMoleculartAreaOnly();

	}
	/**
	 * @return the notifyStructuralChangeJSfunction
	 */
	public String getNotifyStructuralChangeJSfunction() {
		return notifyStructuralChangeJSfunction;
	}

	/**
	 * @param notifyStructuralChangeJSfunction the notifyStructuralChangeJSfunction to set
	 */
	public void setNotifyStructuralChangeJSfunction(String notifyStructuralChangeJSfunction) {
		this.notifyStructuralChangeJSfunction = notifyStructuralChangeJSfunction;
	}

	/**
	 * Notify the JavaScript envirronement that the chemical structure has changed
	 */
	public void notifyStructuralChangeToJS() {
		//TODO: exception handling with JSException: this function will not work outside a web browser
		if(this.notifyStructuralChangeJSfunction != null) {
			JSObject jsObject =  JSObject.getWindow(this);
			jsObject.call(this.notifyStructuralChangeJSfunction, null);
		}
		
		//the 2nd implementation for JSME that uses event
		if(this.afterStructureChangeEvent  != null && this.afterStructureChangeEvent.action != null)
			this.handleAftertructureModifiedEvent();
	}

	
	public String getPrePasteJSfunction() {
		return prePasteJSfunction;
	}

	/**
	 * Set a JS function that will be called before the paste is performed. THis function will receive one argument: a string that a represent a molecular structure.
	 * The return value of the fuinction is a string.
	 * Purpose: convert a name or a SMILES or an InchI into a MOL.
	 * @param prePasteJSfunction
	 */
	public void setPrePasteJSfunction(String prePasteJSfunction) {
		this.prePasteJSfunction = prePasteJSfunction;
	}
	
	
	

	
	/**
	 * 
	 * @return the height in pixel of the top menu
	 */
	int topMenuHeight() {
		return (int) Math.round(topMenuHeight( this.menuScale));
	}
	/**
	 * 
	 * @return the height in pixel of the top menu
	 */
	double topMenuHeight(double scale) {
		return this.depict? 0.0 : (menuCellSize * 2 + menuCellBorder()) * scale;
	}

	/**
	 * 
	 * @return the width in pixel of the top menu
	 */
	int leftMenuWidth() {
		return  (int) Math.round(leftMenuWidth(this.menuScale));
	}
	/**
	 * 
	 * @return the scaled width in pixel of the left menu
	 */
	double leftMenuWidth(double scale) {
		
		return this.depict? 0.0 :(menuCellSize * 1 + menuCellBorder()) * scale;
	}
	/**
	 * 
	 * @return the height in pixel of the bottom bar (info bar)
	 * = 0 in depict mode
	 */
	public int infoAreaHeight() {
		return (int) Math.round(infoAreaHeight(this.menuScale));
	}
	
	public double infoAreaHeight(double scale) {
		return this.depict? 0.0 : menuCellSize * scale;
	}

	
	/**
	 * the right border differs in new and old look
	 * @return
	 */
	int rightBorder() {
		return (int)Math.round(rightBorder(this.menuScale)); //the width of the line on the right of the molecular area in edit mode
	}

	double rightBorder(double scale) {
		return this.depict? 0.0 : (newLook? rightBorderNewLook: rightBorderOldLook) * scale; //the width of the line on the right of the molecular area in edit mode
	}


	
	/*
	 * 
	 * @return the height in pixel of the bottom bar (info bar)
	 * > 0  also in depict mode
	 */
	public int getDefaultInfoBarHeight() {
		return (int)this.standardMenuCellSize;
	}

	public void redrawMoleculartAreaOnly() {
		this.mustRedrawNothing();
		this.mustReDrawMolecularArea = true;
		this.repaint();
		
	}

	public void redrawMolecularAreaOnylForGettingSVG() {
		int savedTouchedAtom = this.mol.touchedAtom;
		int savedTouchedBond= this.mol.touchedBond;
		
		//hide the touched atom or bond
		this.mol.touchedAtom = 0;
		this.mol.touchedBond = 0;
		this.afterStructureChangeEvent.reset(); //oct 2016: avoid an infinite loop when redrawMoleculartAreaOnlForGettingSVG is called within js notification of a structure change

		this.redrawMoleculartAreaOnly();
		
		this.mol.touchedAtom = savedTouchedAtom;
		this.mol.touchedBond = savedTouchedBond;
	}
	
	
	/**
	 * 
	 * @param molIndex
	 * @param atomAndColorCSV : at,c,at,c,at,c, ... at: atom index; c: color index
	 * @param background : background of atoms or foreground
	 */
	public void setAtomColors(int molIndex, String atomAndColorCSV, boolean background) {
		
		//select the molecule to color
		JMEmol molToHighLight = this.selectMolIfValidOrShowError(molIndex);
		
		if(molToHighLight == null) {
			return;
		}
		
		//color its atoms according to the parameters
		molToHighLight.setAtomColors(atomAndColorCSV, background);
		
		//repaint
		this.redrawMoleculartAreaOnly();
	}

	/**
	 * Reset background atom colors
	 * @param molIndex
	 */
	public void resetAtomColors(int molIndex) {
		//select the molecule to decolor
		JMEmol selectedMol = this.selectMolIfValidOrShowError(molIndex);
		
		if(selectedMol == null) {
			return;
		}
		
		//
		selectedMol.resetAtomColors();
		
		//repaint
		this.redrawMoleculartAreaOnly();
		
		//clear the atom colors from the option
		
	}
	/**
	 * Return the selected mol. If the index is not valid, show an error
	 * @param molIndex
	 * @return JMEmol
	 */
	protected JMEmol selectMolIfValidOrShowError(int molIndex) {
		this.clearInfo(); //clear the info in case an error would occur
		if(molIndex < 1 || molIndex> this.numberofMoleculeParts) {
			this.showError("invalid mol index: " + molIndex);
			return null;
		}
		
		return this.moleculeParts[molIndex];

	}
	
	/**
	 * 
	 * @param action
	 * @param moleculePartIndex
	 * @param atomIndex
	 * @param bondIndex
	 */
	protected void recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex, int bondIndex) {
		
		if(this.afterStructureChangeEvent != null) {
			this.afterStructureChangeEvent.setAction(action).setAtomAndBondAndMol(atomIndex, bondIndex, moleculePartIndex);
		}
		//this.notifyStructuralChangeToJS();
		
		//for the undo/redo manager
		this.willPostSave(true);


	}
	protected void recordMoleculePartEvent(String action, int moleculePartIndex) {
		this.recordAfterStructureChangedEvent(action, moleculePartIndex, 0,0);

	}
	
	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * @param action
	 */
	protected void recordAtomEvent(String action) {
		this.recordAtomEvent(action, this.mol.touchedAtom);

	}
//	protected void recordAtomEventAndPostSave(String action) {
//		this.recordAtomEvent(action, this.mol.touchedAtom);
//		this.postSave();
//
//	}
	protected void recordAtomEvent(String action, int atom) {
		this.recordAfterStructureChangedEvent(action, this.actualMoleculePartIndex, atom, 0);

	}
	/**
	 * Shortcut to set the afterStructureChangeEvent
	 * @param action
	 */
	protected void recordBondEvent(String action) {
		this.recordAfterStructureChangedEvent(action, this.actualMoleculePartIndex, 0, this.mol.touchedBond);

	}

	protected void recordAfterStructureChangedEvent(String action) {
		this.recordAfterStructureChangedEvent(action, 0,0,0);

	}
	
	protected void handleAftertructureModifiedEvent() {
		//clear the event after it has been used
		//(afterStructureChangeEvent != null)
		//fterStructureChangeEvent.reset(); //not needed anymore because  of using recordAfterStructureChangedEvent(String action, int moleculePartIndex, int atomIndex, int bondIndex) 
		
		//subclass do something more
		
		System.out.println("Structure modified event: " + afterStructureChangeEvent.getAction());
		updateReactionParts(); //June 2017
	}
	
	
	
	
	
	/**
	 * 
	 * @return true if the editor is in depict mode
	 */
	public boolean isDepictMode() {
		//alert("isDepictMode: "+ this.depict);
		return this.depict;
	}


} //End of JME class




























































// ****************************************************************************
// The goal is to save the location of the window for the next instantiation




@SuppressWarnings("serial")
class FrameWithLocation extends Frame {
	protected Point lastLocation;
	protected Button closeButton;

	public FrameWithLocation(String title) {
		super(title);
		initialize();
	}
	public FrameWithLocation() {
		super();
		initialize();
	}



	public String closeButtonLabel() {
		return "Close";
	}

	public void initialize() {
		this.closeButton = new Button(this.closeButtonLabel());

		// Add a window listener JDK 1.1 for closing the window using the X button of the window
		this.addWindowListener ( new WindowAdapter () {
			public void windowClosing ( WindowEvent evt )
			{
				hide();
			}
		});

	}
	@Override
	public void hide() {
		if(this.isShowing()) {
			Point currentLocation = this.getLocationOnScreen();
			lastLocation.setLocation(currentLocation);
		}
		//Idea: record the delta position relative to the applet instead of the absolute position

		super.hide();
	}

	public void disposeIfShowing() {
		if(this.isShowing()) {
			this.dispose(); //will call hide()
		}
	}
	@Override
	public void show() {
		this.setLocation(this.lastLocation);
		super.show();
	}


	// ----------------------------------------------------------------------------
	@Override
	public boolean action(Event e, Object arg) {
		if(e.target == this.closeButton) {
			this.hide();
			return true;
		}
		return this.customAction(e, arg); //for the queryBox


		/*
		 * else if ("Submit".equals(arg)) {
		 * jme.readSmiles(smilesText.getText()); }
		 */
	}
	public boolean customAction(Event e, Object arg) {
		return false;
	}

	//avoid a x < 0 or y <
	public void safeTranslate(Point location, int deltaX, int deltaY) {
		location.translate(deltaX, deltaY);
		location.x = location.x <0?0:location.x;
		location.y = location.y <0?0:location.y;

	}


}
//****************************************************************************
// show an alert box centered near the center of the source
//mimic the Javascript alert()( function
@SuppressWarnings("serial")
class AlertBox extends FrameWithLocation {

	//the source can be the applet
	public AlertBox(String msg, Component source, Color backgroundColor) {
		super();

		setResizable(false);

		this.setLayout(new GridLayout(0, 1, 0, 0));

		Label label = new Label(msg,Label.CENTER);
		this.add(label);

		//an extra panel is needed, otherwise the button will be as wide as the frame
		Panel p = new Panel();
		p.add(this.closeButton);
		this.add(p);


		if(source != null) {
			// center the window on top of the source

			this.lastLocation = source.getLocationOnScreen();
			this.pack(); //the translation must be done after the pack() otherwise the size of the window (myself) is not known (=0)

			this.safeTranslate(this.lastLocation, source.getWidth()/2 - this.getWidth()/2, source.getHeight()/2 - this.getHeight()/2);
		}
		if(backgroundColor != null) {
			setBackground(backgroundColor);
		}

	}

	@Override
	public String closeButtonLabel() {
		return "OK";
	}


}

//****************************************************************************
@SuppressWarnings("serial")
class MultiBox extends FrameWithLocation {
	//	static Point aboutBoxPoint = new Point(500, 10);
	//	static Point smilesBoxPoint = new Point(200, 50);
	//	static Point atomxBoxPoint = new Point(150, 420);
	Point aboutBoxPoint ;
	Point smilesBoxPoint ;
	Point atomxBoxPoint ;
	static TextField atomicSymbol = new TextField("H"); // pouziva sa v JME
	Button helpButton = new Button("Help");
	Button homeButton = new Button("Home");

	TextField smilesText;
	JME jme; // parent of MultiBox
	// ----------------------------------------------------------------------------

	/**
	 * 
	 * @param box : 1 is for smiles , 2 for X and 3 for about
	 * @param jme
	 */
	MultiBox(int box, JME jme) {
		super();
		this.jme = jme;

		//BB It is not necesssary to specify a font, the default one looks good - not true - Helevetica looks beter because it is correclty centered
		if(jme.dialogFont != null) {
			setFont(jme.dialogFont);
		}
		setBackground(JME.bgColor);
		setResizable(false);

		//setup the first position of dialog box close to the applet
		Point jmeLocation = jme.getLocationOnScreen();
		//System.out.println(jmeLocation);

		if (box == 1) {
			//BB
			if(smilesBoxPoint == null) {
				smilesBoxPoint = new Point(jmeLocation);
				this.safeTranslate(smilesBoxPoint, -30, 0) ; //above  the applet,close to the smiley
			}
			this.lastLocation = smilesBoxPoint;
			initSmilesBox(jme.Smiles());
		}
		else if (box == 2) {
			//BB
			if(atomxBoxPoint == null) {
				//BB
				atomxBoxPoint = new Point(jmeLocation);
				this.safeTranslate(atomxBoxPoint, -50, (int)jme.menuCellSize * 13 -80) ; //left side of the atom X menu cell
			}
			this.lastLocation = atomxBoxPoint;
			initAtomxBox();
		}
		else {
			//BB
			if(aboutBoxPoint == null) {
				aboutBoxPoint = new Point(jmeLocation);
				this.safeTranslate(aboutBoxPoint, (int)jme.menuCellSize * 5, 0) ; //right side next to the info menu cell
			}
			initAboutBox();
			this.lastLocation = aboutBoxPoint;
		}



		pack();
		show();
	}



	// ----------------------------------------------------------------------------
	void initAboutBox() {
		setTitle("About " + JME.programName);
		setLayout(new GridLayout(0, 1, 0, 0));
		//setFont(jme.fontSmall); //BB not needed - done in the constructor
		setBackground(JME.bgColor);
		add(new Label(JME.programName +" Molecular Editor" + " v" + JME.version,
				Label.CENTER));
		add(new Label("Peter Ertl and Bruno Bienfait", Label.CENTER));
		// add(new Label("peter.ertl@novartis.com",Label.CENTER));
		// add(new Label("HomePage: www.molinspiration.com/jme/",Label.CENTER));


		for(String cl : JME.copyright) {
			Label l = new Label(cl, Label.CENTER);
			l.setFont(jme.copyRigthSmallTextFont);
			add(l);
		}

		
		Panel p = new Panel();

		//Home button

		
		//Online help button: open a HTML page that contains help for end users

		p.add(helpButton);

		//not implemented yet
		//		helpButton.addActionListener(new ActionListener() {
		//
		//			@Override
		//			public void actionPerformed(ActionEvent e) {
		//				//System.out.println("help");
		//				try{
		//					AppletContext a = MultiBox.this.jme.getAppletContext();
		//					URL u = new URL(MultiBox.this.jme.helpUrl);
		//					a.showDocument(u,"_self");
		//				}
		//				catch (MalformedURLException urlException){
		//					System.out.println(urlException.getMessage());
		//					MultiBox.this.jme.showError(urlException.getMessage());
		//				}				
		//			}
		//		});
		p.add(this.closeButton);
		add(p);
		//setLocation(aboutBoxPoint);
	}

	// ----------------------------------------------------------------------------
	void initSmilesBox(String smiles) {
		setTitle("SMILES");
		setLayout(new BorderLayout(2, 0)); // 2, 0 gaps
		smilesText = new TextField(smiles + "     ");
		if (!jme.runsmi) {
			//the textfield cannot be copied in JS when the setEditable is set to false
			//smilesText.setEditable(false);
		}
		add("Center", smilesText);
		Panel p = new Panel();
		p.add(this.closeButton);
		if (jme.runsmi) {
			Button b = new Button("Submit");
			p.add(b);
		}
		add("South", p);

		//this.setSmiles(smilesText.getText().trim()); //BB : to size the SMILES box correctly - does not work
		//this.setMaximumSize(new Dimension(330, 200)); //BB does not work
		smilesText.setText(smilesText.getText().trim()); // odstrani "      "
		setResizable(true);
	}

	// ----------------------------------------------------------------------------
	// sets smiles in smiles box a aj upravi dlzku
	//BB: resize does not work
	void setSmiles(String smiles) {
		Dimension d = size();
		int l = jme.menuCellFontSmallerMet.stringWidth(smiles) + 50;
		if (l < 150)
			l = 150;
		//BB : avoid huge dialog box that does not fit the screen
		if(l>400)
			l =400;

		validate();
		this.resize(l, d.height);
		smilesText.setText(smiles);
	}

	// ----------------------------------------------------------------------------
	void initAtomxBox() {
		setTitle("Nonstandard atom");
		setLayout(new BorderLayout(2, 0)); // 2, 0 gaps
		Panel p = new Panel();
		p.add(new Label("atomic SMILES", Label.CENTER));
		add("North", p);
		// 2007.01 fixed bug - frozen xbutton
		String as = "H";
		if (atomicSymbol != null)
			as = atomicSymbol.getText();
		atomicSymbol = new TextField(as, 8);
		add("Center", atomicSymbol);
		p = new Panel();
		p.add(this.closeButton);
		add("South", p);
	}


	// ----------------------------------------------------------------------------
	public boolean keyDown(Event e, int key) {
		// v JME menu nastavi na X (ak bolo medzitym ine) ak tukane zo atomxBox
		if (atomicSymbol == null)
			return false; // nie null iba v atomxBox
		// vracia false, lebo potom by sa nedalo pisat napr v smilesBox
		if (jme.action != JME.ACTION_AN_X) {
			jme.action = JME.ACTION_AN_X;
			jme.active_an = JME.AN_X; // treba
		}
		// JME.repaint(); //can't make static reference ... kvoli ocierneniu X
		return false; // inak sa nedaju pisat pismena do text boxu
	}
	// ----------------------------------------------------------------------------
	@Override
	public boolean customAction(Event e, Object arg) {
		if(e.target == this.helpButton) {
			try{
				AppletContext a = MultiBox.this.jme.getAppletContext();
				URL u = new URL(MultiBox.this.jme.helpUrl);
				a.showDocument(u);
				//a.showDocument(u, "_blank"); //don'use _target
			}
			catch (MalformedURLException urlException){
				//System.out.println(urlException.getMessage());
				MultiBox.this.jme.showError(urlException.getMessage());
			}
			return true;
		}
		return false;
	}

}

// ****************************************************************************
@SuppressWarnings("serial")
class QueryBox extends FrameWithLocation {
	//static Point point = new Point(20, 200);
	Point myLocation;
	TextField text;
	static Button c, n, o, s, p, f, cl, br, i, any, anyec, halogen, aromatic,
	nonaromatic, ring, nonring;
	static Button anyBond, aromaticBond, ringBond, nonringBond, sdBond;
	static Choice choiced, choiceh;
	Color bgc = JME.bgColor;
	boolean isBondQuery = false;
	JME jme; // reference to parent
	// --- buttony etc su definovane ako static aby sa zachovala ich hodnota po
	// novom stlacenie QRY (aby sa window dostalo hore)
	// ----------------------------------------------------------------------------

	QueryBox(JME jme) {
		super("Atom/Bond Query");
		this.jme = jme;

		//BB
		if(myLocation == null) {
			//setup the first position of dialog box close to the applet
			Point jmeLocation = jme.getLocationOnScreen();
			myLocation = new Point(jmeLocation);
			this.safeTranslate(myLocation, -150, 10);


		}
		this.lastLocation = myLocation;

		setLayout(new GridLayout(0, 1));

		//BB It is not necesssary to specify a font, the default one looks good
		if(jme.dialogFont != null) {
			setFont(jme.dialogFont);
		}
		setBackground(bgc);

		Panel p1 = new Panel();
		p1.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		p1.add(new Label("Atom type :"));

		// boolean first = (any == null); // caused problems
		boolean first = true;

		if (first) {
			any = new Button("Any");
			anyec = new Button("Any except C");
			halogen = new Button("Halogen");
		}
		p1.add(any);
		p1.add(anyec);
		p1.add(halogen);
		add(p1);

		Panel p2 = new Panel();
		p2.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		p2.add(new Label("Or select one or more from the list :", Label.LEFT));
		add(p2);

		Panel p3 = new Panel();
		// p3.setLayout(new GridLayout(1,0));
		p3.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		if (first) {
			c = new Button("C");
			n = new Button("N");
			o = new Button("O");
			s = new Button("S");
			p = new Button("P");
			f = new Button("F");
			cl = new Button("Cl");
			br = new Button("Br");
			i = new Button("I");
		}
		p3.add(c);
		p3.add(n);
		p3.add(o);
		p3.add(s);
		p3.add(p);
		p3.add(f);
		p3.add(cl);
		p3.add(br);
		p3.add(i);
		add(p3);

		Panel p4 = new Panel();
		p4.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		if (first) {
			choiceh = new Choice();
			choiceh.addItem("Any");
			choiceh.addItem("0");
			choiceh.addItem("1");
			choiceh.addItem("2");
			choiceh.addItem("3");
		}
		p4.add(new Label("Number of hydrogens :  "));
		p4.add(choiceh);
		add(p4);

		Panel p5 = new Panel();
		p5.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		if (first) {
			choiced = new Choice();
			choiced.addItem("Any");
			choiced.addItem("0");
			choiced.addItem("1");
			choiced.addItem("2");
			choiced.addItem("3");
			choiced.addItem("4");
			choiced.addItem("5");
			choiced.addItem("6");
		}

		p5.add(new Label("Number of connections :", Label.LEFT));
		p5.add(choiced);
		p5.add(new Label(" (H's don't count.)", Label.LEFT));
		add(p5);

		Panel p6 = new Panel();
		p6.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		p6.add(new Label("Atom is :"));
		if (first)
			aromatic = new Button("Aromatic");
		p6.add(aromatic);
		if (first)
			nonaromatic = new Button("Nonaromatic");
		p6.add(nonaromatic);
		if (first)
			ring = new Button("Ring");
		p6.add(ring);
		if (first)
			nonring = new Button("Nonring");
		p6.add(nonring);
		add(p6);

		Panel p9 = new Panel();
		p9.setBackground(getBackground().darker());
		p9.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 1));
		p9.add(new Label("Bond is :"));
		if (first)
			anyBond = new Button("Any");
		p9.add(anyBond);
		if (first)
			aromaticBond = new Button("Aromatic");
		p9.add(aromaticBond);
		// if (first) sdBond = new Button("- or ="); p9.add(sdBond);
		if (first)
			ringBond = new Button("Ring");
		p9.add(ringBond);
		if (first)
			nonringBond = new Button("Nonring");
		p9.add(nonringBond);
		add(p9);

		Panel p8 = new Panel();
		p8.setLayout(new FlowLayout(FlowLayout.CENTER, 3, 1));
		// p8.add(new Label("Query :"));
		if (first)
			text = new TextField("*", 20);
		p8.add(text);
		p8.add(new Button("Reset"));
		p8.add(this.closeButton);
		add(p8);
		setResizable(false);

		if (first) { // musi sa to explicitne, inak nemaju vsetky bgc
			resetAtomList();
			resetAtomType();
			resetBondType();
			aromatic.setBackground(bgc);
			nonaromatic.setBackground(bgc);
			ring.setBackground(bgc);
			nonring.setBackground(bgc);
			choiceh.setBackground(bgc);
			choiced.setBackground(bgc);
			changeColor(any);
		}




		pack();
		show();
	}

	// ----------------------------------------------------------------------------
	@Override
	public boolean customAction(Event e, Object arg) {

		if (arg.equals("Reset")) {
			resetAll();
			changeColor(any); // Any on
			doSmarts();
		} else if (e.target instanceof Button) {
			resetBondType(); // set to any ???
			if (e.target == any) {
				resetAtomList();
				resetAtomType();
			} else if (e.target == anyec) {
				resetAtomList();
				resetAtomType();
			} else if (e.target == halogen) {
				resetAtomList();
				resetAtomType();
			} else if (e.target == ring) {
				nonring.setBackground(bgc);
			} else if (e.target == nonring) {
				ring.setBackground(bgc);
				aromatic.setBackground(bgc);
			} else if (e.target == aromatic) {
				nonaromatic.setBackground(bgc);
				nonring.setBackground(bgc);
			} else if (e.target == nonaromatic) {
				aromatic.setBackground(bgc);
			} else if (e.target == anyBond || e.target == aromaticBond
					|| e.target == ringBond || e.target == nonringBond) {
				resetAll();
				isBondQuery = true;
			} else { // atom z listu pressed (moze by aj posledny vynulovany
				resetAtomType();
			}
			changeColor((Button) (e.target));
			doSmarts();
		} else if (e.target instanceof Choice) {
			resetBondType();
			Choice choice = (Choice) (e.target);
			if (choice.getSelectedIndex() == 0)
				choice.setBackground(bgc);
			else
				choice.setBackground(Color.orange);
			doSmarts();
		}

		// v JME menu nastavi na query (ak bolo medzitym ine)
		if (jme.action != JME.ACTION_QRY) {
			jme.action = JME.ACTION_QRY;
			jme.repaint();
		}

		return true;
	}

	// ----------------------------------------------------------------------------
	private void resetAll() {
		resetAtomList();
		resetAtomType();
		choiceh.select(0);
		choiced.select(0);
		aromatic.setBackground(bgc);
		nonaromatic.setBackground(bgc);
		ring.setBackground(bgc);
		nonring.setBackground(bgc);
		choiceh.setBackground(bgc);
		choiced.setBackground(bgc);
		resetBondType(); // also sets isBondQuery to false

	}

	// ----------------------------------------------------------------------------
	private void resetAtomList() {
		c.setBackground(bgc);
		n.setBackground(bgc);
		o.setBackground(bgc);
		s.setBackground(bgc);
		p.setBackground(bgc);
		f.setBackground(bgc);
		cl.setBackground(bgc);
		br.setBackground(bgc);
		i.setBackground(bgc);
	}

	// ----------------------------------------------------------------------------
	private void resetAtomType() {
		any.setBackground(bgc);
		anyec.setBackground(bgc);
		halogen.setBackground(bgc);
	}

	// ----------------------------------------------------------------------------
	private void resetBondType() {
		anyBond.setBackground(bgc);
		aromaticBond.setBackground(bgc);
		// sdBond.setBackground(bgc);
		ringBond.setBackground(bgc);
		nonringBond.setBackground(bgc);
		isBondQuery = false;
	}

	// ----------------------------------------------------------------------------
	private void changeColor(Button b) {
		if (b.getBackground() == bgc)
			b.setBackground(Color.orange);
		else
			b.setBackground(bgc);
	}

	// ----------------------------------------------------------------------------
	private void doSmarts() {
		String smarts = "";
		boolean showaA = false;

		// basic atom type
		if (any.getBackground() != bgc) {
			smarts = "*";
			showaA = true;
		} else if (anyec.getBackground() != bgc) {
			smarts = "!#6";
			showaA = true;
		} else if (halogen.getBackground() != bgc) {
			f.setBackground(Color.orange);
			cl.setBackground(Color.orange);
			br.setBackground(Color.orange);
			i.setBackground(Color.orange);
			smarts = "F,Cl,Br,I";
		} else {
			boolean ar = aromatic.getBackground() != bgc;
			boolean nar = nonaromatic.getBackground() != bgc;
			if (c.getBackground() != bgc) {
				if (ar)
					smarts += "c,";
				else if (nar)
					smarts += "C,";
				else
					smarts += "#6,";
			}
			if (n.getBackground() != bgc) {
				if (ar)
					smarts += "n,";
				else if (nar)
					smarts += "N,";
				else
					smarts += "#7,";
			}
			if (o.getBackground() != bgc) {
				if (ar)
					smarts += "o,";
				else if (nar)
					smarts += "O,";
				else
					smarts += "#8,";
			}
			if (s.getBackground() != bgc) {
				if (ar)
					smarts += "s,";
				else if (nar)
					smarts += "S,";
				else
					smarts += "#16,";
			}
			if (p.getBackground() != bgc) {
				if (ar)
					smarts += "p,";
				else if (nar)
					smarts += "P,";
				else
					smarts += "#15,";
			}
			if (f.getBackground() != bgc)
				smarts += "F,";
			if (cl.getBackground() != bgc)
				smarts += "Cl,";
			if (br.getBackground() != bgc)
				smarts += "Br,";
			if (i.getBackground() != bgc)
				smarts += "I,";
			// if (h.getBackground() != bgc) smarts += "H,";
			if (smarts.endsWith(","))
				smarts = smarts.substring(0, smarts.length() - 1);
			if (smarts.length() < 1 && !isBondQuery) { // napr pri vynulovani
				// listu
				if (ar)
					smarts = "a";
				else if (nar)
					smarts = "A";
				else {
					any.setBackground(Color.orange);
					smarts = "*";
				}
			}
		}

		// atomic properties
		String ap = "";
		if (showaA && aromatic.getBackground() != bgc)
			ap += ";a";
		if (showaA && nonaromatic.getBackground() != bgc)
			ap += ";A";
		if (ring.getBackground() != bgc)
			ap += ";R";
		if (nonring.getBackground() != bgc)
			ap += ";!R";
		// zjednodusenie (mieso *;r len r ...)
		if (any.getBackground() != bgc && ap.length() > 0)
			smarts = ap.substring(1, ap.length());
		else
			smarts += ap;

		// hydrogens and number of bonds
		int nh = choiceh.getSelectedIndex();
		if (nh > 0) {
			nh--;
			smarts += ";H" + nh;
		}
		int nd = choiced.getSelectedIndex();
		if (nd > 0) {
			nd--;
			smarts += ";D" + nd;
		}

		// bond type
		if (anyBond.getBackground() != bgc)
			smarts = "~";
		if (aromaticBond.getBackground() != bgc)
			smarts = ":";
		// if (sdBond.getBackground() != bgc) smarts = "-,=";
		if (ringBond.getBackground() != bgc)
			smarts = "@";
		if (nonringBond.getBackground() != bgc)
			smarts = "!@";

		text.setText(smarts);
	}

	// --------------------------------------------------------------------------
	boolean isBondQuery() {
		return isBondQuery;
	}

	// --------------------------------------------------------------------------
	String getSmarts() {
		return text.getText();
	}
	// --------------------------------------------------------------------------


}
// ****************************************************************************

class InspectorEvent implements ActionListener {
	JMEmol mol;
	int atomIndex;
	int bondIndex;
	int molIndex;
	int x;
	int y;
	JME jme;
	
	//reuse the same atomInspector each time
	AtomInspector  atomInspector;
	
	public InspectorEvent(JME jme) {
		this.jme = jme;
	}

	public void reset() {
		mol = null;
		molIndex=atomIndex = bondIndex = x = y = 0;
	}

	public int getAtomMap() {
		return mol.getAtom(atomIndex).getMap();
	}
	@Override
	public void actionPerformed(final ActionEvent e) {

		GWT.runAsync(new JSME_RunAsyncCallback() {

			@Override
			public void onSuccess() {
				if(e.getActionCommand() == JME.inspectAtomAction) {
					if(InspectorEvent.this.atomInspector == null) {
						InspectorEvent.this.atomInspector = new AtomInspector();
					}
					
					InspectorEvent.this.atomInspector.action(InspectorEvent.this);
				}
				
			}
			
			
		});

	}
	
	public void changeAtomMap(int newMap) {
		this.jme.changeAtomMap(this.molIndex, this.atomIndex, newMap);
	}

	public void reportError(String message) {
		this.jme.showError(message);
		
	}
	
}


/**
 * Dialog box to set the atom map of the atom - later other properties
 * @author bruno
 *
 */
class AtomInspector  {
	Dialog modalDialog;
	ActionListener actionListener;
	TextField atomicMapField;
	private InspectorEvent inspectorEvent;
	
	@SuppressWarnings("serial")
	public AtomInspector() {
		// Create an OK button
		final Button ok = new Button ("OK");
		Button cancel = new Button("Cancel");
		atomicMapField = new TextField("0", 4);

//		actionListener = new  ActionListener()
//		{
//			public void actionPerformed( ActionEvent e )
//			{
//				// Hide dialog
//				modalDialog.setVisible(false);
//				if(e.getSource() == ok) {
//					//make the changes
//					//System.out.println("Here: " + atomicMapField.getText());
//					try {
//						int newMap = Integer.parseInt(atomicMapField.getText());
//						inspectorEvent.changeAtomMap(newMap);
//
//					} catch (NumberFormatException exception) {
//						inspectorEvent.reportError("invalid atom map");
//					}
//				}
//			}
//		};
		// Create a modal dialog

		
		//parent : should be the applet window
		Frame window = new Frame();

		modalDialog = new Dialog(window) {
			@Override
			public boolean action(Event e, Object arg) {
				this.setVisible(false);
				if(e.target == ok) {
					//make the changes
					//System.out.println("Here: " + atomicMapField.getText());
					try {
						int newMap = Integer.parseInt(atomicMapField.getText());
						inspectorEvent.changeAtomMap(newMap);

					} catch (NumberFormatException exception) {
						inspectorEvent.reportError("invalid atom map");
					}
				}
				
				return true;
			}
			
		};
		modalDialog.setModal(true);
		// Use a flow layout
		modalDialog.setLayout( new FlowLayout() );

		// action listener is not implemented in JSapplet
//		ok.addActionListener( actionListener );
//		
//		cancel.addActionListener( actionListener );

		modalDialog.add( new Label ("New atom map"));
		modalDialog.add( ok );
		modalDialog.add( cancel );

		
		modalDialog.setLayout(new BorderLayout(2, 0)); // 2, 0 gaps
		
		Panel p = new Panel();

		p.add(new Label("atom map", Label.CENTER));
		p.add(atomicMapField);
		modalDialog.add("North", p);

		
		p = new Panel();
		p.add(ok);
		p.add(cancel);
		
		modalDialog.add("South", p);

		// Add a window listener JDK 1.1 for closing the window using the X button of the window
		modalDialog.addWindowListener ( new WindowAdapter () {
			public void windowClosing ( WindowEvent evt )
			{
				modalDialog.setVisible(false);
			}
		});


	}

	
	public void action(InspectorEvent event) {
		if(event.atomIndex > 0) {
			this.inspectorEvent = event;
			String title = "Atom " + event.atomIndex;
			modalDialog.setTitle(title);
			atomicMapField.setText("" + event.getAtomMap());
			
			//FIXME: does not work in JavaScript
			modalDialog.setLocation(event.x, event.y);
			
			//recompute the layount
			modalDialog.pack();
	
			// Show dialog
			modalDialog.setVisible(true);
	
		}
		
	}
	
}